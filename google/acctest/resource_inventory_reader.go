// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/acctest/resource_inventory_reader.go.tmpl
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package acctest

import (
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"sync"

	"gopkg.in/yaml.v2"
)

var (
	// The GlobalMetadataCache is used by VCR tests to avoid loading metadata once per test run.
	// Because of the way VCR tests are run, it's difficult to avoid a global variable.
	GlobalMetadataCache = MetadataCache{
		mutex: &sync.Mutex{},
	}
	providerName = "google"
)

// Metadata represents the structure of the metadata files
type Metadata struct {
	Resource            string          `yaml:"resource"`
	GenerationType      string          `yaml:"generation_type"`
	SourceFile          string          `yaml:"source_file"`
	ApiServiceName      string          `yaml:"api_service_name"`
	ApiVersion          string          `yaml:"api_version"`
	ApiResourceTypeKind string          `yaml:"api_resource_type_kind"`
	CaiAssetNameFormat  string          `yaml:"cai_asset_name_format"`
	ApiVariantPatterns  []string        `yaml:"api_variant_patterns"`
	AutogenStatus       bool            `yaml:"autogen_status,omitempty"`
	Fields              []MetadataField `yaml:"fields"`

	// These keys store information about the metadata file itself.

	// Path is the path of the loaded metadata file
	Path string
	// ServicePackage is the folder within services/ that the metadata file is in
	ServicePackage string
}

type MetadataField struct {
	ApiField     string `yaml:"api_field"`
	Field        string `yaml:"field"`
	ProviderOnly string `yaml:"provider_only"`
	Json         string `yaml:"json"`
}

type MetadataCache struct {
	mutex          *sync.Mutex
	cache          map[string]Metadata
	populated      bool
	populatedError error
}

func (mc *MetadataCache) Populate() error {
	mc.mutex.Lock()
	defer mc.mutex.Unlock()

	if mc.populated {
		return mc.populatedError
	}

	baseDir, err := getServicesDir()
	if err != nil {
		return fmt.Errorf("failed to find services directory: %v", err)
	}

	mc.cache = make(map[string]Metadata)

	var malformed_yaml_errs []string

	// Walk through all service directories once
	err = filepath.Walk(baseDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err // Fail immediately if there's an OS error.
		}

		// Skip non-metadata files
		if info.IsDir() || !strings.HasPrefix(info.Name(), "resource_") || !strings.HasSuffix(info.Name(), "_meta.yaml") {
			return nil
		}

		// Read the file
		content, err := os.ReadFile(path)
		if err != nil {
			return err // Fail immediately if there's an OS error.
		}

		// Parse YAML
		var metadata Metadata
		if err := yaml.Unmarshal(content, &metadata); err != nil {
			// note but keep walking
			malformed_yaml_errs = append(malformed_yaml_errs, fmt.Sprintf("%s: %v", path, err.Error()))
			return nil
		}

		// Skip if resource is empty
		if metadata.Resource == "" {
			return nil
		}

		if _, ok := mc.cache[metadata.Resource]; ok {
			return fmt.Errorf("duplicate resource: %s in %s", metadata.Resource, path)
		}

		metadata.Path = path
		pathParts := strings.Split(path, string(os.PathSeparator))
		servicesIndex := slices.Index(pathParts, "services")
		if servicesIndex == -1 {
			return fmt.Errorf("no service found for %s (%s)", metadata.Resource, path)
		}
		metadata.ServicePackage = pathParts[servicesIndex+1]
		mc.cache[metadata.Resource] = metadata
		return nil
	})

	if err != nil {
		mc.populatedError = fmt.Errorf("error walking directory: %v", err)
	}

	if len(malformed_yaml_errs) > 0 {
		mc.populatedError = fmt.Errorf("YAML parsing errors encountered:\n%v", strings.Join(malformed_yaml_errs, "\n"))
	}

	// Mark cache as populated
	mc.populated = true

	return mc.populatedError
}

// Get takes a resource name (like google_compute_instance) and returns
// the metadata for that resource and an `ok` bool of whether the metadata
// exisxts in the cache.
func (mc *MetadataCache) Get(key string) (Metadata, bool) {
	// For IAM resources, return the parent resource's metadata. This could change if we
	// start generating separate IAM metadata in the future. This is primarily for
	// backwards-compatibility with the previous cache behavior and a workaround for _not_
	// generating IAM resource metadata.
	key, _ = strings.CutSuffix(key, "_iam_member")
	key, _ = strings.CutSuffix(key, "_iam_binding")
	key, _ = strings.CutSuffix(key, "_iam_policy")
	m, ok := mc.cache[key]
	return m, ok
}

func (mc *MetadataCache) Cache() map[string]Metadata {
	return mc.cache
}

// getServicesDir returns the path to the services directory
// It will attempt to find the project root relative to cwd
func getServicesDir() (string, error) {
	// Try to find project root
	root, err := findProjectRoot()
	if err == nil {
		servicesDir := filepath.Join(root, providerName, "services")
		if _, err := os.Stat(servicesDir); err == nil {
			return servicesDir, nil
		}
	}

	// Last resort: try relative to current directory
	currentDir, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("failed to determine current directory: %v", err)
	}

	// Try a few common relative paths
	potentialPaths := []string{
		filepath.Join(currentDir, providerName, "services"),
		filepath.Join(currentDir, "..", providerName, "services"),
		filepath.Join(currentDir, "..", "..", providerName, "services"),
	}

	for _, path := range potentialPaths {
		if _, err := os.Stat(path); err == nil {
			return path, nil
		}
	}

	return "", fmt.Errorf("unable to locate services directory, please provide explicit project root path")
}

// findProjectRoot walks up from the current directory to find the project root
// by looking for the go.mod file
func findProjectRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		// Check if go.mod exists in the current directory
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}

		// Move up to the parent directory
		parentDir := filepath.Dir(dir)
		if parentDir == dir {
			// Reached the filesystem root without finding go.mod
			return "", fmt.Errorf("could not find go.mod file in any parent directory")
		}
		dir = parentDir
	}
}
