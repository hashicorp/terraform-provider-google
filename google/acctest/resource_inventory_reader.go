// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/acctest/resource_inventory_reader.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package acctest

import (
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"sync"

	"gopkg.in/yaml.v2"
)

var (
	// The GlobalMetadataCache is used by VCR tests to avoid loading metadata once per test run.
	// Because of the way VCR tests are run, it's difficult to avoid a global variable.
	GlobalMetadataCache = MetadataCache{
		mutex: &sync.Mutex{},
	}
)

// Metadata represents the structure of the metadata files
type Metadata struct {
	Resource            string          `yaml:"resource"`
	GenerationType      string          `yaml:"generation_type"`
	SourceFile          string          `yaml:"source_file"`
	ApiServiceName      string          `yaml:"api_service_name"`
	ApiVersion          string          `yaml:"api_version"`
	ApiResourceTypeKind string          `yaml:"api_resource_type_kind"`
	CaiAssetNameFormat  string          `yaml:"cai_asset_name_format"`
	ApiVariantPatterns  []string        `yaml:"api_variant_patterns"`
	AutogenStatus       bool            `yaml:"autogen_status,omitempty"`
	Fields              []MetadataField `yaml:"fields"`

	// These keys store information about the metadata file itself.

	// Path is the path of the loaded metadata file
	Path string
	// ServicePackage is the folder within services/ that the metadata file is in
	ServicePackage string
}

type MetadataField struct {
	ApiField     string `yaml:"api_field"`
	Field        string `yaml:"field"`
	ProviderOnly bool   `yaml:"provider_only"`
	Json         bool   `yaml:"json"`
}

type MetadataCache struct {
	mutex          *sync.Mutex
	cache          map[string]Metadata
	populated      bool
	populatedError error
}

func (mc *MetadataCache) Populate() error {
	mc.mutex.Lock()
	defer mc.mutex.Unlock()

	if mc.populated {
		return mc.populatedError
	}

	baseDir, err := getServicesDir()
	if err != nil {
		return fmt.Errorf("failed to find services directory: %v", err)
	}

	mc.cache = make(map[string]Metadata)

	var malformed_yaml_errs []string

	// Walk through all service directories once
	err = filepath.Walk(baseDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err // Fail immediately if there's an OS error.
		}

		// Skip non-metadata files
		if info.IsDir() || !strings.HasPrefix(info.Name(), "resource_") || !strings.HasSuffix(info.Name(), "_meta.yaml") {
			return nil
		}

		// Read the file
		content, err := os.ReadFile(path)
		if err != nil {
			return err // Fail immediately if there's an OS error.
		}

		// Parse YAML
		var metadata Metadata
		if err := yaml.Unmarshal(content, &metadata); err != nil {
			// note but keep walking
			malformed_yaml_errs = append(malformed_yaml_errs, fmt.Sprintf("%s: %v", path, err.Error()))
			return nil
		}

		if _, ok := mc.cache[metadata.Resource]; ok {
			return fmt.Errorf("duplicate resource: %s in %s", metadata.Resource, path)
		}

		metadata.Path = path
		pathParts := strings.Split(path, string(os.PathSeparator))
		servicesIndex := slices.Index(pathParts, "services")
		if servicesIndex == -1 {
			return fmt.Errorf("no service found for %s (%s)", metadata.Resource, path)
		}
		metadata.ServicePackage = pathParts[servicesIndex+1]
		mc.cache[metadata.Resource] = metadata
		return nil
	})

	if err != nil {
		mc.populatedError = fmt.Errorf("error walking directory: %v", err)
	}

	if len(malformed_yaml_errs) > 0 {
		mc.populatedError = fmt.Errorf("YAML parsing errors encountered:\n%v", strings.Join(malformed_yaml_errs, "\n"))
	}

	// Mark cache as populated
	mc.populated = true

	return mc.populatedError
}

// Get takes a resource name (like google_compute_instance) and returns
// the metadata for that resource and an `ok` bool of whether the metadata
// exisxts in the cache.
func (mc *MetadataCache) Get(key string) (Metadata, bool) {
	// For IAM resources, return the parent resource's metadata. This could change if we
	// start generating separate IAM metadata in the future. This is primarily for
	// backwards-compatibility with the previous cache behavior and a workaround for _not_
	// generating IAM resource metadata.
	key, _ = strings.CutSuffix(key, "_iam_member")
	key, _ = strings.CutSuffix(key, "_iam_binding")
	key, _ = strings.CutSuffix(key, "_iam_policy")
	m, ok := mc.cache[key]
	return m, ok
}

func (mc *MetadataCache) Cache() map[string]Metadata {
	return mc.cache
}

// getServicesDir returns the path to the services directory
// It will attempt to find the project root relative to cwd
func getServicesDir() (string, error) {
	var startingDirs []string
	// Try to find project root
	root, err := findProjectRoot()
	if err != nil {
		fmt.Printf("Error finding project root: %v", err)
		// Fall back to dirs relative the current directory
		currentDir, err := os.Getwd()
		if err != nil {
			return "", fmt.Errorf("failed to determine current directory: %v", err)
		}
		startingDirs = []string{
			filepath.Join(currentDir),
			filepath.Join(currentDir, ".."),
			filepath.Join(currentDir, "..", ".."),
		}
	} else {
		startingDirs = append(startingDirs, root)
	}

	for _, dir := range startingDirs {
		files, err := os.ReadDir(dir)
		if err != nil {
			return "", fmt.Errorf("Failed reading dir %q: %v", dir, err)
		}

		for _, file := range files {
			fi, err := file.Info()
			if err != nil {
				return "", fmt.Errorf("Failed getting info for file %q: %v", filepath.Join(dir, file.Name()), err)
			}

			if fi.Mode().IsDir() && strings.HasPrefix(file.Name(), "google") {
				servicesDir := filepath.Join(dir, file.Name(), "services")
				if _, err := os.Stat(servicesDir); err == nil {
					return servicesDir, nil
				}
			}
		}
	}

	return "", fmt.Errorf("unable to locate services directory, please provide explicit project root path")
}

// findProjectRoot walks up from the current directory to find the project root
// by looking for the go.mod file
func findProjectRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		// Check if go.mod exists in the current directory
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}

		// Move up to the parent directory
		parentDir := filepath.Dir(dir)
		if parentDir == dir {
			// Reached the filesystem root without finding go.mod
			return "", fmt.Errorf("could not find go.mod file in any parent directory")
		}
		dir = parentDir
	}
}
