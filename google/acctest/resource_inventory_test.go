// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/acctest/resource_inventory_test.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package acctest_test

import (
	"context"
	"fmt"
	"maps"
	"regexp"
	"slices"
	"strings"
	"testing"

	fwattr "github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	fwschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	fwtypes "github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/acctest"
	"github.com/hashicorp/terraform-provider-google/google/fwprovider"
	"github.com/hashicorp/terraform-provider-google/google/provider"
)

type ProviderResource struct {
	Name   string
	Fields map[string]bool
}

func buildProviderResources(pluginSdk map[string]*schema.Resource, pluginFramework []func() resource.Resource) map[string]ProviderResource {
	ctx := context.Background()
	resources := map[string]ProviderResource{}
	// terraform-plugin-sdk-v2
	for resourceName, resource := range pluginSdk {
		// We don't care about IAM resources because they don't have their own meta.yaml files
		if acctest.IsIamResource(resourceName) {
			continue
		}
		r := ProviderResource{
			Name:   resourceName,
			Fields: map[string]bool{},
		}
		flattened := flattenSchema("", resource.Schema)
		for f := range flattened {
			r.Fields[f] = true
		}
		resources[resourceName] = r
	}
	// plugin-framework
	for _, f := range pluginFramework {
		fwResource := f()
		metadataReq := resource.MetadataRequest{ProviderTypeName: "google"}
		metadataResp := &resource.MetadataResponse{}
		fwResource.Metadata(ctx, metadataReq, metadataResp)

		resourceName := metadataResp.TypeName
		r := ProviderResource{
			Name:   resourceName,
			Fields: map[string]bool{},
		}

		schemaReq := resource.SchemaRequest{}
		schemaResp := &resource.SchemaResponse{}
		fwResource.Schema(ctx, schemaReq, schemaResp)
		flattened := flattenPluginFrameworkSchema(schemaResp.Schema.Attributes)
		for f, _ := range flattened {
			r.Fields[f] = true
		}
		resources[resourceName] = r
	}
	return resources
}

// from mmv1/tools/diff-processor/diff - modified to only include leaf fields
func flattenSchema(parentKey string, schemaObj map[string]*schema.Schema) map[string]*schema.Schema {
	flattened := make(map[string]*schema.Schema)

	if parentKey != "" {
		parentKey += "."
	}

	for fieldName, field := range schemaObj {
		key := parentKey + fieldName
		childResource, hasNestedFields := field.Elem.(*schema.Resource)
		if field.Elem != nil && hasNestedFields && len(childResource.Schema) > 0 {
			for childKey, childField := range flattenSchema(key, childResource.Schema) {
				flattened[childKey] = childField
			}
		} else {
			flattened[key] = field
		}
	}

	return flattened
}

// This is overly simplified - we only have two plugin framework resources so we don't need to handle everything
func flattenPluginFrameworkTypes(parentKey string, attrTypes map[string]fwattr.Type) map[string]bool {
	flattened := make(map[string]bool)
	parentKey += "."
	for fieldName := range attrTypes {
		key := parentKey + fieldName
		flattened[key] = true
	}
	return flattened
}

// This is overly simplified - we only have two plugin framework resources so we don't need to handle everything
func flattenPluginFrameworkSchema(schemaObj map[string]fwschema.Attribute) map[string]bool {
	flattened := make(map[string]bool)
	for fieldName, attribute := range schemaObj {
		key := fieldName
		if l, ok := attribute.(fwschema.ListAttribute); ok {
			if child, ok := l.ElementType.(fwtypes.ObjectType); ok {
				for childKey, _ := range flattenPluginFrameworkTypes(key, child.AttrTypes) {
					flattened[childKey] = true
				}
			}
		} else {
			flattened[key] = true
		}
	}
	return flattened
}

// set of google_resource.field.path fields to ignore during analysis
var ignoredFields = map[string]bool{
	// These fields are ignored because they're client-side only fields added with
	// extra_schema_entry. Shouldn't impact coverage.
	"google_api_gateway_api_config.api_config_id_prefix":                  true,
	"google_bigquery_dataset_access.api_updated_member":                   true,
	"google_bigtable_app_profile.multi_cluster_routing_cluster_ids":       true,
	"google_bigtable_app_profile.row_affinity":                            true,
	"google_compute_firewall.enable_logging":                              true,
	"google_compute_region_ssl_certificate.name_prefix":                   true,
	"google_compute_route.next_hop_instance_zone":                         true,
	"google_compute_ssl_certificate.name_prefix":                          true,
	"google_compute_subnetwork.fingerprint":                               true,
	"google_redis_instance.auth_string":                                   true,
	"google_secret_manager_regional_secret_version.is_secret_data_base64": true,
	"google_secret_manager_secret_version.is_secret_data_base64":          true,
	"google_sourcerepo_repository.create_ignore_already_exists":           true,
	"google_vertex_ai_featurestore_entitytype.region":                     true,
	"google_vertex_ai_featurestore_entitytype_feature.region":             true,
	"google_workflows_workflow.name_prefix":                               true,

	// query / URL params - need to decide how to handle, but don't impact coverage
	"google_compute_instance_from_template.source_instance_template": true,
	"google_bigquery_table.table_metadata_view":                      true,
	"google_container_registry.bucket_self_link":                     true,
	"google_container_registry.location":                             true,

	// Something weird about this one, probably related to flatten_object usage.
	"google_data_catalog_tag.fields.enum_value": true,
}

func ignoreField(r, f string) bool {
	if f == "project" {
		return true
	}
	if ignoredFields[fmt.Sprintf("%s.%s", r, f)] {
		return true
	}
	return false
}

// Slightly modified from mmv1/google/string_utils.go
func underscore(source string) string {
	tmp := regexp.MustCompile(`([A-Z]+)([A-Z][a-z])`).ReplaceAllString(source, "${1}_${2}")
	tmp = regexp.MustCompile(`([a-z\d])([A-Z])`).ReplaceAllString(tmp, "${1}_${2}")
	tmp = strings.Replace(tmp, "-", "_", 1)
	// skip this because we want to operate on nested api fields
	// tmp = strings.Replace(tmp, ".", "_", 1)
	tmp = strings.ToLower(tmp)
	return tmp
}

func TestValidateResourceMetadata(t *testing.T) {
	err := acctest.GlobalMetadataCache.Populate()
	if err != nil {
		t.Fatalf("Failed to populate metadata cache: %v", err)
	}

	ctx := context.Background()
	resources := buildProviderResources(provider.ResourceMap(), fwprovider.New(provider.Provider()).Resources(ctx))
	metaResources := acctest.GlobalMetadataCache.Cache()

	// Check for resources that are only in the provider / only in metadata
	sortedResourceNames := slices.Sorted(maps.Keys(resources))
	for _, resourceName := range sortedResourceNames {
		if _, ok := metaResources[resourceName]; !ok {
			t.Errorf("Resource %q has no meta.yaml file", resourceName)
		}
	}
	for _, resourceName := range slices.Sorted(maps.Keys(metaResources)) {
		if _, ok := resources[resourceName]; !ok {
			t.Errorf("Resource %q has meta.yaml file but isn't present in the provider", resourceName)
		}
	}

	// Check for fields that are in the provider but not in metadata (or vice versa)
	for _, resourceName := range sortedResourceNames {
		r := resources[resourceName]
		m := metaResources[resourceName]
		mFields := map[string]bool{}
		for _, f := range m.Fields {
			terraformField := f.Field
			if terraformField == "" {
				terraformField = underscore(f.ApiField)
			}
			mFields[terraformField] = true
		}
		for _, f := range slices.Sorted(maps.Keys(r.Fields)) {
			if ignoreField(r.Name, f) {
				continue
			}
			if _, ok := mFields[f]; !ok {
				t.Errorf("Field in provider resource; missing in meta.yaml: %s.%s", r.Name, f)
			}
		}
		for f, _ := range mFields {
			if ignoreField(r.Name, f) {
				continue
			}
			if _, ok := r.Fields[f]; !ok {
				t.Errorf("Field in meta.yaml; missing in provider resource: %s.%s", r.Name, f)
			}
		}
	}

	// Most of the fields in this list probably represent bugs in resource logic
	// and should be fixed over time.
	allowedApiNameUnderscores := map[string]bool{
		"google_bigquery_job.user_email":                                                                                               true,
		"google_billing_project_info.billing_account":                                                                                  true,
		"google_cloud_run_v2_service.template.containers.build_info.source_location":                                                   true,
		"google_compute_router_peer.custom_learned_route_priority":                                                                     true,
		"google_dataproc_batch.runtime_config.effective_properties":                                                                    true,
		"google_dataproc_session_template.runtime_config.effective_properties":                                                         true,
		"google_datastream_connection_profile.salesforce_profile.oauth2_client_credentials.client_id":                                  true,
		"google_developer_connect_insights_config.errors.details.detail_message":                                                       true,
		"google_integrations_auth_config.client_certificate.encrypted_private_key":                                                     true,
		"google_integrations_auth_config.client_certificate.passphrase":                                                                true,
		"google_integrations_auth_config.client_certificate.ssl_certificate":                                                           true,
		"google_os_config_v2_policy_orchestrator.orchestration_state.current_iteration_state.error.details.type_url":                   true,
		"google_os_config_v2_policy_orchestrator.orchestration_state.previous_iteration_state.error.details.type_url":                  true,
		"google_os_config_v2_policy_orchestrator_for_folder.orchestration_state.current_iteration_state.error.details.type_url":        true,
		"google_os_config_v2_policy_orchestrator_for_folder.orchestration_state.previous_iteration_state.error.details.type_url":       true,
		"google_os_config_v2_policy_orchestrator_for_organization.orchestration_state.current_iteration_state.error.details.type_url":  true,
		"google_os_config_v2_policy_orchestrator_for_organization.orchestration_state.previous_iteration_state.error.details.type_url": true,
	}

	// Validate yaml files
	for resourceName, r := range metaResources {
		if r.Resource == "" {
			t.Errorf("`resource` is missing from %s", r.Path)
		}
		if r.ServicePackage == "" {
			t.Errorf("%s: can't detect service package", r.Resource)
		}

		// Allowlist google_container_registry because it doesn't clearly correspond to a service.
		// We don't currently have a concept of a "provider-only" resource; if more examples show up,
		// we could consider adding one.
		if resourceName != "google_container_registry" {
			if r.ApiServiceName == "" {
				t.Errorf("%s: `api_service_name` is required and not set", r.Resource)
			}
			// Allowlist google_biglake_iceberg_catalog as a pre-existing case. I believe
			// that's a mistake which should be corrected at some point in the future.
			if r.ApiVersion == "" && resourceName != "google_biglake_iceberg_catalog" {
				t.Errorf("%s: `api_version` is required and not set", r.Resource)
			}
			if r.ApiResourceTypeKind == "" {
				t.Errorf("%s: `api_resource_type_kind` is required and not set", r.Resource)
			}
		}

		for _, f := range r.Fields {
			tfField := f.Field
			if tfField == "" {
				tfField = underscore(f.ApiField)
			}
			if f.ProviderOnly && f.ApiField != "" {
				t.Errorf("%s.%s: `api_field` can't be set for provider-only fields", r.Resource, tfField)
			}
			if f.Field != "" && f.Field == underscore(f.ApiField) {
				t.Errorf("%s.%s: `field` must be omitted because it can be inferred from `api_field`", r.Resource, tfField)
			}
			if strings.Contains(f.ApiField, "_") {
				k := fmt.Sprintf("%s.%s", r.Resource, tfField)
				if !allowedApiNameUnderscores[k] {
					t.Errorf("%s.%s: `api_field` can't contain `_` characters", r.Resource, tfField)
				}
			}
		}
	}
	t.Logf("Docs: https://googlecloudplatform.github.io/magic-modules/reference/metadata/")
}
