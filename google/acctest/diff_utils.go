// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/acctest/diff_utils.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package acctest

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-go/tfprotov5"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
)

const diffTag = "[Diff]"

func isReleaseDiffEnabled() bool {
	releaseDiff := os.Getenv("RELEASE_DIFF")
	return releaseDiff != ""
}

func initializeReleaseDiffTest(c resource.TestCase, testName string, tempOutputFile *os.File) resource.TestCase {
	var releaseProvider string
	packagePath := fmt.Sprint(reflect.TypeOf(transport_tpg.Config{}).PkgPath())
	if strings.Contains(packagePath, "google-beta") {
		releaseProvider = "google-beta"
	} else {
		releaseProvider = "google"
	}

	if c.ExternalProviders != nil {
		c.ExternalProviders[releaseProvider] = resource.ExternalProvider{}
	} else {
		c.ExternalProviders = map[string]resource.ExternalProvider{
			releaseProvider: {
				// if left empty fetches most recent release provider
			},
		}
	}

	localProviderName := "google-local"
	if c.Providers != nil {
		c.Providers = map[string]*schema.Provider{
			localProviderName: GetSDKProvider(testName),
		}
		c.ProtoV5ProviderFactories = map[string]func() (tfprotov5.ProviderServer, error){
			localProviderName: func() (tfprotov5.ProviderServer, error) {
				return nil, nil
			},
		}
	} else {
		c.ProtoV5ProviderFactories = map[string]func() (tfprotov5.ProviderServer, error){
			localProviderName: func() (tfprotov5.ProviderServer, error) {
				provider, err := MuxedProviders(testName)
				return provider(), err
			},
		}
	}
	// InsertDiffSteps adds modified steps to the test that run with an external provider
	// these steps do the actual infrastructure provisioning, and c.Steps is updated in the method to have the modified steps
	c = InsertDiffSteps(c, tempOutputFile, releaseProvider, localProviderName)
	return c
}

// InsertDiffSteps inserts a new step into the test case that reformats the config to use the release provider - this allows us to see the diff
// between the local provider and the release provider
func InsertDiffSteps(c resource.TestCase, tempOutputFile *os.File, releaseProvider string, localProviderName string) resource.TestCase {
	var countSteps = 0

	var replacementSteps []resource.TestStep
	for _, testStep := range c.Steps {
		countSteps++
		if testStep.Config != "" {
			ogConfig := testStep.Config
			fmt.Fprintf(tempOutputFile, "[DEBUG] Original config: %s\n", ogConfig)
			testStep.Config = ReformConfigWithProvider(ogConfig, localProviderName)
			fmt.Fprintf(tempOutputFile, "[DEBUG] Reformatted config: %s\n", testStep.Config)
			testStep.PreConfig = func() {
				fmt.Fprintf(tempOutputFile, "%s Step %d\n", diffTag, countSteps)
			}
			if testStep.ExpectError == nil && !testStep.PlanOnly {
				newStep := resource.TestStep{
					PreConfig: func() {
						fmt.Fprintf(tempOutputFile, "Regular Step %d\n", countSteps)
					},
					Config: ReformConfigWithProvider(ogConfig, releaseProvider),
				}
				testStep.PlanOnly = true
				testStep.ExpectNonEmptyPlan = false
				replacementSteps = append(replacementSteps, newStep)
			}
			replacementSteps = append(replacementSteps, testStep)
		} else {
			replacementSteps = append(replacementSteps, testStep)
		}
	}
	c.Steps = replacementSteps
	return c
}

// reformConfigWithProvider reformats the config to use the given provider
// The method matches a regex for the provider block and replaces it with the given provider.
// For example: ' data "google_compute_network" "default" { provider = "google-local" } '
// will be reformatted to ' data "google_compute_network" "default" { provider = "google-beta" } '
func ReformConfigWithProvider(config, provider string) string {
	configBytes := []byte(config)
	providerReplacement := fmt.Sprintf("provider = %s", provider)
	providerReplacementBytes := []byte(providerReplacement)
	providerBlock := regexp.MustCompile(`provider *=.*google-beta.*`)

	if providerBlock.Match(configBytes) {
		out := string(providerBlock.ReplaceAll(configBytes, providerReplacementBytes))
		return out
	}

	providerReplacement = fmt.Sprintf("${1}\n  %s\n", providerReplacement)
	providerReplacementBytes = []byte(providerReplacement)
	// Match resource and data blocks that use google_ provider
	// regex matches for labels resource and data blocks that use google_ provider

	resourceHeader := regexp.MustCompile(`((resource|data) .*google_.* .*\w+.*\{ *)`)
	return string(resourceHeader.ReplaceAll(configBytes, providerReplacementBytes))
}

// ReadDiffOutput reads the outputted temporary file and returns its contents
func ReadDiffOutput(f *os.File) (string, error) {
	if f == nil {
		return "", fmt.Errorf("file handle is nil")
	}

	// Seek to the beginning of the file in case it was just written to.
	if _, err := f.Seek(0, io.SeekStart); err != nil {
		return "", fmt.Errorf("failed to seek to beginning of file: %w", err)
	}

	// Read the entire file content.
	content, err := os.ReadFile(f.Name())
	if err != nil {
		return "", fmt.Errorf("failed to read file: %w", err)
	}

	return string(content), nil
}

// parseReleaseDiffOutput reads the temporary file created during the release diff test and returns whether the last line has a [Diff] flag, the test output, and any errors
func ParseReleaseDiffOutput(output string) (isDiff bool) {
	trimmedOutput := strings.TrimSpace(output)
	if trimmedOutput == "" {
		return false
	}

	lines := strings.Split(trimmedOutput, "\n")
	lastLine := lines[len(lines)-1]

	isDiff = strings.HasPrefix(lastLine, diffTag)

	return isDiff
}

func writeOutputFileDeferFunction(tempOutputFile *os.File, failed bool) {
	if tempOutputFile == nil {
		return
	}
	// parses the temporary file created during the release diff test and returns the last line of output
	// This is useful for extracting the diff output from the file after the test has run

	testOutput, err := ReadDiffOutput(tempOutputFile)
	if err != nil {
		fmt.Printf("Error reading temporary file: %v\n", err)
		return
	}
	isDiff := ParseReleaseDiffOutput(testOutput)
	tempOutputFile.Close()
	err = os.Remove(tempOutputFile.Name())
	if err != nil {
		fmt.Printf("Temporary File Deletion Error: %v\n", err)
	}
	regularFailureFile, err := os.Create(filepath.Join("", "regular_failure_file.log"))
	if err != nil {
		fmt.Printf("Error creating file: %v\n", err)
		return
	}
	defer regularFailureFile.Close()
	diffFailureFile, err := os.Create(filepath.Join("", "diff_failure_file.log"))
	if err != nil {
		fmt.Printf("Error creating file: %v\n", err)
		return
	}
	defer diffFailureFile.Close()
	if failed {
		// Check if the output line starts with "[Diff]"
		if isDiff {
			fmt.Fprintf(os.Stdout, "%s Breaking Change Detected] \n", diffTag)
			fmt.Fprintf(diffFailureFile, "%s %s\n", diffTag, testOutput)
		} else {
			fmt.Fprintf(regularFailureFile, testOutput)
			fmt.Fprintf(regularFailureFile, "FAILED --- %s\n", testOutput)
		}
	}
}
