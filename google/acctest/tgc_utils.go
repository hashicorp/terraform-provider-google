// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/acctest/tgc_utils.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package acctest

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/url"
	"regexp"
	"strings"
	"testing"
	"time"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/terraform"
	"github.com/hashicorp/terraform-provider-google/google/envvar"
)

type ResourceMetadata struct {
	CaiAssetNames   []string       `json:"cai_asset_names"`
	ResourceType    string         `json:"resource_type"`
	ResourceAddress string         `json:"resource_address"`
	ImportMetadata  ImportMetadata `json:"import_metadata,omitempty"`
	Service         string         `json:"service"`
	CaiContentType  string         `json:"cai_content_type,omitempty"`
}

type ImportMetadata struct {
	Id            string   `json:"id,omitempty"`
	IgnoredFields []string `json:"ignored_fields,omitempty"`
}

// The metadata for each step in one test
type TgcMetadataPayload struct {
	TestName         string                      `json:"test_name"`
	StepNumber       int                         `json:"step_number"`
	RawConfig        string                      `json:"raw_config"`
	ResourceMetadata map[string]ResourceMetadata `json:"resource_metadata"`
	PrimaryResource  string                      `json:"primary_resource"`
	CaiReadTime      time.Time                   `json:"cai_read_time"`
}

// PROJECT_NUMBER instead of PROJECT_ID is in the CAI asset names for the resources in those services
// https://cloud.google.com/asset-inventory/docs/asset-names
var serviceWithProjectNumber = map[string]struct{}{
	"apikeys":               {}, // DCL
	"binaryauthorization":   {},
	"cloudtasks":            {},
	"cloudbuild":            {},
	"colab":                 {},
	"containerattached":     {},
	"containeraws":          {},
	"containerazure":        {},
	"dialogflowcx":          {},
	"discoveryengine":       {},
	"documentai":            {},
	"healthcare":            {},
	"iambeta":               {},
	"iap":                   {},
	"identityplatform":      {},
	"logging":               {},
	"monitoring":            {},
	"osconfig":              {},
	"secretmanager":         {},
	"secretmanagerregional": {},
	"vpcaccess":             {},
}

// encodeToBase64JSON converts a struct to base64-encoded JSON
func encodeToBase64JSON(data interface{}) (string, error) {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return "", fmt.Errorf("error marshalling data to JSON: %v", err)
	}

	return base64.StdEncoding.EncodeToString(jsonData), nil
}

// CollectAllTgcMetadata collects metadata for all resources in a test step
func CollectAllTgcMetadata(tgcPayload TgcMetadataPayload) resource.TestCheckFunc {
	return func(s *terraform.State) error {
		tgcPayload.CaiReadTime = time.Now()

		projectId := envvar.GetTestProjectFromEnv()
		projectNumber := envvar.GetTestProjectNumberFromEnv()

		// Process each resource to get CAI asset names and resolve auto IDs
		for address, metadata := range tgcPayload.ResourceMetadata {
			// https://cloud.google.com/asset-inventory/docs/reference/rest/v1/feeds#ContentType
			isIamResource := IsIamResource(metadata.ResourceType)
			if isIamResource {
				metadata.CaiContentType = "IAM_POLICY"
			} else {
				metadata.CaiContentType = "RESOURCE"
			}

			// If there is import metadata update our primary resource
			if metadata.ImportMetadata.Id != "" {
				tgcPayload.PrimaryResource = address
			}

			rState := s.RootModule().Resources[address]
			if rState == nil || rState.Primary == nil {
				log.Printf("[DEBUG]TGC Terraform error: resource state unavailable for %s, skipping", address)
				continue
			}

			// Technically this will always be populated before this point but keeping it here for now so
			// the implementations are more similar.
			err := GlobalMetadataCache.Populate()
			if err != nil {
				log.Printf("[DEBUG] TGC Terraform error: couldn't populate metadata cache: %v", err)
				metadata.CaiAssetNames = []string{"failed_to_populate_metadata_cache"}
			} else {
				yamlMetadata, ok := GlobalMetadataCache.Get(metadata.ResourceType)
				if !ok {
					log.Printf("[DEBUG]TGC Terraform error: unknown resource type %s", metadata.ResourceType)
					metadata.CaiAssetNames = []string{"unknown"}
				} else if yamlMetadata.CaiAssetNameFormat == "" {
					log.Printf("[DEBUG]TGC Terraform error: unknown CAI asset name format for resource type %s", yamlMetadata.CaiAssetNameFormat)

					var rName string
					switch metadata.ResourceType {
					case "google_project":
						rName = fmt.Sprintf("projects/%s", rState.Primary.Attributes["number"])
					default:
						rName = rState.Primary.ID
					}

					if _, ok := serviceWithProjectNumber[metadata.Service]; ok {
						rName = strings.Replace(rName, projectId, projectNumber, 1)
					}

					if isIamResource {
						rName = getIamResourceId(metadata.ResourceType, rName)
					}

					metadata.CaiAssetNames = []string{fmt.Sprintf("//%s/%s", yamlMetadata.ApiServiceName, rName)}
				} else {
					paramsMap := make(map[string]any, 0)
					params := extractIdentifiers(yamlMetadata.CaiAssetNameFormat)
					for _, param := range params {
						v := rState.Primary.Attributes[param]
						paramsMap[param] = v
					}

					caiAssetName := replacePlaceholders(yamlMetadata.CaiAssetNameFormat, paramsMap)

					if _, ok := serviceWithProjectNumber[metadata.Service]; ok {
						caiAssetName = strings.Replace(caiAssetName, projectId, projectNumber, 1)
					}

					metadata.CaiAssetNames = []string{caiAssetName}
				}
			}

			log.Printf("[DEBUG] CaiAssetNames %#v", metadata.CaiAssetNames)

			// Resolve auto IDs in import metadata
			if metadata.ImportMetadata.Id != "" {
				metadata.ImportMetadata.Id = strings.Replace(metadata.ImportMetadata.Id, "<AUTO_ID>", rState.Primary.ID, 1)
			}

			// Update the metadata in the map
			tgcPayload.ResourceMetadata[address] = metadata
		}

		log.Printf("[DEBUG] tgcPayload caireadtime %s", tgcPayload.CaiReadTime)

		// Encode the entire payload to base64 JSON
		encodedData, err := encodeToBase64JSON(tgcPayload)
		if err != nil {
			log.Printf("[DEBUG]test_step_number=%d TGC Terraform error: %v", tgcPayload.StepNumber, err)
		} else {
			log.Printf("[DEBUG]test_step_number=%d TGC Terraform metadata: %s", tgcPayload.StepNumber, encodedData)
		}

		return nil
	}
}

// For example, for the url "projects/{{project}}/schemas/{{schema}}",
// the identifiers are "project", "schema".
func extractIdentifiers(url string) []string {
	matches := regexp.MustCompile(`\{\{%?(\w+)\}\}`).FindAllStringSubmatch(url, -1)
	var result []string
	for _, match := range matches {
		result = append(result, match[1])
	}
	return result
}

// It replaces all instances of {{key}} in the template with the
// corresponding value from the parameters map.
func replacePlaceholders(template string, params map[string]any) string {
	re := regexp.MustCompile("{{([%[:word:]]+)}}")

	result := re.ReplaceAllStringFunc(template, func(match string) string {
		key := strings.Trim(match, "{}")

		// The % indicates that the name value should be URL-encoded.
		key, shouldBeEncoded := strings.CutPrefix(key, "%")
		if value, ok := params[key]; ok {
			v := value.(string)
			if !shouldBeEncoded {
				return v
			}
			return url.PathEscape(v)
		}

		return match
	})

	return result
}

// parseResources extracts all resources from a Terraform configuration string
func parseResources(config string) []string {
	// This regex matches resource blocks in Terraform configurations
	resourceRegex := regexp.MustCompile(`resource\s+"([^"]+)"\s+"([^"]+)"`)
	matches := resourceRegex.FindAllStringSubmatch(config, -1)

	var resources []string
	for _, match := range matches {
		if len(match) >= 3 {
			// Combine resource type and name to form the address
			resources = append(resources, fmt.Sprintf("%s.%s", match[1], match[2]))
		}
	}

	return resources
}

// determineImportMetadata checks if the next step is an import step and extracts all import metadata
func determineImportMetadata(steps []resource.TestStep, currentStepIndex int, resourceName string) ImportMetadata {
	var metadata ImportMetadata

	// Check if there's a next step and if it's an import step
	if currentStepIndex+1 < len(steps) {
		nextStep := steps[currentStepIndex+1]

		// Check if it's an import step for our resource
		if nextStep.ImportState && nextStep.ResourceName == resourceName {
			// Capture ignored fields if present
			if nextStep.ImportStateVerify && len(nextStep.ImportStateVerifyIgnore) > 0 {
				metadata.IgnoredFields = nextStep.ImportStateVerifyIgnore
			}

			// If ImportStateId is explicitly set, use that
			if nextStep.ImportStateId != "" {
				metadata.Id = nextStep.ImportStateId
				return metadata
			}

			// If ImportStateIdPrefix is set, note it
			if nextStep.ImportStateIdPrefix != "" {
				metadata.Id = fmt.Sprintf("%s<AUTO_ID>", nextStep.ImportStateIdPrefix)
				return metadata
			}

			// If ImportStateIdFunc is set, get function info
			if nextStep.ImportStateIdFunc != nil {
				metadata.Id = "<DYNAMIC_IMPORT_ID>"
				return metadata
			}

			// Default case - the ID will be automatically determined
			metadata.Id = "<AUTO_ID>"
			return metadata
		}
	}

	return metadata
}

// extendWithTGCData adds TGC metadata check function to the last non-plan config entry
func extendWithTGCData(t *testing.T, c resource.TestCase) resource.TestCase {
	var updatedSteps []resource.TestStep

	populateErr := GlobalMetadataCache.Populate()
	if populateErr != nil {
		log.Printf("[DEBUG] TGC Terraform error: couldn't populate metadata cache: %v", populateErr)
	}

	// Process all steps
	for i, step := range c.Steps {
		// If this is a non-plan config step, add our TGC check
		if step.Config != "" && !step.PlanOnly {
			// Parse resources from the config
			resources := parseResources(step.Config)

			// Skip if no resources found
			if len(resources) == 0 {
				updatedSteps = append(updatedSteps, step)
				continue
			}

			// Determine the service package from the first resource
			firstResource := resources[0]
			parts := strings.Split(firstResource, ".")
			if len(parts) < 2 {
				updatedSteps = append(updatedSteps, step)
				continue
			}

			// Collect metadata for all resources
			resourceMetadata := make(map[string]ResourceMetadata)

			// Create the consolidated TGC payload
			tgcPayload := TgcMetadataPayload{
				TestName:         t.Name(),
				StepNumber:       i + 1, // Step number starts from 1
				RawConfig:        step.Config,
				ResourceMetadata: resourceMetadata,
			}

			for _, res := range resources {
				parts := strings.Split(res, ".")
				if len(parts) >= 2 {
					resourceType := parts[0]

					// Determine import metadata if the next step is an import step
					importMeta := determineImportMetadata(c.Steps, i, res)

					service := "unknown"
					if populateErr != nil {
						service = "failed_to_populate_metadata_cache"
					} else if yamlMetadata, ok := GlobalMetadataCache.Get(resourceType); ok {
						service = yamlMetadata.ServicePackage
					}

					// Create metadata for this resource
					resourceMetadata[res] = ResourceMetadata{
						ResourceType:    resourceType,
						ResourceAddress: res,
						ImportMetadata:  importMeta,
						Service:         service,
						// CaiAssetNames will be populated at runtime in the check function
					}
				}
			}

			// Add a single consolidated TGC check for all resources
			tgcCheck := CollectAllTgcMetadata(tgcPayload)

			// If there's an existing check function, wrap it with our consolidated check
			if step.Check != nil {
				existingCheck := step.Check
				step.Check = resource.ComposeTestCheckFunc(
					existingCheck,
					tgcCheck,
				)
			} else {
				// Otherwise, just use our consolidated check
				step.Check = tgcCheck
			}
		}

		updatedSteps = append(updatedSteps, step)
	}

	c.Steps = updatedSteps
	return c
}

// Gets IAM resource Id by removing the IAM role and member binding information from id
// id "projects/local-mediator-361721/zones/us-central1-a/instances/tf-test-my-instancev8xqssrek2/roles/compute.osLogin/user:admin@example.com"
// will become "projects/local-mediator-361721/zones/us-central1-a/instances/tf-test-my-instancev8xqssrek2"
func getIamResourceId(resourceType, id string) string {
	parts := strings.Split(id, "/roles/")

	if len(parts) > 0 {
		return parts[0]
	}

	return id
}

var iamSuffixes = []string{
	"_iam_member",
	"_iam_policy",
	"_iam_binding",
	"_iam_audit_config",
}

// Checks if a resource is an IAM resource
func IsIamResource(resourceType string) bool {
	for _, suffix := range iamSuffixes {
		if strings.HasSuffix(resourceType, suffix) {
			return true
		}
	}
	return false
}
