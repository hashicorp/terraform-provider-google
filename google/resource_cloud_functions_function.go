// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"reflect"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/helper/validation"
)

type cloudFunctionId struct {
	Project string
	Region  string
	Name    string
}

func (s *cloudFunctionId) cloudFunctionId() string {
	return fmt.Sprintf("projects/%s/locations/%s/functions/%s", s.Project, s.Region, s.Name)
}

// Differs from validateGcpName because Cloud Functions allow capital letters
// at start/end
func validateResourceCloudFunctionsFunctionName(v interface{}, k string) (ws []string, errors []error) {
	re := `^(?:[a-zA-Z](?:[-_a-zA-Z0-9]{0,61}[a-zA-Z0-9])?)$`
	return validateRegexp(re)(v, k)
}

// based on compareSelfLinkOrResourceName, but less reusable and allows multi-/
// strings in the new state (config) part
func compareSelfLinkOrResourceNameWithMultipleParts(_, old, new string, _ *schema.ResourceData) bool {
	return strings.HasSuffix(old, new)
}

func resourceCloudFunctionsFunction() *schema.Resource {
	return &schema.Resource{
		Create: resourceCloudFunctionsFunctionCreate,
		Read:   resourceCloudFunctionsFunctionRead,
		Update: resourceCloudFunctionsFunctionUpdate,
		Delete: resourceCloudFunctionsFunctionDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCloudFunctionsFunctionImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(5 * time.Minute),
			Update: schema.DefaultTimeout(5 * time.Minute),
			Delete: schema.DefaultTimeout(5 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validateResourceCloudFunctionsFunctionName,
				Description: `A user-defined name of the function. Function names must
be unique globally and match pattern 'projects/*/locations/*/functions/*'.`,
			},
			"region": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The location of this cloud function.`,
			},
			"available_memory_mb": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: `The amount of memory in MB available for a function. Defaults to 256MB.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `User-provided description of a function.`,
			},
			"entry_point": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `The name of the function (as defined in source code) that will be executed.
Defaults to the resource name suffix, if not specified. For backward
compatibility, if function with given name is not found, then the system
will try to use function named "function". For Node.js this is name of a
function exported by the module specified in 'source_location'.`,
			},
			"environment_variables": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: `Environment variables that shall be available during function execution.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"event_trigger": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `A source that fires events in response to a condition in another service.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"event_type": {
							Type:     schema.TypeString,
							Required: true,
							Description: `The type of event to observe. For example:
'providers/cloud.storage/eventTypes/object.change' and
'providers/cloud.pubsub/eventTypes/topic.publish'.`,
						},
						"resource": {
							Type:             schema.TypeString,
							Required:         true,
							DiffSuppressFunc: compareSelfLinkOrResourceNameWithMultipleParts,
							Description: `The resource(s) from which to observe events,
for example, 'projects/_/buckets/myBucket.'`,
						},
						"failure_policy": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Specifies policy for failed executions.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"retry": {
										Type:        schema.TypeBool,
										Required:    true,
										Description: `Whether the function should be retried on failure. Defaults to 'false'.`,
									},
								},
							},
						},
						"service": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The hostname of the service that should be observed.`,
						},
					},
				},
			},
			"https_trigger": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `An HTTPS endpoint type of source that can be triggered via URL.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"url": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The deployed url for the function.`,
						},
					},
				},
				ExactlyOneOf: []string{"https_trigger", "event_trigger"},
			},
			"ingress_settings": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: validation.StringInSlice([]string{"INGRESS_SETTINGS_UNSPECIFIED", "ALLOW_ALL", "ALLOW_INTERNAL_ONLY", ""}, false),
				Description:  `The ingress settings for the function, controlling what traffic can reach it. Possible values: ["INGRESS_SETTINGS_UNSPECIFIED", "ALLOW_ALL", "ALLOW_INTERNAL_ONLY"]`,
			},
			"labels": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: `Labels associated with this Cloud Function.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"max_instances": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: `The limit on the maximum number of function instances that may coexist at a given time.`,
			},
			"network": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `The VPC Network that this cloud function can connect to. It can be either
the fully-qualified URI, or the short name of the network resource. If the
short network name is used, the network must belong to the same project.
Otherwise, it must belong to a project within the same organization.
The format of this field is either 'projects/{project}/global/networks/{network}'
or '{network}', where {project} is a project id where the network is defined,
and {network} is the short name of the network.

This field is mutually exclusive with 'vpcConnector' and will be replaced by it.`,
				ExactlyOneOf: []string{"network", "vpc_connector"},
			},
			"runtime": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `The runtime in which to run the function. Required when deploying a new
function, optional when updating an existing function. For a complete
list of possible choices, see the [gcloud command reference](https://cloud.google.com/sdk/gcloud/reference/functions/deploy#--runtime).`,
			},
			"source_archive_url": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `The Google Cloud Storage URL, starting with gs://, pointing to the zip
archive which contains the function.`,
				ExactlyOneOf: []string{"source_archive_url", "source_repository", "source_upload_url"},
			},
			"source_repository": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The source repository where a function is hosted.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The URL pointing to the hosted repository where the function is defined`,
						},
						"deployed_url": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The URL pointing to the hosted repository where the function were defined
at the time of deployment.`,
						},
					},
				},
				ExactlyOneOf: []string{"source_repository", "source_archive_url", "source_upload_url"},
			},
			"source_upload_url": {
				Type:         schema.TypeString,
				Optional:     true,
				Description:  `The Google Cloud Storage signed URL used for source uploading.`,
				ExactlyOneOf: []string{"source_repository", "source_archive_url", "source_upload_url"},
			},
			"timeout": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `The function execution timeout. Execution is considered failed and can
be terminated if the function is not completed at the end of the timeout
period. Defaults to 60 seconds.`,
			},
			"trigger_http": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Use HTTP to trigger this function`,
			},
			"vpc_connector": {
				Type:             schema.TypeString,
				Optional:         true,
				DiffSuppressFunc: compareSelfLinkOrResourceName,
				Description: `The VPC Network Connector that this cloud function can connect to. It can be
either the fully-qualified URI, or the short name of the network connector
resource. The format of this field is 'projects/*/locations/*/connectors/*'

This field is mutually exclusive with 'network' field and will eventually replace it.`,
				ExactlyOneOf: []string{"network", "vpc_connector"},
			},
			"vpc_connector_egress_settings": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: validation.StringInSlice([]string{"VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED", "PRIVATE_RANGES_ONLY", "ALL_TRAFFIC", ""}, false),
				Description:  `The egress settings for the connector, controlling what traffic is diverted through it. Possible values: ["VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED", "PRIVATE_RANGES_ONLY", "ALL_TRAFFIC"]`,
			},
			"service_account_email": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The email of the function's service account. If empty, defaults to
'{project_id}@appspot.gserviceaccount.com'.`,
			},
			"status": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Status of the function deployment.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The last update timestamp of a Cloud Function`,
			},
			"version_id": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The version identifier of the Cloud Function. Each deployment attempt
results in a new version of a function being created.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
	}
}

func resourceCloudFunctionsFunctionCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	obj := make(map[string]interface{})
	nameProp, err := expandCloudFunctionsFunctionName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !isEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	descriptionProp, err := expandCloudFunctionsFunctionDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !isEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	entryPointProp, err := expandCloudFunctionsFunctionEntryPoint(d.Get("entry_point"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("entry_point"); !isEmptyValue(reflect.ValueOf(entryPointProp)) && (ok || !reflect.DeepEqual(v, entryPointProp)) {
		obj["entryPoint"] = entryPointProp
	}
	runtimeProp, err := expandCloudFunctionsFunctionRuntime(d.Get("runtime"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("runtime"); !isEmptyValue(reflect.ValueOf(runtimeProp)) && (ok || !reflect.DeepEqual(v, runtimeProp)) {
		obj["runtime"] = runtimeProp
	}
	timeoutProp, err := expandCloudFunctionsFunctionTimeout(d.Get("timeout"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("timeout"); !isEmptyValue(reflect.ValueOf(timeoutProp)) && (ok || !reflect.DeepEqual(v, timeoutProp)) {
		obj["timeout"] = timeoutProp
	}
	availableMemoryMbProp, err := expandCloudFunctionsFunctionAvailableMemoryMb(d.Get("available_memory_mb"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("available_memory_mb"); !isEmptyValue(reflect.ValueOf(availableMemoryMbProp)) && (ok || !reflect.DeepEqual(v, availableMemoryMbProp)) {
		obj["availableMemoryMb"] = availableMemoryMbProp
	}
	labelsProp, err := expandCloudFunctionsFunctionLabels(d.Get("labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("labels"); !isEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	environmentVariablesProp, err := expandCloudFunctionsFunctionEnvironmentVariables(d.Get("environment_variables"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("environment_variables"); !isEmptyValue(reflect.ValueOf(environmentVariablesProp)) && (ok || !reflect.DeepEqual(v, environmentVariablesProp)) {
		obj["environmentVariables"] = environmentVariablesProp
	}
	networkProp, err := expandCloudFunctionsFunctionNetwork(d.Get("network"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network"); !isEmptyValue(reflect.ValueOf(networkProp)) && (ok || !reflect.DeepEqual(v, networkProp)) {
		obj["network"] = networkProp
	}
	maxInstancesProp, err := expandCloudFunctionsFunctionMaxInstances(d.Get("max_instances"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("max_instances"); !isEmptyValue(reflect.ValueOf(maxInstancesProp)) && (ok || !reflect.DeepEqual(v, maxInstancesProp)) {
		obj["maxInstances"] = maxInstancesProp
	}
	vpcConnectorProp, err := expandCloudFunctionsFunctionVPCConnector(d.Get("vpc_connector"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vpc_connector"); !isEmptyValue(reflect.ValueOf(vpcConnectorProp)) && (ok || !reflect.DeepEqual(v, vpcConnectorProp)) {
		obj["vpcConnector"] = vpcConnectorProp
	}
	vpcConnectorEgressSettingsProp, err := expandCloudFunctionsFunctionVPCConnectorEgressSettings(d.Get("vpc_connector_egress_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vpc_connector_egress_settings"); !isEmptyValue(reflect.ValueOf(vpcConnectorEgressSettingsProp)) && (ok || !reflect.DeepEqual(v, vpcConnectorEgressSettingsProp)) {
		obj["vpcConnectorEgressSettings"] = vpcConnectorEgressSettingsProp
	}
	ingressSettingsProp, err := expandCloudFunctionsFunctionIngressSettings(d.Get("ingress_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ingress_settings"); !isEmptyValue(reflect.ValueOf(ingressSettingsProp)) && (ok || !reflect.DeepEqual(v, ingressSettingsProp)) {
		obj["ingressSettings"] = ingressSettingsProp
	}
	sourceArchiveUrlProp, err := expandCloudFunctionsFunctionSourceArchiveUrl(d.Get("source_archive_url"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("source_archive_url"); !isEmptyValue(reflect.ValueOf(sourceArchiveUrlProp)) && (ok || !reflect.DeepEqual(v, sourceArchiveUrlProp)) {
		obj["sourceArchiveUrl"] = sourceArchiveUrlProp
	}
	sourceRepositoryProp, err := expandCloudFunctionsFunctionSourceRepository(d.Get("source_repository"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("source_repository"); !isEmptyValue(reflect.ValueOf(sourceRepositoryProp)) && (ok || !reflect.DeepEqual(v, sourceRepositoryProp)) {
		obj["sourceRepository"] = sourceRepositoryProp
	}
	sourceUploadUrlProp, err := expandCloudFunctionsFunctionSourceUploadUrl(d.Get("source_upload_url"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("source_upload_url"); !isEmptyValue(reflect.ValueOf(sourceUploadUrlProp)) && (ok || !reflect.DeepEqual(v, sourceUploadUrlProp)) {
		obj["sourceUploadUrl"] = sourceUploadUrlProp
	}
	httpsTriggerProp, err := expandCloudFunctionsFunctionHttpsTrigger(d.Get("https_trigger"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("https_trigger"); !isEmptyValue(reflect.ValueOf(httpsTriggerProp)) && (ok || !reflect.DeepEqual(v, httpsTriggerProp)) {
		obj["httpsTrigger"] = httpsTriggerProp
	}
	eventTriggerProp, err := expandCloudFunctionsFunctionEventTrigger(d.Get("event_trigger"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("event_trigger"); !isEmptyValue(reflect.ValueOf(eventTriggerProp)) && (ok || !reflect.DeepEqual(v, eventTriggerProp)) {
		obj["eventTrigger"] = eventTriggerProp
	}
	locationProp, err := expandCloudFunctionsFunctionRegion(d.Get("region"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("region"); !isEmptyValue(reflect.ValueOf(locationProp)) && (ok || !reflect.DeepEqual(v, locationProp)) {
		obj["location"] = locationProp
	}
	trigger_httpProp, err := expandCloudFunctionsFunctionTriggerHttp(d.Get("trigger_http"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("trigger_http"); !isEmptyValue(reflect.ValueOf(trigger_httpProp)) && (ok || !reflect.DeepEqual(v, trigger_httpProp)) {
		obj["trigger_http"] = trigger_httpProp
	}

	url, err := replaceVars(d, config, "{{CloudFunctionsBasePath}}projects/{{project}}/locations/{{location}}/functions")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Function: %#v", obj)
	project, err := getProject(d, config)
	if err != nil {
		return err
	}
	res, err := sendRequestWithTimeout(config, "POST", project, url, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating Function: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "projects/{{project}}/locations/{{location}}/functions/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = cloudFunctionsOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating Function",
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Function: %s", err)
	}

	if err := d.Set("name", flattenCloudFunctionsFunctionName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = replaceVars(d, config, "projects/{{project}}/locations/{{location}}/functions/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Function %q: %#v", d.Id(), res)

	return resourceCloudFunctionsFunctionRead(d, meta)
}

func resourceCloudFunctionsFunctionRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	url, err := replaceVars(d, config, "{{CloudFunctionsBasePath}}projects/{{project}}/locations/{{location}}/functions/{{name}}")
	if err != nil {
		return err
	}

	project, err := getProject(d, config)
	if err != nil {
		return err
	}
	res, err := sendRequest(config, "GET", project, url, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("CloudFunctionsFunction %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}

	if err := d.Set("name", flattenCloudFunctionsFunctionName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("description", flattenCloudFunctionsFunctionDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("status", flattenCloudFunctionsFunctionStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("entry_point", flattenCloudFunctionsFunctionEntryPoint(res["entryPoint"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("runtime", flattenCloudFunctionsFunctionRuntime(res["runtime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("timeout", flattenCloudFunctionsFunctionTimeout(res["timeout"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("available_memory_mb", flattenCloudFunctionsFunctionAvailableMemoryMb(res["availableMemoryMb"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("service_account_email", flattenCloudFunctionsFunctionServiceAccountEmail(res["serviceAccountEmail"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("update_time", flattenCloudFunctionsFunctionUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("version_id", flattenCloudFunctionsFunctionVersionId(res["versionId"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("labels", flattenCloudFunctionsFunctionLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("environment_variables", flattenCloudFunctionsFunctionEnvironmentVariables(res["environmentVariables"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("network", flattenCloudFunctionsFunctionNetwork(res["network"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("max_instances", flattenCloudFunctionsFunctionMaxInstances(res["maxInstances"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("vpc_connector", flattenCloudFunctionsFunctionVPCConnector(res["vpcConnector"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("vpc_connector_egress_settings", flattenCloudFunctionsFunctionVPCConnectorEgressSettings(res["vpcConnectorEgressSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("ingress_settings", flattenCloudFunctionsFunctionIngressSettings(res["ingressSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("source_archive_url", flattenCloudFunctionsFunctionSourceArchiveUrl(res["sourceArchiveUrl"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("source_repository", flattenCloudFunctionsFunctionSourceRepository(res["sourceRepository"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("source_upload_url", flattenCloudFunctionsFunctionSourceUploadUrl(res["sourceUploadUrl"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("https_trigger", flattenCloudFunctionsFunctionHttpsTrigger(res["httpsTrigger"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("event_trigger", flattenCloudFunctionsFunctionEventTrigger(res["eventTrigger"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("region", flattenCloudFunctionsFunctionRegion(res["location"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}
	if err := d.Set("trigger_http", flattenCloudFunctionsFunctionTriggerHttp(res["trigger_http"], d, config)); err != nil {
		return fmt.Errorf("Error reading Function: %s", err)
	}

	return nil
}

func resourceCloudFunctionsFunctionUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	project, err := getProject(d, config)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandCloudFunctionsFunctionName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	descriptionProp, err := expandCloudFunctionsFunctionDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	entryPointProp, err := expandCloudFunctionsFunctionEntryPoint(d.Get("entry_point"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("entry_point"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, entryPointProp)) {
		obj["entryPoint"] = entryPointProp
	}
	runtimeProp, err := expandCloudFunctionsFunctionRuntime(d.Get("runtime"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("runtime"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, runtimeProp)) {
		obj["runtime"] = runtimeProp
	}
	timeoutProp, err := expandCloudFunctionsFunctionTimeout(d.Get("timeout"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("timeout"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, timeoutProp)) {
		obj["timeout"] = timeoutProp
	}
	availableMemoryMbProp, err := expandCloudFunctionsFunctionAvailableMemoryMb(d.Get("available_memory_mb"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("available_memory_mb"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, availableMemoryMbProp)) {
		obj["availableMemoryMb"] = availableMemoryMbProp
	}
	labelsProp, err := expandCloudFunctionsFunctionLabels(d.Get("labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("labels"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	environmentVariablesProp, err := expandCloudFunctionsFunctionEnvironmentVariables(d.Get("environment_variables"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("environment_variables"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, environmentVariablesProp)) {
		obj["environmentVariables"] = environmentVariablesProp
	}
	networkProp, err := expandCloudFunctionsFunctionNetwork(d.Get("network"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, networkProp)) {
		obj["network"] = networkProp
	}
	maxInstancesProp, err := expandCloudFunctionsFunctionMaxInstances(d.Get("max_instances"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("max_instances"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, maxInstancesProp)) {
		obj["maxInstances"] = maxInstancesProp
	}
	vpcConnectorProp, err := expandCloudFunctionsFunctionVPCConnector(d.Get("vpc_connector"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vpc_connector"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, vpcConnectorProp)) {
		obj["vpcConnector"] = vpcConnectorProp
	}
	vpcConnectorEgressSettingsProp, err := expandCloudFunctionsFunctionVPCConnectorEgressSettings(d.Get("vpc_connector_egress_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vpc_connector_egress_settings"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, vpcConnectorEgressSettingsProp)) {
		obj["vpcConnectorEgressSettings"] = vpcConnectorEgressSettingsProp
	}
	ingressSettingsProp, err := expandCloudFunctionsFunctionIngressSettings(d.Get("ingress_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ingress_settings"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, ingressSettingsProp)) {
		obj["ingressSettings"] = ingressSettingsProp
	}
	sourceArchiveUrlProp, err := expandCloudFunctionsFunctionSourceArchiveUrl(d.Get("source_archive_url"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("source_archive_url"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, sourceArchiveUrlProp)) {
		obj["sourceArchiveUrl"] = sourceArchiveUrlProp
	}
	sourceRepositoryProp, err := expandCloudFunctionsFunctionSourceRepository(d.Get("source_repository"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("source_repository"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, sourceRepositoryProp)) {
		obj["sourceRepository"] = sourceRepositoryProp
	}
	sourceUploadUrlProp, err := expandCloudFunctionsFunctionSourceUploadUrl(d.Get("source_upload_url"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("source_upload_url"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, sourceUploadUrlProp)) {
		obj["sourceUploadUrl"] = sourceUploadUrlProp
	}
	httpsTriggerProp, err := expandCloudFunctionsFunctionHttpsTrigger(d.Get("https_trigger"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("https_trigger"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, httpsTriggerProp)) {
		obj["httpsTrigger"] = httpsTriggerProp
	}
	eventTriggerProp, err := expandCloudFunctionsFunctionEventTrigger(d.Get("event_trigger"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("event_trigger"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, eventTriggerProp)) {
		obj["eventTrigger"] = eventTriggerProp
	}
	locationProp, err := expandCloudFunctionsFunctionRegion(d.Get("region"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("region"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, locationProp)) {
		obj["location"] = locationProp
	}
	trigger_httpProp, err := expandCloudFunctionsFunctionTriggerHttp(d.Get("trigger_http"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("trigger_http"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, trigger_httpProp)) {
		obj["trigger_http"] = trigger_httpProp
	}

	url, err := replaceVars(d, config, "{{CloudFunctionsBasePath}}projects/{{project}}/locations/{{location}}/functions/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Function %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("name") {
		updateMask = append(updateMask, "name")
	}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("entry_point") {
		updateMask = append(updateMask, "entryPoint")
	}

	if d.HasChange("runtime") {
		updateMask = append(updateMask, "runtime")
	}

	if d.HasChange("timeout") {
		updateMask = append(updateMask, "timeout")
	}

	if d.HasChange("available_memory_mb") {
		updateMask = append(updateMask, "availableMemoryMb")
	}

	if d.HasChange("labels") {
		updateMask = append(updateMask, "labels")
	}

	if d.HasChange("environment_variables") {
		updateMask = append(updateMask, "environmentVariables")
	}

	if d.HasChange("network") {
		updateMask = append(updateMask, "network")
	}

	if d.HasChange("max_instances") {
		updateMask = append(updateMask, "maxInstances")
	}

	if d.HasChange("vpc_connector") {
		updateMask = append(updateMask, "vpcConnector")
	}

	if d.HasChange("vpc_connector_egress_settings") {
		updateMask = append(updateMask, "vpcConnectorEgressSettings")
	}

	if d.HasChange("ingress_settings") {
		updateMask = append(updateMask, "ingressSettings")
	}

	if d.HasChange("source_archive_url") {
		updateMask = append(updateMask, "sourceArchiveUrl")
	}

	if d.HasChange("source_repository") {
		updateMask = append(updateMask, "sourceRepository")
	}

	if d.HasChange("source_upload_url") {
		updateMask = append(updateMask, "sourceUploadUrl")
	}

	if d.HasChange("https_trigger") {
		updateMask = append(updateMask, "httpsTrigger")
	}

	if d.HasChange("event_trigger") {
		updateMask = append(updateMask, "eventTrigger")
	}

	if d.HasChange("region") {
		updateMask = append(updateMask, "location")
	}

	if d.HasChange("trigger_http") {
		updateMask = append(updateMask, "trigger_http")
	}
	// updateMask is a URL parameter but not present in the schema, so replaceVars
	// won't set it
	url, err = addQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}
	res, err := sendRequestWithTimeout(config, "PUT", project, url, obj, d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return fmt.Errorf("Error updating Function %q: %s", d.Id(), err)
	}

	err = cloudFunctionsOperationWaitTime(
		config, res, project, "Updating Function",
		d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return err
	}

	return resourceCloudFunctionsFunctionRead(d, meta)
}

func resourceCloudFunctionsFunctionDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	project, err := getProject(d, config)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{CloudFunctionsBasePath}}projects/{{project}}/locations/{{location}}/functions/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting Function %q", d.Id())

	res, err := sendRequestWithTimeout(config, "DELETE", project, url, obj, d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return handleNotFoundError(err, d, "Function")
	}

	err = cloudFunctionsOperationWaitTime(
		config, res, project, "Deleting Function",
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Function %q: %#v", d.Id(), res)
	return nil
}

func resourceCloudFunctionsFunctionImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/functions/(?P<name>[^/]+)",
		"(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)",
		"(?P<location>[^/]+)/(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "projects/{{project}}/locations/{{location}}/functions/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCloudFunctionsFunctionName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionDescription(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionStatus(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionEntryPoint(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionRuntime(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionTimeout(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionAvailableMemoryMb(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := strconv.ParseInt(strVal, 10, 64); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudFunctionsFunctionServiceAccountEmail(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionUpdateTime(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionVersionId(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionLabels(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionEnvironmentVariables(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionNetwork(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionMaxInstances(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := strconv.ParseInt(strVal, 10, 64); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudFunctionsFunctionVPCConnector(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionVPCConnectorEgressSettings(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionIngressSettings(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionSourceArchiveUrl(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionSourceRepository(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["url"] =
		flattenCloudFunctionsFunctionSourceRepositoryUrl(original["url"], d, config)
	transformed["deployed_url"] =
		flattenCloudFunctionsFunctionSourceRepositoryDeployedUrl(original["deployedUrl"], d, config)
	return []interface{}{transformed}
}
func flattenCloudFunctionsFunctionSourceRepositoryUrl(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionSourceRepositoryDeployedUrl(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionSourceUploadUrl(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionHttpsTrigger(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["url"] =
		flattenCloudFunctionsFunctionHttpsTriggerUrl(original["url"], d, config)
	return []interface{}{transformed}
}
func flattenCloudFunctionsFunctionHttpsTriggerUrl(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionEventTrigger(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["event_type"] =
		flattenCloudFunctionsFunctionEventTriggerEventType(original["eventType"], d, config)
	transformed["resource"] =
		flattenCloudFunctionsFunctionEventTriggerResource(original["resource"], d, config)
	transformed["service"] =
		flattenCloudFunctionsFunctionEventTriggerService(original["service"], d, config)
	transformed["failure_policy"] =
		flattenCloudFunctionsFunctionEventTriggerFailurePolicy(original["failurePolicy"], d, config)
	return []interface{}{transformed}
}
func flattenCloudFunctionsFunctionEventTriggerEventType(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionEventTriggerResource(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionEventTriggerService(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionEventTriggerFailurePolicy(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["retry"] =
		flattenCloudFunctionsFunctionEventTriggerFailurePolicyRetry(original["retry"], d, config)
	return []interface{}{transformed}
}
func flattenCloudFunctionsFunctionEventTriggerFailurePolicyRetry(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionRegion(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudFunctionsFunctionTriggerHttp(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func expandCloudFunctionsFunctionName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionDescription(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionEntryPoint(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionRuntime(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionTimeout(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionAvailableMemoryMb(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionLabels(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudFunctionsFunctionEnvironmentVariables(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudFunctionsFunctionNetwork(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionMaxInstances(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionVPCConnector(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionVPCConnectorEgressSettings(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionIngressSettings(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionSourceArchiveUrl(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionSourceRepository(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUrl, err := expandCloudFunctionsFunctionSourceRepositoryUrl(original["url"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUrl); val.IsValid() && !isEmptyValue(val) {
		transformed["url"] = transformedUrl
	}

	transformedDeployedUrl, err := expandCloudFunctionsFunctionSourceRepositoryDeployedUrl(original["deployed_url"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDeployedUrl); val.IsValid() && !isEmptyValue(val) {
		transformed["deployedUrl"] = transformedDeployedUrl
	}

	return transformed, nil
}

func expandCloudFunctionsFunctionSourceRepositoryUrl(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionSourceRepositoryDeployedUrl(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionSourceUploadUrl(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionHttpsTrigger(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUrl, err := expandCloudFunctionsFunctionHttpsTriggerUrl(original["url"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUrl); val.IsValid() && !isEmptyValue(val) {
		transformed["url"] = transformedUrl
	}

	return transformed, nil
}

func expandCloudFunctionsFunctionHttpsTriggerUrl(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionEventTrigger(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEventType, err := expandCloudFunctionsFunctionEventTriggerEventType(original["event_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEventType); val.IsValid() && !isEmptyValue(val) {
		transformed["eventType"] = transformedEventType
	}

	transformedResource, err := expandCloudFunctionsFunctionEventTriggerResource(original["resource"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResource); val.IsValid() && !isEmptyValue(val) {
		transformed["resource"] = transformedResource
	}

	transformedService, err := expandCloudFunctionsFunctionEventTriggerService(original["service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedService); val.IsValid() && !isEmptyValue(val) {
		transformed["service"] = transformedService
	}

	transformedFailurePolicy, err := expandCloudFunctionsFunctionEventTriggerFailurePolicy(original["failure_policy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFailurePolicy); val.IsValid() && !isEmptyValue(val) {
		transformed["failurePolicy"] = transformedFailurePolicy
	}

	return transformed, nil
}

func expandCloudFunctionsFunctionEventTriggerEventType(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionEventTriggerResource(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionEventTriggerService(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionEventTriggerFailurePolicy(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRetry, err := expandCloudFunctionsFunctionEventTriggerFailurePolicyRetry(original["retry"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRetry); val.IsValid() && !isEmptyValue(val) {
		transformed["retry"] = transformedRetry
	}

	return transformed, nil
}

func expandCloudFunctionsFunctionEventTriggerFailurePolicyRetry(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionRegion(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudFunctionsFunctionTriggerHttp(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}
