// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceCloudDeployTarget() *schema.Resource {
	return &schema.Resource{
		Create: resourceCloudDeployTargetCreate,
		Read:   resourceCloudDeployTargetRead,
		Update: resourceCloudDeployTargetUpdate,
		Delete: resourceCloudDeployTargetDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCloudDeployTargetImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"annotations": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: `User annotations. These attributes can only be set and used by the user, and not by Google Cloud Deploy.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"anthos_cluster": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Information specifying a GKE Cluster.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"membership": {
							Type:         schema.TypeString,
							Optional:     true,
							Description:  `Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is projects/{project}/locations/{location}/memberships/{membership_name}.`,
							ExactlyOneOf: []string{"gke.0.cluster", "anthos_cluster.0.membership"},
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Description of the Target.`,
			},
			"execution_configs": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Configurations for all execution that relates to this Target. Each ExecutionEnvironmentUsage value may only be used in a single configuration;
using the same value multiple times is an error. When one or more configurations are specified, they must include the RENDER and DEPLOY ExecutionEnvironmentUsage values.
When no configurations are specified, execution will use the default specified in DefaultPool.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"usages": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Possible usages of this configuration.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"artifact_storage": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `Cloud Storage location where execution outputs should be stored. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir").
If unspecified, a default bucket located in the same region will be used.`,
						},
						"service_account": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) will be used.`,
						},
						"worker_pool": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Resource name of the Cloud Build worker pool to use. The format is projects/{project}/locations/{location}/workerPools/{pool}.`,
						},
					},
				},
			},
			"gke": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Information specifying a GKE Cluster.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cluster": {
							Type:         schema.TypeString,
							Optional:     true,
							Description:  `Information specifying a GKE Cluster. Format is 'projects/{projectId}/locations/{locationId}/clusters/{cluster_id}.`,
							ExactlyOneOf: []string{"gke.0.cluster", "anthos_cluster.0.membership"},
						},
						"internal_ip": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `If true, cluster is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used.
The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise.`,
						},
					},
				},
			},
			"labels": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: `Resource labels to represent user-provided metadata.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The name of the Target. This value may be up to 60 characters, and valid characters are [a-z0-9_]. The first character cannot be a number.`,
			},
			"region": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `The region of the Target Store. eg us-central1`,
			},
			"require_approval": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Whether or not the Target requires approval.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCloudDeployTargetCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandCloudDeployTargetDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !isEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	labelsProp, err := expandCloudDeployTargetLabels(d.Get("labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("labels"); !isEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	annotationsProp, err := expandCloudDeployTargetAnnotations(d.Get("annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("annotations"); !isEmptyValue(reflect.ValueOf(annotationsProp)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}
	requireApprovalProp, err := expandCloudDeployTargetRequireApproval(d.Get("require_approval"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("require_approval"); !isEmptyValue(reflect.ValueOf(requireApprovalProp)) && (ok || !reflect.DeepEqual(v, requireApprovalProp)) {
		obj["requireApproval"] = requireApprovalProp
	}
	gkeProp, err := expandCloudDeployTargetGke(d.Get("gke"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("gke"); !isEmptyValue(reflect.ValueOf(gkeProp)) && (ok || !reflect.DeepEqual(v, gkeProp)) {
		obj["gke"] = gkeProp
	}
	anthosClusterProp, err := expandCloudDeployTargetAnthosCluster(d.Get("anthos_cluster"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("anthos_cluster"); !isEmptyValue(reflect.ValueOf(anthosClusterProp)) && (ok || !reflect.DeepEqual(v, anthosClusterProp)) {
		obj["anthosCluster"] = anthosClusterProp
	}
	executionConfigsProp, err := expandCloudDeployTargetExecutionConfigs(d.Get("execution_configs"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("execution_configs"); !isEmptyValue(reflect.ValueOf(executionConfigsProp)) && (ok || !reflect.DeepEqual(v, executionConfigsProp)) {
		obj["executionConfigs"] = executionConfigsProp
	}

	url, err := replaceVars(d, config, "{{CloudDeployBasePath}}projects/{{project}}/locations/{{region}}/targets?targetId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Target: %#v", obj)
	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Target: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "POST", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating Target: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "projects/{{project}}/locations/{{region}}/targets/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = cloudDeployOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating Target", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Target: %s", err)
	}

	// This may have caused the ID to update - update it if so.
	id, err = replaceVars(d, config, "projects/{{project}}/locations/{{region}}/targets/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Target %q: %#v", d.Id(), res)

	return resourceCloudDeployTargetRead(d, meta)
}

func resourceCloudDeployTargetRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{CloudDeployBasePath}}projects/{{project}}/locations/{{region}}/targets/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Target: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("CloudDeployTarget %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Target: %s", err)
	}

	if err := d.Set("description", flattenCloudDeployTargetDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Target: %s", err)
	}
	if err := d.Set("labels", flattenCloudDeployTargetLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Target: %s", err)
	}
	if err := d.Set("annotations", flattenCloudDeployTargetAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Target: %s", err)
	}
	if err := d.Set("require_approval", flattenCloudDeployTargetRequireApproval(res["requireApproval"], d, config)); err != nil {
		return fmt.Errorf("Error reading Target: %s", err)
	}
	if err := d.Set("gke", flattenCloudDeployTargetGke(res["gke"], d, config)); err != nil {
		return fmt.Errorf("Error reading Target: %s", err)
	}
	if err := d.Set("anthos_cluster", flattenCloudDeployTargetAnthosCluster(res["anthosCluster"], d, config)); err != nil {
		return fmt.Errorf("Error reading Target: %s", err)
	}
	if err := d.Set("execution_configs", flattenCloudDeployTargetExecutionConfigs(res["executionConfigs"], d, config)); err != nil {
		return fmt.Errorf("Error reading Target: %s", err)
	}

	return nil
}

func resourceCloudDeployTargetUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Target: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandCloudDeployTargetDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	labelsProp, err := expandCloudDeployTargetLabels(d.Get("labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("labels"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	annotationsProp, err := expandCloudDeployTargetAnnotations(d.Get("annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("annotations"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}
	requireApprovalProp, err := expandCloudDeployTargetRequireApproval(d.Get("require_approval"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("require_approval"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, requireApprovalProp)) {
		obj["requireApproval"] = requireApprovalProp
	}
	gkeProp, err := expandCloudDeployTargetGke(d.Get("gke"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("gke"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, gkeProp)) {
		obj["gke"] = gkeProp
	}
	anthosClusterProp, err := expandCloudDeployTargetAnthosCluster(d.Get("anthos_cluster"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("anthos_cluster"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, anthosClusterProp)) {
		obj["anthosCluster"] = anthosClusterProp
	}
	executionConfigsProp, err := expandCloudDeployTargetExecutionConfigs(d.Get("execution_configs"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("execution_configs"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, executionConfigsProp)) {
		obj["executionConfigs"] = executionConfigsProp
	}

	url, err := replaceVars(d, config, "{{CloudDeployBasePath}}projects/{{project}}/locations/{{region}}/targets/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Target %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("labels") {
		updateMask = append(updateMask, "labels")
	}

	if d.HasChange("annotations") {
		updateMask = append(updateMask, "annotations")
	}

	if d.HasChange("require_approval") {
		updateMask = append(updateMask, "requireApproval")
	}

	if d.HasChange("gke") {
		updateMask = append(updateMask, "gke")
	}

	if d.HasChange("anthos_cluster") {
		updateMask = append(updateMask, "anthosCluster")
	}

	if d.HasChange("execution_configs") {
		updateMask = append(updateMask, "executionConfigs")
	}
	// updateMask is a URL parameter but not present in the schema, so replaceVars
	// won't set it
	url, err = addQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "PATCH", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return fmt.Errorf("Error updating Target %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating Target %q: %#v", d.Id(), res)
	}

	err = cloudDeployOperationWaitTime(
		config, res, project, "Updating Target", userAgent,
		d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return err
	}

	return resourceCloudDeployTargetRead(d, meta)
}

func resourceCloudDeployTargetDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Target: %s", err)
	}
	billingProject = project

	url, err := replaceVars(d, config, "{{CloudDeployBasePath}}projects/{{project}}/locations/{{region}}/targets/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting Target %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "DELETE", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return handleNotFoundError(err, d, "Target")
	}

	err = cloudDeployOperationWaitTime(
		config, res, project, "Deleting Target", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Target %q: %#v", d.Id(), res)
	return nil
}

func resourceCloudDeployTargetImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"projects/(?P<project>[^/]+)/locations/(?P<region>[^/]+)/targets/(?P<name>[^/]+)",
		"(?P<project>[^/]+)/(?P<region>[^/]+)/(?P<name>[^/]+)",
		"(?P<region>[^/]+)/(?P<name>[^/]+)",
		"(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "projects/{{project}}/locations/{{region}}/targets/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCloudDeployTargetDescription(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudDeployTargetLabels(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudDeployTargetAnnotations(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudDeployTargetRequireApproval(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudDeployTargetGke(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cluster"] =
		flattenCloudDeployTargetGkeCluster(original["cluster"], d, config)
	transformed["internal_ip"] =
		flattenCloudDeployTargetGkeInternalIp(original["internalIp"], d, config)
	return []interface{}{transformed}
}
func flattenCloudDeployTargetGkeCluster(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudDeployTargetGkeInternalIp(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudDeployTargetAnthosCluster(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["membership"] =
		flattenCloudDeployTargetAnthosClusterMembership(original["membership"], d, config)
	return []interface{}{transformed}
}
func flattenCloudDeployTargetAnthosClusterMembership(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudDeployTargetExecutionConfigs(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"usages":           flattenCloudDeployTargetExecutionConfigsUsages(original["usages"], d, config),
			"service_account":  flattenCloudDeployTargetExecutionConfigsServiceAccount(original["serviceAccount"], d, config),
			"artifact_storage": flattenCloudDeployTargetExecutionConfigsArtifactStorage(original["artifactStorage"], d, config),
			"worker_pool":      flattenCloudDeployTargetExecutionConfigsWorkerPool(original["workerPool"], d, config),
		})
	}
	return transformed
}
func flattenCloudDeployTargetExecutionConfigsUsages(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudDeployTargetExecutionConfigsServiceAccount(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudDeployTargetExecutionConfigsArtifactStorage(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudDeployTargetExecutionConfigsWorkerPool(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func expandCloudDeployTargetDescription(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudDeployTargetLabels(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudDeployTargetAnnotations(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudDeployTargetRequireApproval(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudDeployTargetGke(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCluster, err := expandCloudDeployTargetGkeCluster(original["cluster"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCluster); val.IsValid() && !isEmptyValue(val) {
		transformed["cluster"] = transformedCluster
	}

	transformedInternalIp, err := expandCloudDeployTargetGkeInternalIp(original["internal_ip"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInternalIp); val.IsValid() && !isEmptyValue(val) {
		transformed["internalIp"] = transformedInternalIp
	}

	return transformed, nil
}

func expandCloudDeployTargetGkeCluster(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudDeployTargetGkeInternalIp(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudDeployTargetAnthosCluster(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMembership, err := expandCloudDeployTargetAnthosClusterMembership(original["membership"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMembership); val.IsValid() && !isEmptyValue(val) {
		transformed["membership"] = transformedMembership
	}

	return transformed, nil
}

func expandCloudDeployTargetAnthosClusterMembership(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudDeployTargetExecutionConfigs(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedUsages, err := expandCloudDeployTargetExecutionConfigsUsages(original["usages"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedUsages); val.IsValid() && !isEmptyValue(val) {
			transformed["usages"] = transformedUsages
		}

		transformedServiceAccount, err := expandCloudDeployTargetExecutionConfigsServiceAccount(original["service_account"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedServiceAccount); val.IsValid() && !isEmptyValue(val) {
			transformed["serviceAccount"] = transformedServiceAccount
		}

		transformedArtifactStorage, err := expandCloudDeployTargetExecutionConfigsArtifactStorage(original["artifact_storage"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedArtifactStorage); val.IsValid() && !isEmptyValue(val) {
			transformed["artifactStorage"] = transformedArtifactStorage
		}

		transformedWorkerPool, err := expandCloudDeployTargetExecutionConfigsWorkerPool(original["worker_pool"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedWorkerPool); val.IsValid() && !isEmptyValue(val) {
			transformed["workerPool"] = transformedWorkerPool
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudDeployTargetExecutionConfigsUsages(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudDeployTargetExecutionConfigsServiceAccount(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudDeployTargetExecutionConfigsArtifactStorage(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudDeployTargetExecutionConfigsWorkerPool(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}
