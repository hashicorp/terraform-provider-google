// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/fwresource/framework_import_test.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package fwresource

import (
	"context"
	"reflect"
	"strings"
	"testing"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func TestParseImportId(t *testing.T) {
	testSchema := schema.Schema{
		Attributes: map[string]schema.Attribute{
			"project": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"zone": schema.StringAttribute{
				Required: true,
			},
			"instance_id": schema.Int64Attribute{
				Required: true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.RequiresReplace(),
				},
			},
		},
	}

	cases := map[string]struct {
		importId           string
		idRegexes          []string
		resourceSchema     schema.Schema
		providerConfig     *transport_tpg.Config
		expectedAttributes map[string]attr.Value
		expectError        bool
		errorContains      string
	}{
		"successfully parses full resource ID format": {
			importId: "projects/my-project/zones/us-central1-a/instances/12345",
			idRegexes: []string{
				"projects/(?P<project>[^/]+)/zones/(?P<zone>[^/]+)/instances/(?P<instance_id>[^/]+)",
				"(?P<project>[^/]+)/(?P<zone>[^/]+)/(?P<instance_id>[^/]+)",
			},
			resourceSchema: testSchema,
			providerConfig: &transport_tpg.Config{},
			expectedAttributes: map[string]attr.Value{
				"project":     types.StringValue("my-project"),
				"zone":        types.StringValue("us-central1-a"),
				"instance_id": types.Int64Value(12345),
			},
		},
		"successfully parses shorter ID format": {
			importId: "my-project/us-central1-a/12345",
			idRegexes: []string{
				"projects/(?P<project>[^/]+)/zones/(?P<zone>[^/]+)/instances/(?P<instance_id>[^/]+)",
				"(?P<project>[^/]+)/(?P<zone>[^/]+)/(?P<instance_id>[^/]+)",
			},
			resourceSchema: testSchema,
			providerConfig: &transport_tpg.Config{},
			expectedAttributes: map[string]attr.Value{
				"project":     types.StringValue("my-project"),
				"zone":        types.StringValue("us-central1-a"),
				"instance_id": types.Int64Value(12345),
			},
		},
		"successfully uses provider default for project": {
			importId: "us-central1-a/my-instance/12345",
			idRegexes: []string{
				"projects/(?P<project>[^/]+)/zones/(?P<zone>[^/]+)/instances/(?P<name>[^/]+)/(?P<instance_id>[^/]+)", // Most specific
				"(?P<zone>[^/]+)/(?P<name>[^/]+)/(?P<instance_id>[^/]+)",
			},
			resourceSchema: testSchema,
			providerConfig: &transport_tpg.Config{
				Project: "default-provider-project",
			},
			expectedAttributes: map[string]attr.Value{
				"project":     types.StringValue("default-provider-project"),
				"zone":        types.StringValue("us-central1-a"),
				"name":        types.StringValue("my-instance"),
				"instance_id": types.Int64Value(12345),
			},
		},
		"returns error for non-matching ID": {
			importId: "invalid-id-format",
			idRegexes: []string{
				"projects/(?P<project>[^/]+)/zones/(?P<zone>[^/]+)/instances/(?P<instance_id>[^/]+)",
			},
			resourceSchema: testSchema,
			providerConfig: &transport_tpg.Config{},
			expectError:    true,
			errorContains:  "doesn't match any of the accepted formats",
		},
		"returns error for value that cannot be converted to type": {
			importId: "projects/my-project/zones/us-central1-a/instances/not-an-integer",
			idRegexes: []string{
				"projects/(?P<project>[^/]+)/zones/(?P<zone>[^/]+)/instances/(?P<instance_id>[^/]+)",
			},
			resourceSchema: testSchema,
			providerConfig: &transport_tpg.Config{},
			expectError:    true,
			errorContains:  "Failed to parse \"not-an-integer\" as an integer",
		},
		"returns error for invalid regex pattern": {
			importId: "any/id",
			idRegexes: []string{
				"projects/(?P<project>[^/]+)/zones/(?P<zone>[^/+", // Invalid regex with unclosed bracket
			},
			resourceSchema: testSchema,
			providerConfig: &transport_tpg.Config{},
			expectError:    true,
			errorContains:  "could not compile regex",
		},
		"warns about field in regex not present in schema": {
			importId: "projects/my-project/zones/us-central1-a/instances/12345/extra/field",
			idRegexes: []string{
				"projects/(?P<project>[^/]+)/zones/(?P<zone>[^/]+)/instances/(?P<instance_id>[^/]+)/extra/(?P<extra_field>[^/]+)",
			},
			resourceSchema: testSchema,
			providerConfig: &transport_tpg.Config{},
			// We expect success, but with a warning diagnostic. The valid fields should still be parsed.
			expectedAttributes: map[string]attr.Value{
				"project":     types.StringValue("my-project"),
				"zone":        types.StringValue("us-central1-a"),
				"instance_id": types.Int64Value(12345),
			},
		},
	}

	for name, tc := range cases {
		t.Run(name, func(t *testing.T) {
			ctx := context.Background()
			req := resource.ImportStateRequest{
				ID: tc.importId,
			}

			parsedAttributes, diags := ParseImportId(ctx, req, tc.resourceSchema, tc.providerConfig, tc.idRegexes)

			if diags.HasError() {
				if tc.expectError {
					// Check if the error message contains the expected substring.
					if tc.errorContains != "" {
						found := false
						for _, d := range diags.Errors() {
							if strings.Contains(d.Detail(), tc.errorContains) {
								found = true
								break
							}
						}
						if !found {
							t.Fatalf("expected error to contain %q, but it did not. Got: %v", tc.errorContains, diags.Errors())
						}
					}
					// Correctly handled an expected error.
					return
				}
				t.Fatalf("unexpected error: %v", diags)
			}

			if tc.expectError {
				t.Fatal("expected an error, but got none")
			}

			if !reflect.DeepEqual(tc.expectedAttributes, parsedAttributes) {
				t.Fatalf("incorrect attributes parsed.\n- got:  %v\n- want: %v", parsedAttributes, tc.expectedAttributes)
			}
		})
	}
}
