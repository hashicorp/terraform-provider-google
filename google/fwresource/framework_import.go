// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/fwresource/framework_import.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package fwresource

import (
	"context"
	"fmt"
	"regexp"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

// ParseImportId uses a list of regular expressions to parse a resource's import ID.
// It extracts named capture groups from the regex and converts them to their
// corresponding type-safe attribute values based on the provided resource schema.
// It also handles setting default values (project, region, etc) if they are not
// present in the import ID.
func ParseImportId(
	ctx context.Context,
	req resource.ImportStateRequest,
	resourceSchema schema.Schema,
	providerConfig *transport_tpg.Config,
	idRegexes []string,
) (map[string]attr.Value, diag.Diagnostics) {
	var diags diag.Diagnostics
	parsedAttributes := make(map[string]attr.Value)

	var matchFound bool
	for _, idFormat := range idRegexes {
		re, err := regexp.Compile(idFormat)
		if err != nil {
			diags.AddError(
				"Invalid Import Regex",
				fmt.Sprintf("Provider developer error: could not compile regex %q. Please report this issue. Error: %s", idFormat, err),
			)
			// This is a developer error, so we stop immediately.
			return nil, diags
		}

		if match := re.FindStringSubmatch(req.ID); match != nil {
			matchFound = true
			subexpNames := re.SubexpNames()
			for i, valueStr := range match {
				// Index 0 is the full match, so we skip it.
				if i == 0 {
					continue
				}

				fieldName := subexpNames[i]
				if fieldName == "" {
					continue
				}

				// Look up the attribute in the resource's schema.
				attribute, ok := resourceSchema.Attributes[fieldName]
				if !ok {
					diags.AddWarning(
						"Unknown Import Field",
						fmt.Sprintf("Parsed field %q from import ID but it is not defined in the resource schema.", fieldName),
					)
					continue
				}

				// Convert the parsed string value to the correct attr.Value type.
				attrVal, conversionDiags := convertToAttrValue(valueStr, attribute)
				diags.Append(conversionDiags...)
				if conversionDiags.HasError() {
					continue
				}
				parsedAttributes[fieldName] = attrVal
			}
			// Once a match is found, we stop. The most specific regex should be first.
			break
		}
	}

	if !matchFound {
		diags.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Import ID %q doesn't match any of the accepted formats: %v", req.ID, idRegexes),
		)
		return nil, diags
	}

	// Handle default values like project, region, and zone.
	defaultDiags := addDefaultValues(ctx, parsedAttributes, providerConfig, resourceSchema, idRegexes[0])
	diags.Append(defaultDiags...)

	return parsedAttributes, diags
}

// convertToAttrValue converts a string to the appropriate attr.Value based on the schema attribute type.
func convertToAttrValue(valueStr string, attr schema.Attribute) (attr.Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	switch attr.(type) {
	case schema.StringAttribute:
		return types.StringValue(valueStr), nil
	case schema.Int64Attribute:
		intVal, err := strconv.ParseInt(valueStr, 10, 64)
		if err != nil {
			diags.AddError(
				"Import Value Conversion Error",
				fmt.Sprintf("Failed to parse %q as an integer: %s", valueStr, err),
			)
			return nil, diags
		}
		return types.Int64Value(intVal), nil
	case schema.BoolAttribute:
		boolVal, err := strconv.ParseBool(valueStr)
		if err != nil {
			diags.AddError(
				"Import Value Conversion Error",
				fmt.Sprintf("Failed to parse %q as a boolean: %s", valueStr, err),
			)
			return nil, diags
		}
		return types.BoolValue(boolVal), nil
	case schema.Float64Attribute:
		floatVal, err := strconv.ParseFloat(valueStr, 64)
		if err != nil {
			diags.AddError(
				"Import Value Conversion Error",
				fmt.Sprintf("Failed to parse %q as a float: %s", valueStr, err),
			)
			return nil, diags
		}
		return types.Float64Value(floatVal), nil
	default:
		// For complex types like List, Object, etc., a simple string conversion is not feasible.
		// The assumption is that import IDs will only contain primitive types.
		diags.AddError(
			"Unsupported Import Attribute Type",
			fmt.Sprintf("Importing attributes of type %T is not supported. This is a provider developer issue.", attr),
		)
		return nil, diags
	}
}

// addDefaultValues checks for common provider-level defaults (project, region, zone)
// and adds them to the parsed attributes map if they were not already set from the import ID.
func addDefaultValues(
	ctx context.Context,
	parsedAttributes map[string]attr.Value,
	config *transport_tpg.Config,
	resourceSchema schema.Schema,
	primaryRegex string,
) diag.Diagnostics {
	var diags diag.Diagnostics

	defaults := map[string]func(*transport_tpg.Config) (string, error){
		"project": func(c *transport_tpg.Config) (string, error) { return c.Project, nil },
		"region":  func(c *transport_tpg.Config) (string, error) { return c.Region, nil },
		"zone":    func(c *transport_tpg.Config) (string, error) { return c.Zone, nil },
	}

	for field, getDefault := range defaults {
		// Check if the primary regex expects this field.
		if !strings.Contains(primaryRegex, fmt.Sprintf("(?P<%s>", field)) {
			continue
		}
		// Check if the resource schema actually has this attribute.
		if _, ok := resourceSchema.Attributes[field]; !ok {
			continue
		}
		// Check if the value was already parsed from the import ID.
		if _, ok := parsedAttributes[field]; ok {
			continue
		}

		// Get the default value from the provider configuration.
		value, err := getDefault(config)
		if err != nil {
			diags.AddError(
				fmt.Sprintf("Failed to get default value for %s", field),
				err.Error(),
			)
			continue
		}

		if value != "" {
			parsedAttributes[field] = types.StringValue(value)
		}
	}

	return diags
}
