// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"net"
	"reflect"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func rrdatasDnsDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	o, n := d.GetChange("rrdatas")
	if o == nil || n == nil {
		return false
	}

	oList := convertStringArr(o.([]interface{}))
	nList := convertStringArr(n.([]interface{}))

	parseFunc := func(record string) string {
		switch d.Get("type") {
		case "AAAA":
			// parse ipv6 to a key from one list
			return net.ParseIP(record).String()
		case "MX", "DS":
			return strings.ToLower(record)
		case "TXT":
			return strings.ToLower(strings.Trim(record, `"`))
		default:
			return record
		}
	}
	return rrdatasListDiffSuppress(oList, nList, parseFunc, d)
}

// suppress on a list when 1) its items have dups that need to be ignored
// and 2) string comparison on the items may need a special parse function
// example of usage can be found ../../../third_party/terraform/tests/resource_dns_record_set_test.go.erb
func rrdatasListDiffSuppress(oldList, newList []string, fun func(x string) string, _ *schema.ResourceData) bool {
	// compare two lists of unordered records
	diff := make(map[string]bool, len(oldList))
	for _, oldRecord := range oldList {
		// set all new IPs to true
		diff[fun(oldRecord)] = true
	}
	for _, newRecord := range newList {
		// set matched IPs to false otherwise can't suppress
		if diff[fun(newRecord)] {
			diff[fun(newRecord)] = false
		} else {
			return false
		}
	}
	// can't suppress if unmatched records are found
	for _, element := range diff {
		if element {
			return false
		}
	}
	return true
}

func resourceDNSResourceDnsRecordSet() *schema.Resource {
	return &schema.Resource{
		Create: resourceDNSResourceDnsRecordSetCreate,
		Read:   resourceDNSResourceDnsRecordSetRead,
		Update: resourceDNSResourceDnsRecordSetUpdate,
		Delete: resourceDNSResourceDnsRecordSetDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDNSResourceDnsRecordSetImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(4 * time.Minute),
			Update: schema.DefaultTimeout(4 * time.Minute),
			Delete: schema.DefaultTimeout(4 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"managed_zone": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: compareSelfLinkOrResourceName,
				Description:      `Identifies the managed zone addressed by this request.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `For example, www.example.com.`,
			},
			"type": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validation.StringInSlice([]string{"A", "AAAA", "CAA", "CNAME", "DNSKEY", "DS", "IPSECVPNKEY", "MX", "NAPTR", "NS", "PTR", "SOA", "SPF", "SRV", "SSHFP", "TLSA", "TXT"}, false),
				Description:  `One of valid DNS resource types. Possible values: ["A", "AAAA", "CAA", "CNAME", "DNSKEY", "DS", "IPSECVPNKEY", "MX", "NAPTR", "NS", "PTR", "SOA", "SPF", "SRV", "SSHFP", "TLSA", "TXT"]`,
			},
			"rrdatas": {
				Type:             schema.TypeList,
				Optional:         true,
				ForceNew:         true,
				DiffSuppressFunc: rrdatasDnsDiffSuppress,
				Description: `The string data for the records in this record set whose meaning depends on the DNS type. 
For TXT record, if the string data contains spaces, add surrounding \" if you don't want your string to get
split on spaces. To specify a single record value longer than 255 characters such as a TXT record for 
DKIM, add \"\" inside the Terraform configuration string (e.g. "first255characters\"\"morecharacters").`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"ttl": {
				Type:     schema.TypeInt,
				Optional: true,
				Description: `Number of seconds that this ResourceRecordSet can be cached by
resolvers.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDNSResourceDnsRecordSetCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandDNSResourceDnsRecordSetName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !isEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	typeProp, err := expandDNSResourceDnsRecordSetType(d.Get("type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("type"); !isEmptyValue(reflect.ValueOf(typeProp)) && (ok || !reflect.DeepEqual(v, typeProp)) {
		obj["type"] = typeProp
	}
	ttlProp, err := expandDNSResourceDnsRecordSetTtl(d.Get("ttl"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ttl"); !isEmptyValue(reflect.ValueOf(ttlProp)) && (ok || !reflect.DeepEqual(v, ttlProp)) {
		obj["ttl"] = ttlProp
	}
	rrdatasProp, err := expandDNSResourceDnsRecordSetRrdatas(d.Get("rrdatas"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("rrdatas"); !isEmptyValue(reflect.ValueOf(rrdatasProp)) && (ok || !reflect.DeepEqual(v, rrdatasProp)) {
		obj["rrdatas"] = rrdatasProp
	}
	managed_zoneProp, err := expandDNSResourceDnsRecordSetManagedZone(d.Get("managed_zone"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("managed_zone"); !isEmptyValue(reflect.ValueOf(managed_zoneProp)) && (ok || !reflect.DeepEqual(v, managed_zoneProp)) {
		obj["managed_zone"] = managed_zoneProp
	}

	url, err := replaceVars(d, config, "{{DNSBasePath}}projects/{{project}}/managedZones/{{managed_zone}}/rrsets")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new ResourceDnsRecordSet: %#v", obj)
	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ResourceDnsRecordSet: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "POST", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating ResourceDnsRecordSet: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "projects/{{project}}/managedZones/{{managed_zone}}/rrsets/{{name}}/{{type}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating ResourceDnsRecordSet %q: %#v", d.Id(), res)

	return resourceDNSResourceDnsRecordSetRead(d, meta)
}

func resourceDNSResourceDnsRecordSetRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{DNSBasePath}}projects/{{project}}/managedZones/{{managed_zone}}/rrsets/{{name}}/{{type}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ResourceDnsRecordSet: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("DNSResourceDnsRecordSet %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading ResourceDnsRecordSet: %s", err)
	}

	if err := d.Set("name", flattenDNSResourceDnsRecordSetName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading ResourceDnsRecordSet: %s", err)
	}
	if err := d.Set("type", flattenDNSResourceDnsRecordSetType(res["type"], d, config)); err != nil {
		return fmt.Errorf("Error reading ResourceDnsRecordSet: %s", err)
	}
	if err := d.Set("ttl", flattenDNSResourceDnsRecordSetTtl(res["ttl"], d, config)); err != nil {
		return fmt.Errorf("Error reading ResourceDnsRecordSet: %s", err)
	}
	if err := d.Set("rrdatas", flattenDNSResourceDnsRecordSetRrdatas(res["rrdatas"], d, config)); err != nil {
		return fmt.Errorf("Error reading ResourceDnsRecordSet: %s", err)
	}

	return nil
}

func resourceDNSResourceDnsRecordSetUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ResourceDnsRecordSet: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	typeProp, err := expandDNSResourceDnsRecordSetType(d.Get("type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("type"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, typeProp)) {
		obj["type"] = typeProp
	}
	ttlProp, err := expandDNSResourceDnsRecordSetTtl(d.Get("ttl"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ttl"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, ttlProp)) {
		obj["ttl"] = ttlProp
	}

	url, err := replaceVars(d, config, "{{DNSBasePath}}projects/{{project}}/managedZones/{{managed_zone}}/rrsets/{{name}}/{{type}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating ResourceDnsRecordSet %q: %#v", d.Id(), obj)

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "PATCH", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return fmt.Errorf("Error updating ResourceDnsRecordSet %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating ResourceDnsRecordSet %q: %#v", d.Id(), res)
	}

	return resourceDNSResourceDnsRecordSetRead(d, meta)
}

func resourceDNSResourceDnsRecordSetDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ResourceDnsRecordSet: %s", err)
	}
	billingProject = project

	url, err := replaceVars(d, config, "{{DNSBasePath}}projects/{{project}}/managedZones/{{managed_zone}}/rrsets/{{name}}/{{type}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting ResourceDnsRecordSet %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "DELETE", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return handleNotFoundError(err, d, "ResourceDnsRecordSet")
	}

	log.Printf("[DEBUG] Finished deleting ResourceDnsRecordSet %q: %#v", d.Id(), res)
	return nil
}

func resourceDNSResourceDnsRecordSetImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"projects/(?P<project>[^/]+)/managedZones/(?P<managed_zone>[^/]+)/rrsets/(?P<name>[^/]+)/(?P<type>[^/]+)",
		"(?P<project>[^/]+)/(?P<managed_zone>[^/]+)/(?P<name>[^/]+)/(?P<type>[^/]+)",
		"(?P<managed_zone>[^/]+)/(?P<name>[^/]+)/(?P<type>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "projects/{{project}}/managedZones/{{managed_zone}}/rrsets/{{name}}/{{type}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenDNSResourceDnsRecordSetName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenDNSResourceDnsRecordSetType(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenDNSResourceDnsRecordSetTtl(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := strconv.ParseInt(strVal, 10, 64); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDNSResourceDnsRecordSetRrdatas(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func expandDNSResourceDnsRecordSetName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDNSResourceDnsRecordSetType(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDNSResourceDnsRecordSetTtl(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDNSResourceDnsRecordSetRrdatas(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDNSResourceDnsRecordSetManagedZone(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	f, err := parseGlobalFieldValue("managedZones", v.(string), "project", d, config, true)
	if err != nil {
		return nil, fmt.Errorf("Invalid value for managed_zone: %s", err)
	}
	return f.RelativeLink(), nil
}
