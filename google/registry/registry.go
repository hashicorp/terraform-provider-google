// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/registry/registry.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package registry

import (
	"log"
	"sync"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

// Product defines the shared configuration for a single Magic Modules product. It is
// defined in `product.yaml`.
type Product struct {
	// Name is the product name in lower case, e.g,. "alloydb".
	Name string
	// BaseUrl is the base URL for API requests. It may contain Magic Modules templating directives.
	BaseUrl string
}

// Register adds the product definition to the internal product registry.
func (p Product) Register() {
	products.Lock()
	defer products.Unlock()
	if _, ok := products.m[p.Name]; ok {
		log.Fatalf("Duplicate registration attempt for product %q", p.Name)
	}
	products.m[p.Name] = p
}

type registeredProducts struct {
	sync.RWMutex
	m map[string]Product
}

var products = &registeredProducts{
	m: make(map[string]Product),
}

// SchemaType differentitates a registered Terraform schema in cases where multiple schemas
// share a name. For instance, resources and their corresponding data sources are identically named.
type SchemaType int

const (
	SchemaTypeResource SchemaType = iota
	SchemaTypeIAMResource
	SchemaTypeDataSource
	SchemaTypeIAMDataSource
)

// IsDataSource is a helper method that returns whether a SchemaType refers to a data source or resource.
func (s SchemaType) IsDataSource() bool {
	return s == SchemaTypeDataSource || s == SchemaTypeIAMDataSource
}

// Schema is used to configure a resource or data source within the registry.
type Schema struct {
	// Name is the externally visible name, e.g., "google_alloydb_cluster".
	Name string
	// ProductName is the `Product` that this `Schema` is associated with.
	ProductName string
	// Type defines how the `Schema` should be registered.
	Type SchemaType
	// Schema contains the underlying Terraform schema. The data within is shared and assumed
	// to be immutable.
	Schema *schema.Resource
}

// Register adds the schema definition to the internal registry.
func (s Schema) Register() {
	products.Lock()
	defer products.Unlock()
	if s.Type.IsDataSource() {
		if _, ok := schemas.d[s.Name]; ok {
			log.Fatalf("Duplicate registration attempt for data source %q", s.Name)
		}
		schemas.d[s.Name] = s
	} else {
		if _, ok := schemas.r[s.Name]; ok {
			log.Fatalf("Duplicate registration attempt for resource %q", s.Name)
		}
		schemas.r[s.Name] = s
	}
}

type registeredSchemas struct {
	sync.RWMutex
	r map[string]Schema
	d map[string]Schema
}

var schemas = &registeredSchemas{
	r: make(map[string]Schema),
	d: make(map[string]Schema),
}

// Resource returns the Terraform schema for the requested resource. The function panics
// if the requested resource is not registered. This function is called during provider
// intitialization when the absence of a resource is an unrecoverable error.
func Resource(name string) *schema.Resource {
	schemas.RLock()
	defer schemas.RUnlock()
	r, ok := schemas.r[name]
	if !ok {
		log.Fatalf("No resource schema for %q registered", name)
	}
	return r.Schema
}

// DataSource returns the Terraform schema for the requested data source. The function panics
// if the requested data source is not registered. This function is called during provider
// intitialization when the absence of a data source is an unrecoverable error.
func DataSource(name string) *schema.Resource {
	schemas.RLock()
	defer schemas.RUnlock()
	d, ok := schemas.d[name]
	if !ok {
		log.Fatalf("No data source schema for %q registered", name)
	}
	return d.Schema
}
