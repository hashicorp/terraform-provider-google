// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/databasemigrationservice/MigrationJob.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package databasemigrationservice

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceDatabaseMigrationServiceMigrationJob() *schema.Resource {
	return &schema.Resource{
		Create: resourceDatabaseMigrationServiceMigrationJobCreate,
		Read:   resourceDatabaseMigrationServiceMigrationJobRead,
		Update: resourceDatabaseMigrationServiceMigrationJobUpdate,
		Delete: resourceDatabaseMigrationServiceMigrationJobDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDatabaseMigrationServiceMigrationJobImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(60 * time.Minute),
			Update: schema.DefaultTimeout(60 * time.Minute),
			Delete: schema.DefaultTimeout(60 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"destination": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of the destination connection profile resource in the form of projects/{project}/locations/{location}/connectionProfiles/{destinationConnectionProfile}.`,
			},
			"migration_job_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The ID of the migration job.`,
			},
			"source": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of the source connection profile resource in the form of projects/{project}/locations/{location}/connectionProfiles/{sourceConnectionProfile}.`,
			},
			"type": {
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"ONE_TIME", "CONTINUOUS"}),
				Description:  `The type of the migration job. Possible values: ["ONE_TIME", "CONTINUOUS"]`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The migration job display name.`,
			},
			"dump_flags": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The initial dump flags.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"dump_flags": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `A list of dump flags`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The name of the flag`,
									},
									"value": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The vale of the flag`,
									},
								},
							},
						},
					},
				},
			},
			"dump_path": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `The path to the dump file in Google Cloud Storage,
in the format: (gs://[BUCKET_NAME]/[OBJECT_NAME]).
This field and the "dump_flags" field are mutually exclusive.`,
			},
			"dump_type": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"LOGICAL", "PHYSICAL", ""}),
				Description: `The type of the data dump. Supported for MySQL to CloudSQL for MySQL
migrations only. Possible values: ["LOGICAL", "PHYSICAL"]`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `The resource labels for migration job to use to annotate any related underlying resources such as Compute Engine VMs.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"location": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The location where the migration job should reside.`,
			},
			"performance_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Data dump parallelism settings used by the migration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"dump_parallel_level": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"MIN", "OPTIMAL", "MAX", ""}),
							Description:  `Initial dump parallelism level. Possible values: ["MIN", "OPTIMAL", "MAX"]`,
						},
					},
				},
			},
			"reverse_ssh_connectivity": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The details of the VPC network that the source database is located in.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"vm": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The name of the virtual machine (Compute Engine) used as the bastion server
for the SSH tunnel.`,
						},
						"vm_ip": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The IP of the virtual machine (Compute Engine) used as the bastion server
for the SSH tunnel.`,
						},
						"vm_port": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `The forwarding port of the virtual machine (Compute Engine) used as the
bastion server for the SSH tunnel.`,
						},
						"vpc": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the VPC to peer with the Cloud SQL private network.`,
						},
					},
				},
				ExactlyOneOf: []string{"static_ip_connectivity", "vpc_peering_connectivity"},
			},
			"static_ip_connectivity": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `If set to an empty object ('{}'), the source database will allow incoming
connections from the public IP of the destination database.
You can retrieve the public IP of the Cloud SQL instance from the
Cloud SQL console or using Cloud SQL APIs.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{},
				},
				ExactlyOneOf: []string{"reverse_ssh_connectivity", "vpc_peering_connectivity"},
			},
			"vpc_peering_connectivity": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The details of the VPC network that the source database is located in.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"vpc": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the VPC network to peer with the Cloud SQL private network.`,
						},
					},
				},
				ExactlyOneOf: []string{"static_ip_connectivity", "reverse_ssh_connectivity"},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The timestamp when the resource was created. A timestamp in RFC3339 UTC 'Zulu' format, accurate to nanoseconds. Example: '2014-10-02T15:01:23.045123456Z'.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"error": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. The error details in case of state FAILED.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"code": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The status code, which should be an enum value of google.rpc.Code.`,
						},
						"details": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `A list of messages that carry the error details.`,
							Elem: &schema.Schema{
								Type: schema.TypeMap,
							},
						},
						"message": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Human readable message indicating details about the current status.`,
						},
					},
				},
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The name of this migration job resource in the form of projects/{project}/locations/{location}/migrationJobs/{migrationJob}.`,
			},
			"phase": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The current migration job phase.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The current migration job state.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDatabaseMigrationServiceMigrationJobCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandDatabaseMigrationServiceMigrationJobDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	typeProp, err := expandDatabaseMigrationServiceMigrationJobType(d.Get("type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("type"); !tpgresource.IsEmptyValue(reflect.ValueOf(typeProp)) && (ok || !reflect.DeepEqual(v, typeProp)) {
		obj["type"] = typeProp
	}
	sourceProp, err := expandDatabaseMigrationServiceMigrationJobSource(d.Get("source"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("source"); !tpgresource.IsEmptyValue(reflect.ValueOf(sourceProp)) && (ok || !reflect.DeepEqual(v, sourceProp)) {
		obj["source"] = sourceProp
	}
	destinationProp, err := expandDatabaseMigrationServiceMigrationJobDestination(d.Get("destination"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("destination"); !tpgresource.IsEmptyValue(reflect.ValueOf(destinationProp)) && (ok || !reflect.DeepEqual(v, destinationProp)) {
		obj["destination"] = destinationProp
	}
	dumpFlagsProp, err := expandDatabaseMigrationServiceMigrationJobDumpFlags(d.Get("dump_flags"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dump_flags"); !tpgresource.IsEmptyValue(reflect.ValueOf(dumpFlagsProp)) && (ok || !reflect.DeepEqual(v, dumpFlagsProp)) {
		obj["dumpFlags"] = dumpFlagsProp
	}
	performanceConfigProp, err := expandDatabaseMigrationServiceMigrationJobPerformanceConfig(d.Get("performance_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("performance_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(performanceConfigProp)) && (ok || !reflect.DeepEqual(v, performanceConfigProp)) {
		obj["performanceConfig"] = performanceConfigProp
	}
	dumpPathProp, err := expandDatabaseMigrationServiceMigrationJobDumpPath(d.Get("dump_path"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dump_path"); !tpgresource.IsEmptyValue(reflect.ValueOf(dumpPathProp)) && (ok || !reflect.DeepEqual(v, dumpPathProp)) {
		obj["dumpPath"] = dumpPathProp
	}
	dumpTypeProp, err := expandDatabaseMigrationServiceMigrationJobDumpType(d.Get("dump_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dump_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(dumpTypeProp)) && (ok || !reflect.DeepEqual(v, dumpTypeProp)) {
		obj["dumpType"] = dumpTypeProp
	}
	staticIpConnectivityProp, err := expandDatabaseMigrationServiceMigrationJobStaticIpConnectivity(d.Get("static_ip_connectivity"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("static_ip_connectivity"); ok || !reflect.DeepEqual(v, staticIpConnectivityProp) {
		obj["staticIpConnectivity"] = staticIpConnectivityProp
	}
	reverseSshConnectivityProp, err := expandDatabaseMigrationServiceMigrationJobReverseSshConnectivity(d.Get("reverse_ssh_connectivity"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("reverse_ssh_connectivity"); !tpgresource.IsEmptyValue(reflect.ValueOf(reverseSshConnectivityProp)) && (ok || !reflect.DeepEqual(v, reverseSshConnectivityProp)) {
		obj["reverseSshConnectivity"] = reverseSshConnectivityProp
	}
	vpcPeeringConnectivityProp, err := expandDatabaseMigrationServiceMigrationJobVpcPeeringConnectivity(d.Get("vpc_peering_connectivity"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vpc_peering_connectivity"); !tpgresource.IsEmptyValue(reflect.ValueOf(vpcPeeringConnectivityProp)) && (ok || !reflect.DeepEqual(v, vpcPeeringConnectivityProp)) {
		obj["vpcPeeringConnectivity"] = vpcPeeringConnectivityProp
	}
	labelsProp, err := expandDatabaseMigrationServiceMigrationJobEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DatabaseMigrationServiceBasePath}}projects/{{project}}/locations/{{location}}/migrationJobs?migrationJobId={{migration_job_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new MigrationJob: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for MigrationJob: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating MigrationJob: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/migrationJobs/{{migration_job_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = DatabaseMigrationServiceOperationWaitTime(
		config, res, project, "Creating MigrationJob", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create MigrationJob: %s", err)
	}

	log.Printf("[DEBUG] Finished creating MigrationJob %q: %#v", d.Id(), res)

	return resourceDatabaseMigrationServiceMigrationJobRead(d, meta)
}

func resourceDatabaseMigrationServiceMigrationJobRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DatabaseMigrationServiceBasePath}}projects/{{project}}/locations/{{location}}/migrationJobs/{{migration_job_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for MigrationJob: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DatabaseMigrationServiceMigrationJob %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}

	if err := d.Set("name", flattenDatabaseMigrationServiceMigrationJobName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("display_name", flattenDatabaseMigrationServiceMigrationJobDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("create_time", flattenDatabaseMigrationServiceMigrationJobCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("labels", flattenDatabaseMigrationServiceMigrationJobLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("state", flattenDatabaseMigrationServiceMigrationJobState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("phase", flattenDatabaseMigrationServiceMigrationJobPhase(res["phase"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("error", flattenDatabaseMigrationServiceMigrationJobError(res["error"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("type", flattenDatabaseMigrationServiceMigrationJobType(res["type"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("source", flattenDatabaseMigrationServiceMigrationJobSource(res["source"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("destination", flattenDatabaseMigrationServiceMigrationJobDestination(res["destination"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("dump_flags", flattenDatabaseMigrationServiceMigrationJobDumpFlags(res["dumpFlags"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("performance_config", flattenDatabaseMigrationServiceMigrationJobPerformanceConfig(res["performanceConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("dump_path", flattenDatabaseMigrationServiceMigrationJobDumpPath(res["dumpPath"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("dump_type", flattenDatabaseMigrationServiceMigrationJobDumpType(res["dumpType"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("static_ip_connectivity", flattenDatabaseMigrationServiceMigrationJobStaticIpConnectivity(res["staticIpConnectivity"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("reverse_ssh_connectivity", flattenDatabaseMigrationServiceMigrationJobReverseSshConnectivity(res["reverseSshConnectivity"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("vpc_peering_connectivity", flattenDatabaseMigrationServiceMigrationJobVpcPeeringConnectivity(res["vpcPeeringConnectivity"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("terraform_labels", flattenDatabaseMigrationServiceMigrationJobTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}
	if err := d.Set("effective_labels", flattenDatabaseMigrationServiceMigrationJobEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading MigrationJob: %s", err)
	}

	return nil
}

func resourceDatabaseMigrationServiceMigrationJobUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for MigrationJob: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	displayNameProp, err := expandDatabaseMigrationServiceMigrationJobDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	dumpFlagsProp, err := expandDatabaseMigrationServiceMigrationJobDumpFlags(d.Get("dump_flags"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dump_flags"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dumpFlagsProp)) {
		obj["dumpFlags"] = dumpFlagsProp
	}
	performanceConfigProp, err := expandDatabaseMigrationServiceMigrationJobPerformanceConfig(d.Get("performance_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("performance_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, performanceConfigProp)) {
		obj["performanceConfig"] = performanceConfigProp
	}
	dumpPathProp, err := expandDatabaseMigrationServiceMigrationJobDumpPath(d.Get("dump_path"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dump_path"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dumpPathProp)) {
		obj["dumpPath"] = dumpPathProp
	}
	dumpTypeProp, err := expandDatabaseMigrationServiceMigrationJobDumpType(d.Get("dump_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dump_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dumpTypeProp)) {
		obj["dumpType"] = dumpTypeProp
	}
	staticIpConnectivityProp, err := expandDatabaseMigrationServiceMigrationJobStaticIpConnectivity(d.Get("static_ip_connectivity"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("static_ip_connectivity"); ok || !reflect.DeepEqual(v, staticIpConnectivityProp) {
		obj["staticIpConnectivity"] = staticIpConnectivityProp
	}
	reverseSshConnectivityProp, err := expandDatabaseMigrationServiceMigrationJobReverseSshConnectivity(d.Get("reverse_ssh_connectivity"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("reverse_ssh_connectivity"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, reverseSshConnectivityProp)) {
		obj["reverseSshConnectivity"] = reverseSshConnectivityProp
	}
	vpcPeeringConnectivityProp, err := expandDatabaseMigrationServiceMigrationJobVpcPeeringConnectivity(d.Get("vpc_peering_connectivity"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vpc_peering_connectivity"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, vpcPeeringConnectivityProp)) {
		obj["vpcPeeringConnectivity"] = vpcPeeringConnectivityProp
	}
	labelsProp, err := expandDatabaseMigrationServiceMigrationJobEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DatabaseMigrationServiceBasePath}}projects/{{project}}/locations/{{location}}/migrationJobs/{{migration_job_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating MigrationJob %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("dump_flags") {
		updateMask = append(updateMask, "dumpFlags")
	}

	if d.HasChange("performance_config") {
		updateMask = append(updateMask, "performanceConfig")
	}

	if d.HasChange("dump_path") {
		updateMask = append(updateMask, "dumpPath")
	}

	if d.HasChange("dump_type") {
		updateMask = append(updateMask, "dumpType")
	}

	if d.HasChange("static_ip_connectivity") {
		updateMask = append(updateMask, "staticIpConnectivity")
	}

	if d.HasChange("reverse_ssh_connectivity") {
		updateMask = append(updateMask, "reverseSshConnectivity")
	}

	if d.HasChange("vpc_peering_connectivity") {
		updateMask = append(updateMask, "vpcPeeringConnectivity")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating MigrationJob %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating MigrationJob %q: %#v", d.Id(), res)
		}

		err = DatabaseMigrationServiceOperationWaitTime(
			config, res, project, "Updating MigrationJob", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceDatabaseMigrationServiceMigrationJobRead(d, meta)
}

func resourceDatabaseMigrationServiceMigrationJobDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for MigrationJob: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{DatabaseMigrationServiceBasePath}}projects/{{project}}/locations/{{location}}/migrationJobs/{{migration_job_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting MigrationJob %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "MigrationJob")
	}

	err = DatabaseMigrationServiceOperationWaitTime(
		config, res, project, "Deleting MigrationJob", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting MigrationJob %q: %#v", d.Id(), res)
	return nil
}

func resourceDatabaseMigrationServiceMigrationJobImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/migrationJobs/(?P<migration_job_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<migration_job_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<migration_job_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/migrationJobs/{{migration_job_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenDatabaseMigrationServiceMigrationJobName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDatabaseMigrationServiceMigrationJobState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobPhase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobError(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["code"] =
		flattenDatabaseMigrationServiceMigrationJobErrorCode(original["code"], d, config)
	transformed["message"] =
		flattenDatabaseMigrationServiceMigrationJobErrorMessage(original["message"], d, config)
	transformed["details"] =
		flattenDatabaseMigrationServiceMigrationJobErrorDetails(original["details"], d, config)
	return []interface{}{transformed}
}
func flattenDatabaseMigrationServiceMigrationJobErrorCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDatabaseMigrationServiceMigrationJobErrorMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobErrorDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	detailsArray := v.([]interface{})
	for i, raw := range detailsArray {
		m := raw.(map[string]interface{})
		if len(m) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		for k, val := range m {
			if _, ok := val.(string); !ok {
				b, err := json.Marshal(v)
				if err != nil {
					return err
				}
				m[k] = string(b)
			}
		}
		detailsArray[i] = m
	}
	return detailsArray
}

func flattenDatabaseMigrationServiceMigrationJobType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobDestination(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobDumpFlags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dump_flags"] =
		flattenDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlags(original["dumpFlags"], d, config)
	return []interface{}{transformed}
}
func flattenDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":  flattenDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlagsName(original["name"], d, config),
			"value": flattenDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlagsValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlagsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlagsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobPerformanceConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dump_parallel_level"] =
		flattenDatabaseMigrationServiceMigrationJobPerformanceConfigDumpParallelLevel(original["dumpParallelLevel"], d, config)
	return []interface{}{transformed}
}
func flattenDatabaseMigrationServiceMigrationJobPerformanceConfigDumpParallelLevel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobDumpPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobDumpType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobStaticIpConnectivity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDatabaseMigrationServiceMigrationJobReverseSshConnectivity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["vm_ip"] =
		flattenDatabaseMigrationServiceMigrationJobReverseSshConnectivityVmIp(original["vmIp"], d, config)
	transformed["vm_port"] =
		flattenDatabaseMigrationServiceMigrationJobReverseSshConnectivityVmPort(original["vmPort"], d, config)
	transformed["vm"] =
		flattenDatabaseMigrationServiceMigrationJobReverseSshConnectivityVm(original["vm"], d, config)
	transformed["vpc"] =
		flattenDatabaseMigrationServiceMigrationJobReverseSshConnectivityVpc(original["vpc"], d, config)
	return []interface{}{transformed}
}
func flattenDatabaseMigrationServiceMigrationJobReverseSshConnectivityVmIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobReverseSshConnectivityVmPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDatabaseMigrationServiceMigrationJobReverseSshConnectivityVm(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobReverseSshConnectivityVpc(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobVpcPeeringConnectivity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["vpc"] =
		flattenDatabaseMigrationServiceMigrationJobVpcPeeringConnectivityVpc(original["vpc"], d, config)
	return []interface{}{transformed}
}
func flattenDatabaseMigrationServiceMigrationJobVpcPeeringConnectivityVpc(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatabaseMigrationServiceMigrationJobTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDatabaseMigrationServiceMigrationJobEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandDatabaseMigrationServiceMigrationJobDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobDestination(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobDumpFlags(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDumpFlags, err := expandDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlags(original["dump_flags"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDumpFlags); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dumpFlags"] = transformedDumpFlags
	}

	return transformed, nil
}

func expandDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlags(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlagsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlagsValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlagsName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobDumpFlagsDumpFlagsValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobPerformanceConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDumpParallelLevel, err := expandDatabaseMigrationServiceMigrationJobPerformanceConfigDumpParallelLevel(original["dump_parallel_level"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDumpParallelLevel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dumpParallelLevel"] = transformedDumpParallelLevel
	}

	return transformed, nil
}

func expandDatabaseMigrationServiceMigrationJobPerformanceConfigDumpParallelLevel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobDumpPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobDumpType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobStaticIpConnectivity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDatabaseMigrationServiceMigrationJobReverseSshConnectivity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedVmIp, err := expandDatabaseMigrationServiceMigrationJobReverseSshConnectivityVmIp(original["vm_ip"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVmIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vmIp"] = transformedVmIp
	}

	transformedVmPort, err := expandDatabaseMigrationServiceMigrationJobReverseSshConnectivityVmPort(original["vm_port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVmPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vmPort"] = transformedVmPort
	}

	transformedVm, err := expandDatabaseMigrationServiceMigrationJobReverseSshConnectivityVm(original["vm"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVm); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vm"] = transformedVm
	}

	transformedVpc, err := expandDatabaseMigrationServiceMigrationJobReverseSshConnectivityVpc(original["vpc"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVpc); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vpc"] = transformedVpc
	}

	return transformed, nil
}

func expandDatabaseMigrationServiceMigrationJobReverseSshConnectivityVmIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobReverseSshConnectivityVmPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobReverseSshConnectivityVm(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobReverseSshConnectivityVpc(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobVpcPeeringConnectivity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedVpc, err := expandDatabaseMigrationServiceMigrationJobVpcPeeringConnectivityVpc(original["vpc"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVpc); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vpc"] = transformedVpc
	}

	return transformed, nil
}

func expandDatabaseMigrationServiceMigrationJobVpcPeeringConnectivityVpc(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatabaseMigrationServiceMigrationJobEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
