// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/chronicle/Retrohunt.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package chronicle

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceChronicleRetrohunt() *schema.Resource {
	return &schema.Resource{
		Create: resourceChronicleRetrohuntCreate,
		Read:   resourceChronicleRetrohuntRead,
		Delete: resourceChronicleRetrohuntDelete,

		Importer: &schema.ResourceImporter{
			State: resourceChronicleRetrohuntImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"instance": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"rule": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"retrohunt": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"instance": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The unique identifier for the Chronicle instance, which is the same as the customer ID.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".`,
			},
			"process_interval": {
				Type:     schema.TypeList,
				Required: true,
				ForceNew: true,
				Description: `Represents a time interval, encoded as a Timestamp start (inclusive) and a
Timestamp end (exclusive).

The start must be less than or equal to the end.
When the start equals the end, the interval is empty (matches no time).
When both start and end are unspecified, the interval matches any time.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"end_time": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Exclusive end of the interval.`,
						},
						"start_time": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Inclusive start of the interval.`,
						},
					},
				},
			},
			"rule": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The Rule ID of the rule.`,
			},
			"retrohunt": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `The retrohunt ID of the Retrohunt. A retrohunt is an execution of a Rule over a time range in the past.`,
			},
			"execution_interval": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `Represents a time interval, encoded as a Timestamp start (inclusive) and a
Timestamp end (exclusive).

The start must be less than or equal to the end.
When the start equals the end, the interval is empty (matches no time).
When both start and end are unspecified, the interval matches any time.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"end_time": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `Optional. Exclusive end of the interval.

If specified, a Timestamp matching this interval will have to be before the
end.`,
						},
						"start_time": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `Optional. Inclusive start of the interval.

If specified, a Timestamp matching this interval will have to be the same
or after the start.`,
						},
					},
				},
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The resource name of the retrohunt.
Retrohunt is the child of a rule revision. {rule} in the format below is
structured as {rule_id@revision_id}.
Format:
projects/{project}/locations/{location}/instances/{instance}/rules/{rule}/retrohunts/{retrohunt}`,
			},
			"progress_percentage": {
				Type:        schema.TypeFloat,
				Computed:    true,
				Description: `Output only. Percent progress of the retrohunt towards completion, from 0.00 to 100.00.`,
			},
			"state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Output only. The state of the retrohunt.
Possible values:
RUNNING
DONE
CANCELLED
FAILED`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceChronicleRetrohuntCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	processIntervalProp, err := expandChronicleRetrohuntProcessInterval(d.Get("process_interval"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("process_interval"); !tpgresource.IsEmptyValue(reflect.ValueOf(processIntervalProp)) && (ok || !reflect.DeepEqual(v, processIntervalProp)) {
		obj["processInterval"] = processIntervalProp
	}
	retrohuntProp, err := expandChronicleRetrohuntRetrohunt(d.Get("retrohunt"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("retrohunt"); !tpgresource.IsEmptyValue(reflect.ValueOf(retrohuntProp)) && (ok || !reflect.DeepEqual(v, retrohuntProp)) {
		obj["retrohunt"] = retrohuntProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ChronicleBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance}}/rules/{{rule}}/retrohunts")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Retrohunt: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Retrohunt: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Retrohunt: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{instance}}/rules/{{rule}}/retrohunts/{{retrohunt}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if instanceValue, ok := d.GetOk("instance"); ok && instanceValue.(string) != "" {
			if err = identity.Set("instance", instanceValue.(string)); err != nil {
				return fmt.Errorf("Error setting instance: %s", err)
			}
		}
		if ruleValue, ok := d.GetOk("rule"); ok && ruleValue.(string) != "" {
			if err = identity.Set("rule", ruleValue.(string)); err != nil {
				return fmt.Errorf("Error setting rule: %s", err)
			}
		}
		if retrohuntValue, ok := d.GetOk("retrohunt"); ok && retrohuntValue.(string) != "" {
			if err = identity.Set("retrohunt", retrohuntValue.(string)); err != nil {
				return fmt.Errorf("Error setting retrohunt: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = ChronicleOperationWaitTime(
		config, res, project, "Creating Retrohunt", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Retrohunt: %s", err)
	}

	// Retrohunt create operations don't return the resource data in the response field; instead, it is in the
	// "metadata" field. Luckily, this is the case even for the first operation returned (prior to create completion)
	// so we can pull it from there.
	// Removing this post_create logic would require https://github.com/hashicorp/terraform-provider-google/issues/22392
	metadata := res["metadata"].(map[string]interface{})
	retrohunt := metadata["retrohunt"].(string)
	parts := strings.Split(retrohunt, "/")
	retrohunt_id := parts[len(parts)-1]
	log.Printf("[DEBUG] Setting retrohunt to %s", retrohunt_id)
	if err := d.Set("retrohunt", retrohunt_id); err != nil {
		return fmt.Errorf("Error setting Retrohunt ID: %s", err)
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{instance}}/rules/{{rule}}/retrohunts/{{retrohunt}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Retrohunt %q: %#v", d.Id(), res)

	return resourceChronicleRetrohuntRead(d, meta)
}

func resourceChronicleRetrohuntRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ChronicleBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance}}/rules/{{rule}}/retrohunts/{{retrohunt}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Retrohunt: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ChronicleRetrohunt %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Retrohunt: %s", err)
	}

	if err := d.Set("progress_percentage", flattenChronicleRetrohuntProgressPercentage(res["progressPercentage"], d, config)); err != nil {
		return fmt.Errorf("Error reading Retrohunt: %s", err)
	}
	if err := d.Set("name", flattenChronicleRetrohuntName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Retrohunt: %s", err)
	}
	if err := d.Set("process_interval", flattenChronicleRetrohuntProcessInterval(res["processInterval"], d, config)); err != nil {
		return fmt.Errorf("Error reading Retrohunt: %s", err)
	}
	if err := d.Set("execution_interval", flattenChronicleRetrohuntExecutionInterval(res["executionInterval"], d, config)); err != nil {
		return fmt.Errorf("Error reading Retrohunt: %s", err)
	}
	if err := d.Set("state", flattenChronicleRetrohuntState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Retrohunt: %s", err)
	}
	if err := d.Set("retrohunt", flattenChronicleRetrohuntRetrohunt(res["retrohunt"], d, config)); err != nil {
		return fmt.Errorf("Error reading Retrohunt: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("instance"); !ok && v == "" {
			err = identity.Set("instance", d.Get("instance").(string))
			if err != nil {
				return fmt.Errorf("Error setting instance: %s", err)
			}
		}
		if v, ok := identity.GetOk("rule"); !ok && v == "" {
			err = identity.Set("rule", d.Get("rule").(string))
			if err != nil {
				return fmt.Errorf("Error setting rule: %s", err)
			}
		}
		if v, ok := identity.GetOk("retrohunt"); !ok && v == "" {
			err = identity.Set("retrohunt", d.Get("retrohunt").(string))
			if err != nil {
				return fmt.Errorf("Error setting retrohunt: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceChronicleRetrohuntDelete(d *schema.ResourceData, meta interface{}) error {
	log.Printf("[WARNING] Chronicle Retrohunt resources"+
		" cannot be deleted from Google Cloud. The resource %s will be removed from Terraform"+
		" state, but will still be present on Google Cloud.", d.Id())
	d.SetId("")

	return nil
}

func resourceChronicleRetrohuntImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/instances/(?P<instance>[^/]+)/rules/(?P<rule>[^/]+)/retrohunts/(?P<retrohunt>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<instance>[^/]+)/(?P<rule>[^/]+)/(?P<retrohunt>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<instance>[^/]+)/(?P<rule>[^/]+)/(?P<retrohunt>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{instance}}/rules/{{rule}}/retrohunts/{{retrohunt}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenChronicleRetrohuntProgressPercentage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleRetrohuntName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleRetrohuntProcessInterval(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["start_time"] =
		flattenChronicleRetrohuntProcessIntervalStartTime(original["startTime"], d, config)
	transformed["end_time"] =
		flattenChronicleRetrohuntProcessIntervalEndTime(original["endTime"], d, config)
	return []interface{}{transformed}
}
func flattenChronicleRetrohuntProcessIntervalStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleRetrohuntProcessIntervalEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleRetrohuntExecutionInterval(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["end_time"] =
		flattenChronicleRetrohuntExecutionIntervalEndTime(original["endTime"], d, config)
	transformed["start_time"] =
		flattenChronicleRetrohuntExecutionIntervalStartTime(original["startTime"], d, config)
	return []interface{}{transformed}
}
func flattenChronicleRetrohuntExecutionIntervalEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleRetrohuntExecutionIntervalStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleRetrohuntState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleRetrohuntRetrohunt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	parts := strings.Split(d.Get("name").(string), "/")
	return parts[len(parts)-1]
}

func expandChronicleRetrohuntProcessInterval(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedStartTime, err := expandChronicleRetrohuntProcessIntervalStartTime(original["start_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStartTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["startTime"] = transformedStartTime
	}

	transformedEndTime, err := expandChronicleRetrohuntProcessIntervalEndTime(original["end_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEndTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["endTime"] = transformedEndTime
	}

	return transformed, nil
}

func expandChronicleRetrohuntProcessIntervalStartTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandChronicleRetrohuntProcessIntervalEndTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandChronicleRetrohuntRetrohunt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
