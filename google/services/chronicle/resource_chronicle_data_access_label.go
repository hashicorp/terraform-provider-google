// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/chronicle/DataAccessLabel.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package chronicle

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceChronicleDataAccessLabel() *schema.Resource {
	return &schema.Resource{
		Create: resourceChronicleDataAccessLabelCreate,
		Read:   resourceChronicleDataAccessLabelRead,
		Update: resourceChronicleDataAccessLabelUpdate,
		Delete: resourceChronicleDataAccessLabelDelete,

		Importer: &schema.ResourceImporter{
			State: resourceChronicleDataAccessLabelImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"data_access_label_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Required. The ID to use for the data access label, which will become the label's
display name and the final component of the label's resource name. The
maximum number of characters should be 63. Regex pattern is as per AIP:
https://google.aip.dev/122#resource-id-segments`,
			},
			"instance": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The unique identifier for the Chronicle instance, which is the same as the customer ID.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the resource. This is the geographical region where the Chronicle instance resides, such as "us" or "europe-west2".`,
			},
			"udm_query": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `A UDM query over event data.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Optional. A description of the data access label for a human reader.`,
			},
			"author": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The user who created the data access label.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The time at which the data access label was created.`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The short name displayed for the label as it appears on event data. This is same as data access label id.`,
			},
			"last_editor": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The user who last updated the data access label.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The unique resource name of the data access label. This unique identifier is generated using values provided for the URL parameters.
Format:
projects/{project}/locations/{location}/instances/{instance}/dataAccessLabels/{data_access_label_id}`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The time at which the data access label was last updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceChronicleDataAccessLabelCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandChronicleDataAccessLabelDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	udmQueryProp, err := expandChronicleDataAccessLabelUdmQuery(d.Get("udm_query"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("udm_query"); !tpgresource.IsEmptyValue(reflect.ValueOf(udmQueryProp)) && (ok || !reflect.DeepEqual(v, udmQueryProp)) {
		obj["udmQuery"] = udmQueryProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ChronicleBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance}}/dataAccessLabels?dataAccessLabelId={{data_access_label_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new DataAccessLabel: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for DataAccessLabel: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating DataAccessLabel: %s", err)
	}
	if err := d.Set("name", flattenChronicleDataAccessLabelName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{instance}}/dataAccessLabels/{{data_access_label_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating DataAccessLabel %q: %#v", d.Id(), res)

	return resourceChronicleDataAccessLabelRead(d, meta)
}

func resourceChronicleDataAccessLabelRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ChronicleBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance}}/dataAccessLabels/{{data_access_label_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for DataAccessLabel: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ChronicleDataAccessLabel %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading DataAccessLabel: %s", err)
	}

	if err := d.Set("author", flattenChronicleDataAccessLabelAuthor(res["author"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataAccessLabel: %s", err)
	}
	if err := d.Set("last_editor", flattenChronicleDataAccessLabelLastEditor(res["lastEditor"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataAccessLabel: %s", err)
	}
	if err := d.Set("description", flattenChronicleDataAccessLabelDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataAccessLabel: %s", err)
	}
	if err := d.Set("udm_query", flattenChronicleDataAccessLabelUdmQuery(res["udmQuery"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataAccessLabel: %s", err)
	}
	if err := d.Set("name", flattenChronicleDataAccessLabelName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataAccessLabel: %s", err)
	}
	if err := d.Set("display_name", flattenChronicleDataAccessLabelDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataAccessLabel: %s", err)
	}
	if err := d.Set("create_time", flattenChronicleDataAccessLabelCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataAccessLabel: %s", err)
	}
	if err := d.Set("update_time", flattenChronicleDataAccessLabelUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataAccessLabel: %s", err)
	}

	return nil
}

func resourceChronicleDataAccessLabelUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for DataAccessLabel: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandChronicleDataAccessLabelDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	udmQueryProp, err := expandChronicleDataAccessLabelUdmQuery(d.Get("udm_query"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("udm_query"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, udmQueryProp)) {
		obj["udmQuery"] = udmQueryProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ChronicleBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance}}/dataAccessLabels/{{data_access_label_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating DataAccessLabel %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("udm_query") {
		updateMask = append(updateMask, "udmQuery")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating DataAccessLabel %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating DataAccessLabel %q: %#v", d.Id(), res)
		}

	}

	return resourceChronicleDataAccessLabelRead(d, meta)
}

func resourceChronicleDataAccessLabelDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for DataAccessLabel: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{ChronicleBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance}}/dataAccessLabels/{{data_access_label_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting DataAccessLabel %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "DataAccessLabel")
	}

	log.Printf("[DEBUG] Finished deleting DataAccessLabel %q: %#v", d.Id(), res)
	return nil
}

func resourceChronicleDataAccessLabelImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/instances/(?P<instance>[^/]+)/dataAccessLabels/(?P<data_access_label_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<instance>[^/]+)/(?P<data_access_label_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<instance>[^/]+)/(?P<data_access_label_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{instance}}/dataAccessLabels/{{data_access_label_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenChronicleDataAccessLabelAuthor(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleDataAccessLabelLastEditor(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleDataAccessLabelDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleDataAccessLabelUdmQuery(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleDataAccessLabelName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleDataAccessLabelDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleDataAccessLabelCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenChronicleDataAccessLabelUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandChronicleDataAccessLabelDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandChronicleDataAccessLabelUdmQuery(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
