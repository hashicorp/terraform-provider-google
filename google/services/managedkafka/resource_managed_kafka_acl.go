// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/managedkafka/Acl.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package managedkafka

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceManagedKafkaAcl() *schema.Resource {
	return &schema.Resource{
		Create: resourceManagedKafkaAclCreate,
		Read:   resourceManagedKafkaAclRead,
		Update: resourceManagedKafkaAclUpdate,
		Delete: resourceManagedKafkaAclDelete,

		Importer: &schema.ResourceImporter{
			State: resourceManagedKafkaAclImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"acl_entries": {
				Type:        schema.TypeSet,
				Required:    true,
				Description: `The acl entries that apply to the resource pattern. The maximum number of allowed entries is 100.`,
				Elem:        managedkafkaAclAclEntriesSchema(),
				// Default schema.HashSchema is used.
			},
			"acl_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The ID to use for the acl, which will become the final component of the acl's name. The structure of 'aclId' defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. 'aclId' is structured like one of the following:
For acls on the cluster: 'cluster'
For acls on a single resource within the cluster: 'topic/{resource_name}' 'consumerGroup/{resource_name}' 'transactionalId/{resource_name}'
For acls on all resources that match a prefix: 'topicPrefixed/{resource_name}' 'consumerGroupPrefixed/{resource_name}' 'transactionalIdPrefixed/{resource_name}'
For acls on all resources of a given type (i.e. the wildcard literal '*''): 'allTopics' (represents 'topic/*') 'allConsumerGroups' (represents 'consumerGroup/*') 'allTransactionalIds' (represents 'transactionalId/*').`,
			},
			"cluster": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The cluster name.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `ID of the location of the Kafka resource. See https://cloud.google.com/managed-kafka/docs/locations for a list of supported locations.`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `'etag' is used for concurrency control. An 'etag' is returned in the
response to 'GetAcl' and 'CreateAcl'. Callers are required to put that etag
in the request to 'UpdateAcl' to ensure that their change will be applied
to the same version of the acl that exists in the Kafka Cluster.

A terminal 'T' character in the etag indicates that the AclEntries were
truncated due to repeated field limits.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The name of the acl. The 'ACL_ID' segment is used when connecting directly to the cluster. Must be in the format 'projects/PROJECT_ID/locations/LOCATION/clusters/CLUSTER_ID/acls/ACL_ID'.`,
			},
			"pattern_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The acl pattern type derived from the name. One of: LITERAL, PREFIXED.`,
			},
			"resource_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The acl resource name derived from the name. For cluster resource_type, this is always "kafka-cluster". Can be the wildcard literal "*".`,
			},
			"resource_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The acl resource type derived from the name. One of: CLUSTER, TOPIC, GROUP, TRANSACTIONAL_ID.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func managedkafkaAclAclEntriesSchema() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"operation": {
				Type:     schema.TypeString,
				Required: true,
				Description: `The operation type. Allowed values are (case insensitive): ALL, READ,
WRITE, CREATE, DELETE, ALTER, DESCRIBE, CLUSTER_ACTION, DESCRIBE_CONFIGS,
ALTER_CONFIGS, and IDEMPOTENT_WRITE. See https://kafka.apache.org/documentation/#operations_resources_and_protocols
for valid combinations of resource_type and operation for different Kafka API requests.`,
			},
			"principal": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The principal. Specified as Google Cloud account, with the Kafka StandardAuthorizer prefix User:". For example: "User:test-kafka-client@test-project.iam.gserviceaccount.com". Can be the wildcard "User:*" to refer to all users.`,
			},
			"host": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The host. Must be set to "*" for Managed Service for Apache Kafka.`,
				Default:     "*",
			},
			"permission_type": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The permission type. Accepted values are (case insensitive): ALLOW, DENY.`,
				Default:     "ALLOW",
			},
		},
	}
}

func resourceManagedKafkaAclCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	aclEntriesProp, err := expandManagedKafkaAclAclEntries(d.Get("acl_entries"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("acl_entries"); !tpgresource.IsEmptyValue(reflect.ValueOf(aclEntriesProp)) && (ok || !reflect.DeepEqual(v, aclEntriesProp)) {
		obj["aclEntries"] = aclEntriesProp
	}
	etagProp, err := expandManagedKafkaAclEtag(d.Get("etag"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("etag"); !tpgresource.IsEmptyValue(reflect.ValueOf(etagProp)) && (ok || !reflect.DeepEqual(v, etagProp)) {
		obj["etag"] = etagProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ManagedKafkaBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/acls?aclId={{acl_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Acl: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Acl: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Acl: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/acls/{{acl_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// This is useful if the resource in question doesn't have a perfectly consistent API
	// That is, the Operation for Create might return before the Get operation shows the
	// completed state of the resource.
	time.Sleep(5 * time.Second)

	log.Printf("[DEBUG] Finished creating Acl %q: %#v", d.Id(), res)

	return resourceManagedKafkaAclRead(d, meta)
}

func resourceManagedKafkaAclRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ManagedKafkaBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/acls/{{acl_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Acl: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ManagedKafkaAcl %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Acl: %s", err)
	}

	if err := d.Set("name", flattenManagedKafkaAclName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Acl: %s", err)
	}
	if err := d.Set("acl_entries", flattenManagedKafkaAclAclEntries(res["aclEntries"], d, config)); err != nil {
		return fmt.Errorf("Error reading Acl: %s", err)
	}
	if err := d.Set("etag", flattenManagedKafkaAclEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Acl: %s", err)
	}
	if err := d.Set("resource_type", flattenManagedKafkaAclResourceType(res["resourceType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Acl: %s", err)
	}
	if err := d.Set("resource_name", flattenManagedKafkaAclResourceName(res["resourceName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Acl: %s", err)
	}
	if err := d.Set("pattern_type", flattenManagedKafkaAclPatternType(res["patternType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Acl: %s", err)
	}

	return nil
}

func resourceManagedKafkaAclUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Acl: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	aclEntriesProp, err := expandManagedKafkaAclAclEntries(d.Get("acl_entries"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("acl_entries"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, aclEntriesProp)) {
		obj["aclEntries"] = aclEntriesProp
	}
	etagProp, err := expandManagedKafkaAclEtag(d.Get("etag"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("etag"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, etagProp)) {
		obj["etag"] = etagProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ManagedKafkaBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/acls/{{acl_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Acl %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("acl_entries") {
		updateMask = append(updateMask, "aclEntries")
	}

	if d.HasChange("etag") {
		updateMask = append(updateMask, "etag")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Acl %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Acl %q: %#v", d.Id(), res)
		}

	}

	// This is useful if the resource in question doesn't have a perfectly consistent API
	// That is, the Operation for Create might return before the Get operation shows the
	// completed state of the resource.
	time.Sleep(5 * time.Second)
	return resourceManagedKafkaAclRead(d, meta)
}

func resourceManagedKafkaAclDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Acl: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{ManagedKafkaBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/acls/{{acl_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Acl %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Acl")
	}

	log.Printf("[DEBUG] Finished deleting Acl %q: %#v", d.Id(), res)
	return nil
}

func resourceManagedKafkaAclImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/clusters/(?P<cluster>[^/]+)/acls/(?P<acl_id>.+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/acls/{{acl_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenManagedKafkaAclName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenManagedKafkaAclAclEntries(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := schema.NewSet(schema.HashResource(managedkafkaAclAclEntriesSchema()), []interface{}{})
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed.Add(map[string]interface{}{
			"principal":       flattenManagedKafkaAclAclEntriesPrincipal(original["principal"], d, config),
			"permission_type": flattenManagedKafkaAclAclEntriesPermissionType(original["permissionType"], d, config),
			"operation":       flattenManagedKafkaAclAclEntriesOperation(original["operation"], d, config),
			"host":            flattenManagedKafkaAclAclEntriesHost(original["host"], d, config),
		})
	}
	return transformed
}
func flattenManagedKafkaAclAclEntriesPrincipal(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenManagedKafkaAclAclEntriesPermissionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenManagedKafkaAclAclEntriesOperation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenManagedKafkaAclAclEntriesHost(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenManagedKafkaAclEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenManagedKafkaAclResourceType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenManagedKafkaAclResourceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenManagedKafkaAclPatternType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandManagedKafkaAclAclEntries(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	v = v.(*schema.Set).List()
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedPrincipal, err := expandManagedKafkaAclAclEntriesPrincipal(original["principal"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrincipal); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["principal"] = transformedPrincipal
		}

		transformedPermissionType, err := expandManagedKafkaAclAclEntriesPermissionType(original["permission_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPermissionType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["permissionType"] = transformedPermissionType
		}

		transformedOperation, err := expandManagedKafkaAclAclEntriesOperation(original["operation"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOperation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["operation"] = transformedOperation
		}

		transformedHost, err := expandManagedKafkaAclAclEntriesHost(original["host"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHost); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["host"] = transformedHost
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandManagedKafkaAclAclEntriesPrincipal(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandManagedKafkaAclAclEntriesPermissionType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandManagedKafkaAclAclEntriesOperation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandManagedKafkaAclAclEntriesHost(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandManagedKafkaAclEtag(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
