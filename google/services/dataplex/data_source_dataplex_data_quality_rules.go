// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/dataplex/data_source_dataplex_data_quality_rules.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package dataplex

import (
	"fmt"
	"strings"
	"unicode"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func DataSourceDataplexDataQualityRules() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceDataplexDataQualityRulesRead,
		Schema: map[string]*schema.Schema{
			"project": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"location": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"data_scan_id": {
				Type:     schema.TypeString,
				Required: true,
			},
			"rules": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"column": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The unnested column which this rule is evaluated against.`,
						},
						"ignore_null": {
							Type:     schema.TypeBool,
							Computed: true,
							Description: `Rows with null values will automatically fail a rule, unless ignoreNull is true. In that case, such null rows are trivially considered passing. 
											This field is only valid for the following type of rules: RangeExpectation, RegexExpectation, SetExpectation, UniquenessExpectation`,
						},
						"dimension": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The dimension a rule belongs to. Supported dimensions are "COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "FRESHNESS", "VOLUME"`,
						},
						"threshold": {
							Type:        schema.TypeFloat,
							Computed:    true,
							Description: `The minimum ratio of passing_rows / total_rows required to pass this rule, with a range of [0.0, 1.0]. 0 indicates default value (i.e. 1.0). This field is only valid for row-level type rules.`,
						},
						"name": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `A mutable name for the rule. 
											The name must contain only letters (a-z, A-Z), numbers (0-9), or hyphens (-).
											The maximum length is 63 characters.
											Must start with a letter.
											Must end with a number or a letter.`,
						},
						"description": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Description of the rule. (The maximum length is 1,024 characters.)`,
						},
						"suspended": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether the Rule is active or suspended. Default is false.`,
						},
						"range_expectation": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"min_value": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The minimum column value allowed for a row to pass this validation.`,
									},
									"max_value": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The maximum column value allowed for a row to pass this validation.`,
									},
									"strict_min_enabled": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.`,
									},
									"strict_max_enabled": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: ` Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.`,
									},
								},
							},
							Description: `Row-level rule which evaluates whether each column value lies between a specified range.`,
						},
						"non_null_expectation": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Row-level rule which evaluates whether each column value is null.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},
						"set_expectation": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"values": {
										Type:        schema.TypeList,
										Computed:    true,
										Elem:        &schema.Schema{Type: schema.TypeString},
										Description: `Expected values for the column value.`,
									},
								},
							},
							Description: `Row-level rule which evaluates whether each column value is contained by a specified set.`,
						},
						"regex_expectation": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"regex": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `A regular expression the column value is expected to match.`,
									},
								},
							},

							Description: `Row-level rule which evaluates whether each column value matches a specified regex.`,
						},
						"uniqueness_expectation": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Row-level rule which evaluates whether each column value is unique.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},
						"statistic_range_expectation": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"statistic": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The list of aggregate metrics a rule can be evaluated against. 
																	Possible values: ["STATISTIC_UNDEFINED", "MEAN", "MIN", "MAX"]`,
									},
									"min_value": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The minimum column value allowed for a row to pass this validation.`,
									},
									"max_value": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The maximum column value allowed for a row to pass this validation.`,
									},
									"strict_min_enabled": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Whether each value needs to be strictly greater than ('>') the minimum, or if equality is allowed.`,
									},
									"strict_max_enabled": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: ` Whether each value needs to be strictly lesser than ('<') the maximum, or if equality is allowed.`,
									},
								},
							},
							Description: `Aggregate rule which evaluates whether the column aggregate statistic lies between a specified range.`,
						},
						"row_condition_expectation": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"sql_expression": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The SQL expression.`,
									},
								},
							},
							Description: `Row-level rule which evaluates whether each row in a table passes the specified condition.`,
						},
						"table_condition_expectation": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"sql_expression": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The SQL expression.`,
									},
								},
							},
							Description: `Aggregate rule which evaluates whether the provided expression is true for a table.`,
						},
						"sql_assertion": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"sql_statement": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The SQL expression.`,
									},
								},
							},
							Description: `Aggregate rule which evaluates the number of rows returned for the provided statement. If any rows are returned, this rule fails.`,
						},
					},
				},
			},
		},
	}
}

func camelToSnake(s string) string {
	var result strings.Builder
	for i, ch := range s {
		if unicode.IsUpper(ch) {
			if i > 0 {
				result.WriteByte('_')
			}
			result.WriteRune(unicode.ToLower(ch))
		} else {
			result.WriteRune(ch)
		}
	}
	return result.String()
}

func flattenDataSourceDataplexDataQualityRulesExpectation(expectation interface{}) []interface{} {
	expectationsToSet := make(map[string]interface{})

	if expectation == nil {
		return []interface{}{expectationsToSet}
	}

	originalExpectation := expectation.(map[string]interface{})
	for k, v := range originalExpectation {
		snakeCaseKey := camelToSnake(k)
		expectationsToSet[snakeCaseKey] = v
	}
	return []interface{}{expectationsToSet}
}

func flattenDataSourceDataplexDataQualityRulesRules(rules interface{}) []interface{} {
	rulesToSet := make([]interface{}, 0)

	originalRules := rules.([]interface{})

	for _, rule := range originalRules {

		newRuleMap := make(map[string]interface{})
		ruleMap := rule.(map[string]interface{})

		for k, v := range ruleMap {
			snakeCaseKey := camelToSnake(k)
			if strings.HasSuffix(k, "Expectation") {
				// For expectation fields, need extra flatten
				newRuleMap[snakeCaseKey] = flattenDataSourceDataplexDataQualityRulesExpectation(v)
			} else {
				// For other fields (column, dimension, threshold, etc.), directly assign
				newRuleMap[snakeCaseKey] = v
			}
		}
		rulesToSet = append(rulesToSet, newRuleMap)
	}

	return rulesToSet
}

func dataSourceDataplexDataQualityRulesRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return err
	}

	location, err := tpgresource.GetLocation(d, config)
	if err != nil {
		return err
	}

	data_scan_id := d.Get("data_scan_id").(string)

	url, err := tpgresource.ReplaceVars(d, config, "{{DataplexBasePath}}projects/{{project}}/locations/{{location}}/dataScans/{{data_scan_id}}:generateDataQualityRules")
	if err != nil {
		return err
	}

	id := fmt.Sprintf("projects/%s/locations/%s/dataScans/%s", project, location, data_scan_id)
	d.SetId(id)

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:               config,
		Method:               "POST",
		Project:              project,
		RawURL:               url,
		UserAgent:            userAgent,
		ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{transport_tpg.Is429QuotaError},
	})

	if err != nil {
		return transport_tpg.HandleDataSourceNotFoundError(err, d, fmt.Sprintf("DataQualityRules %q", d.Id()), url)
	}

	if err := d.Set("rules", flattenDataSourceDataplexDataQualityRulesRules(res["rule"])); err != nil {
		return fmt.Errorf("Error setting rule: %s", err)
	}

	return nil
}
