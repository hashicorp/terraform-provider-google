// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/dataplex/Entry.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package dataplex

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"sort"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

// GetEntry supports up to 100 aspects. Therefore we set a threshold at 99.
const maxAspectNumber = 99

// NumberOfAspectsValidation checks if the number of aspects on an entry exceeds certain threshold.
func NumberOfAspectsValidation(i interface{}, k string) (warnings []string, errors []error) {
	s, isSlice := i.([]interface{})
	m, isMap := i.(map[string]interface{})

	if !isSlice && !isMap {
		errors = append(errors, fmt.Errorf("expected type of field %q to be array, but got %T", k, i))
		return warnings, errors
	}

	if len(s)+len(m) > maxAspectNumber {
		errors = append(errors, fmt.Errorf(
			"field %q has an invalid content: %q. The maximal number of aspects is 99.",
			k, i,
		))
	}

	return warnings, errors
}

// ProjectNumberValidation checks if the input string conforms to the pattern:
// "projects/<project-number>/<anything>"
func ProjectNumberValidation(i interface{}, k string) (warnings []string, errors []error) {
	v, ok := i.(string)

	if !ok {
		errors = append(errors, fmt.Errorf("expected type of field %q to be string, but got %T", k, i))
		return warnings, errors
	}

	var projectNumberRegex = regexp.MustCompile(`^projects\/[1-9]\d*\/.+$`)
	if !projectNumberRegex.MatchString(v) {
		errors = append(errors, fmt.Errorf(
			"field %q has an invalid format: %q. Expected format: 'projects/<project-number>/<anything>'. Please note that project IDs are not supported.",
			k, v,
		))
	}

	return warnings, errors
}

// ProjectNumberValidation checks if the input string conforms to the pattern:
// "projects/<project-number>/<anything>"
func AspectProjectNumberValidation(i interface{}, k string) (warnings []string, errors []error) {
	v, ok := i.(string)
	if !ok {
		errors = append(errors, fmt.Errorf("expected type of field %q to be string, but got %T", k, i))
		return warnings, errors
	}

	var numberDotAnythingRegex = regexp.MustCompile(`^[1-9]\d*\..+$`)

	if !numberDotAnythingRegex.MatchString(v) {
		errors = append(errors, fmt.Errorf(
			"field %q has an invalid format: %q. Expected format: '<project number>.anything'. Please note that project IDs are not supported.",
			k, v,
		))
	}

	return warnings, errors
}

// FilterAspects filters the aspects in res based on aspectKeySet.
// It returns an error if type assertions fail.
func FilterAspects(aspectKeySet map[string]struct{}, res map[string]interface{}) error {
	aspectsRaw, ok := res["aspects"]
	if !ok || aspectsRaw == nil {
		return nil
	}

	aspectsMap, ok := aspectsRaw.(map[string]interface{})
	if !ok {
		return fmt.Errorf("FilterAspects: 'aspects' field is not a map[string]interface{}, got %T", aspectsRaw)
	}

	for key := range aspectsMap {
		if _, keep := aspectKeySet[key]; !keep {
			delete(aspectsMap, key)
		}
	}
	return nil
}

// AddAspectsToSet adds aspect keys from the aspects interface to the aspectKeySet.
// It returns an error if type assertions fail or expected keys are missing.
func AddAspectsToSet(aspectKeySet map[string]struct{}, aspects interface{}) error {
	if aspects == nil {
		return nil
	}
	aspectsSlice, ok := aspects.([]interface{})
	if !ok {
		return fmt.Errorf("AddAspectsToSet: input 'aspects' is not a []interface{}, got %T", aspects)
	}

	for i, aspectItemRaw := range aspectsSlice {
		aspectMap, ok := aspectItemRaw.(map[string]interface{})
		if !ok {
			return fmt.Errorf("AddAspectsToSet: item at index %d is not a map[string]interface{}, got %T", i, aspectItemRaw)
		}

		keyRaw, keyExists := aspectMap["aspect_key"]
		if !keyExists {
			return fmt.Errorf("AddAspectsToSet: 'aspect_key' not found in aspect item at index %d", i)
		}

		keyString, ok := keyRaw.(string)
		if !ok {
			return fmt.Errorf("AddAspectsToSet: 'aspect_key' in item at index %d is not a string, got %T", i, keyRaw)
		}
		aspectKeySet[keyString] = struct{}{}
	}
	return nil
}

// InverseTransformAspects converts the "aspects" map back to a slice of maps,
// re-inserting the "aspectKey". Modifies obj in-place.
// It returns an error if type assertions fail.
func InverseTransformAspects(res map[string]interface{}) error {
	aspectsRaw, ok := res["aspects"]
	if !ok || aspectsRaw == nil {
		return nil
	}

	originalMap, ok := aspectsRaw.(map[string]interface{})
	if !ok {
		return fmt.Errorf("InverseTransformAspects: 'aspects' field is not a map[string]interface{}, got %T", aspectsRaw)
	}

	newSlice := make([]interface{}, 0, len(originalMap))

	for key, value := range originalMap {
		innerMap, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("InverseTransformAspects: value for key '%s' is not a map[string]interface{}, got %T", key, value)
		}
		box := make(map[string]interface{}, 2)
		box["aspectKey"] = key
		box["aspect"] = innerMap
		newSlice = append(newSlice, box)
	}
	res["aspects"] = newSlice
	return nil
}

// TransformAspects concisely transforms the "aspects" slice within obj into a map.
// Modifies obj in-place.
// It returns an error if type assertions fail or expected keys are missing.
func TransformAspects(obj map[string]interface{}) error {
	aspectsRaw, ok := obj["aspects"]
	if !ok || aspectsRaw == nil {
		return nil
	}

	originalSlice, ok := aspectsRaw.([]interface{})
	if !ok {
		return fmt.Errorf("TransformAspects: 'aspects' field is not a []interface{}, got %T", aspectsRaw)
	}

	newMap := make(map[string]interface{}, len(originalSlice))
	for i, item := range originalSlice {
		aspectMap, ok := item.(map[string]interface{})
		if !ok {
			return fmt.Errorf("TransformAspects: item in 'aspects' slice at index %d is not a map[string]interface{}, got %T", i, item)
		}

		keyRaw, keyExists := aspectMap["aspectKey"]
		if !keyExists {
			return fmt.Errorf("TransformAspects: 'aspectKey' not found in aspect item at index %d", i)
		}
		key, ok := keyRaw.(string)
		if !ok {
			return fmt.Errorf("TransformAspects: 'aspectKey' in item at index %d is not a string, got %T", i, keyRaw)
		}

		valueRaw, valueExists := aspectMap["aspect"]
		if !valueExists {
			newMap[key] = map[string]interface{}{"data": map[string]interface{}{}}
			continue
		}

		value, ok := valueRaw.(map[string]interface{})
		if ok {
			newMap[key] = value
		} else {
			newMap[key] = map[string]interface{}{"data": map[string]interface{}{}}
		}
	}
	obj["aspects"] = newMap
	return nil
}

func ResourceDataplexEntry() *schema.Resource {
	return &schema.Resource{
		Create: resourceDataplexEntryCreate,
		Read:   resourceDataplexEntryRead,
		Update: resourceDataplexEntryUpdate,
		Delete: resourceDataplexEntryDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDataplexEntryImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(5 * time.Minute),
			Update: schema.DefaultTimeout(5 * time.Minute),
			Delete: schema.DefaultTimeout(5 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"entry_type": {
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: ProjectNumberValidation,
				Description:  `The relative resource name of the entry type that was used to create this entry, in the format projects/{project_number}/locations/{locationId}/entryTypes/{entryTypeId}.`,
			},
			"aspects": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The aspects that are attached to the entry.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"aspect": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `A nested object resource.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"data": {
										Type:         schema.TypeString,
										Required:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `The content of the aspect in JSON form, according to its aspect type schema. The maximum size of the field is 120KB (encoded as UTF-8).`,
									},
									"aspect_type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The resource name of the type used to create this Aspect.`,
									},
									"create_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The time when the Aspect was created.`,
									},
									"path": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The path in the entry under which the aspect is attached.`,
									},
									"update_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The time when the Aspect was last modified.`,
									},
								},
							},
						},
						"aspect_key": {
							Type:         schema.TypeString,
							Required:     true,
							ValidateFunc: AspectProjectNumberValidation,
							Description: `Depending on how the aspect is attached to the entry, the format of the aspect key can be one of the following:

If the aspect is attached directly to the entry: {project_number}.{locationId}.{aspectTypeId}
If the aspect is attached to an entry's path: {project_number}.{locationId}.{aspectTypeId}@{path}`,
						},
					},
				},
			},
			"entry_group_id": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The entry group id of the entry group the entry will be created in.`,
			},
			"entry_id": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The entry id of the entry.`,
			},
			"entry_source": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `A nested object resource.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ancestors": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: ``,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The name of the ancestor resource.`,
									},
									"type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The type of the ancestor resource.`,
									},
								},
							},
						},
						"create_time": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: validation.IsRFC3339Time,
							Description:  `The time when the resource was created in the source system.`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `A description of the data resource. Maximum length is 2,000 characters.`,
						},
						"display_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `A user-friendly display name. Maximum length is 500 characters.`,
						},
						"labels": {
							Type:     schema.TypeMap,
							Optional: true,
							Description: `User-defined labels. The maximum size of keys and values is 128 characters each.
An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"platform": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The platform containing the source system. Maximum length is 64 characters.`,
						},
						"resource": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the resource in the source system. Maximum length is 4,000 characters.`,
						},
						"system": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the source system. Maximum length is 64 characters.`,
						},
						"update_time": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: validation.IsRFC3339Time,
							Description: `The time when the resource was last updated in the source system.
If the entry exists in the system and its EntrySource has updateTime populated,
further updates to the EntrySource of the entry must provide incremental updates to its updateTime.`,
						},
						"location": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Location of the resource in the source system. You can search the entry by this location.
By default, this should match the location of the entry group containing this entry.
A different value allows capturing the source location for data external to Google Cloud.`,
						},
					},
				},
			},
			"fully_qualified_name": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `A name for the entry that can be referenced by an external system. For more information, see https://cloud.google.com/dataplex/docs/fully-qualified-names.
The maximum size of the field is 4000 characters.`,
			},
			"location": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The location where entry will be created.`,
			},
			"parent_entry": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The resource name of the parent entry, in the format projects/{project_number}/locations/{locationId}/entryGroups/{entryGroupId}/entries/{entryId}.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time when the Entry was created in Dataplex.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The relative resource name of the entry, in the format projects/{project_number}/locations/{locationId}/entryGroups/{entryGroupId}/entries/{entryId}.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time when the entry was last updated in Dataplex.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDataplexEntryCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	entryTypeProp, err := expandDataplexEntryEntryType(d.Get("entry_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("entry_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(entryTypeProp)) && (ok || !reflect.DeepEqual(v, entryTypeProp)) {
		obj["entryType"] = entryTypeProp
	}
	aspectsProp, err := expandDataplexEntryAspects(d.Get("aspects"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("aspects"); !tpgresource.IsEmptyValue(reflect.ValueOf(aspectsProp)) && (ok || !reflect.DeepEqual(v, aspectsProp)) {
		obj["aspects"] = aspectsProp
	}
	parentEntryProp, err := expandDataplexEntryParentEntry(d.Get("parent_entry"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("parent_entry"); !tpgresource.IsEmptyValue(reflect.ValueOf(parentEntryProp)) && (ok || !reflect.DeepEqual(v, parentEntryProp)) {
		obj["parentEntry"] = parentEntryProp
	}
	fullyQualifiedNameProp, err := expandDataplexEntryFullyQualifiedName(d.Get("fully_qualified_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("fully_qualified_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(fullyQualifiedNameProp)) && (ok || !reflect.DeepEqual(v, fullyQualifiedNameProp)) {
		obj["fullyQualifiedName"] = fullyQualifiedNameProp
	}
	entrySourceProp, err := expandDataplexEntryEntrySource(d.Get("entry_source"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("entry_source"); !tpgresource.IsEmptyValue(reflect.ValueOf(entrySourceProp)) && (ok || !reflect.DeepEqual(v, entrySourceProp)) {
		obj["entrySource"] = entrySourceProp
	}

	obj, err = resourceDataplexEntryEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DataplexBasePath}}projects/{{project}}/locations/{{location}}/entryGroups/{{entry_group_id}}/entries?entryId={{entry_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Entry: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Entry: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Entry: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/entryGroups/{{entry_group_id}}/entries/{{entry_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Entry %q: %#v", d.Id(), res)

	return resourceDataplexEntryRead(d, meta)
}

func resourceDataplexEntryRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DataplexBasePath}}projects/{{project}}/locations/{{location}}/entryGroups/{{entry_group_id}}/entries/{{entry_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Entry: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"view": "ALL"})
	if err != nil {
		return err
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DataplexEntry %q", d.Id()))
	}

	res, err = resourceDataplexEntryDecoder(d, meta, res)
	if err != nil {
		return err
	}

	if res == nil {
		// Decoding the object has resulted in it being gone. It may be marked deleted
		log.Printf("[DEBUG] Removing DataplexEntry because it no longer exists.")
		d.SetId("")
		return nil
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Entry: %s", err)
	}

	if err := d.Set("name", flattenDataplexEntryName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Entry: %s", err)
	}
	if err := d.Set("entry_type", flattenDataplexEntryEntryType(res["entryType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Entry: %s", err)
	}
	if err := d.Set("create_time", flattenDataplexEntryCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Entry: %s", err)
	}
	if err := d.Set("update_time", flattenDataplexEntryUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Entry: %s", err)
	}
	if err := d.Set("aspects", flattenDataplexEntryAspects(res["aspects"], d, config)); err != nil {
		return fmt.Errorf("Error reading Entry: %s", err)
	}
	if err := d.Set("parent_entry", flattenDataplexEntryParentEntry(res["parentEntry"], d, config)); err != nil {
		return fmt.Errorf("Error reading Entry: %s", err)
	}
	if err := d.Set("fully_qualified_name", flattenDataplexEntryFullyQualifiedName(res["fullyQualifiedName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Entry: %s", err)
	}
	if err := d.Set("entry_source", flattenDataplexEntryEntrySource(res["entrySource"], d, config)); err != nil {
		return fmt.Errorf("Error reading Entry: %s", err)
	}

	return nil
}

func resourceDataplexEntryUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Entry: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	aspectsProp, err := expandDataplexEntryAspects(d.Get("aspects"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("aspects"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, aspectsProp)) {
		obj["aspects"] = aspectsProp
	}
	fullyQualifiedNameProp, err := expandDataplexEntryFullyQualifiedName(d.Get("fully_qualified_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("fully_qualified_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, fullyQualifiedNameProp)) {
		obj["fullyQualifiedName"] = fullyQualifiedNameProp
	}
	entrySourceProp, err := expandDataplexEntryEntrySource(d.Get("entry_source"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("entry_source"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, entrySourceProp)) {
		obj["entrySource"] = entrySourceProp
	}

	obj, err = resourceDataplexEntryEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DataplexBasePath}}projects/{{project}}/locations/{{location}}/entryGroups/{{entry_group_id}}/entries/{{entry_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Entry %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("aspects") {
		updateMask = append(updateMask, "aspects")
	}

	if d.HasChange("fully_qualified_name") {
		updateMask = append(updateMask, "fullyQualifiedName")
	}

	if d.HasChange("entry_source") {
		updateMask = append(updateMask, "entrySource")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}
	if d.HasChange("aspects") {
		url, err = transport_tpg.AddQueryParams(url, map[string]string{"deleteMissingAspects": "true"})
		if err != nil {
			return err
		}

		aspectKeysOfInterest := make(map[string]struct{})
		currentAspects, futureAspects := d.GetChange("aspects")

		err = AddAspectsToSet(aspectKeysOfInterest, currentAspects)

		if err != nil {
			return err
		}

		err = AddAspectsToSet(aspectKeysOfInterest, futureAspects)

		if err != nil {
			return err
		}

		aspectKeysArray := make([]string, 0, len(aspectKeysOfInterest))

		for key := range aspectKeysOfInterest {
			aspectKeysArray = append(aspectKeysArray, key)
		}

		sort.Strings(aspectKeysArray)

		genericAspectKeysArray := make([]interface{}, len(aspectKeysArray))
		for i, key := range aspectKeysArray {
			genericAspectKeysArray[i] = key
		}

		url, err = transport_tpg.AddArrayQueryParams(url, "aspectKeys", genericAspectKeysArray)
		if err != nil {
			return err
		}
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Entry %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Entry %q: %#v", d.Id(), res)
		}

	}

	return resourceDataplexEntryRead(d, meta)
}

func resourceDataplexEntryDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Entry: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{DataplexBasePath}}projects/{{project}}/locations/{{location}}/entryGroups/{{entry_group_id}}/entries/{{entry_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Entry %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Entry")
	}

	log.Printf("[DEBUG] Finished deleting Entry %q: %#v", d.Id(), res)
	return nil
}

func resourceDataplexEntryImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/entryGroups/(?P<entry_group_id>[^/]+)/entries/(?P<entry_id>.+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<entry_group_id>[^/]+)/(?P<entry_id>.+)$",
		"^(?P<location>[^/]+)/(?P<entry_group_id>[^/]+)/(?P<entry_id>.+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Double curly braces are the templating language's special marker.
	// We need them literally here, so apply a simple trick to force it.
	template := "projects/{{project}}/locations/{{location}}/entryGroups/{{entry_group_id}}/entries/{{entry_id}}"

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, template)
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)
	return []*schema.ResourceData{d}, nil
}

func flattenDataplexEntryName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntryType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

// This file is a transposition of mmv1/templates/terraform/flatten_property_method.go.tmpl
// Most of the code is copied from there, with the exception of sorting logic.
func flattenDataplexEntryAspects(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]map[string]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"aspect_key": flattenDataplexEntryAspectsAspectKey(original["aspectKey"], d, config),
			"aspect":     flattenDataplexEntryAspectsAspect(original["aspect"], d, config),
		})
	}

	configData := []map[string]interface{}{}

	for _, item := range d.Get("aspects").([]interface{}) {
		configData = append(configData, item.(map[string]interface{}))
	}

	sorted, err := tpgresource.SortMapsByConfigOrder(configData, transformed, "aspect_key")
	if err != nil {
		log.Printf("[ERROR] Could not sort API response value: %s", err)
		return v
	}

	return sorted
}
func flattenDataplexEntryAspectsAspectKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryAspectsAspect(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["aspect_type"] =
		flattenDataplexEntryAspectsAspectAspectType(original["aspectType"], d, config)
	transformed["path"] =
		flattenDataplexEntryAspectsAspectPath(original["path"], d, config)
	transformed["create_time"] =
		flattenDataplexEntryAspectsAspectCreateTime(original["createTime"], d, config)
	transformed["update_time"] =
		flattenDataplexEntryAspectsAspectUpdateTime(original["updateTime"], d, config)
	transformed["data"] =
		flattenDataplexEntryAspectsAspectData(original["data"], d, config)
	return []interface{}{transformed}
}
func flattenDataplexEntryAspectsAspectAspectType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryAspectsAspectPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryAspectsAspectCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryAspectsAspectUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryAspectsAspectData(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenDataplexEntryParentEntry(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryFullyQualifiedName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntrySource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["resource"] =
		flattenDataplexEntryEntrySourceResource(original["resource"], d, config)
	transformed["system"] =
		flattenDataplexEntryEntrySourceSystem(original["system"], d, config)
	transformed["platform"] =
		flattenDataplexEntryEntrySourcePlatform(original["platform"], d, config)
	transformed["display_name"] =
		flattenDataplexEntryEntrySourceDisplayName(original["displayName"], d, config)
	transformed["description"] =
		flattenDataplexEntryEntrySourceDescription(original["description"], d, config)
	transformed["labels"] =
		flattenDataplexEntryEntrySourceLabels(original["labels"], d, config)
	transformed["ancestors"] =
		flattenDataplexEntryEntrySourceAncestors(original["ancestors"], d, config)
	transformed["create_time"] =
		flattenDataplexEntryEntrySourceCreateTime(original["createTime"], d, config)
	transformed["update_time"] =
		flattenDataplexEntryEntrySourceUpdateTime(original["updateTime"], d, config)
	transformed["location"] =
		flattenDataplexEntryEntrySourceLocation(original["location"], d, config)
	return []interface{}{transformed}
}
func flattenDataplexEntryEntrySourceResource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntrySourceSystem(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntrySourcePlatform(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntrySourceDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntrySourceDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntrySourceLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntrySourceAncestors(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name": flattenDataplexEntryEntrySourceAncestorsName(original["name"], d, config),
			"type": flattenDataplexEntryEntrySourceAncestorsType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenDataplexEntryEntrySourceAncestorsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntrySourceAncestorsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntrySourceCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntrySourceUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataplexEntryEntrySourceLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandDataplexEntryEntryType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspects(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAspectKey, err := expandDataplexEntryAspectsAspectKey(original["aspect_key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAspectKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["aspectKey"] = transformedAspectKey
		}

		transformedAspect, err := expandDataplexEntryAspectsAspect(original["aspect"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAspect); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["aspect"] = transformedAspect
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDataplexEntryAspectsAspectKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspect(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAspectType, err := expandDataplexEntryAspectsAspectAspectType(original["aspect_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAspectType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["aspectType"] = transformedAspectType
	}

	transformedPath, err := expandDataplexEntryAspectsAspectPath(original["path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["path"] = transformedPath
	}

	transformedCreateTime, err := expandDataplexEntryAspectsAspectCreateTime(original["create_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCreateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["createTime"] = transformedCreateTime
	}

	transformedUpdateTime, err := expandDataplexEntryAspectsAspectUpdateTime(original["update_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUpdateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["updateTime"] = transformedUpdateTime
	}

	transformedData, err := expandDataplexEntryAspectsAspectData(original["data"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedData); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["data"] = transformedData
	}

	return transformed, nil
}

func expandDataplexEntryAspectsAspectAspectType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectCreateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectUpdateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectData(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	m := make(map[string]interface{})
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	return m, nil
}

func expandDataplexEntryParentEntry(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryFullyQualifiedName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedResource, err := expandDataplexEntryEntrySourceResource(original["resource"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["resource"] = transformedResource
	}

	transformedSystem, err := expandDataplexEntryEntrySourceSystem(original["system"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSystem); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["system"] = transformedSystem
	}

	transformedPlatform, err := expandDataplexEntryEntrySourcePlatform(original["platform"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPlatform); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["platform"] = transformedPlatform
	}

	transformedDisplayName, err := expandDataplexEntryEntrySourceDisplayName(original["display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayName"] = transformedDisplayName
	}

	transformedDescription, err := expandDataplexEntryEntrySourceDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedLabels, err := expandDataplexEntryEntrySourceLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedAncestors, err := expandDataplexEntryEntrySourceAncestors(original["ancestors"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAncestors); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ancestors"] = transformedAncestors
	}

	transformedCreateTime, err := expandDataplexEntryEntrySourceCreateTime(original["create_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCreateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["createTime"] = transformedCreateTime
	}

	transformedUpdateTime, err := expandDataplexEntryEntrySourceUpdateTime(original["update_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUpdateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["updateTime"] = transformedUpdateTime
	}

	transformedLocation, err := expandDataplexEntryEntrySourceLocation(original["location"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["location"] = transformedLocation
	}

	return transformed, nil
}

func expandDataplexEntryEntrySourceResource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceSystem(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourcePlatform(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandDataplexEntryEntrySourceAncestors(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandDataplexEntryEntrySourceAncestorsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedType, err := expandDataplexEntryEntrySourceAncestorsType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDataplexEntryEntrySourceAncestorsName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceAncestorsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceCreateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceUpdateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceDataplexEntryEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	// The yaml file does not allow validation for Array fields.
	// Therefore we add validation as a part of the encoding proecess.
	aspects := obj["aspects"]
	if aspects != nil {
		_, errors := NumberOfAspectsValidation(aspects, "aspects")
		if len(errors) > 0 {
			return nil, errors[0]
		}
	}

	err := TransformAspects(obj)

	if err != nil {
		return nil, err
	}

	return obj, nil
}

func resourceDataplexEntryDecoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
	aspects := res["aspects"]
	if aspects != nil {
		_, errors := NumberOfAspectsValidation(aspects, "aspects")
		if len(errors) > 0 {
			return nil, errors[0]
		}
	}

	aspectKeysOfInterest := make(map[string]struct{})
	var err error

	if d.HasChange("aspects") {
		currentAspects, futureAspects := d.GetChange("aspects")
		err = AddAspectsToSet(aspectKeysOfInterest, currentAspects)
		if err != nil {
			return nil, err
		}
		err = AddAspectsToSet(aspectKeysOfInterest, futureAspects)
		if err != nil {
			return nil, err
		}
	} else {
		err = AddAspectsToSet(aspectKeysOfInterest, d.Get("aspects"))
		if err != nil {
			return nil, err
		}
	}

	err = FilterAspects(aspectKeysOfInterest, res)

	if err != nil {
		return nil, err
	}

	err = InverseTransformAspects(res)

	if err != nil {
		return nil, err
	}

	return res, nil
}
