// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package datafusion

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-provider-google/google/fwmodels"
	"github.com/hashicorp/terraform-provider-google/google/fwresource"
	"github.com/hashicorp/terraform-provider-google/google/fwtransport"

	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

var instanceAcceleratorOptions = []string{
	"delta.default.checkpoint.directory",
	"ui.feature.cdc",
}

func instanceOptionsDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the options generated by adding an accelerator to a data fusion instance
	for _, option := range instanceAcceleratorOptions {
		if strings.Contains(k, option) && new == "" {
			return true
		}
	}

	// Let diff be determined by options (above)
	if strings.Contains(k, "options.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

var (
	_ resource.Resource              = &DataFusionInstanceFWResource{}
	_ resource.ResourceWithConfigure = &DataFusionInstanceFWResource{}
)

func NewDataFusionInstanceFWResource() resource.Resource {
	return &DataFusionInstanceFWResource{}
}

type DataFusionInstanceFWResource struct {
	providerConfig *transport_tpg.Config
}

type DataFusionInstanceFWModel struct {
	Name                        types.String `tfsdk:"name"`
	Type                        types.String `tfsdk:"type"`
	Accelerators                types.List   `tfsdk:"accelerators"`
	CryptoKeyConfig             types.Nested `tfsdk:"crypto_key_config"`
	DataprocServiceAccount      types.String `tfsdk:"dataproc_service_account"`
	Description                 types.String `tfsdk:"description"`
	DisplayName                 types.String `tfsdk:"display_name"`
	EnableRbac                  types.Bool   `tfsdk:"enable_rbac"`
	EnableStackdriverLogging    types.Bool   `tfsdk:"enable_stackdriver_logging"`
	EnableStackdriverMonitoring types.Bool   `tfsdk:"enable_stackdriver_monitoring"`
	EventPublishConfig          types.Nested `tfsdk:"event_publish_config"`
	Labels                      types.Map    `tfsdk:"labels"`
	NetworkConfig               types.Nested `tfsdk:"network_config"`
	Options                     types.Map    `tfsdk:"options"`
	PrivateInstance             types.Bool   `tfsdk:"private_instance"`
	Region                      types.String `tfsdk:"region"`
	Tags                        types.Map    `tfsdk:"tags"`
	Version                     types.String `tfsdk:"version"`
	Zone                        types.String `tfsdk:"zone"`
	ApiEndpoint                 types.String `tfsdk:"api_endpoint"`
	CreateTime                  types.String `tfsdk:"create_time"`
	EffectiveLabels             types.Map    `tfsdk:"effective_labels"`
	GcsBucket                   types.String `tfsdk:"gcs_bucket"`
	P4ServiceAccount            types.String `tfsdk:"p4_service_account"`
	ServiceEndpoint             types.String `tfsdk:"service_endpoint"`
	State                       types.String `tfsdk:"state"`
	StateMessage                types.String `tfsdk:"state_message"`
	TenantProjectId             types.String `tfsdk:"tenant_project_id"`
	TerraformLabels             types.Map    `tfsdk:"terraform_labels"`
	UpdateTime                  types.String `tfsdk:"update_time"`
	Project                     types.String `tfsdk:"project"`
}

// Metadata returns the resource type name.
func (d *DataFusionInstanceFWResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_fw_data_fusion_instance"
}

func (r *DataFusionInstanceFWResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	p, ok := req.ProviderData.(*transport_tpg.Config)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *transport_tpg.Config, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	r.providerConfig = p
}

func (d *DataFusionInstanceFWResource) Schema(ctx context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "A resource to represent a SQL User object.",

		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{

					stringplanmodifier.RequiresReplace(),
				},
			},
			"type": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{

					stringplanmodifier.RequiresReplace(),
				},
			},
			"accelerators": schema.ListAttribute{
				Optional: true,
			},
			"crypto_key_config": schema.NestedAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.Nested{

					nestedplanmodifier.RequiresReplace(),
				},
			},
			"dataproc_service_account": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{

					stringplanmodifier.RequiresReplace(),
				},
			},
			"description": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{

					stringplanmodifier.RequiresReplace(),
				},
			},
			"display_name": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{

					stringplanmodifier.RequiresReplace(),
				},
			},
			"enable_rbac": schema.BoolAttribute{
				Optional: true,
			},
			"enable_stackdriver_logging": schema.BoolAttribute{
				Optional: true,
			},
			"enable_stackdriver_monitoring": schema.BoolAttribute{
				Optional: true,
			},
			"event_publish_config": schema.NestedAttribute{
				Optional: true,
			},
			"labels": schema.MapAttribute{
				Optional: true,
			},
			"network_config": schema.NestedAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.Nested{

					nestedplanmodifier.RequiresReplace(),
				},
			},
			"options": schema.MapAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Map{

					mapplanmodifier.RequiresReplace(),
					mapplanmodifier.UseStateForUnknown(),
				},
			},
			"private_instance": schema.BoolAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.Bool{

					boolplanmodifier.RequiresReplace(),
				},
			},
			"region": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{

					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"tags": schema.MapAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.Map{

					mapplanmodifier.RequiresReplace(),
				},
			},
			"version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{

					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"zone": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{

					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"api_endpoint": schema.StringAttribute{
				Computed: true,
			},
			"create_time": schema.StringAttribute{
				Computed: true,
			},
			"effective_labels": schema.MapAttribute{
				Computed: true,
			},
			"gcs_bucket": schema.StringAttribute{
				Computed: true,
			},
			"p4_service_account": schema.StringAttribute{
				Computed: true,
			},
			"service_endpoint": schema.StringAttribute{
				Computed: true,
			},
			"state": schema.StringAttribute{
				Computed: true,
			},
			"state_message": schema.StringAttribute{
				Computed: true,
			},
			"tenant_project_id": schema.StringAttribute{
				Computed: true,
			},
			"terraform_labels": schema.MapAttribute{
				Computed: true,
			},
			"update_time": schema.StringAttribute{
				Computed: true,
			},
			"project": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			// This is included for backwards compatibility with the original, SDK-implemented resource.
			"id": schema.StringAttribute{
				Description:         "Project identifier",
				MarkdownDescription: "Project identifier",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

func (r *DataFusionInstanceFWResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data DataFusionInstanceFWModel
	var metaData *fwmodels.ProviderMetaModel
	// Read Provider meta into the meta model
	resp.Diagnostics.Append(req.ProviderMeta.Get(ctx, &metaData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	project := fwresource.GetProjectFramework(data.Project, types.StringValue(r.providerConfig.Project), &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}
	region := fwresource.GetRegionFramework(data.Region, types.StringValue(r.providerConfig.Region), &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	var schemaDefaultVals fwtransport.DefaultVars
	schemaDefaultVals.Project = project
	schemaDefaultVals.Region = region

	// Use provider_meta to set User-Agent
	userAgent := fwtransport.GenerateFrameworkUserAgentString(metaData, r.providerConfig.UserAgent)

	obj := make(map[string]interface{})
	nameProp, diags := data.Name.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["name"] = nameProp
	typeProp, diags := data.Type.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["type"] = typeProp
	acceleratorsProp, diags := data.Accelerators.ToListValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["accelerators"] = acceleratorsProp
	cryptoKeyConfigProp, diags := data.CryptoKeyConfig.ToNestedValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["cryptoKeyConfig"] = cryptoKeyConfigProp
	dataprocServiceAccountProp, diags := data.DataprocServiceAccount.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["dataprocServiceAccount"] = dataprocServiceAccountProp
	descriptionProp, diags := data.Description.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["description"] = descriptionProp
	displayNameProp, diags := data.DisplayName.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["displayName"] = displayNameProp
	enableRbacProp, diags := data.EnableRbac.ToBoolValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["enableRbac"] = enableRbacProp
	enableStackdriverLoggingProp, diags := data.EnableStackdriverLogging.ToBoolValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["enableStackdriverLogging"] = enableStackdriverLoggingProp
	enableStackdriverMonitoringProp, diags := data.EnableStackdriverMonitoring.ToBoolValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["enableStackdriverMonitoring"] = enableStackdriverMonitoringProp
	eventPublishConfigProp, diags := data.EventPublishConfig.ToNestedValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["eventPublishConfig"] = eventPublishConfigProp
	labelsProp, diags := data.Labels.ToMapValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["labels"] = labelsProp
	networkConfigProp, diags := data.NetworkConfig.ToNestedValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["networkConfig"] = networkConfigProp
	optionsProp, diags := data.Options.ToMapValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["options"] = optionsProp
	privateInstanceProp, diags := data.PrivateInstance.ToBoolValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["privateInstance"] = privateInstanceProp
	regionProp, diags := data.Region.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["region"] = regionProp
	tagsProp, diags := data.Tags.ToMapValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["tags"] = tagsProp
	versionProp, diags := data.Version.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["version"] = versionProp
	zoneProp, diags := data.Zone.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["zone"] = zoneProp
	apiEndpointProp, diags := data.ApiEndpoint.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["apiEndpoint"] = apiEndpointProp
	createTimeProp, diags := data.CreateTime.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["createTime"] = createTimeProp
	labelsProp, diags := data.EffectiveLabels.ToMapValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["labels"] = labelsProp
	gcsBucketProp, diags := data.GcsBucket.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["gcsBucket"] = gcsBucketProp
	p4ServiceAccountProp, diags := data.P4ServiceAccount.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["p4ServiceAccount"] = p4ServiceAccountProp
	serviceEndpointProp, diags := data.ServiceEndpoint.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["serviceEndpoint"] = serviceEndpointProp
	stateProp, diags := data.State.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["state"] = stateProp
	stateMessageProp, diags := data.StateMessage.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["stateMessage"] = stateMessageProp
	tenantProjectIdProp, diags := data.TenantProjectId.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["tenantProjectId"] = tenantProjectIdProp
	labelsProp, diags := data.TerraformLabels.ToMapValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["labels"] = labelsProp
	updateTimeProp, diags := data.UpdateTime.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	obj["updateTime"] = updateTimeProp

	createTimeout, diags := data.Timeouts.Create(ctx, 20*time.Minute)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	url := fwtransport.ReplaceVars(ctx, req, &resp.Diagnostics, schemaDefaultVals, r.providerConfig, "{{DataFusionBasePath}}projects/{{project}}/locations/{{region}}/instances?instanceId={{name}}")
	if resp.Diagnostics.HasError() {
		return
	}

	log.Printf("[DEBUG] Creating new Instance: %#v", obj)

	headers := make(http.Header)
	res := fwtransport.SendRequest(fwtransport.SendRequestOptions{
		Config:    r.providerConfig,
		Method:    "POST",
		Project:   billingProject.ValueString(),
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   createTimeout,
		Headers:   headers,
	}, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "created Instance resource")

	data.Id = types.StringValue("projects/{{project}}/locations/{{region}}/instances/{{name}}")
	data.Project = project
	data.Region = region

	// read back Instance
	r.DataFusionInstanceFWRefresh(ctx, &data, &resp.State, req, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)

}

func (r *DataFusionInstanceFWResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data DataFusionInstanceFWModel
	var metaData *fwmodels.ProviderMetaModel

	// Read Provider meta into the meta model
	resp.Diagnostics.Append(req.ProviderMeta.Get(ctx, &metaData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Use provider_meta to set User-Agent
	r.client.UserAgent = fwtransport.GenerateFrameworkUserAgentString(metaData, r.client.UserAgent)

	tflog.Trace(ctx, "read Instance resource")

	// read back Instance
	r.DataFusionInstanceFWRefresh(ctx, &data, &resp.State, req, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DataFusionInstanceFWResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var state, plan DataFusionInstanceFWModel
	var metaData *fwmodels.ProviderMetaModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	project := fwresource.GetProjectFramework(plan.Project, types.StringValue(r.providerConfig.Project), &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}
	region := fwresource.GetRegionFramework(plan.Region, types.StringValue(r.providerConfig.Region), &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	var schemaDefaultVals fwtransport.DefaultVars
	schemaDefaultVals.Project = project
	schemaDefaultVals.Region = region

	// Use provider_meta to set User-Agent
	userAgent := fwtransport.GenerateFrameworkUserAgentString(metaData, r.providerConfig.UserAgent)

	obj := make(map[string]interface{})
	if !plan.Accelerators.Equal(state.Accelerators) {
		acceleratorsProp, diags := plan.Accelerators.ToListValue(ctx)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		obj["accelerators"] = acceleratorsProp
	}
	if !plan.EnableRbac.Equal(state.EnableRbac) {
		enableRbacProp, diags := plan.EnableRbac.ToBoolValue(ctx)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		obj["enableRbac"] = enableRbacProp
	}
	if !plan.EnableStackdriverLogging.Equal(state.EnableStackdriverLogging) {
		enableStackdriverLoggingProp, diags := plan.EnableStackdriverLogging.ToBoolValue(ctx)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		obj["enableStackdriverLogging"] = enableStackdriverLoggingProp
	}
	if !plan.EnableStackdriverMonitoring.Equal(state.EnableStackdriverMonitoring) {
		enableStackdriverMonitoringProp, diags := plan.EnableStackdriverMonitoring.ToBoolValue(ctx)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		obj["enableStackdriverMonitoring"] = enableStackdriverMonitoringProp
	}
	if !plan.EventPublishConfig.Equal(state.EventPublishConfig) {
		eventPublishConfigProp, diags := plan.EventPublishConfig.ToNestedValue(ctx)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		obj["eventPublishConfig"] = eventPublishConfigProp
	}
	if !plan.Version.Equal(state.Version) {
		versionProp, diags := plan.Version.ToStringValue(ctx)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		obj["version"] = versionProp
	}
	if !plan.EffectiveLabels.Equal(state.EffectiveLabels) {
		labelsProp, diags := plan.EffectiveLabels.ToMapValue(ctx)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		obj["labels"] = labelsProp
	}

	url := fwtransport.ReplaceVars(ctx, req, &resp.Diagnostics, schemaDefaultVals, r.providerConfig, "{{DataFusionBasePath}}projects/{{project}}/locations/{{region}}/instances?instanceId={{name}}")
	if resp.Diagnostics.HasError() {
		return
	}

	log.Printf("[DEBUG] Updating Instance: %#v", obj)

	headers := make(http.Header)
	updateMask := []string{}

	if !plan.EnableStackdriverLogging.Equal(state.EnableStackdriverLogging) {
		updateMask = append(updateMask, "enableStackdriverLogging")
	}

	if !plan.EnableStackdriverMonitoring.Equal(state.EnableStackdriverMonitoring) {
		updateMask = append(updateMask, "enableStackdriverMonitoring")
	}

	if !plan.EnableRbac.Equal(state.EnableRbac) {
		updateMask = append(updateMask, "enableRbac")
	}

	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it

	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}
	res := fwtransport.SendRequest(fwtransport.SendRequestOptions{
		Config:    r.providerConfig,
		Method:    "PATCH",
		Project:   billingProject.ValueString(),
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   createTimeout,
		Headers:   headers,
	}, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "updated Instance resource")

	// read back Instance
	r.DataFusionInstanceFWRefresh(ctx, &plan, &resp.State, req, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

func (r *DataFusionInstanceFWResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data DataFusionInstanceFWModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	project := fwresource.GetProjectFramework(data.Project, types.StringValue(r.providerConfig.Project), &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}
	region := fwresource.GetRegionFramework(data.Region, types.StringValue(r.providerConfig.Region), &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	var schemaDefaultVals fwtransport.DefaultVars
	schemaDefaultVals.Project = project
	schemaDefaultVals.Region = region

	// Use provider_meta to set User-Agent
	userAgent := fwtransport.GenerateFrameworkUserAgentString(metaData, r.providerConfig.UserAgent)

	obj := make(map[string]interface{})

	deleteTimeout, diags := data.Timeouts.Delete(ctx, 20*time.Minute)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	url := fwtransport.ReplaceVars(ctx, req, &resp.Diagnostics, schemaDefaultVals, r.providerConfig, "{{DataFusionBasePath}}projects/{{project}}/locations/{{region}}/instances/{{name}}")
	if resp.Diagnostics.HasError() {
		return
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Instance %q", r.Id())
	res := fwtransport.SendRequest(fwtransport.SendRequestOptions{
		Config:    r.providerConfig,
		Method:    "DELETE",
		Project:   billingProject.ValueString(),
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   createTimeout,
		Headers:   headers,
	}, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		diags.AddError(fmt.Sprintf("Error deleting Instance: %s", data.Id))
		return
	}

	log.Printf("[DEBUG] Finished deleting Instance %q: %#v", data.Id, res)
}

func (r *DataFusionInstanceFWResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}

func (r *DataFusionInstanceFWResource) DataFusionInstanceFWRefresh(ctx context.Context, data *DataFusionInstanceFWModel, state *tfsdk.State, req interface{}, diag *diag.Diagnostics) {
	var metaData *fwmodels.ProviderMetaModel
	//load default values
	project := fwresource.GetProjectFramework(data.Project, types.StringValue(r.providerConfig.Project), &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}
	region := fwresource.GetRegionFramework(data.Region, types.StringValue(r.providerConfig.Region), &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	var schemaDefaultVals fwtransport.DefaultVars
	schemaDefaultVals.Project = project
	schemaDefaultVals.Region = region

	// Use provider_meta to set User-Agent
	userAgent := fwtransport.GenerateFrameworkUserAgentString(metaData, r.providerConfig.UserAgent)

	url := fwtransport.ReplaceVars(ctx, req, &resp.Diagnostics, schemaDefaultVals, r.providerConfig, "{{DataFusionBasePath}}projects/{{project}}/locations/{{region}}/instances/{{name}}")
	if resp.Diagnostics.HasError() {
		return
	}

	log.Printf("[DEBUG] Refreshing Instancedata: %s", data.Id.ValueString())

	headers := make(http.Header)
	res := fwtransport.SendRequest(fwtransport.SendRequestOptions{
		Config:    r.providerConfig,
		Method:    "GET",
		Project:   billingProject.ValueString(),
		RawURL:    url,
		UserAgent: userAgent,
		Timeout:   createTimeout,
		Headers:   headers,
	}, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		fwtransport.HandleNotFoundError(ctx, err, &resp.State, fmt.Sprintf("DataFusionInstance %s", data.Id.ValueString()), &resp.Diagnostics)
		if resp.Diagnostics.HasError() {
			return
		}
	}

	data.Name = res["name"]
	nameProp, diags := data.Name.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.Type = res["type"]
	typeProp, diags := data.Type.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.Accelerators = res["accelerators"]
	acceleratorsProp, diags := data.Accelerators.ToListValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.CryptoKeyConfig = res["cryptoKeyConfig"]
	cryptoKeyConfigProp, diags := data.CryptoKeyConfig.ToNestedValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.DataprocServiceAccount = res["dataprocServiceAccount"]
	dataprocServiceAccountProp, diags := data.DataprocServiceAccount.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.Description = res["description"]
	descriptionProp, diags := data.Description.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.DisplayName = res["displayName"]
	displayNameProp, diags := data.DisplayName.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.EnableRbac = res["enableRbac"]
	enableRbacProp, diags := data.EnableRbac.ToBoolValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.EnableStackdriverLogging = res["enableStackdriverLogging"]
	enableStackdriverLoggingProp, diags := data.EnableStackdriverLogging.ToBoolValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.EnableStackdriverMonitoring = res["enableStackdriverMonitoring"]
	enableStackdriverMonitoringProp, diags := data.EnableStackdriverMonitoring.ToBoolValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.EventPublishConfig = res["eventPublishConfig"]
	eventPublishConfigProp, diags := data.EventPublishConfig.ToNestedValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.Labels = res["labels"]
	labelsProp, diags := data.Labels.ToMapValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.NetworkConfig = res["networkConfig"]
	networkConfigProp, diags := data.NetworkConfig.ToNestedValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.Options = res["options"]
	optionsProp, diags := data.Options.ToMapValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.PrivateInstance = res["privateInstance"]
	privateInstanceProp, diags := data.PrivateInstance.ToBoolValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.Region = res["region"]
	regionProp, diags := data.Region.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.Tags = res["tags"]
	tagsProp, diags := data.Tags.ToMapValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.Version = res["version"]
	versionProp, diags := data.Version.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.Zone = res["zone"]
	zoneProp, diags := data.Zone.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.ApiEndpoint = res["apiEndpoint"]
	apiEndpointProp, diags := data.ApiEndpoint.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.CreateTime = res["createTime"]
	createTimeProp, diags := data.CreateTime.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.EffectiveLabels = res["labels"]
	labelsProp, diags := data.EffectiveLabels.ToMapValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.GcsBucket = res["gcsBucket"]
	gcsBucketProp, diags := data.GcsBucket.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.P4ServiceAccount = res["p4ServiceAccount"]
	p4ServiceAccountProp, diags := data.P4ServiceAccount.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.ServiceEndpoint = res["serviceEndpoint"]
	serviceEndpointProp, diags := data.ServiceEndpoint.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.State = res["state"]
	stateProp, diags := data.State.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.StateMessage = res["stateMessage"]
	stateMessageProp, diags := data.StateMessage.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.TenantProjectId = res["tenantProjectId"]
	tenantProjectIdProp, diags := data.TenantProjectId.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.TerraformLabels = res["labels"]
	labelsProp, diags := data.TerraformLabels.ToMapValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	data.UpdateTime = res["updateTime"]
	updateTimeProp, diags := data.UpdateTime.ToStringValue(ctx)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "refreshed Instance resource data")

}
