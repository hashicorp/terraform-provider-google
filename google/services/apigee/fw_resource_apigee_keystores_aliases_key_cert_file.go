// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/apigee/fw_resource_apigee_keystores_aliases_key_cert_file.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package apigee

import (
	"bytes"
	"context"
	"fmt"
	"mime/multipart"
	"time"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-provider-google/google/fwmodels"
	"github.com/hashicorp/terraform-provider-google/google/fwresource"
	"github.com/hashicorp/terraform-provider-google/google/fwtransport"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

var (
	_ resource.Resource                = &ApigeeKeystoresAliasesKeyCertFileResource{}
	_ resource.ResourceWithConfigure   = &ApigeeKeystoresAliasesKeyCertFileResource{}
	_ resource.ResourceWithImportState = &ApigeeKeystoresAliasesKeyCertFileResource{}
)

func NewApigeeKeystoresAliasesKeyCertFileResource() resource.Resource {
	return &ApigeeKeystoresAliasesKeyCertFileResource{}
}

type ApigeeKeystoresAliasesKeyCertFileResource struct {
	providerConfig *transport_tpg.Config
}

type ApigeeKeystoresAliasesKeyCertFileResourceModel struct {
	Id          types.String   `tfsdk:"id"`
	OrgId       types.String   `tfsdk:"org_id"`
	Environment types.String   `tfsdk:"environment"`
	Keystore    types.String   `tfsdk:"keystore"`
	Alias       types.String   `tfsdk:"alias"`
	Cert        types.String   `tfsdk:"cert"`
	Key         types.String   `tfsdk:"key"`
	Password    types.String   `tfsdk:"password"`
	Type        types.String   `tfsdk:"type"`
	CertsInfo   types.List     `tfsdk:"certs_info"`
	Timeouts    timeouts.Value `tfsdk:"timeouts"`
}

type CertInfoDetailModel struct {
	BasicConstraints        types.String `tfsdk:"basic_constraints"`
	ExpiryDate              types.String `tfsdk:"expiry_date"`
	IsValid                 types.String `tfsdk:"is_valid"`
	Issuer                  types.String `tfsdk:"issuer"`
	PublicKey               types.String `tfsdk:"public_key"`
	SerialNumber            types.String `tfsdk:"serial_number"`
	SigAlgName              types.String `tfsdk:"sig_alg_name"`
	Subject                 types.String `tfsdk:"subject"`
	SubjectAlternativeNames types.List   `tfsdk:"subject_alternative_names"`
	ValidFrom               types.String `tfsdk:"valid_from"`
	Version                 types.Int64  `tfsdk:"version"`
}

func (r *ApigeeKeystoresAliasesKeyCertFileResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_apigee_keystores_aliases_key_cert_file"
}

func (r *ApigeeKeystoresAliasesKeyCertFileResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	p, ok := req.ProviderData.(*transport_tpg.Config)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *transport_tpg.Config, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.providerConfig = p
}

func (r *ApigeeKeystoresAliasesKeyCertFileResource) Schema(ctx context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "An alias from a key/cert file.",
		Attributes: map[string]schema.Attribute{
			"org_id": schema.StringAttribute{
				Description: "Organization ID associated with the alias.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"environment": schema.StringAttribute{
				Description: "Environment associated with the alias.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"keystore": schema.StringAttribute{
				Description: "Keystore Name.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"alias": schema.StringAttribute{
				Description: "Alias Name.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"cert": schema.StringAttribute{
				Description: "Cert content.",
				Required:    true,
			},
			"key": schema.StringAttribute{
				Description: "Private Key content, omit if uploading to truststore.",
				Optional:    true,
				Sensitive:   true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"password": schema.StringAttribute{
				Description: "Password for the Private Key if it's encrypted.",
				Optional:    true,
				Sensitive:   true,
			},
			"type": schema.StringAttribute{
				Description: "Optional. Type of Alias.",
				Computed:    true,
			},
			"id": schema.StringAttribute{
				Description: "Project identifier",
				Computed:    true,
			},
			"certs_info": schema.ListAttribute{
				Description: "Chain of certificates under this alias.",
				Computed:    true,
				ElementType: types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"basic_constraints":         types.StringType,
						"expiry_date":               types.StringType,
						"is_valid":                  types.StringType,
						"issuer":                    types.StringType,
						"public_key":                types.StringType,
						"serial_number":             types.StringType,
						"sig_alg_name":              types.StringType,
						"subject":                   types.StringType,
						"subject_alternative_names": types.ListType{ElemType: types.StringType},
						"valid_from":                types.StringType,
						"version":                   types.Int64Type,
					},
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
		},
	}
}

func (r *ApigeeKeystoresAliasesKeyCertFileResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan ApigeeKeystoresAliasesKeyCertFileResourceModel
	var metaData *fwmodels.ProviderMetaModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.ProviderMeta.Get(ctx, &metaData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := plan.Timeouts.Create(ctx, 20*time.Minute)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	buf := new(bytes.Buffer)
	bw := multipart.NewWriter(buf)
	if !plan.Key.IsNull() && !plan.Key.IsUnknown() {
		keyFilePartWriter, _ := bw.CreateFormField("keyFile")
		keyFilePartWriter.Write([]byte(plan.Key.ValueString()))
	}
	if !plan.Password.IsNull() && !plan.Password.IsUnknown() {
		keyFilePartWriter, _ := bw.CreateFormField("password")
		keyFilePartWriter.Write([]byte(plan.Password.ValueString()))
	}
	certFilePartWriter, _ := bw.CreateFormField("certFile")
	certFilePartWriter.Write([]byte(plan.Cert.ValueString()))
	bw.Close()

	billingProject := types.StringValue(r.providerConfig.BillingProject)

	var schemaDefaultVals fwtransport.DefaultVars

	userAgent := fwtransport.GenerateFrameworkUserAgentString(metaData, r.providerConfig.UserAgent)
	url := fwtransport.ReplaceVars(ctx, req, &resp.Diagnostics, schemaDefaultVals, r.providerConfig, "{{ApigeeBasePath}}organizations/{{org_id}}/environments/{{environment}}/keystores/{{keystore}}/aliases?format=keycertfile&alias={{alias}}&ignoreExpiryValidation=true")
	if resp.Diagnostics.HasError() {
		return
	}

	res, err := sendRequestRawBodyWithTimeout(r.providerConfig, "POST", billingProject.ValueString(), url, userAgent, buf, bw.FormDataContentType(), createTimeout)
	if err != nil {
		resp.Diagnostics.AddError("Error, failure to create key cert file", err.Error())
		return
	}

	tflog.Trace(ctx, "Successfully created Apigee Keystore Alias", map[string]interface{}{"response": res})

	id := fmt.Sprintf("organizations/%s/environments/%s/keystores/%s/aliases/%s",
		plan.OrgId.ValueString(),
		plan.Environment.ValueString(),
		plan.Keystore.ValueString(),
		plan.Alias.ValueString(),
	)
	plan.Id = types.StringValue(id)

	r.refresh(ctx, req, &plan, &resp.State, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

func (r *ApigeeKeystoresAliasesKeyCertFileResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state ApigeeKeystoresAliasesKeyCertFileResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	r.refresh(ctx, req, &state, &resp.State, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (r *ApigeeKeystoresAliasesKeyCertFileResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan ApigeeKeystoresAliasesKeyCertFileResourceModel
	var state ApigeeKeystoresAliasesKeyCertFileResourceModel
	var metaData *fwmodels.ProviderMetaModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.ProviderMeta.Get(ctx, &metaData)...)
	if resp.Diagnostics.HasError() {
		return
	}
	updateTimeout, diags := plan.Timeouts.Update(ctx, 20*time.Minute)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	buf := new(bytes.Buffer)
	bw := multipart.NewWriter(buf)
	certFilePartWriter, err := bw.CreateFormField("certFile")
	if err != nil {
		resp.Diagnostics.AddError("Unable to create form field for certificate", err.Error())
		return
	}
	certFilePartWriter.Write([]byte(plan.Cert.ValueString()))
	bw.Close()

	billingProject := types.StringValue(r.providerConfig.BillingProject)
	userAgent := fwtransport.GenerateFrameworkUserAgentString(metaData, r.providerConfig.UserAgent)

	var schemaDefaultVals fwtransport.DefaultVars

	url := fwtransport.ReplaceVars(ctx, req, &resp.Diagnostics, schemaDefaultVals, r.providerConfig, "{{ApigeeBasePath}}organizations/{{org_id}}/environments/{{environment}}/keystores/{{keystore}}/aliases/{{alias}}?ignoreExpiryValidation=true")
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "Updating Apigee Keystore Alias", map[string]interface{}{"url": url})
	res, err := sendRequestRawBodyWithTimeout(r.providerConfig, "PUT", billingProject.ValueString(), url, userAgent, buf, bw.FormDataContentType(), updateTimeout)

	if err != nil {
		resp.Diagnostics.AddError("Error, failure to update key cert file", err.Error())
		return
	}

	tflog.Trace(ctx, "Successfully sent update request for Apigee Keystore Alias", map[string]interface{}{"response": res})

	r.refresh(ctx, req, &plan, &resp.State, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

func (r *ApigeeKeystoresAliasesKeyCertFileResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data ApigeeKeystoresAliasesKeyCertFileResourceModel
	var metaData *fwmodels.ProviderMetaModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.ProviderMeta.Get(ctx, &metaData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, 20*time.Minute)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	userAgent := fwtransport.GenerateFrameworkUserAgentString(metaData, r.providerConfig.UserAgent)

	var schemaDefaultVals fwtransport.DefaultVars
	url := fwtransport.ReplaceVars(ctx, req, &resp.Diagnostics, schemaDefaultVals, r.providerConfig, "{{ApigeeBasePath}}organizations/{{org_id}}/environments/{{environment}}/keystores/{{keystore}}/aliases/{{alias}}")
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "Deleting Apigee Keystore Alias", map[string]interface{}{"url": url})

	_, _ = fwtransport.SendRequest(fwtransport.SendRequestOptions{
		Config:    r.providerConfig,
		Method:    "DELETE",
		Project:   data.OrgId.ValueString(),
		RawURL:    url,
		UserAgent: userAgent,
		Timeout:   deleteTimeout,
	}, &resp.Diagnostics)

	tflog.Trace(ctx, "Successfully deleted Apigee Keystore Alias.")
}

func (r *ApigeeKeystoresAliasesKeyCertFileResource) refresh(ctx context.Context, req interface{}, data *ApigeeKeystoresAliasesKeyCertFileResourceModel, state *tfsdk.State, diags *diag.Diagnostics) {
	var metaData *fwmodels.ProviderMetaModel

	userAgent := fwtransport.GenerateFrameworkUserAgentString(metaData, r.providerConfig.UserAgent)

	var schemaDefaultVals fwtransport.DefaultVars
	url := fwtransport.ReplaceVars(ctx, req, diags, schemaDefaultVals, r.providerConfig, "{{ApigeeBasePath}}organizations/{{org_id}}/environments/{{environment}}/keystores/{{keystore}}/aliases/{{alias}}")
	if diags.HasError() {
		return
	}

	readTimeout, timeoutDiags := data.Timeouts.Read(ctx, 20*time.Minute)
	diags.Append(timeoutDiags...)
	if diags.HasError() {
		return
	}

	tflog.Trace(ctx, "Refreshing Apigee Keystore Alias", map[string]interface{}{"url": url})

	res, _ := fwtransport.SendRequest(fwtransport.SendRequestOptions{
		Config:    r.providerConfig,
		Method:    "GET",
		Project:   data.OrgId.ValueString(),
		RawURL:    url,
		UserAgent: userAgent,
		Timeout:   readTimeout,
	}, diags)

	if diags.HasError() {
		return
	}

	tflog.Trace(ctx, "Successfully refreshed Apigee Keystore Alias", map[string]interface{}{"response": res})

	id := fmt.Sprintf("organizations/%s/environments/%s/keystores/%s/aliases/%s",
		data.OrgId.ValueString(),
		data.Environment.ValueString(),
		data.Keystore.ValueString(),
		data.Alias.ValueString(),
	)
	data.Id = types.StringValue(id)

	data.Type = types.StringValue(res["type"].(string))

	flattenedCertsInfo, certDiags := flattenCertsInfo(res["certsInfo"])
	diags.Append(certDiags...)
	if diags.HasError() {
		return
	}
	data.CertsInfo = flattenedCertsInfo
}

var certInfoObjectType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"basic_constraints":         types.StringType,
		"expiry_date":               types.StringType,
		"is_valid":                  types.StringType,
		"issuer":                    types.StringType,
		"public_key":                types.StringType,
		"serial_number":             types.StringType,
		"sig_alg_name":              types.StringType,
		"subject":                   types.StringType,
		"subject_alternative_names": types.ListType{ElemType: types.StringType},
		"valid_from":                types.StringType,
		"version":                   types.Int64Type,
	},
}

func flattenCertsInfo(v interface{}) (types.List, diag.Diagnostics) {
	if v == nil {
		return types.ListNull(certInfoObjectType), nil
	}

	var diags diag.Diagnostics

	certsInfoMap, ok := v.(map[string]interface{})
	if !ok {
		diags.AddError("Invalid Type", "Cannot flatten certs_info: input is not a map.")
		return types.ListNull(certInfoObjectType), diags
	}
	if len(certsInfoMap) == 0 {
		return types.ListNull(certInfoObjectType), nil
	}

	certInfoListRaw, ok := certsInfoMap["certInfo"].([]interface{})
	if !ok || len(certInfoListRaw) == 0 {
		return types.ListNull(certInfoObjectType), nil
	}

	var certInfoDetails []CertInfoDetailModel
	for _, rawCertInfo := range certInfoListRaw {
		certInfo, ok := rawCertInfo.(map[string]interface{})
		if !ok || len(certInfo) == 0 {
			continue
		}
		getStringValue := func(key string) types.String {
			if val, ok := certInfo[key].(string); ok {
				return types.StringValue(val)
			}
			return types.StringNull()
		}
		var sansValue types.List
		if sansRaw, ok := certInfo["subjectAlternativeNames"].([]interface{}); ok {
			sans := make([]string, 0, len(sansRaw))
			for _, san := range sansRaw {
				if s, ok := san.(string); ok {
					sans = append(sans, s)
				}
			}
			var listDiags diag.Diagnostics
			sansValue, listDiags = types.ListValueFrom(context.Background(), types.StringType, sans)
			diags.Append(listDiags...)
		} else {
			sansValue = types.ListNull(types.StringType)
		}
		var versionValue types.Int64
		if versionRaw, ok := certInfo["version"]; ok {
			switch v := versionRaw.(type) {
			case float64:
				versionValue = types.Int64Value(int64(v))
			case string:
				versionValue = types.Int64Null()
			default:
				versionValue = types.Int64Null()
			}
		} else {
			versionValue = types.Int64Null()
		}
		detail := CertInfoDetailModel{
			BasicConstraints:        getStringValue("basicConstraints"),
			ExpiryDate:              getStringValue("expiryDate"),
			IsValid:                 getStringValue("isValid"),
			Issuer:                  getStringValue("issuer"),
			PublicKey:               getStringValue("publicKey"),
			SerialNumber:            getStringValue("serialNumber"),
			SigAlgName:              getStringValue("sigAlgName"),
			Subject:                 getStringValue("subject"),
			ValidFrom:               getStringValue("validFrom"),
			SubjectAlternativeNames: sansValue,
			Version:                 versionValue,
		}
		certInfoDetails = append(certInfoDetails, detail)
	}

	if diags.HasError() {
		return types.ListNull(certInfoObjectType), diags
	}

	flattenedList, listDiags := types.ListValueFrom(context.Background(), certInfoObjectType, certInfoDetails)
	diags.Append(listDiags...)

	return flattenedList, diags
}

func (r *ApigeeKeystoresAliasesKeyCertFileResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	idRegexes := []string{
		"organizations/(?P<org_id>[^/]+)/environments/(?P<environment>[^/]+)/keystores/(?P<keystore>[^/]+)/aliases/(?P<alias>[^/]+)",
		"(?P<org_id>[^/]+)/(?P<environment>[^/]+)/(?P<keystore>[^/]+)/(?P<alias>[^/]+)",
	}

	var resourceSchemaResp resource.SchemaResponse
	r.Schema(ctx, resource.SchemaRequest{}, &resourceSchemaResp)
	if resourceSchemaResp.Diagnostics.HasError() {
		resp.Diagnostics.Append(resourceSchemaResp.Diagnostics...)
		return
	}

	parsedAttributes, diags := fwresource.ParseImportId(ctx, req, resourceSchemaResp.Schema, r.providerConfig, idRegexes)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	for name, value := range parsedAttributes {
		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root(name), value)...)
	}
}
