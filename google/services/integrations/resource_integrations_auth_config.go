// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/integrations/AuthConfig.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package integrations

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceIntegrationsAuthConfig() *schema.Resource {
	return &schema.Resource{
		Create: resourceIntegrationsAuthConfigCreate,
		Read:   resourceIntegrationsAuthConfigRead,
		Update: resourceIntegrationsAuthConfigUpdate,
		Delete: resourceIntegrationsAuthConfigDelete,

		Importer: &schema.ResourceImporter{
			State: resourceIntegrationsAuthConfigImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The name of the auth config.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Location in which client needs to be provisioned.`,
			},
			"client_certificate": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Raw client certificate`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"encrypted_private_key": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines.`,
						},
						"ssl_certificate": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines.`,
						},
						"passphrase": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `'passphrase' should be left unset if private key is not encrypted.
Note that 'passphrase' is not the password for web server, but an extra layer of security to protected private key.`,
						},
					},
				},
			},
			"decrypted_credential": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Raw auth credentials.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"credential_type": {
							Type:             schema.TypeString,
							Required:         true,
							DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
							Description:      `Credential type associated with auth configs.`,
						},
						"auth_token": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Auth token credential.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"token": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The token for the auth type.`,
									},
									"type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Authentication type, e.g. "Basic", "Bearer", etc.`,
									},
								},
							},
							ConflictsWith: []string{"decrypted_credential.0.username_and_password", "decrypted_credential.0.oauth2_authorization_code", "decrypted_credential.0.oauth2_client_credentials", "decrypted_credential.0.jwt", "decrypted_credential.0.service_account_credentials", "decrypted_credential.0.oidc_token"},
						},
						"jwt": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `JWT credential.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"jwt_header": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Identifies which algorithm is used to generate the signature.`,
									},
									"jwt_payload": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Contains a set of claims. The JWT specification defines seven Registered Claim Names which are the standard fields commonly included in tokens. Custom claims are usually also included, depending on the purpose of the token.`,
									},
									"secret": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `User's pre-shared secret to sign the token.`,
									},
									"jwt": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The token calculated by the header, payload and signature.`,
									},
								},
							},
							ConflictsWith: []string{"decrypted_credential.0.username_and_password", "decrypted_credential.0.oauth2_authorization_code", "decrypted_credential.0.oauth2_client_credentials", "decrypted_credential.0.auth_token", "decrypted_credential.0.service_account_credentials", "decrypted_credential.0.oidc_token"},
						},
						"oauth2_authorization_code": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `OAuth2 authorization code credential.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auth_endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The auth url endpoint to send the auth code request to.`,
									},
									"client_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The client's id.`,
									},
									"client_secret": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The client's secret.`,
									},
									"scope": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `A space-delimited list of requested scope permissions.`,
									},
									"token_endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The token url endpoint to send the token request to.`,
									},
								},
							},
							ConflictsWith: []string{"decrypted_credential.0.username_and_password", "decrypted_credential.0.oauth2_client_credentials", "decrypted_credential.0.jwt", "decrypted_credential.0.auth_token", "decrypted_credential.0.service_account_credentials", "decrypted_credential.0.oidc_token"},
						},
						"oauth2_client_credentials": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `OAuth2 client credentials.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"client_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The client's ID.`,
									},
									"client_secret": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The client's secret.`,
									},
									"request_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"REQUEST_TYPE_UNSPECIFIED", "REQUEST_BODY", "QUERY_PARAMETERS", "ENCODED_HEADER", ""}),
										Description:  `Represent how to pass parameters to fetch access token Possible values: ["REQUEST_TYPE_UNSPECIFIED", "REQUEST_BODY", "QUERY_PARAMETERS", "ENCODED_HEADER"]`,
									},
									"scope": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `A space-delimited list of requested scope permissions.`,
									},
									"token_endpoint": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The token endpoint is used by the client to obtain an access token by presenting its authorization grant or refresh token.`,
									},
									"token_params": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Token parameters for the auth request.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"entries": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `A list of parameter map entries.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"key": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `Key of the map entry.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"literal_value": {
																			Type:        schema.TypeList,
																			Optional:    true,
																			Description: `Passing a literal value`,
																			MaxItems:    1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"string_value": {
																						Type:        schema.TypeString,
																						Optional:    true,
																						Description: `String.`,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"value": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `Value of the map entry.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"literal_value": {
																			Type:        schema.TypeList,
																			Optional:    true,
																			Description: `Passing a literal value`,
																			MaxItems:    1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"string_value": {
																						Type:        schema.TypeString,
																						Optional:    true,
																						Description: `String.`,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							ConflictsWith: []string{"decrypted_credential.0.username_and_password", "decrypted_credential.0.oauth2_authorization_code", "decrypted_credential.0.jwt", "decrypted_credential.0.auth_token", "decrypted_credential.0.service_account_credentials", "decrypted_credential.0.oidc_token"},
						},
						"oidc_token": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Google OIDC ID Token.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"audience": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Audience to be used when generating OIDC token. The audience claim identifies the recipients that the JWT is intended for.`,
									},
									"service_account_email": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The service account email to be used as the identity for the token.`,
									},
									"token": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `ID token obtained for the service account.`,
									},
									"token_expire_time": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The approximate time until the token retrieved is valid.

A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
									},
								},
							},
							ConflictsWith: []string{"decrypted_credential.0.username_and_password", "decrypted_credential.0.oauth2_authorization_code", "decrypted_credential.0.oauth2_client_credentials", "decrypted_credential.0.jwt", "decrypted_credential.0.auth_token", "decrypted_credential.0.service_account_credentials"},
						},
						"service_account_credentials": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Service account credential.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"scope": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `A space-delimited list of requested scope permissions.`,
									},
									"service_account": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Name of the service account that has the permission to make the request.`,
									},
								},
							},
							ConflictsWith: []string{"decrypted_credential.0.username_and_password", "decrypted_credential.0.oauth2_authorization_code", "decrypted_credential.0.oauth2_client_credentials", "decrypted_credential.0.jwt", "decrypted_credential.0.auth_token", "decrypted_credential.0.oidc_token"},
						},
						"username_and_password": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Username and password credential.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"password": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Password to be used.`,
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Username to be used.`,
									},
								},
							},
							ConflictsWith: []string{"decrypted_credential.0.oauth2_authorization_code", "decrypted_credential.0.oauth2_client_credentials", "decrypted_credential.0.jwt", "decrypted_credential.0.auth_token", "decrypted_credential.0.service_account_credentials", "decrypted_credential.0.oidc_token"},
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `A description of the auth config.`,
			},
			"expiry_notification_duration": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `User can define the time to receive notification after which the auth config becomes invalid. Support up to 30 days. Support granularity in hours.

A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"override_valid_time": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `User provided expiry time to override. For the example of Salesforce, username/password credentials can be valid for 6 months depending on the instance settings.

A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
			},
			"visibility": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"PRIVATE", "CLIENT_VISIBLE", ""}),
				Description:  `The visibility of the auth config. Possible values: ["PRIVATE", "CLIENT_VISIBLE"]`,
			},
			"certificate_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Certificate id for client certificate.`,
			},
			"create_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The timestamp when the auth config is created.

A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
			},
			"creator_email": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The creator's email address. Generated based on the End User Credentials/LOAS role of the user making the call.`,
			},
			"credential_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Credential type of the encrypted credential.`,
			},
			"encrypted_credential": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Auth credential encrypted by Cloud KMS. Can be decrypted as Credential with proper KMS key.

A base64-encoded string.`,
			},
			"last_modifier_email": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The last modifier's email address. Generated based on the End User Credentials/LOAS role of the user making the call.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Resource name of the auth config.`,
			},
			"reason": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The reason / details of the current status.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The status of the auth config.`,
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The timestamp when the auth config is modified.

A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
			},
			"valid_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The time until the auth config is valid. Empty or max value is considered the auth config won't expire.

A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceIntegrationsAuthConfigCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandIntegrationsAuthConfigDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	descriptionProp, err := expandIntegrationsAuthConfigDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	visibilityProp, err := expandIntegrationsAuthConfigVisibility(d.Get("visibility"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("visibility"); !tpgresource.IsEmptyValue(reflect.ValueOf(visibilityProp)) && (ok || !reflect.DeepEqual(v, visibilityProp)) {
		obj["visibility"] = visibilityProp
	}
	expiryNotificationDurationProp, err := expandIntegrationsAuthConfigExpiryNotificationDuration(d.Get("expiry_notification_duration"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("expiry_notification_duration"); !tpgresource.IsEmptyValue(reflect.ValueOf(expiryNotificationDurationProp)) && (ok || !reflect.DeepEqual(v, expiryNotificationDurationProp)) {
		obj["expiryNotificationDuration"] = expiryNotificationDurationProp
	}
	overrideValidTimeProp, err := expandIntegrationsAuthConfigOverrideValidTime(d.Get("override_valid_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("override_valid_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(overrideValidTimeProp)) && (ok || !reflect.DeepEqual(v, overrideValidTimeProp)) {
		obj["overrideValidTime"] = overrideValidTimeProp
	}
	decryptedCredentialProp, err := expandIntegrationsAuthConfigDecryptedCredential(d.Get("decrypted_credential"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("decrypted_credential"); !tpgresource.IsEmptyValue(reflect.ValueOf(decryptedCredentialProp)) && (ok || !reflect.DeepEqual(v, decryptedCredentialProp)) {
		obj["decryptedCredential"] = decryptedCredentialProp
	}
	client_certificateProp, err := expandIntegrationsAuthConfigClientCertificate(d.Get("client_certificate"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client_certificate"); !tpgresource.IsEmptyValue(reflect.ValueOf(client_certificateProp)) && (ok || !reflect.DeepEqual(v, client_certificateProp)) {
		obj["client_certificate"] = client_certificateProp
	}

	lockName, err := tpgresource.ReplaceVars(d, config, "{{name}}")
	if err != nil {
		return err
	}
	transport_tpg.MutexStore.Lock(lockName)
	defer transport_tpg.MutexStore.Unlock(lockName)

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationsBasePath}}projects/{{project}}/locations/{{location}}/authConfigs")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new AuthConfig: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for AuthConfig: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// Move client certificate to url param from request body
	if cc, ok := obj["client_certificate"]; ok {
		ccm := cc.(map[string]any)

		params := map[string]string{
			"clientCertificate.sslCertificate":      ccm["ssl_certificate"].(string),
			"clientCertificate.encryptedPrivateKey": ccm["encrypted_private_key"].(string),
		}
		if pp, ok := ccm["passphrase"]; ok {
			params["clientCertificate.passphrase"] = pp.(string)
		}
		url, err = transport_tpg.AddQueryParams(url, params)
		if err != nil {
			return err
		}
		delete(obj, "client_certificate")
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating AuthConfig: %s", err)
	}
	if err := d.Set("name", flattenIntegrationsAuthConfigName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// `name` is autogenerated from the api so needs to be set post-create
	name, ok := res["name"]
	if !ok {
		respBody, ok := res["response"]
		if !ok {
			return fmt.Errorf("Create response didn't contain critical fields. Create may not have succeeded.")
		}

		name, ok = respBody.(map[string]interface{})["name"]
		if !ok {
			return fmt.Errorf("Create response didn't contain critical fields. Create may not have succeeded.")
		}
	}
	if err := d.Set("name", name.(string)); err != nil {
		return fmt.Errorf("Error setting name: %s", err)
	}
	d.SetId(name.(string))

	log.Printf("[DEBUG] Finished creating AuthConfig %q: %#v", d.Id(), res)

	return resourceIntegrationsAuthConfigRead(d, meta)
}

func resourceIntegrationsAuthConfigRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationsBasePath}}{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for AuthConfig: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("IntegrationsAuthConfig %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}

	if err := d.Set("name", flattenIntegrationsAuthConfigName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("display_name", flattenIntegrationsAuthConfigDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("description", flattenIntegrationsAuthConfigDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("certificate_id", flattenIntegrationsAuthConfigCertificateId(res["certificateId"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("credential_type", flattenIntegrationsAuthConfigCredentialType(res["credentialType"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("creator_email", flattenIntegrationsAuthConfigCreatorEmail(res["creatorEmail"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("create_time", flattenIntegrationsAuthConfigCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("last_modifier_email", flattenIntegrationsAuthConfigLastModifierEmail(res["lastModifierEmail"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("update_time", flattenIntegrationsAuthConfigUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("visibility", flattenIntegrationsAuthConfigVisibility(res["visibility"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("state", flattenIntegrationsAuthConfigState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("reason", flattenIntegrationsAuthConfigReason(res["reason"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("expiry_notification_duration", flattenIntegrationsAuthConfigExpiryNotificationDuration(res["expiryNotificationDuration"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("valid_time", flattenIntegrationsAuthConfigValidTime(res["validTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("override_valid_time", flattenIntegrationsAuthConfigOverrideValidTime(res["overrideValidTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("encrypted_credential", flattenIntegrationsAuthConfigEncryptedCredential(res["encryptedCredential"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}
	if err := d.Set("decrypted_credential", flattenIntegrationsAuthConfigDecryptedCredential(res["decryptedCredential"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthConfig: %s", err)
	}

	return nil
}

func resourceIntegrationsAuthConfigUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for AuthConfig: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	displayNameProp, err := expandIntegrationsAuthConfigDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	descriptionProp, err := expandIntegrationsAuthConfigDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	visibilityProp, err := expandIntegrationsAuthConfigVisibility(d.Get("visibility"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("visibility"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, visibilityProp)) {
		obj["visibility"] = visibilityProp
	}
	expiryNotificationDurationProp, err := expandIntegrationsAuthConfigExpiryNotificationDuration(d.Get("expiry_notification_duration"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("expiry_notification_duration"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, expiryNotificationDurationProp)) {
		obj["expiryNotificationDuration"] = expiryNotificationDurationProp
	}
	overrideValidTimeProp, err := expandIntegrationsAuthConfigOverrideValidTime(d.Get("override_valid_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("override_valid_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, overrideValidTimeProp)) {
		obj["overrideValidTime"] = overrideValidTimeProp
	}
	decryptedCredentialProp, err := expandIntegrationsAuthConfigDecryptedCredential(d.Get("decrypted_credential"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("decrypted_credential"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, decryptedCredentialProp)) {
		obj["decryptedCredential"] = decryptedCredentialProp
	}
	client_certificateProp, err := expandIntegrationsAuthConfigClientCertificate(d.Get("client_certificate"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client_certificate"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, client_certificateProp)) {
		obj["client_certificate"] = client_certificateProp
	}

	lockName, err := tpgresource.ReplaceVars(d, config, "{{name}}")
	if err != nil {
		return err
	}
	transport_tpg.MutexStore.Lock(lockName)
	defer transport_tpg.MutexStore.Unlock(lockName)

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationsBasePath}}{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating AuthConfig %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	params := map[string]string{}

	// Move client certificate to url param from request body
	if cc, ok := obj["client_certificate"]; ok {
		ccm := cc.(map[string]any)

		params["clientCertificate.sslCertificate"] = ccm["ssl_certificate"].(string)
		params["clientCertificate.encryptedPrivateKey"] = ccm["encrypted_private_key"].(string)
		if pp, ok := ccm["passphrase"]; ok {
			params["clientCertificate.passphrase"] = pp.(string)
		}
		delete(obj, "client_certificate")
	}

	// By default allow all fields to be updated via terraform
	params["updateMask"] = "*"

	url, err = transport_tpg.AddQueryParams(url, params)
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "PATCH",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutUpdate),
		Headers:   headers,
	})

	if err != nil {
		return fmt.Errorf("Error updating AuthConfig %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating AuthConfig %q: %#v", d.Id(), res)
	}

	return resourceIntegrationsAuthConfigRead(d, meta)
}

func resourceIntegrationsAuthConfigDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for AuthConfig: %s", err)
	}
	billingProject = project

	lockName, err := tpgresource.ReplaceVars(d, config, "{{name}}")
	if err != nil {
		return err
	}
	transport_tpg.MutexStore.Lock(lockName)
	defer transport_tpg.MutexStore.Unlock(lockName)

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationsBasePath}}{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting AuthConfig %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "AuthConfig")
	}

	log.Printf("[DEBUG] Finished deleting AuthConfig %q: %#v", d.Id(), res)
	return nil
}

func resourceIntegrationsAuthConfigImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {

	config := meta.(*transport_tpg.Config)

	// current import_formats can't import fields with forward slashes in their value
	if err := tpgresource.ParseImportId([]string{"(?P<project>[^ ]+) (?P<name>[^ ]+)", "(?P<name>[^ ]+)"}, d, config); err != nil {
		return nil, err
	}

	return []*schema.ResourceData{d}, nil
}

func flattenIntegrationsAuthConfigName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigCertificateId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigCredentialType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigCreatorEmail(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigLastModifierEmail(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigVisibility(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigExpiryNotificationDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigValidTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigOverrideValidTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigEncryptedCredential(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredential(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["credential_type"] =
		flattenIntegrationsAuthConfigDecryptedCredentialCredentialType(original["credentialType"], d, config)
	transformed["username_and_password"] =
		flattenIntegrationsAuthConfigDecryptedCredentialUsernameAndPassword(original["usernameAndPassword"], d, config)
	transformed["oauth2_authorization_code"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCode(original["oauth2AuthorizationCode"], d, config)
	transformed["oauth2_client_credentials"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentials(original["oauth2ClientCredentials"], d, config)
	transformed["jwt"] =
		flattenIntegrationsAuthConfigDecryptedCredentialJwt(original["jwt"], d, config)
	transformed["auth_token"] =
		flattenIntegrationsAuthConfigDecryptedCredentialAuthToken(original["authToken"], d, config)
	transformed["service_account_credentials"] =
		flattenIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentials(original["serviceAccountCredentials"], d, config)
	transformed["oidc_token"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOidcToken(original["oidcToken"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialCredentialType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.ConvertSelfLinkToV1(v.(string))
}

func flattenIntegrationsAuthConfigDecryptedCredentialUsernameAndPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["username"] =
		flattenIntegrationsAuthConfigDecryptedCredentialUsernameAndPasswordUsername(original["username"], d, config)
	transformed["password"] =
		flattenIntegrationsAuthConfigDecryptedCredentialUsernameAndPasswordPassword(original["password"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialUsernameAndPasswordUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialUsernameAndPasswordPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["client_id"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeClientId(original["clientId"], d, config)
	transformed["client_secret"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeClientSecret(original["clientSecret"], d, config)
	transformed["scope"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeScope(original["scope"], d, config)
	transformed["auth_endpoint"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeAuthEndpoint(original["authEndpoint"], d, config)
	transformed["token_endpoint"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeTokenEndpoint(original["tokenEndpoint"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeClientId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeClientSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeAuthEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeTokenEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentials(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["client_id"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsClientId(original["clientId"], d, config)
	transformed["client_secret"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsClientSecret(original["clientSecret"], d, config)
	transformed["token_endpoint"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenEndpoint(original["tokenEndpoint"], d, config)
	transformed["scope"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsScope(original["scope"], d, config)
	transformed["token_params"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParams(original["tokenParams"], d, config)
	transformed["request_type"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsRequestType(original["requestType"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsClientId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsClientSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["entries"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntries(original["entries"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntries(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":   flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKey(original["key"], d, config),
			"value": flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["literal_value"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKeyLiteralValue(original["literalValue"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKeyLiteralValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["string_value"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKeyLiteralValueStringValue(original["stringValue"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKeyLiteralValueStringValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["literal_value"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValueLiteralValue(original["literalValue"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValueLiteralValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["string_value"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValueLiteralValueStringValue(original["stringValue"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValueLiteralValueStringValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsRequestType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialJwt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["jwt_header"] =
		flattenIntegrationsAuthConfigDecryptedCredentialJwtJwtHeader(original["jwtHeader"], d, config)
	transformed["jwt_payload"] =
		flattenIntegrationsAuthConfigDecryptedCredentialJwtJwtPayload(original["jwtPayload"], d, config)
	transformed["secret"] =
		flattenIntegrationsAuthConfigDecryptedCredentialJwtSecret(original["secret"], d, config)
	transformed["jwt"] =
		flattenIntegrationsAuthConfigDecryptedCredentialJwtJwt(original["jwt"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialJwtJwtHeader(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialJwtJwtPayload(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialJwtSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialJwtJwt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialAuthToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["type"] =
		flattenIntegrationsAuthConfigDecryptedCredentialAuthTokenType(original["type"], d, config)
	transformed["token"] =
		flattenIntegrationsAuthConfigDecryptedCredentialAuthTokenToken(original["token"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialAuthTokenType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialAuthTokenToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentials(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_account"] =
		flattenIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentialsServiceAccount(original["serviceAccount"], d, config)
	transformed["scope"] =
		flattenIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentialsScope(original["scope"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentialsServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentialsScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOidcToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_account_email"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOidcTokenServiceAccountEmail(original["serviceAccountEmail"], d, config)
	transformed["audience"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOidcTokenAudience(original["audience"], d, config)
	transformed["token"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOidcTokenToken(original["token"], d, config)
	transformed["token_expire_time"] =
		flattenIntegrationsAuthConfigDecryptedCredentialOidcTokenTokenExpireTime(original["tokenExpireTime"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationsAuthConfigDecryptedCredentialOidcTokenServiceAccountEmail(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOidcTokenAudience(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOidcTokenToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationsAuthConfigDecryptedCredentialOidcTokenTokenExpireTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandIntegrationsAuthConfigDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigVisibility(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigExpiryNotificationDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigOverrideValidTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredential(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCredentialType, err := expandIntegrationsAuthConfigDecryptedCredentialCredentialType(original["credential_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCredentialType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["credentialType"] = transformedCredentialType
	}

	transformedUsernameAndPassword, err := expandIntegrationsAuthConfigDecryptedCredentialUsernameAndPassword(original["username_and_password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsernameAndPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["usernameAndPassword"] = transformedUsernameAndPassword
	}

	transformedOauth2AuthorizationCode, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCode(original["oauth2_authorization_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauth2AuthorizationCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauth2AuthorizationCode"] = transformedOauth2AuthorizationCode
	}

	transformedOauth2ClientCredentials, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentials(original["oauth2_client_credentials"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauth2ClientCredentials); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauth2ClientCredentials"] = transformedOauth2ClientCredentials
	}

	transformedJwt, err := expandIntegrationsAuthConfigDecryptedCredentialJwt(original["jwt"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedJwt); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["jwt"] = transformedJwt
	}

	transformedAuthToken, err := expandIntegrationsAuthConfigDecryptedCredentialAuthToken(original["auth_token"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthToken); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authToken"] = transformedAuthToken
	}

	transformedServiceAccountCredentials, err := expandIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentials(original["service_account_credentials"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccountCredentials); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccountCredentials"] = transformedServiceAccountCredentials
	}

	transformedOidcToken, err := expandIntegrationsAuthConfigDecryptedCredentialOidcToken(original["oidc_token"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOidcToken); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oidcToken"] = transformedOidcToken
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialCredentialType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialUsernameAndPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUsername, err := expandIntegrationsAuthConfigDecryptedCredentialUsernameAndPasswordUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	transformedPassword, err := expandIntegrationsAuthConfigDecryptedCredentialUsernameAndPasswordPassword(original["password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["password"] = transformedPassword
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialUsernameAndPasswordUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialUsernameAndPasswordPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedClientId, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeClientId(original["client_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientId"] = transformedClientId
	}

	transformedClientSecret, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeClientSecret(original["client_secret"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientSecret"] = transformedClientSecret
	}

	transformedScope, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeScope(original["scope"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScope); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scope"] = transformedScope
	}

	transformedAuthEndpoint, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeAuthEndpoint(original["auth_endpoint"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthEndpoint); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authEndpoint"] = transformedAuthEndpoint
	}

	transformedTokenEndpoint, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeTokenEndpoint(original["token_endpoint"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTokenEndpoint); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tokenEndpoint"] = transformedTokenEndpoint
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeClientId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeClientSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeScope(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeAuthEndpoint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2AuthorizationCodeTokenEndpoint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentials(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedClientId, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsClientId(original["client_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientId"] = transformedClientId
	}

	transformedClientSecret, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsClientSecret(original["client_secret"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientSecret"] = transformedClientSecret
	}

	transformedTokenEndpoint, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenEndpoint(original["token_endpoint"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTokenEndpoint); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tokenEndpoint"] = transformedTokenEndpoint
	}

	transformedScope, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsScope(original["scope"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScope); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scope"] = transformedScope
	}

	transformedTokenParams, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParams(original["token_params"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTokenParams); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tokenParams"] = transformedTokenParams
	}

	transformedRequestType, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsRequestType(original["request_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRequestType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["requestType"] = transformedRequestType
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsClientId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsClientSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenEndpoint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsScope(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEntries, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntries(original["entries"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEntries); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["entries"] = transformedEntries
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntries(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedValue, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLiteralValue, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKeyLiteralValue(original["literal_value"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLiteralValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["literalValue"] = transformedLiteralValue
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKeyLiteralValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedStringValue, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKeyLiteralValueStringValue(original["string_value"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStringValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["stringValue"] = transformedStringValue
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesKeyLiteralValueStringValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLiteralValue, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValueLiteralValue(original["literal_value"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLiteralValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["literalValue"] = transformedLiteralValue
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValueLiteralValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedStringValue, err := expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValueLiteralValueStringValue(original["string_value"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStringValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["stringValue"] = transformedStringValue
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsTokenParamsEntriesValueLiteralValueStringValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOauth2ClientCredentialsRequestType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialJwt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedJwtHeader, err := expandIntegrationsAuthConfigDecryptedCredentialJwtJwtHeader(original["jwt_header"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedJwtHeader); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["jwtHeader"] = transformedJwtHeader
	}

	transformedJwtPayload, err := expandIntegrationsAuthConfigDecryptedCredentialJwtJwtPayload(original["jwt_payload"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedJwtPayload); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["jwtPayload"] = transformedJwtPayload
	}

	transformedSecret, err := expandIntegrationsAuthConfigDecryptedCredentialJwtSecret(original["secret"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secret"] = transformedSecret
	}

	transformedJwt, err := expandIntegrationsAuthConfigDecryptedCredentialJwtJwt(original["jwt"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedJwt); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["jwt"] = transformedJwt
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialJwtJwtHeader(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialJwtJwtPayload(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialJwtSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialJwtJwt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialAuthToken(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedType, err := expandIntegrationsAuthConfigDecryptedCredentialAuthTokenType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedToken, err := expandIntegrationsAuthConfigDecryptedCredentialAuthTokenToken(original["token"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedToken); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["token"] = transformedToken
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialAuthTokenType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialAuthTokenToken(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentials(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServiceAccount, err := expandIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentialsServiceAccount(original["service_account"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccount"] = transformedServiceAccount
	}

	transformedScope, err := expandIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentialsScope(original["scope"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScope); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scope"] = transformedScope
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentialsServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialServiceAccountCredentialsScope(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOidcToken(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServiceAccountEmail, err := expandIntegrationsAuthConfigDecryptedCredentialOidcTokenServiceAccountEmail(original["service_account_email"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccountEmail); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccountEmail"] = transformedServiceAccountEmail
	}

	transformedAudience, err := expandIntegrationsAuthConfigDecryptedCredentialOidcTokenAudience(original["audience"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAudience); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["audience"] = transformedAudience
	}

	transformedToken, err := expandIntegrationsAuthConfigDecryptedCredentialOidcTokenToken(original["token"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedToken); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["token"] = transformedToken
	}

	transformedTokenExpireTime, err := expandIntegrationsAuthConfigDecryptedCredentialOidcTokenTokenExpireTime(original["token_expire_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTokenExpireTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tokenExpireTime"] = transformedTokenExpireTime
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOidcTokenServiceAccountEmail(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOidcTokenAudience(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOidcTokenToken(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigDecryptedCredentialOidcTokenTokenExpireTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigClientCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSslCertificate, err := expandIntegrationsAuthConfigClientCertificateSslCertificate(original["ssl_certificate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSslCertificate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ssl_certificate"] = transformedSslCertificate
	}

	transformedEncryptedPrivateKey, err := expandIntegrationsAuthConfigClientCertificateEncryptedPrivateKey(original["encrypted_private_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEncryptedPrivateKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["encrypted_private_key"] = transformedEncryptedPrivateKey
	}

	transformedPassphrase, err := expandIntegrationsAuthConfigClientCertificatePassphrase(original["passphrase"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassphrase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["passphrase"] = transformedPassphrase
	}

	return transformed, nil
}

func expandIntegrationsAuthConfigClientCertificateSslCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigClientCertificateEncryptedPrivateKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationsAuthConfigClientCertificatePassphrase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
