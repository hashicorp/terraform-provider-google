// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/eventarc/GoogleApiSource.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package eventarc

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceEventarcGoogleApiSource() *schema.Resource {
	return &schema.Resource{
		Create: resourceEventarcGoogleApiSourceCreate,
		Read:   resourceEventarcGoogleApiSourceRead,
		Update: resourceEventarcGoogleApiSourceUpdate,
		Delete: resourceEventarcGoogleApiSourceDelete,

		Importer: &schema.ResourceImporter{
			State: resourceEventarcGoogleApiSourceImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.SetAnnotationsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"destination": {
				Type:     schema.TypeString,
				Required: true,
				Description: `Destination is the message bus that the GoogleApiSource is delivering to.
It must be point to the full resource name of a MessageBus. Format:
"projects/{PROJECT_ID}/locations/{region}/messagesBuses/{MESSAGE_BUS_ID)`,
			},
			"google_api_source_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The user-provided ID to be assigned to the GoogleApiSource. It should match
the format '^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$'.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Resource annotations.

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"crypto_key_name": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Resource name of a KMS crypto key (managed by the user) used to
encrypt/decrypt their event data.

It must match the pattern
'projects/*/locations/*/keyRings/*/cryptoKeys/*'.`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Resource display name.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Resource labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"logging_config": {
				Type:     schema.TypeList,
				Computed: true,
				Optional: true,
				Description: `The configuration for Platform Telemetry logging for Eventarc Advanced
resources.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"log_severity": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"NONE", "DEBUG", "INFO", "NOTICE", "WARNING", "ERROR", "CRITICAL", "ALERT", "EMERGENCY", ""}),
							Description: `The minimum severity of logs that will be sent to Stackdriver/Platform
Telemetry. Logs at severitiy â‰¥ this value will be sent, unless it is NONE. Possible values: ["NONE", "DEBUG", "INFO", "NOTICE", "WARNING", "ERROR", "CRITICAL", "ALERT", "EMERGENCY"]`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The creation time.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `This checksum is computed by the server based on the value of other
fields, and might be sent only on update and delete requests to ensure that
the client has an up-to-date value before proceeding.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Resource name of the form
projects/{project}/locations/{location}/googleApiSources/{google_api_source}`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Server assigned unique identifier for the channel. The value is a UUID4
string and guaranteed to remain unchanged until the resource is deleted.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The last-modified time.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceEventarcGoogleApiSourceCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	cryptoKeyNameProp, err := expandEventarcGoogleApiSourceCryptoKeyName(d.Get("crypto_key_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("crypto_key_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(cryptoKeyNameProp)) && (ok || !reflect.DeepEqual(v, cryptoKeyNameProp)) {
		obj["cryptoKeyName"] = cryptoKeyNameProp
	}
	displayNameProp, err := expandEventarcGoogleApiSourceDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	destinationProp, err := expandEventarcGoogleApiSourceDestination(d.Get("destination"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("destination"); !tpgresource.IsEmptyValue(reflect.ValueOf(destinationProp)) && (ok || !reflect.DeepEqual(v, destinationProp)) {
		obj["destination"] = destinationProp
	}
	loggingConfigProp, err := expandEventarcGoogleApiSourceLoggingConfig(d.Get("logging_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("logging_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(loggingConfigProp)) && (ok || !reflect.DeepEqual(v, loggingConfigProp)) {
		obj["loggingConfig"] = loggingConfigProp
	}
	labelsProp, err := expandEventarcGoogleApiSourceEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	annotationsProp, err := expandEventarcGoogleApiSourceEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(annotationsProp)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{EventarcBasePath}}projects/{{project}}/locations/{{location}}/googleApiSources?googleApiSourceId={{google_api_source_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new GoogleApiSource: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for GoogleApiSource: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating GoogleApiSource: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/googleApiSources/{{google_api_source_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = EventarcOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating GoogleApiSource", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create GoogleApiSource: %s", err)
	}

	if err := d.Set("name", flattenEventarcGoogleApiSourceName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/googleApiSources/{{google_api_source_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating GoogleApiSource %q: %#v", d.Id(), res)

	return resourceEventarcGoogleApiSourceRead(d, meta)
}

func resourceEventarcGoogleApiSourceRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{EventarcBasePath}}projects/{{project}}/locations/{{location}}/googleApiSources/{{google_api_source_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for GoogleApiSource: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("EventarcGoogleApiSource %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}

	if err := d.Set("update_time", flattenEventarcGoogleApiSourceUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("labels", flattenEventarcGoogleApiSourceLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("crypto_key_name", flattenEventarcGoogleApiSourceCryptoKeyName(res["cryptoKeyName"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("etag", flattenEventarcGoogleApiSourceEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("annotations", flattenEventarcGoogleApiSourceAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("display_name", flattenEventarcGoogleApiSourceDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("destination", flattenEventarcGoogleApiSourceDestination(res["destination"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("logging_config", flattenEventarcGoogleApiSourceLoggingConfig(res["loggingConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("name", flattenEventarcGoogleApiSourceName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("uid", flattenEventarcGoogleApiSourceUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("create_time", flattenEventarcGoogleApiSourceCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("terraform_labels", flattenEventarcGoogleApiSourceTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("effective_labels", flattenEventarcGoogleApiSourceEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}
	if err := d.Set("effective_annotations", flattenEventarcGoogleApiSourceEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading GoogleApiSource: %s", err)
	}

	return nil
}

func resourceEventarcGoogleApiSourceUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for GoogleApiSource: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	cryptoKeyNameProp, err := expandEventarcGoogleApiSourceCryptoKeyName(d.Get("crypto_key_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("crypto_key_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, cryptoKeyNameProp)) {
		obj["cryptoKeyName"] = cryptoKeyNameProp
	}
	displayNameProp, err := expandEventarcGoogleApiSourceDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	destinationProp, err := expandEventarcGoogleApiSourceDestination(d.Get("destination"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("destination"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, destinationProp)) {
		obj["destination"] = destinationProp
	}
	loggingConfigProp, err := expandEventarcGoogleApiSourceLoggingConfig(d.Get("logging_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("logging_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, loggingConfigProp)) {
		obj["loggingConfig"] = loggingConfigProp
	}
	labelsProp, err := expandEventarcGoogleApiSourceEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	annotationsProp, err := expandEventarcGoogleApiSourceEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{EventarcBasePath}}projects/{{project}}/locations/{{location}}/googleApiSources/{{google_api_source_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating GoogleApiSource %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("crypto_key_name") {
		updateMask = append(updateMask, "cryptoKeyName")
	}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("destination") {
		updateMask = append(updateMask, "destination")
	}

	if d.HasChange("logging_config") {
		updateMask = append(updateMask, "loggingConfig")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}

	if d.HasChange("effective_annotations") {
		updateMask = append(updateMask, "annotations")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating GoogleApiSource %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating GoogleApiSource %q: %#v", d.Id(), res)
		}

		err = EventarcOperationWaitTime(
			config, res, project, "Updating GoogleApiSource", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceEventarcGoogleApiSourceRead(d, meta)
}

func resourceEventarcGoogleApiSourceDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for GoogleApiSource: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{EventarcBasePath}}projects/{{project}}/locations/{{location}}/googleApiSources/{{google_api_source_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting GoogleApiSource %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "GoogleApiSource")
	}

	err = EventarcOperationWaitTime(
		config, res, project, "Deleting GoogleApiSource", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting GoogleApiSource %q: %#v", d.Id(), res)
	return nil
}

func resourceEventarcGoogleApiSourceImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/googleApiSources/(?P<google_api_source_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<google_api_source_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<google_api_source_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/googleApiSources/{{google_api_source_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenEventarcGoogleApiSourceUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcGoogleApiSourceLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenEventarcGoogleApiSourceCryptoKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcGoogleApiSourceEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcGoogleApiSourceAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenEventarcGoogleApiSourceDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcGoogleApiSourceDestination(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcGoogleApiSourceLoggingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["log_severity"] =
		flattenEventarcGoogleApiSourceLoggingConfigLogSeverity(original["logSeverity"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcGoogleApiSourceLoggingConfigLogSeverity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcGoogleApiSourceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcGoogleApiSourceUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcGoogleApiSourceCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcGoogleApiSourceTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenEventarcGoogleApiSourceEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcGoogleApiSourceEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandEventarcGoogleApiSourceCryptoKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcGoogleApiSourceDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcGoogleApiSourceDestination(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcGoogleApiSourceLoggingConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLogSeverity, err := expandEventarcGoogleApiSourceLoggingConfigLogSeverity(original["log_severity"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLogSeverity); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["logSeverity"] = transformedLogSeverity
	}

	return transformed, nil
}

func expandEventarcGoogleApiSourceLoggingConfigLogSeverity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcGoogleApiSourceEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandEventarcGoogleApiSourceEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
