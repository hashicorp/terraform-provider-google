// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/eventarc/Pipeline.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package eventarc

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceEventarcPipeline() *schema.Resource {
	return &schema.Resource{
		Create: resourceEventarcPipelineCreate,
		Read:   resourceEventarcPipelineRead,
		Update: resourceEventarcPipelineUpdate,
		Delete: resourceEventarcPipelineDelete,

		Importer: &schema.ResourceImporter{
			State: resourceEventarcPipelineImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"destinations": {
				Type:     schema.TypeList,
				Required: true,
				Description: `List of destinations to which messages will be forwarded. Currently,
exactly one destination is supported per Pipeline.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"authentication_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Represents a config used to authenticate message requests.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"google_oidc": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Represents a config used to authenticate with a Google OIDC token using
a GCP service account. Use this authentication method to invoke your
Cloud Run and Cloud Functions destinations or HTTP endpoints that
support Google OIDC.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"service_account": {
													Type:     schema.TypeString,
													Required: true,
													Description: `Service account email used to generate the OIDC Token.
The principal who calls this API must have
iam.serviceAccounts.actAs permission in the service account. See
https://cloud.google.com/iam/docs/understanding-service-accounts
for more information. Eventarc service agents must have
roles/roles/iam.serviceAccountTokenCreator role to allow the
Pipeline to create OpenID tokens for authenticated requests.`,
												},
												"audience": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `Audience to be used to generate the OIDC Token. The audience claim
identifies the recipient that the JWT is intended for. If
unspecified, the destination URI will be used.`,
												},
											},
										},
									},
									"oauth_token": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Contains information needed for generating an
[OAuth token](https://developers.google.com/identity/protocols/OAuth2).
This type of authorization should generally only be used when calling
Google APIs hosted on *.googleapis.com.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"service_account": {
													Type:     schema.TypeString,
													Required: true,
													Description: `Service account email used to generate the [OAuth
token](https://developers.google.com/identity/protocols/OAuth2).
The principal who calls this API must have
iam.serviceAccounts.actAs permission in the service account. See
https://cloud.google.com/iam/docs/understanding-service-accounts
for more information. Eventarc service agents must have
roles/roles/iam.serviceAccountTokenCreator role to allow Pipeline
to create OAuth2 tokens for authenticated requests.`,
												},
												"scope": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `OAuth scope to be used for generating OAuth access token. If not
specified, "https://www.googleapis.com/auth/cloud-platform" will be
used.`,
												},
											},
										},
									},
								},
							},
						},
						"http_endpoint": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Represents a HTTP endpoint destination.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"uri": {
										Type:     schema.TypeString,
										Required: true,
										Description: `The URI of the HTTP enpdoint.

The value must be a RFC2396 URI string.
Examples: 'https://svc.us-central1.p.local:8080/route'.
Only the HTTPS protocol is supported.`,
									},
									"message_binding_template": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The CEL expression used to modify how the destination-bound HTTP
request is constructed.

If a binding expression is not specified here, the message
is treated as a CloudEvent and is mapped to the HTTP request according
to the CloudEvent HTTP Protocol Binding Binary Content Mode
(https://github.com/cloudevents/spec/blob/main/cloudevents/bindings/http-protocol-binding.md#31-binary-content-mode).
In this representation, all fields except the 'data' and
'datacontenttype' field on the message are mapped to HTTP request
headers with a prefix of 'ce-'.

To construct the HTTP request payload and the value of the content-type
HTTP header, the payload format is defined as follows:
1) Use the output_payload_format_type on the Pipeline.Destination if it
is set, else:
2) Use the input_payload_format_type on the Pipeline if it is set,
else:
3) Treat the payload as opaque binary data.

The 'data' field of the message is converted to the payload format or
left as-is for case 3) and then attached as the payload of the HTTP
request. The 'content-type' header on the HTTP request is set to the
payload format type or left empty for case 3). However, if a mediation
has updated the 'datacontenttype' field on the message so that it is
not the same as the payload format type but it is still a prefix of the
payload format type, then the 'content-type' header on the HTTP request
is set to this 'datacontenttype' value. For example, if the
'datacontenttype' is "application/json" and the payload format type is
"application/json; charset=utf-8", then the 'content-type' header on
the HTTP request is set to "application/json; charset=utf-8".

If a non-empty binding expression is specified then this expression is
used to modify the default CloudEvent HTTP Protocol Binding Binary
Content representation.
The result of the CEL expression must be a map of key/value pairs
which is used as follows:
- If a map named 'headers' exists on the result of the expression,
then its key/value pairs are directly mapped to the HTTP request
headers. The headers values are constructed from the corresponding
value type's canonical representation. If the 'headers' field doesn't
exist then the resulting HTTP request will be the headers of the
CloudEvent HTTP Binding Binary Content Mode representation of the final
message. Note: If the specified binding expression, has updated the
'datacontenttype' field on the message so that it is not the same as
the payload format type but it is still a prefix of the payload format
type, then the 'content-type' header in the 'headers' map is set to
this 'datacontenttype' value.
- If a field named 'body' exists on the result of the expression then
its value is directly mapped to the body of the request. If the value
of the 'body' field is of type bytes or string then it is used for
the HTTP request body as-is, with no conversion. If the body field is
of any other type then it is converted to a JSON string. If the body
field does not exist then the resulting payload of the HTTP request
will be data value of the CloudEvent HTTP Binding Binary Content Mode
representation of the final message as described earlier.
- Any other fields in the resulting expression will be ignored.

The CEL expression may access the incoming CloudEvent message in its
definition, as follows:
- The 'data' field of the incoming CloudEvent message can be accessed
using the 'message.data' value. Subfields of 'message.data' may also be
accessed if an input_payload_format has been specified on the Pipeline.
- Each attribute of the incoming CloudEvent message can be accessed
using the 'message.' value, where  is replaced with the
name of the attribute.
- Existing headers can be accessed in the CEL expression using the
'headers' variable. The 'headers' variable defines a map of key/value
pairs corresponding to the HTTP headers of the CloudEvent HTTP Binding
Binary Content Mode representation of the final message as described
earlier. For example, the following CEL expression can be used to
construct an HTTP request by adding an additional header to the HTTP
headers of the CloudEvent HTTP Binding Binary Content Mode
representation of the final message and by overwriting the body of the
request:

'''
{
"headers": headers.merge({"new-header-key": "new-header-value"}),
"body": "new-body"
}
'''
- The default binding for the message payload can be accessed using the
'body' variable. It conatins a string representation of the message
payload in the format specified by the 'output_payload_format' field.
If the 'input_payload_format' field is not set, the 'body'
variable contains the same message payload bytes that were published.

Additionally, the following CEL extension functions are provided for
use in this CEL expression:
- toBase64Url:
map.toBase64Url() -> string
- Converts a CelValue to a base64url encoded string
- toJsonString: map.toJsonString() -> string
- Converts a CelValue to a JSON string
- merge:
map1.merge(map2) -> map3
- Merges the passed CEL map with the existing CEL map the
function is applied to.
- If the same key exists in both maps, if the key's value is type
map both maps are merged else the value from the passed map is
used.
- denormalize:
map.denormalize() -> map
- Denormalizes a CEL map such that every value of type map or key
in the map is expanded to return a single level map.
- The resulting keys are "." separated indices of the map keys.
- For example:
{
"a": 1,
"b": {
"c": 2,
"d": 3
}
"e": [4, 5]
}
.denormalize()
-> {
"a": 1,
"b.c": 2,
"b.d": 3,
"e.0": 4,
"e.1": 5
}
- setField:
map.setField(key, value) -> message
- Sets the field of the message with the given key to the
given value.
- If the field is not present it will be added.
- If the field is present it will be overwritten.
- The key can be a dot separated path to set a field in a nested
message.
- Key must be of type string.
- Value may be any valid type.
- removeFields:
map.removeFields([key1, key2, ...]) -> message
- Removes the fields of the map with the given keys.
- The keys can be a dot separated path to remove a field in a
nested message.
- If a key is not found it will be ignored.
- Keys must be of type string.
- toMap:
[map1, map2, ...].toMap() -> map
- Converts a CEL list of CEL maps to a single CEL map
- toCloudEventJsonWithPayloadFormat:
message.toCloudEventJsonWithPayloadFormat() -> map
- Converts a message to the corresponding structure of JSON
format for CloudEvents.
- It converts 'data' to destination payload format
specified in 'output_payload_format'. If 'output_payload_format' is
not set, the data will remain unchanged.
- It also sets the corresponding datacontenttype of
the CloudEvent, as indicated by
'output_payload_format'. If no
'output_payload_format' is set it will use the value of the
"datacontenttype" attribute on the CloudEvent if present, else
remove "datacontenttype" attribute.
- This function expects that the content of the message will
adhere to the standard CloudEvent format. If it doesn't then this
function will fail.
- The result is a CEL map that corresponds to the JSON
representation of the CloudEvent. To convert that data to a JSON
string it can be chained with the toJsonString function.

The Pipeline expects that the message it receives adheres to the
standard CloudEvent format. If it doesn't then the outgoing message
request may fail with a persistent error.`,
									},
								},
							},
						},
						"message_bus": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The resource name of the Message Bus to which events should be
published. The Message Bus resource should exist in the same project as
the Pipeline. Format:
'projects/{project}/locations/{location}/messageBuses/{message_bus}'`,
						},
						"network_config": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Represents a network config to be used for destination resolution and
connectivity.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"network_attachment": {
										Type:     schema.TypeString,
										Required: true,
										Description: `Name of the NetworkAttachment that allows access to the consumer VPC.
Format:
'projects/{PROJECT_ID}/regions/{REGION}/networkAttachments/{NETWORK_ATTACHMENT_NAME}'`,
									},
								},
							},
						},
						"output_payload_format": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Represents the format of message data.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"avro": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `The format of an AVRO message payload.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"schema_definition": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The entire schema definition is stored in this field.`,
												},
											},
										},
									},
									"json": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `The format of a JSON message payload.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},
									"protobuf": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `The format of a Protobuf message payload.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"schema_definition": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The entire schema definition is stored in this field.`,
												},
											},
										},
									},
								},
							},
						},
						"topic": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The resource name of the Pub/Sub topic to which events should be
published. Format:
'projects/{project}/locations/{location}/topics/{topic}'`,
						},
						"workflow": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The resource name of the Workflow whose Executions are triggered by
the events. The Workflow resource should be deployed in the same
project as the Pipeline. Format:
'projects/{project}/locations/{location}/workflows/{workflow}'`,
						},
					},
				},
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"pipeline_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The user-provided ID to be assigned to the Pipeline. It should match the
format '^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$'.`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `User-defined annotations. See https://google.aip.dev/128#annotations.

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"crypto_key_name": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Resource name of a KMS crypto key (managed by the user) used to
encrypt/decrypt the event data. If not set, an internal Google-owned key
will be used to encrypt messages. It must match the pattern
"projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}".`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Display name of resource.`,
			},
			"input_payload_format": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Represents the format of message data.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"avro": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The format of an AVRO message payload.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"schema_definition": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The entire schema definition is stored in this field.`,
									},
								},
							},
						},
						"json": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The format of a JSON message payload.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},
						"protobuf": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The format of a Protobuf message payload.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"schema_definition": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The entire schema definition is stored in this field.`,
									},
								},
							},
						},
					},
				},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `User labels attached to the Pipeline that can be used to group
resources. An object containing a list of "key": value pairs. Example: {
"name": "wrench", "mass": "1.3kg", "count": "3" }.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"logging_config": {
				Type:     schema.TypeList,
				Computed: true,
				Optional: true,
				Description: `The configuration for Platform Telemetry logging for Eventarc Advanced
resources.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"log_severity": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"NONE", "DEBUG", "INFO", "NOTICE", "WARNING", "ERROR", "CRITICAL", "ALERT", "EMERGENCY", ""}),
							Description: `The minimum severity of logs that will be sent to Stackdriver/Platform
Telemetry. Logs at severitiy â‰¥ this value will be sent, unless it is NONE. Possible values: ["NONE", "DEBUG", "INFO", "NOTICE", "WARNING", "ERROR", "CRITICAL", "ALERT", "EMERGENCY"]`,
						},
					},
				},
			},
			"mediations": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `List of mediation operations to be performed on the message. Currently,
only one Transformation operation is allowed in each Pipeline.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"transformation": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Transformation defines the way to transform an incoming message.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"transformation_template": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The CEL expression template to apply to transform messages.
The following CEL extension functions are provided for
use in this CEL expression:
- merge:
map1.merge(map2) -> map3
- Merges the passed CEL map with the existing CEL map the
function is applied to.
- If the same key exists in both maps, if the key's value is type
map both maps are merged else the value from the passed map is
used.
- denormalize:
map.denormalize() -> map
- Denormalizes a CEL map such that every value of type map or key
in the map is expanded to return a single level map.
- The resulting keys are "." separated indices of the map keys.
- For example:
{
"a": 1,
"b": {
"c": 2,
"d": 3
}
"e": [4, 5]
}
.denormalize()
-> {
"a": 1,
"b.c": 2,
"b.d": 3,
"e.0": 4,
"e.1": 5
}
- setField:
map.setField(key, value) -> message
- Sets the field of the message with the given key to the
given value.
- If the field is not present it will be added.
- If the field is present it will be overwritten.
- The key can be a dot separated path to set a field in a nested
message.
- Key must be of type string.
- Value may be any valid type.
- removeFields:
map.removeFields([key1, key2, ...]) -> message
- Removes the fields of the map with the given keys.
- The keys can be a dot separated path to remove a field in a
nested message.
- If a key is not found it will be ignored.
- Keys must be of type string.
- toMap:
[map1, map2, ...].toMap() -> map
- Converts a CEL list of CEL maps to a single CEL map
- toDestinationPayloadFormat():
message.data.toDestinationPayloadFormat() -> string or bytes
- Converts the message data to the destination payload format
specified in Pipeline.Destination.output_payload_format
- This function is meant to be applied to the message.data field.
- If the destination payload format is not set, the function will
return the message data unchanged.
- toCloudEventJsonWithPayloadFormat:
message.toCloudEventJsonWithPayloadFormat() -> map
- Converts a message to the corresponding structure of JSON
format for CloudEvents
- This function applies toDestinationPayloadFormat() to the
message data. It also sets the corresponding datacontenttype of
the CloudEvent, as indicated by
Pipeline.Destination.output_payload_format. If no
output_payload_format is set it will use the existing
datacontenttype on the CloudEvent if present, else leave
datacontenttype absent.
- This function expects that the content of the message will
adhere to the standard CloudEvent format. If it doesn't then this
function will fail.
- The result is a CEL map that corresponds to the JSON
representation of the CloudEvent. To convert that data to a JSON
string it can be chained with the toJsonString function.`,
									},
								},
							},
						},
					},
				},
			},
			"retry_policy": {
				Type:     schema.TypeList,
				Computed: true,
				Optional: true,
				Description: `The retry policy configuration for the Pipeline. The pipeline
exponentially backs off in case the destination is non responsive or
returns a retryable error code. The default semantics are as follows:
The backoff starts with a 5 second delay and doubles the
delay after each failed attempt (10 seconds, 20 seconds, 40 seconds, etc.).
The delay is capped at 60 seconds by default.
Please note that if you set the min_retry_delay and max_retry_delay fields
to the same value this will make the duration between retries constant.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"max_attempts": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `The maximum number of delivery attempts for any message. The value must
be between 1 and 100.
The default value for this field is 5.`,
							Default: 5,
						},
						"max_retry_delay": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The maximum amount of seconds to wait between retry attempts. The value
must be between 1 and 600.
The default value for this field is 60.`,
							Default: "60s",
						},
						"min_retry_delay": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The minimum amount of seconds to wait between retry attempts. The value
must be between 1 and 600.
The default value for this field is 5.`,
							Default: "5s",
						},
					},
				},
			},
			"create_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The creation time.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up
to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and
"2014-10-02T15:01:23.045123456Z".`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `This checksum is computed by the server based on the value of
other fields, and might be sent only on create requests to ensure that the
client has an up-to-date value before proceeding.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The resource name of the Pipeline. Must be unique within the
location of the project and must be in
'projects/{project}/locations/{location}/pipelines/{pipeline}' format.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Server-assigned unique identifier for the Pipeline. The value
is a UUID4 string and guaranteed to remain unchanged until the resource is
deleted.`,
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The last-modified time.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up
to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and
"2014-10-02T15:01:23.045123456Z".`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceEventarcPipelineCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandEventarcPipelineDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	cryptoKeyNameProp, err := expandEventarcPipelineCryptoKeyName(d.Get("crypto_key_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("crypto_key_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(cryptoKeyNameProp)) && (ok || !reflect.DeepEqual(v, cryptoKeyNameProp)) {
		obj["cryptoKeyName"] = cryptoKeyNameProp
	}
	inputPayloadFormatProp, err := expandEventarcPipelineInputPayloadFormat(d.Get("input_payload_format"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("input_payload_format"); !tpgresource.IsEmptyValue(reflect.ValueOf(inputPayloadFormatProp)) && (ok || !reflect.DeepEqual(v, inputPayloadFormatProp)) {
		obj["inputPayloadFormat"] = inputPayloadFormatProp
	}
	retryPolicyProp, err := expandEventarcPipelineRetryPolicy(d.Get("retry_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("retry_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(retryPolicyProp)) && (ok || !reflect.DeepEqual(v, retryPolicyProp)) {
		obj["retryPolicy"] = retryPolicyProp
	}
	destinationsProp, err := expandEventarcPipelineDestinations(d.Get("destinations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("destinations"); !tpgresource.IsEmptyValue(reflect.ValueOf(destinationsProp)) && (ok || !reflect.DeepEqual(v, destinationsProp)) {
		obj["destinations"] = destinationsProp
	}
	mediationsProp, err := expandEventarcPipelineMediations(d.Get("mediations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("mediations"); !tpgresource.IsEmptyValue(reflect.ValueOf(mediationsProp)) && (ok || !reflect.DeepEqual(v, mediationsProp)) {
		obj["mediations"] = mediationsProp
	}
	loggingConfigProp, err := expandEventarcPipelineLoggingConfig(d.Get("logging_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("logging_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(loggingConfigProp)) && (ok || !reflect.DeepEqual(v, loggingConfigProp)) {
		obj["loggingConfig"] = loggingConfigProp
	}
	annotationsProp, err := expandEventarcPipelineEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(annotationsProp)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}
	labelsProp, err := expandEventarcPipelineEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{EventarcBasePath}}projects/{{project}}/locations/{{location}}/pipelines?pipelineId={{pipeline_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Pipeline: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Pipeline: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Pipeline: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/pipelines/{{pipeline_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = EventarcOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating Pipeline", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create Pipeline: %s", err)
	}

	if err := d.Set("name", flattenEventarcPipelineName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/pipelines/{{pipeline_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Pipeline %q: %#v", d.Id(), res)

	return resourceEventarcPipelineRead(d, meta)
}

func resourceEventarcPipelineRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{EventarcBasePath}}projects/{{project}}/locations/{{location}}/pipelines/{{pipeline_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Pipeline: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("EventarcPipeline %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}

	if err := d.Set("annotations", flattenEventarcPipelineAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("display_name", flattenEventarcPipelineDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("crypto_key_name", flattenEventarcPipelineCryptoKeyName(res["cryptoKeyName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("input_payload_format", flattenEventarcPipelineInputPayloadFormat(res["inputPayloadFormat"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("retry_policy", flattenEventarcPipelineRetryPolicy(res["retryPolicy"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("etag", flattenEventarcPipelineEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("update_time", flattenEventarcPipelineUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("labels", flattenEventarcPipelineLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("uid", flattenEventarcPipelineUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("destinations", flattenEventarcPipelineDestinations(res["destinations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("mediations", flattenEventarcPipelineMediations(res["mediations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("logging_config", flattenEventarcPipelineLoggingConfig(res["loggingConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("name", flattenEventarcPipelineName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("create_time", flattenEventarcPipelineCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("effective_annotations", flattenEventarcPipelineEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("terraform_labels", flattenEventarcPipelineTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}
	if err := d.Set("effective_labels", flattenEventarcPipelineEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Pipeline: %s", err)
	}

	return nil
}

func resourceEventarcPipelineUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Pipeline: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	displayNameProp, err := expandEventarcPipelineDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	cryptoKeyNameProp, err := expandEventarcPipelineCryptoKeyName(d.Get("crypto_key_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("crypto_key_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, cryptoKeyNameProp)) {
		obj["cryptoKeyName"] = cryptoKeyNameProp
	}
	inputPayloadFormatProp, err := expandEventarcPipelineInputPayloadFormat(d.Get("input_payload_format"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("input_payload_format"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, inputPayloadFormatProp)) {
		obj["inputPayloadFormat"] = inputPayloadFormatProp
	}
	retryPolicyProp, err := expandEventarcPipelineRetryPolicy(d.Get("retry_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("retry_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, retryPolicyProp)) {
		obj["retryPolicy"] = retryPolicyProp
	}
	destinationsProp, err := expandEventarcPipelineDestinations(d.Get("destinations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("destinations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, destinationsProp)) {
		obj["destinations"] = destinationsProp
	}
	mediationsProp, err := expandEventarcPipelineMediations(d.Get("mediations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("mediations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, mediationsProp)) {
		obj["mediations"] = mediationsProp
	}
	loggingConfigProp, err := expandEventarcPipelineLoggingConfig(d.Get("logging_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("logging_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, loggingConfigProp)) {
		obj["loggingConfig"] = loggingConfigProp
	}
	annotationsProp, err := expandEventarcPipelineEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}
	labelsProp, err := expandEventarcPipelineEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{EventarcBasePath}}projects/{{project}}/locations/{{location}}/pipelines/{{pipeline_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Pipeline %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("crypto_key_name") {
		updateMask = append(updateMask, "cryptoKeyName")
	}

	if d.HasChange("input_payload_format") {
		updateMask = append(updateMask, "inputPayloadFormat")
	}

	if d.HasChange("retry_policy") {
		updateMask = append(updateMask, "retryPolicy")
	}

	if d.HasChange("destinations") {
		updateMask = append(updateMask, "destinations")
	}

	if d.HasChange("mediations") {
		updateMask = append(updateMask, "mediations")
	}

	if d.HasChange("logging_config") {
		updateMask = append(updateMask, "loggingConfig")
	}

	if d.HasChange("effective_annotations") {
		updateMask = append(updateMask, "annotations")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Pipeline %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Pipeline %q: %#v", d.Id(), res)
		}

		err = EventarcOperationWaitTime(
			config, res, project, "Updating Pipeline", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceEventarcPipelineRead(d, meta)
}

func resourceEventarcPipelineDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Pipeline: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{EventarcBasePath}}projects/{{project}}/locations/{{location}}/pipelines/{{pipeline_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Pipeline %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Pipeline")
	}

	err = EventarcOperationWaitTime(
		config, res, project, "Deleting Pipeline", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Pipeline %q: %#v", d.Id(), res)
	return nil
}

func resourceEventarcPipelineImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/pipelines/(?P<pipeline_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<pipeline_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<pipeline_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/pipelines/{{pipeline_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenEventarcPipelineAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenEventarcPipelineDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineCryptoKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineInputPayloadFormat(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["protobuf"] =
		flattenEventarcPipelineInputPayloadFormatProtobuf(original["protobuf"], d, config)
	transformed["avro"] =
		flattenEventarcPipelineInputPayloadFormatAvro(original["avro"], d, config)
	transformed["json"] =
		flattenEventarcPipelineInputPayloadFormatJson(original["json"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineInputPayloadFormatProtobuf(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["schema_definition"] =
		flattenEventarcPipelineInputPayloadFormatProtobufSchemaDefinition(original["schemaDefinition"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineInputPayloadFormatProtobufSchemaDefinition(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineInputPayloadFormatAvro(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["schema_definition"] =
		flattenEventarcPipelineInputPayloadFormatAvroSchemaDefinition(original["schemaDefinition"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineInputPayloadFormatAvroSchemaDefinition(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineInputPayloadFormatJson(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenEventarcPipelineRetryPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["max_retry_delay"] =
		flattenEventarcPipelineRetryPolicyMaxRetryDelay(original["maxRetryDelay"], d, config)
	transformed["max_attempts"] =
		flattenEventarcPipelineRetryPolicyMaxAttempts(original["maxAttempts"], d, config)
	transformed["min_retry_delay"] =
		flattenEventarcPipelineRetryPolicyMinRetryDelay(original["minRetryDelay"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineRetryPolicyMaxRetryDelay(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineRetryPolicyMaxAttempts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenEventarcPipelineRetryPolicyMinRetryDelay(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenEventarcPipelineUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"authentication_config": flattenEventarcPipelineDestinationsAuthenticationConfig(original["authenticationConfig"], d, config),
			"output_payload_format": flattenEventarcPipelineDestinationsOutputPayloadFormat(original["outputPayloadFormat"], d, config),
			"network_config":        flattenEventarcPipelineDestinationsNetworkConfig(original["networkConfig"], d, config),
			"http_endpoint":         flattenEventarcPipelineDestinationsHttpEndpoint(original["httpEndpoint"], d, config),
			"workflow":              flattenEventarcPipelineDestinationsWorkflow(original["workflow"], d, config),
			"message_bus":           flattenEventarcPipelineDestinationsMessageBus(original["messageBus"], d, config),
			"topic":                 flattenEventarcPipelineDestinationsTopic(original["topic"], d, config),
		})
	}
	return transformed
}
func flattenEventarcPipelineDestinationsAuthenticationConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["google_oidc"] =
		flattenEventarcPipelineDestinationsAuthenticationConfigGoogleOidc(original["googleOidc"], d, config)
	transformed["oauth_token"] =
		flattenEventarcPipelineDestinationsAuthenticationConfigOauthToken(original["oauthToken"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineDestinationsAuthenticationConfigGoogleOidc(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_account"] =
		flattenEventarcPipelineDestinationsAuthenticationConfigGoogleOidcServiceAccount(original["serviceAccount"], d, config)
	transformed["audience"] =
		flattenEventarcPipelineDestinationsAuthenticationConfigGoogleOidcAudience(original["audience"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineDestinationsAuthenticationConfigGoogleOidcServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinationsAuthenticationConfigGoogleOidcAudience(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinationsAuthenticationConfigOauthToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_account"] =
		flattenEventarcPipelineDestinationsAuthenticationConfigOauthTokenServiceAccount(original["serviceAccount"], d, config)
	transformed["scope"] =
		flattenEventarcPipelineDestinationsAuthenticationConfigOauthTokenScope(original["scope"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineDestinationsAuthenticationConfigOauthTokenServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinationsAuthenticationConfigOauthTokenScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinationsOutputPayloadFormat(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["protobuf"] =
		flattenEventarcPipelineDestinationsOutputPayloadFormatProtobuf(original["protobuf"], d, config)
	transformed["avro"] =
		flattenEventarcPipelineDestinationsOutputPayloadFormatAvro(original["avro"], d, config)
	transformed["json"] =
		flattenEventarcPipelineDestinationsOutputPayloadFormatJson(original["json"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineDestinationsOutputPayloadFormatProtobuf(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["schema_definition"] =
		flattenEventarcPipelineDestinationsOutputPayloadFormatProtobufSchemaDefinition(original["schemaDefinition"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineDestinationsOutputPayloadFormatProtobufSchemaDefinition(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinationsOutputPayloadFormatAvro(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["schema_definition"] =
		flattenEventarcPipelineDestinationsOutputPayloadFormatAvroSchemaDefinition(original["schemaDefinition"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineDestinationsOutputPayloadFormatAvroSchemaDefinition(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinationsOutputPayloadFormatJson(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenEventarcPipelineDestinationsNetworkConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["network_attachment"] =
		flattenEventarcPipelineDestinationsNetworkConfigNetworkAttachment(original["networkAttachment"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineDestinationsNetworkConfigNetworkAttachment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinationsHttpEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenEventarcPipelineDestinationsHttpEndpointUri(original["uri"], d, config)
	transformed["message_binding_template"] =
		flattenEventarcPipelineDestinationsHttpEndpointMessageBindingTemplate(original["messageBindingTemplate"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineDestinationsHttpEndpointUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinationsHttpEndpointMessageBindingTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinationsWorkflow(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinationsMessageBus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineDestinationsTopic(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineMediations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"transformation": flattenEventarcPipelineMediationsTransformation(original["transformation"], d, config),
		})
	}
	return transformed
}
func flattenEventarcPipelineMediationsTransformation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["transformation_template"] =
		flattenEventarcPipelineMediationsTransformationTransformationTemplate(original["transformationTemplate"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineMediationsTransformationTransformationTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineLoggingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["log_severity"] =
		flattenEventarcPipelineLoggingConfigLogSeverity(original["logSeverity"], d, config)
	return []interface{}{transformed}
}
func flattenEventarcPipelineLoggingConfigLogSeverity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenEventarcPipelineTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenEventarcPipelineEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandEventarcPipelineDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineCryptoKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineInputPayloadFormat(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProtobuf, err := expandEventarcPipelineInputPayloadFormatProtobuf(original["protobuf"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProtobuf); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["protobuf"] = transformedProtobuf
	}

	transformedAvro, err := expandEventarcPipelineInputPayloadFormatAvro(original["avro"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAvro); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["avro"] = transformedAvro
	}

	transformedJson, err := expandEventarcPipelineInputPayloadFormatJson(original["json"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["json"] = transformedJson
	}

	return transformed, nil
}

func expandEventarcPipelineInputPayloadFormatProtobuf(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSchemaDefinition, err := expandEventarcPipelineInputPayloadFormatProtobufSchemaDefinition(original["schema_definition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSchemaDefinition); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["schemaDefinition"] = transformedSchemaDefinition
	}

	return transformed, nil
}

func expandEventarcPipelineInputPayloadFormatProtobufSchemaDefinition(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineInputPayloadFormatAvro(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSchemaDefinition, err := expandEventarcPipelineInputPayloadFormatAvroSchemaDefinition(original["schema_definition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSchemaDefinition); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["schemaDefinition"] = transformedSchemaDefinition
	}

	return transformed, nil
}

func expandEventarcPipelineInputPayloadFormatAvroSchemaDefinition(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineInputPayloadFormatJson(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandEventarcPipelineRetryPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMaxRetryDelay, err := expandEventarcPipelineRetryPolicyMaxRetryDelay(original["max_retry_delay"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxRetryDelay); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxRetryDelay"] = transformedMaxRetryDelay
	}

	transformedMaxAttempts, err := expandEventarcPipelineRetryPolicyMaxAttempts(original["max_attempts"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxAttempts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxAttempts"] = transformedMaxAttempts
	}

	transformedMinRetryDelay, err := expandEventarcPipelineRetryPolicyMinRetryDelay(original["min_retry_delay"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinRetryDelay); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minRetryDelay"] = transformedMinRetryDelay
	}

	return transformed, nil
}

func expandEventarcPipelineRetryPolicyMaxRetryDelay(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineRetryPolicyMaxAttempts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineRetryPolicyMinRetryDelay(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAuthenticationConfig, err := expandEventarcPipelineDestinationsAuthenticationConfig(original["authentication_config"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAuthenticationConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["authenticationConfig"] = transformedAuthenticationConfig
		}

		transformedOutputPayloadFormat, err := expandEventarcPipelineDestinationsOutputPayloadFormat(original["output_payload_format"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOutputPayloadFormat); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["outputPayloadFormat"] = transformedOutputPayloadFormat
		}

		transformedNetworkConfig, err := expandEventarcPipelineDestinationsNetworkConfig(original["network_config"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetworkConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["networkConfig"] = transformedNetworkConfig
		}

		transformedHttpEndpoint, err := expandEventarcPipelineDestinationsHttpEndpoint(original["http_endpoint"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHttpEndpoint); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["httpEndpoint"] = transformedHttpEndpoint
		}

		transformedWorkflow, err := expandEventarcPipelineDestinationsWorkflow(original["workflow"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedWorkflow); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["workflow"] = transformedWorkflow
		}

		transformedMessageBus, err := expandEventarcPipelineDestinationsMessageBus(original["message_bus"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMessageBus); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["messageBus"] = transformedMessageBus
		}

		transformedTopic, err := expandEventarcPipelineDestinationsTopic(original["topic"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTopic); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["topic"] = transformedTopic
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandEventarcPipelineDestinationsAuthenticationConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGoogleOidc, err := expandEventarcPipelineDestinationsAuthenticationConfigGoogleOidc(original["google_oidc"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGoogleOidc); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["googleOidc"] = transformedGoogleOidc
	}

	transformedOauthToken, err := expandEventarcPipelineDestinationsAuthenticationConfigOauthToken(original["oauth_token"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauthToken); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauthToken"] = transformedOauthToken
	}

	return transformed, nil
}

func expandEventarcPipelineDestinationsAuthenticationConfigGoogleOidc(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServiceAccount, err := expandEventarcPipelineDestinationsAuthenticationConfigGoogleOidcServiceAccount(original["service_account"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccount"] = transformedServiceAccount
	}

	transformedAudience, err := expandEventarcPipelineDestinationsAuthenticationConfigGoogleOidcAudience(original["audience"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAudience); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["audience"] = transformedAudience
	}

	return transformed, nil
}

func expandEventarcPipelineDestinationsAuthenticationConfigGoogleOidcServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinationsAuthenticationConfigGoogleOidcAudience(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinationsAuthenticationConfigOauthToken(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServiceAccount, err := expandEventarcPipelineDestinationsAuthenticationConfigOauthTokenServiceAccount(original["service_account"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccount"] = transformedServiceAccount
	}

	transformedScope, err := expandEventarcPipelineDestinationsAuthenticationConfigOauthTokenScope(original["scope"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScope); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scope"] = transformedScope
	}

	return transformed, nil
}

func expandEventarcPipelineDestinationsAuthenticationConfigOauthTokenServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinationsAuthenticationConfigOauthTokenScope(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinationsOutputPayloadFormat(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProtobuf, err := expandEventarcPipelineDestinationsOutputPayloadFormatProtobuf(original["protobuf"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProtobuf); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["protobuf"] = transformedProtobuf
	}

	transformedAvro, err := expandEventarcPipelineDestinationsOutputPayloadFormatAvro(original["avro"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAvro); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["avro"] = transformedAvro
	}

	transformedJson, err := expandEventarcPipelineDestinationsOutputPayloadFormatJson(original["json"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["json"] = transformedJson
	}

	return transformed, nil
}

func expandEventarcPipelineDestinationsOutputPayloadFormatProtobuf(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSchemaDefinition, err := expandEventarcPipelineDestinationsOutputPayloadFormatProtobufSchemaDefinition(original["schema_definition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSchemaDefinition); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["schemaDefinition"] = transformedSchemaDefinition
	}

	return transformed, nil
}

func expandEventarcPipelineDestinationsOutputPayloadFormatProtobufSchemaDefinition(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinationsOutputPayloadFormatAvro(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSchemaDefinition, err := expandEventarcPipelineDestinationsOutputPayloadFormatAvroSchemaDefinition(original["schema_definition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSchemaDefinition); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["schemaDefinition"] = transformedSchemaDefinition
	}

	return transformed, nil
}

func expandEventarcPipelineDestinationsOutputPayloadFormatAvroSchemaDefinition(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinationsOutputPayloadFormatJson(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandEventarcPipelineDestinationsNetworkConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNetworkAttachment, err := expandEventarcPipelineDestinationsNetworkConfigNetworkAttachment(original["network_attachment"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetworkAttachment); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["networkAttachment"] = transformedNetworkAttachment
	}

	return transformed, nil
}

func expandEventarcPipelineDestinationsNetworkConfigNetworkAttachment(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinationsHttpEndpoint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandEventarcPipelineDestinationsHttpEndpointUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedMessageBindingTemplate, err := expandEventarcPipelineDestinationsHttpEndpointMessageBindingTemplate(original["message_binding_template"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMessageBindingTemplate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["messageBindingTemplate"] = transformedMessageBindingTemplate
	}

	return transformed, nil
}

func expandEventarcPipelineDestinationsHttpEndpointUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinationsHttpEndpointMessageBindingTemplate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinationsWorkflow(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinationsMessageBus(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineDestinationsTopic(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineMediations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedTransformation, err := expandEventarcPipelineMediationsTransformation(original["transformation"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTransformation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["transformation"] = transformedTransformation
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandEventarcPipelineMediationsTransformation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTransformationTemplate, err := expandEventarcPipelineMediationsTransformationTransformationTemplate(original["transformation_template"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTransformationTemplate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["transformationTemplate"] = transformedTransformationTemplate
	}

	return transformed, nil
}

func expandEventarcPipelineMediationsTransformationTransformationTemplate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineLoggingConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLogSeverity, err := expandEventarcPipelineLoggingConfigLogSeverity(original["log_severity"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLogSeverity); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["logSeverity"] = transformedLogSeverity
	}

	return transformed, nil
}

func expandEventarcPipelineLoggingConfigLogSeverity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandEventarcPipelineEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandEventarcPipelineEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
