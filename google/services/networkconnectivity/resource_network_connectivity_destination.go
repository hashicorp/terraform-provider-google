// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/networkconnectivity/Destination.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package networkconnectivity

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceNetworkConnectivityDestination() *schema.Resource {
	return &schema.Resource{
		Create: resourceNetworkConnectivityDestinationCreate,
		Read:   resourceNetworkConnectivityDestinationRead,
		Update: resourceNetworkConnectivityDestinationUpdate,
		Delete: resourceNetworkConnectivityDestinationDelete,

		Importer: &schema.ResourceImporter{
			State: resourceNetworkConnectivityDestinationImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"multicloud_data_transfer_config": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"endpoints": {
				Type:        schema.TypeSet,
				Required:    true,
				Description: `The list of DestinationEndpoint resources configured for the IP prefix.`,
				Elem:        networkconnectivityDestinationEndpointsSchema(),
				// Default schema.HashSchema is used.
			},
			"ip_prefix": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The IP prefix that represents your workload on another CSP.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the destination.`,
			},
			"multicloud_data_transfer_config": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The multicloud data transfer config of the destination.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of the destination.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `A description of this resource.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `User-defined labels.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time when the 'Destination' resource was created.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The etag is computed by the server, and might be sent with update and
delete requests so that the client has an up-to-date value before
proceeding.`,
			},
			"state_timeline": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `The timeline of the expected 'Destination' states or the current rest
state. If a state change is expected, the value is 'ADDING',
'DELETING' or 'SUSPENDING', depending on the action specified.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"states": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The state and activation time details of the resource state.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"effective_time": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Accompanies only the transient states, which include 'ADDING',
'DELETING', and 'SUSPENDING', to denote the time until which the
transient state of the resource will be effective. For instance, if the
state is 'ADDING', this field shows the time when the resource state
transitions to 'ACTIVE'.`,
									},
									"state": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The state of the resource.`,
									},
								},
							},
						},
					},
				},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The Google-generated unique ID for the 'Destination' resource.
This value is unique across all 'Destination' resources.
If a resource is deleted and another with the same name is
created, the new resource is assigned a different and unique ID.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time when the 'Destination' resource was updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func networkconnectivityDestinationEndpointsSchema() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"asn": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The ASN of the remote IP prefix.`,
			},
			"csp": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The CSP of the remote IP prefix.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The state of the DestinationEndpoint resource.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time when the DestinationEndpoint resource was updated.`,
			},
		},
	}
}

func resourceNetworkConnectivityDestinationCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	etagProp, err := expandNetworkConnectivityDestinationEtag(d.Get("etag"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("etag"); !tpgresource.IsEmptyValue(reflect.ValueOf(etagProp)) && (ok || !reflect.DeepEqual(v, etagProp)) {
		obj["etag"] = etagProp
	}
	descriptionProp, err := expandNetworkConnectivityDestinationDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	ipPrefixProp, err := expandNetworkConnectivityDestinationIpPrefix(d.Get("ip_prefix"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ip_prefix"); !tpgresource.IsEmptyValue(reflect.ValueOf(ipPrefixProp)) && (ok || !reflect.DeepEqual(v, ipPrefixProp)) {
		obj["ipPrefix"] = ipPrefixProp
	}
	endpointsProp, err := expandNetworkConnectivityDestinationEndpoints(d.Get("endpoints"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("endpoints"); !tpgresource.IsEmptyValue(reflect.ValueOf(endpointsProp)) && (ok || !reflect.DeepEqual(v, endpointsProp)) {
		obj["endpoints"] = endpointsProp
	}
	effectiveLabelsProp, err := expandNetworkConnectivityDestinationEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkConnectivityBasePath}}projects/{{project}}/locations/{{location}}/multicloudDataTransferConfigs/{{multicloud_data_transfer_config}}/destinations?destination_id={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Destination: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Destination: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Destination: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/multicloudDataTransferConfigs/{{multicloud_data_transfer_config}}/destinations/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if multicloudDataTransferConfigValue, ok := d.GetOk("multicloud_data_transfer_config"); ok && multicloudDataTransferConfigValue.(string) != "" {
			if err = identity.Set("multicloud_data_transfer_config", multicloudDataTransferConfigValue.(string)); err != nil {
				return fmt.Errorf("Error setting multicloud_data_transfer_config: %s", err)
			}
		}
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = NetworkConnectivityOperationWaitTime(
		config, res, project, "Creating Destination", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Destination: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Destination %q: %#v", d.Id(), res)

	return resourceNetworkConnectivityDestinationRead(d, meta)
}

func resourceNetworkConnectivityDestinationRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkConnectivityBasePath}}projects/{{project}}/locations/{{location}}/multicloudDataTransferConfigs/{{multicloud_data_transfer_config}}/destinations/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Destination: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("NetworkConnectivityDestination %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}

	if err := d.Set("create_time", flattenNetworkConnectivityDestinationCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}
	if err := d.Set("update_time", flattenNetworkConnectivityDestinationUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}
	if err := d.Set("labels", flattenNetworkConnectivityDestinationLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}
	if err := d.Set("etag", flattenNetworkConnectivityDestinationEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}
	if err := d.Set("description", flattenNetworkConnectivityDestinationDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}
	if err := d.Set("ip_prefix", flattenNetworkConnectivityDestinationIpPrefix(res["ipPrefix"], d, config)); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}
	if err := d.Set("endpoints", flattenNetworkConnectivityDestinationEndpoints(res["endpoints"], d, config)); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}
	if err := d.Set("state_timeline", flattenNetworkConnectivityDestinationStateTimeline(res["stateTimeline"], d, config)); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}
	if err := d.Set("uid", flattenNetworkConnectivityDestinationUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}
	if err := d.Set("terraform_labels", flattenNetworkConnectivityDestinationTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}
	if err := d.Set("effective_labels", flattenNetworkConnectivityDestinationEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Destination: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("multicloud_data_transfer_config"); !ok && v == "" {
			err = identity.Set("multicloud_data_transfer_config", d.Get("multicloud_data_transfer_config").(string))
			if err != nil {
				return fmt.Errorf("Error setting multicloud_data_transfer_config: %s", err)
			}
		}
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("name"); !ok && v == "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceNetworkConnectivityDestinationUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if multicloudDataTransferConfigValue, ok := d.GetOk("multicloud_data_transfer_config"); ok && multicloudDataTransferConfigValue.(string) != "" {
			if err = identity.Set("multicloud_data_transfer_config", multicloudDataTransferConfigValue.(string)); err != nil {
				return fmt.Errorf("Error setting multicloud_data_transfer_config: %s", err)
			}
		}
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Destination: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	etagProp, err := expandNetworkConnectivityDestinationEtag(d.Get("etag"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("etag"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, etagProp)) {
		obj["etag"] = etagProp
	}
	descriptionProp, err := expandNetworkConnectivityDestinationDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	endpointsProp, err := expandNetworkConnectivityDestinationEndpoints(d.Get("endpoints"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("endpoints"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, endpointsProp)) {
		obj["endpoints"] = endpointsProp
	}
	effectiveLabelsProp, err := expandNetworkConnectivityDestinationEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkConnectivityBasePath}}projects/{{project}}/locations/{{location}}/multicloudDataTransferConfigs/{{multicloud_data_transfer_config}}/destinations/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Destination %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("etag") {
		updateMask = append(updateMask, "etag")
	}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("endpoints") {
		updateMask = append(updateMask, "endpoints")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Destination %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Destination %q: %#v", d.Id(), res)
		}

		err = NetworkConnectivityOperationWaitTime(
			config, res, project, "Updating Destination", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceNetworkConnectivityDestinationRead(d, meta)
}

func resourceNetworkConnectivityDestinationDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Destination: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkConnectivityBasePath}}projects/{{project}}/locations/{{location}}/multicloudDataTransferConfigs/{{multicloud_data_transfer_config}}/destinations/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Destination %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Destination")
	}

	err = NetworkConnectivityOperationWaitTime(
		config, res, project, "Deleting Destination", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Destination %q: %#v", d.Id(), res)
	return nil
}

func resourceNetworkConnectivityDestinationImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/multicloudDataTransferConfigs/(?P<multicloud_data_transfer_config>[^/]+)/destinations/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<multicloud_data_transfer_config>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<multicloud_data_transfer_config>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/multicloudDataTransferConfigs/{{multicloud_data_transfer_config}}/destinations/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenNetworkConnectivityDestinationCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkConnectivityDestinationEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationIpPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationEndpoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := schema.NewSet(schema.HashResource(networkconnectivityDestinationEndpointsSchema()), []interface{}{})
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed.Add(map[string]interface{}{
			"asn":         flattenNetworkConnectivityDestinationEndpointsAsn(original["asn"], d, config),
			"csp":         flattenNetworkConnectivityDestinationEndpointsCsp(original["csp"], d, config),
			"state":       flattenNetworkConnectivityDestinationEndpointsState(original["state"], d, config),
			"update_time": flattenNetworkConnectivityDestinationEndpointsUpdateTime(original["updateTime"], d, config),
		})
	}
	return transformed
}
func flattenNetworkConnectivityDestinationEndpointsAsn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationEndpointsCsp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationEndpointsState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationEndpointsUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationStateTimeline(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["states"] =
		flattenNetworkConnectivityDestinationStateTimelineStates(original["states"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkConnectivityDestinationStateTimelineStates(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"state":          flattenNetworkConnectivityDestinationStateTimelineStatesState(original["state"], d, config),
			"effective_time": flattenNetworkConnectivityDestinationStateTimelineStatesEffectiveTime(original["effectiveTime"], d, config),
		})
	}
	return transformed
}
func flattenNetworkConnectivityDestinationStateTimelineStatesState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationStateTimelineStatesEffectiveTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityDestinationTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkConnectivityDestinationEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandNetworkConnectivityDestinationEtag(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityDestinationDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityDestinationIpPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityDestinationEndpoints(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	v = v.(*schema.Set).List()
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAsn, err := expandNetworkConnectivityDestinationEndpointsAsn(original["asn"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAsn); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["asn"] = transformedAsn
		}

		transformedCsp, err := expandNetworkConnectivityDestinationEndpointsCsp(original["csp"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCsp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["csp"] = transformedCsp
		}

		transformedState, err := expandNetworkConnectivityDestinationEndpointsState(original["state"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["state"] = transformedState
		}

		transformedUpdateTime, err := expandNetworkConnectivityDestinationEndpointsUpdateTime(original["update_time"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedUpdateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["updateTime"] = transformedUpdateTime
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkConnectivityDestinationEndpointsAsn(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityDestinationEndpointsCsp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityDestinationEndpointsState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityDestinationEndpointsUpdateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityDestinationEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
