// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/iamworkforcepool/WorkforcePoolProviderKey.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package iamworkforcepool

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

const workforcePoolProviderKeyIdRegexp = `^[a-z0-9-]{4,32}$`

func ValidateWorkforcePoolProviderKeyId(v interface{}, k string) (ws []string, errors []error) {
	value := v.(string)

	if strings.HasPrefix(value, "gcp-") {
		errors = append(errors, fmt.Errorf(
			"%q (%q) can not start with \"gcp-\". "+
				"The prefix `gcp-` is reserved for use by Google, and may not be specified.", k, value))
	}

	if !regexp.MustCompile(workforcePoolProviderKeyIdRegexp).MatchString(value) {
		errors = append(errors, fmt.Errorf(
			"%q (%q) must be 4-32 characters, and may contain the characters [a-z0-9-].", k, value))
	}

	return
}

func ResourceIAMWorkforcePoolWorkforcePoolProviderKey() *schema.Resource {
	return &schema.Resource{
		Create: resourceIAMWorkforcePoolWorkforcePoolProviderKeyCreate,
		Read:   resourceIAMWorkforcePoolWorkforcePoolProviderKeyRead,
		Delete: resourceIAMWorkforcePoolWorkforcePoolProviderKeyDelete,

		Importer: &schema.ResourceImporter{
			State: resourceIAMWorkforcePoolWorkforcePoolProviderKeyImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"key_data": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `Immutable. Public half of the asymmetric key.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"key_spec": {
							Type:         schema.TypeString,
							Required:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"RSA_2048", "RSA_3072", "RSA_4096"}),
							Description:  `The specifications for the key. Possible values: ["RSA_2048", "RSA_3072", "RSA_4096"]`,
						},
						"format": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The format of the key.`,
						},
						"key": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The key data. The format of the key is represented by the format field.`,
						},
						"not_after_time": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Latest timestamp when this key is valid. Attempts to use this key after this time will fail.
Only present if the key data represents a X.509 certificate.

Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits.
Offsets other than "Z" are also accepted.
Examples: "2014-10-02T15:01:23Z", "2014-10-02T15:01:23.045123456Z" or "2014-10-02T15:01:23+05:30".`,
						},
						"not_before_time": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Earliest timestamp when this key is valid. Attempts to use this key before this time will fail.
Only present if the key data represents a X.509 certificate.

Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits.
Offsets other than "Z" are also accepted.
Examples: "2014-10-02T15:01:23Z", "2014-10-02T15:01:23.045123456Z" or "2014-10-02T15:01:23+05:30".`,
						},
					},
				},
			},
			"key_id": {
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: ValidateWorkforcePoolProviderKeyId,
				Description:  `The ID to use for the key, which becomes the final component of the resource name. This value must be 4-32 characters, and may contain the characters [a-z0-9-].`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location for the resource.`,
			},
			"provider_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The ID of the provider.`,
			},
			"use": {
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"ENCRYPTION"}),
				Description:  `The purpose of the key. Possible values: ["ENCRYPTION"]`,
			},
			"workforce_pool_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The ID of the workforce pool.`,
			},
			"expire_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The time after which the key will be permanently deleted and cannot be recovered.
Note that the key may get purged before this time if the total limit of keys per provider is exceeded.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The resource name of the key.
Format: 'locations/{location}/workforcePools/{workforcePoolId}/providers/{providerId}/keys/{keyId}'`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The state of the key.`,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceIAMWorkforcePoolWorkforcePoolProviderKeyCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	keyDataProp, err := expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyData(d.Get("key_data"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("key_data"); !tpgresource.IsEmptyValue(reflect.ValueOf(keyDataProp)) && (ok || !reflect.DeepEqual(v, keyDataProp)) {
		obj["keyData"] = keyDataProp
	}
	useProp, err := expandIAMWorkforcePoolWorkforcePoolProviderKeyUse(d.Get("use"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("use"); !tpgresource.IsEmptyValue(reflect.ValueOf(useProp)) && (ok || !reflect.DeepEqual(v, useProp)) {
		obj["use"] = useProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{IAMWorkforcePoolBasePath}}locations/{{location}}/workforcePools/{{workforce_pool_id}}/providers/{{provider_id}}/keys?workforcePoolProviderKeyId={{key_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new WorkforcePoolProviderKey: %#v", obj)
	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating WorkforcePoolProviderKey: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "locations/{{location}}/workforcePools/{{workforce_pool_id}}/providers/{{provider_id}}/keys/{{key_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = IAMWorkforcePoolOperationWaitTime(
		config, res, "Creating WorkforcePoolProviderKey", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create WorkforcePoolProviderKey: %s", err)
	}

	log.Printf("[DEBUG] Finished creating WorkforcePoolProviderKey %q: %#v", d.Id(), res)

	return resourceIAMWorkforcePoolWorkforcePoolProviderKeyRead(d, meta)
}

func resourceIAMWorkforcePoolWorkforcePoolProviderKeyRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{IAMWorkforcePoolBasePath}}locations/{{location}}/workforcePools/{{workforce_pool_id}}/providers/{{provider_id}}/keys/{{key_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("IAMWorkforcePoolWorkforcePoolProviderKey %q", d.Id()))
	}

	if err := d.Set("name", flattenIAMWorkforcePoolWorkforcePoolProviderKeyName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading WorkforcePoolProviderKey: %s", err)
	}
	if err := d.Set("key_data", flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyData(res["keyData"], d, config)); err != nil {
		return fmt.Errorf("Error reading WorkforcePoolProviderKey: %s", err)
	}
	if err := d.Set("state", flattenIAMWorkforcePoolWorkforcePoolProviderKeyState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading WorkforcePoolProviderKey: %s", err)
	}
	if err := d.Set("use", flattenIAMWorkforcePoolWorkforcePoolProviderKeyUse(res["use"], d, config)); err != nil {
		return fmt.Errorf("Error reading WorkforcePoolProviderKey: %s", err)
	}
	if err := d.Set("expire_time", flattenIAMWorkforcePoolWorkforcePoolProviderKeyExpireTime(res["expireTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading WorkforcePoolProviderKey: %s", err)
	}

	return nil
}

func resourceIAMWorkforcePoolWorkforcePoolProviderKeyDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	url, err := tpgresource.ReplaceVars(d, config, "{{IAMWorkforcePoolBasePath}}locations/{{location}}/workforcePools/{{workforce_pool_id}}/providers/{{provider_id}}/keys/{{key_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting WorkforcePoolProviderKey %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "WorkforcePoolProviderKey")
	}

	err = IAMWorkforcePoolOperationWaitTime(
		config, res, "Deleting WorkforcePoolProviderKey", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting WorkforcePoolProviderKey %q: %#v", d.Id(), res)
	return nil
}

func resourceIAMWorkforcePoolWorkforcePoolProviderKeyImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^locations/(?P<location>[^/]+)/workforcePools/(?P<workforce_pool_id>[^/]+)/providers/(?P<provider_id>[^/]+)/keys/(?P<key_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<workforce_pool_id>[^/]+)/(?P<provider_id>[^/]+)/(?P<key_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "locations/{{location}}/workforcePools/{{workforce_pool_id}}/providers/{{provider_id}}/keys/{{key_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenIAMWorkforcePoolWorkforcePoolProviderKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyData(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["format"] =
		flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataFormat(original["format"], d, config)
	transformed["not_before_time"] =
		flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataNotBeforeTime(original["notBeforeTime"], d, config)
	transformed["not_after_time"] =
		flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataNotAfterTime(original["notAfterTime"], d, config)
	transformed["key"] =
		flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataKey(original["key"], d, config)
	transformed["key_spec"] =
		flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataKeySpec(original["keySpec"], d, config)
	return []interface{}{transformed}
}
func flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataFormat(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataNotBeforeTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataNotAfterTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataKeySpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIAMWorkforcePoolWorkforcePoolProviderKeyState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIAMWorkforcePoolWorkforcePoolProviderKeyUse(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIAMWorkforcePoolWorkforcePoolProviderKeyExpireTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyData(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFormat, err := expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataFormat(original["format"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFormat); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["format"] = transformedFormat
	}

	transformedNotBeforeTime, err := expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataNotBeforeTime(original["not_before_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNotBeforeTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["notBeforeTime"] = transformedNotBeforeTime
	}

	transformedNotAfterTime, err := expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataNotAfterTime(original["not_after_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNotAfterTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["notAfterTime"] = transformedNotAfterTime
	}

	transformedKey, err := expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataKey(original["key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["key"] = transformedKey
	}

	transformedKeySpec, err := expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataKeySpec(original["key_spec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKeySpec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["keySpec"] = transformedKeySpec
	}

	return transformed, nil
}

func expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataFormat(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataNotBeforeTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataNotAfterTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIAMWorkforcePoolWorkforcePoolProviderKeyKeyDataKeySpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIAMWorkforcePoolWorkforcePoolProviderKeyUse(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
