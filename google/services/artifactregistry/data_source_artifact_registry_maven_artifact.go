// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/artifactregistry/data_source_artifact_registry_maven_artifact.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package artifactregistry

import (
	"fmt"
	"net/url"
	"sort"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

type MavenArtifact struct {
	name       string
	pomUri     string
	version    string
	createTime string
	updateTime string
}

func DataSourceArtifactRegistryMavenArtifact() *schema.Resource {
	return &schema.Resource{
		Read: DataSourceArtifactRegistryMavenArtifactRead,

		Schema: map[string]*schema.Schema{
			"project": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"location": {
				Type:     schema.TypeString,
				Required: true,
			},
			"repository_id": {
				Type:     schema.TypeString,
				Required: true,
			},
			"group_id": {
				Type:     schema.TypeString,
				Required: true,
			},
			"artifact_id": {
				Type:     schema.TypeString,
				Required: true,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"pom_uri": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"version": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"create_time": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
	}
}

func DataSourceArtifactRegistryMavenArtifactRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return err
	}

	var res MavenArtifact

	artifactId, version := parseMavenArtifact(d.Get("artifact_id").(string))

	groupId := d.Get("group_id").(string)

	packageName := fmt.Sprintf("%s:%s", groupId, artifactId)

	if version != "" {
		// fetch package by version
		// https://cloud.google.com/artifact-registry/docs/reference/rest/v1/projects.locations.repositories.mavenArtifacts/get
		packageUrlSafe := url.QueryEscape(packageName)
		urlRequest, err := tpgresource.ReplaceVars(d, config, fmt.Sprintf("{{ArtifactRegistryBasePath}}projects/{{project}}/locations/{{location}}/repositories/{{repository_id}}/mavenArtifacts/%s:%s", packageUrlSafe, version))
		if err != nil {
			return fmt.Errorf("Error setting api endpoint")
		}

		resGet, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "GET",
			RawURL:    urlRequest,
			UserAgent: userAgent,
		})
		if err != nil {
			return err
		}

		res = convertMavenArtifactResponseToStruct(resGet)
	} else {
		// fetch the list of packages, ordered by update time
		// https://cloud.google.com/artifact-registry/docs/reference/rest/v1/projects.locations.repositories.mavenArtifacts/list
		urlRequest, err := tpgresource.ReplaceVars(d, config, "{{ArtifactRegistryBasePath}}projects/{{project}}/locations/{{location}}/repositories/{{repository_id}}/mavenArtifacts")
		if err != nil {
			return fmt.Errorf("Error setting api endpoint")
		}

		// to reduce the number of pages we need to fetch, we set the pageSize to 1000(max)
		urlRequest, err = transport_tpg.AddQueryParams(urlRequest, map[string]string{"pageSize": "1000"})
		if err != nil {
			return err
		}

		res, err = retrieveAndFilterMavenArtifacts(d, config, urlRequest, userAgent, groupId, artifactId, version)
		if err != nil {
			return err
		}
	}

	// Set Terraform schema fields
	if err := d.Set("project", project); err != nil {
		return err
	}
	if err := d.Set("name", res.name); err != nil {
		return err
	}
	if err := d.Set("pom_uri", res.pomUri); err != nil {
		return err
	}
	if err := d.Set("version", res.version); err != nil {
		return err
	}
	if err := d.Set("create_time", res.createTime); err != nil {
		return err
	}
	if err := d.Set("update_time", res.updateTime); err != nil {
		return err
	}

	d.SetId(res.name)

	return nil
}

func parseMavenArtifact(pkg string) (artifactId string, version string) {
	splitByColon := strings.Split(pkg, ":")

	if len(splitByColon) == 2 {
		artifactId = splitByColon[0]
		version = splitByColon[1]
	} else {
		artifactId = pkg
	}

	return artifactId, version
}

func retrieveAndFilterMavenArtifacts(d *schema.ResourceData, config *transport_tpg.Config, urlRequest string, userAgent string, groupId string, artifactId string, version string) (MavenArtifact, error) {
	// Paging through the list method until either:
	// if a version was provided, the matching package name and version pair
	// otherwise, return the first matching package name

	var allPackages []MavenArtifact

	for {
		resListMavenArtifacts, token, err := retrieveListOfMavenArtifacts(config, urlRequest, userAgent)
		if err != nil {
			return MavenArtifact{}, err
		}

		for _, pkg := range resListMavenArtifacts {
			if strings.Contains(pkg.name, "/"+url.QueryEscape(groupId)+":"+url.QueryEscape(artifactId)+":") {
				allPackages = append(allPackages, pkg)
			}
		}

		if token == "" {
			break
		}

		urlRequest, err = transport_tpg.AddQueryParams(urlRequest, map[string]string{"pageToken": token})
		if err != nil {
			return MavenArtifact{}, err
		}
	}

	if len(allPackages) == 0 {
		return MavenArtifact{}, fmt.Errorf("Requested Maven package was not found.")
	}

	// Client-side sort by updateTime descending (latest first)
	sort.Slice(allPackages, func(i, j int) bool {
		// Parse RFC3339 timestamps, fallback to string compare if parse fails
		ti, err1 := time.Parse(time.RFC3339, allPackages[i].updateTime)
		tj, err2 := time.Parse(time.RFC3339, allPackages[j].updateTime)
		if err1 == nil && err2 == nil {
			return ti.After(tj)
		}
		return allPackages[i].updateTime > allPackages[j].updateTime
	})

	if version != "" {
		for _, pkg := range allPackages {
			if pkg.version == version {
				return pkg, nil
			}
		}
		return MavenArtifact{}, fmt.Errorf("Requested version was not found.")
	}

	// Return the latest package if no version specified
	return allPackages[0], nil
}

func retrieveListOfMavenArtifacts(config *transport_tpg.Config, urlRequest string, userAgent string) ([]MavenArtifact, string, error) {
	resList, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		RawURL:    urlRequest,
		UserAgent: userAgent,
	})
	if err != nil {
		return make([]MavenArtifact, 0), "", err
	}

	if nextPageToken, ok := resList["nextPageToken"].(string); ok {
		return flattenMavenArtifactDataSourceListResponse(resList), nextPageToken, nil
	} else {
		return flattenMavenArtifactDataSourceListResponse(resList), "", nil
	}
}

func flattenMavenArtifactDataSourceListResponse(res map[string]interface{}) []MavenArtifact {
	var mavenArtifacts []MavenArtifact

	resMavenArtifacts, _ := res["mavenArtifacts"].([]interface{})

	for _, resPackage := range resMavenArtifacts {
		pkg, _ := resPackage.(map[string]interface{})
		mavenArtifacts = append(mavenArtifacts, convertMavenArtifactResponseToStruct(pkg))
	}

	return mavenArtifacts
}

func convertMavenArtifactResponseToStruct(res map[string]interface{}) MavenArtifact {
	var mavenArtifact MavenArtifact

	if name, ok := res["name"].(string); ok {
		mavenArtifact.name = name
	}

	if pomUri, ok := res["pomUri"].(string); ok {
		mavenArtifact.pomUri = pomUri
	}

	if version, ok := res["version"].(string); ok {
		mavenArtifact.version = version
	}

	if createTime, ok := res["createTime"].(string); ok {
		mavenArtifact.createTime = createTime
	}

	if updateTime, ok := res["updateTime"].(string); ok {
		mavenArtifact.updateTime = updateTime
	}

	return mavenArtifact
}
