// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/artifactregistry/data_source_artifact_registry_npm_package.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package artifactregistry

import (
	"fmt"
	"net/url"
	"sort"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

type NpmPackage struct {
	name        string
	packageName string
	version     string
	tags        []string
	createTime  time.Time
	updateTime  time.Time
}

func DataSourceArtifactRegistryNpmPackage() *schema.Resource {
	return &schema.Resource{
		Read: DataSourceArtifactRegistryNpmPackageRead,

		Schema: map[string]*schema.Schema{
			"project": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Project ID of the project.",
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The region of the Artifact Registry repository.",
			},
			"repository_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The repository ID containing the Npm package.",
			},
			"package_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The name of the Npm package.",
			},
			"version": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The version of the Npm package.",
			},
			"tags": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "The tags associated with the Npm package.",
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The fully qualified name of the Npm package.",
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The time the package was created.",
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The time the package was last updated.",
			},
		},
	}
}

func DataSourceArtifactRegistryNpmPackageRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return err
	}

	var res NpmPackage

	packageName, version := parseNpmPackage(d.Get("package_name").(string))

	if version != "" {
		// fetch package by version
		// https://cloud.google.com/artifact-registry/docs/reference/rest/v1/projects.locations.repositories.npmPackages/get
		packageUrlSafe := url.QueryEscape(packageName)
		urlRequest, err := tpgresource.ReplaceVars(d, config, fmt.Sprintf("{{ArtifactRegistryBasePath}}projects/{{project}}/locations/{{location}}/repositories/{{repository_id}}/npmPackages/%s:%s", packageUrlSafe, version))
		if err != nil {
			return fmt.Errorf("Error setting api endpoint")
		}

		resGet, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "GET",
			RawURL:    urlRequest,
			UserAgent: userAgent,
		})
		if err != nil {
			return err
		}

		res = convertNpmPackageResponseToStruct(resGet)
	} else {
		// fetch the list of packages, ordered by update time
		// https://cloud.google.com/artifact-registry/docs/reference/rest/v1/projects.locations.repositories.npmPackages/list
		urlRequest, err := tpgresource.ReplaceVars(d, config, "{{ArtifactRegistryBasePath}}projects/{{project}}/locations/{{location}}/repositories/{{repository_id}}/npmPackages")
		if err != nil {
			return fmt.Errorf("Error setting api endpoint")
		}

		// to reduce the number of pages we need to fetch, we set the pageSize to 1000(max)
		urlRequest, err = transport_tpg.AddQueryParams(urlRequest, map[string]string{"pageSize": "1000"})
		if err != nil {
			return err
		}

		res, err = retrieveAndFilterNpmPackages(d, config, urlRequest, userAgent, packageName, version)
		if err != nil {
			return err
		}
	}

	// Set Terraform schema fields
	if err := d.Set("project", project); err != nil {
		return err
	}
	if err := d.Set("package_name", packageName); err != nil {
		return err
	}
	if err := d.Set("name", res.name); err != nil {
		return err
	}
	if err := d.Set("version", res.version); err != nil {
		return err
	}
	if err := d.Set("tags", res.tags); err != nil {
		return err
	}
	if err := d.Set("create_time", res.createTime.Format(time.RFC3339Nano)); err != nil {
		return err
	}
	if err := d.Set("update_time", res.updateTime.Format(time.RFC3339Nano)); err != nil {
		return err
	}

	d.SetId(res.name)

	return nil
}

func parseNpmPackage(pkg string) (packageName string, version string) {
	splitByColon := strings.Split(pkg, ":")

	if len(splitByColon) == 2 {
		packageName = splitByColon[0]
		version = splitByColon[1]
	} else {
		packageName = pkg
	}

	return packageName, version
}

func retrieveAndFilterNpmPackages(d *schema.ResourceData, config *transport_tpg.Config, urlRequest string, userAgent string, packageName string, version string) (NpmPackage, error) {
	// Paging through the list method until either:
	// if a version was provided, the matching package name and version pair
	// otherwise, return the first matching package name

	var allPackages []NpmPackage

	for {
		resListNpmPackages, token, err := retrieveListOfNpmPackages(config, urlRequest, userAgent)
		if err != nil {
			return NpmPackage{}, err
		}

		for _, pkg := range resListNpmPackages {
			if strings.Contains(pkg.name, "/"+url.QueryEscape(packageName)+":") {
				allPackages = append(allPackages, pkg)
			}
		}

		if token == "" {
			break
		}

		urlRequest, err = transport_tpg.AddQueryParams(urlRequest, map[string]string{"pageToken": token})
		if err != nil {
			return NpmPackage{}, err
		}
	}

	if len(allPackages) == 0 {
		return NpmPackage{}, fmt.Errorf("Requested Npm package was not found.")
	}

	// Client-side sort by updateTime descending and createTime descending
	sort.Slice(allPackages, func(i, j int) bool {
		if !allPackages[i].updateTime.Equal(allPackages[j].updateTime) {
			return allPackages[i].updateTime.After(allPackages[j].updateTime)
		}
		return allPackages[i].createTime.After(allPackages[j].createTime)
	})

	if version != "" {
		for _, pkg := range allPackages {
			if pkg.version == version {
				return pkg, nil
			}
		}
		return NpmPackage{}, fmt.Errorf("Requested version was not found.")
	}

	// Return the latest package if no version specified
	return allPackages[0], nil
}

func retrieveListOfNpmPackages(config *transport_tpg.Config, urlRequest string, userAgent string) ([]NpmPackage, string, error) {
	resList, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		RawURL:    urlRequest,
		UserAgent: userAgent,
	})
	if err != nil {
		return make([]NpmPackage, 0), "", err
	}

	if nextPageToken, ok := resList["nextPageToken"].(string); ok {
		return flattenNpmPackageDataSourceListResponse(resList), nextPageToken, nil
	} else {
		return flattenNpmPackageDataSourceListResponse(resList), "", nil
	}
}

func flattenNpmPackageDataSourceListResponse(res map[string]interface{}) []NpmPackage {
	var npmPackages []NpmPackage

	resNpmPackages, _ := res["npmPackages"].([]interface{})

	for _, resPackage := range resNpmPackages {
		pkg, _ := resPackage.(map[string]interface{})
		npmPackages = append(npmPackages, convertNpmPackageResponseToStruct(pkg))
	}

	return npmPackages
}

func convertNpmPackageResponseToStruct(res map[string]interface{}) NpmPackage {
	var npmPackage NpmPackage

	if name, ok := res["name"].(string); ok {
		npmPackage.name = name
	}

	if packageName, ok := res["packageName"].(string); ok {
		npmPackage.packageName = packageName
	}

	if version, ok := res["version"].(string); ok {
		npmPackage.version = version
	}

	var tags []string
	if rawTags, ok := res["tags"].([]interface{}); ok {
		for _, tag := range rawTags {
			if tagStr, ok := tag.(string); ok {
				tags = append(tags, tagStr)
			}
		}
	}
	npmPackage.tags = tags

	if createTimeStr, ok := res["createTime"].(string); ok {
		npmPackage.createTime, _ = time.Parse(time.RFC3339, createTimeStr)
	}

	if updateTimeStr, ok := res["updateTime"].(string); ok {
		npmPackage.updateTime, _ = time.Parse(time.RFC3339, updateTimeStr)
	}

	return npmPackage
}
