// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/networkmanagement/data_source_network_management_connectivity_tests.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package networkmanagement

import (
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func DataSourceGoogleNetworkManagementConnectivityTests() *schema.Resource {
	testSchema := tpgresource.DatasourceSchemaFromResourceSchema(ResourceNetworkManagementConnectivityTest().Schema)
	return &schema.Resource{
		Read: dataSourceGoogleNetworkManagementConnectivityTests,
		Schema: map[string]*schema.Schema{
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"filter": {
				Type:        schema.TypeString,
				Description: `Lists the ConnectivityTests that match the filter expression. A filter expression filters the resources listed in the response.`,
				Optional:    true,
			},
			"connectivity_tests": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: testSchema,
				},
			},
		},
		UseJSONNumber: true,
	}
}

func dataSourceGoogleNetworkManagementConnectivityTests(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkManagementBasePath}}projects/{{project}}/locations/global/connectivityTests")
	if err != nil {
		return err
	}

	filter, has_filter := d.GetOk("filter")

	if has_filter {
		url, err = transport_tpg.AddQueryParams(url, map[string]string{"filter": filter.(string)})
		if err != nil {
			return err
		}
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connectivity Tests: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// To handle pagination locally
	allTests := make([]interface{}, 0)
	token := ""
	for paginate := true; paginate; {
		if token != "" {
			url, err = transport_tpg.AddQueryParams(url, map[string]string{"pageToken": token})
			if err != nil {
				return err
			}
		}
		tests, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "GET",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
		})
		if err != nil {
			return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("NetworkManagementConnectivityTests %q", d.Id()))
		}
		testsInterface := tests["resources"]
		if testsInterface == nil {
			break
		}
		allTests = append(allTests, testsInterface.([]interface{})...)
		tokenInterface := tests["nextPageToken"]
		if tokenInterface == nil {
			paginate = false
		} else {
			paginate = true
			token = tokenInterface.(string)
		}
	}
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("error setting project: %s", err)
	}

	if err := d.Set("filter", filter); err != nil {
		return fmt.Errorf("error setting filter: %s", err)
	}

	if err := d.Set("connectivity_tests", flattenNetworkManagementConnectivityTests(allTests, d, config)); err != nil {
		return fmt.Errorf("error setting connectivity tests: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/global/connectivityTests")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	if has_filter {
		id += "/filter=" + filter.(string)
	}
	d.SetId(id)
	return nil
}

func flattenNetworkManagementConnectivityTests(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":                   flattenNetworkManagementConnectivityTestName(original["name"], d, config),
			"description":            flattenNetworkManagementConnectivityTestDescription(original["description"], d, config),
			"source":                 flattenNetworkManagementConnectivityTestSource(original["source"], d, config),
			"destination":            flattenNetworkManagementConnectivityTestDestination(original["destination"], d, config),
			"protocol":               flattenNetworkManagementConnectivityTestProtocol(original["protocol"], d, config),
			"related_projects":       flattenNetworkManagementConnectivityTestRelatedProjects(original["relatedProjects"], d, config),
			"labels":                 flattenNetworkManagementConnectivityTestLabels(original["labels"], d, config),
			"round_trip":             flattenNetworkManagementConnectivityTestRoundTrip(original["roundTrip"], d, config),
			"bypass_firewall_checks": flattenNetworkManagementConnectivityTestBypassFirewallChecks(original["bypassFirewallChecks"], d, config),
			"terraform_labels":       flattenNetworkManagementConnectivityTestTerraformLabels(original["labels"], d, config),
			"effective_labels":       flattenNetworkManagementConnectivityTestEffectiveLabels(original["labels"], d, config),
			"project":                getDataFromName(original["name"], 1),
		})
	}
	return transformed
}

func getDataFromName(v interface{}, part int) string {
	name := v.(string)
	split := strings.Split(name, "/")
	return split[part]
}
