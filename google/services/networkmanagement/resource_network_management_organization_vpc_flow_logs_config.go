// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/networkmanagement/OrganizationVpcFlowLogsConfig.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package networkmanagement

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceNetworkManagementOrganizationVpcFlowLogsConfig() *schema.Resource {
	return &schema.Resource{
		Create: resourceNetworkManagementOrganizationVpcFlowLogsConfigCreate,
		Read:   resourceNetworkManagementOrganizationVpcFlowLogsConfigRead,
		Update: resourceNetworkManagementOrganizationVpcFlowLogsConfigUpdate,
		Delete: resourceNetworkManagementOrganizationVpcFlowLogsConfigDelete,

		Importer: &schema.ResourceImporter{
			State: resourceNetworkManagementOrganizationVpcFlowLogsConfigImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"organization": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"vpc_flow_logs_config_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"location": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource
within its parent collection as described in https://google.aip.dev/122. See documentation
for resource type 'networkmanagement.googleapis.com/VpcFlowLogsConfig'.`,
			},
			"organization": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"vpc_flow_logs_config_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Required. ID of the 'VpcFlowLogsConfig'.`,
			},
			"aggregation_interval": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				Description: `Optional. The aggregation interval for the logs. Default value is
INTERVAL_5_SEC.   Possible values: INTERVAL_5_SEC INTERVAL_30_SEC INTERVAL_1_MIN INTERVAL_5_MIN INTERVAL_10_MIN INTERVAL_15_MIN`,
			},
			"cross_project_metadata": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"CROSS_PROJECT_METADATA_ENABLED", "CROSS_PROJECT_METADATA_DISABLED", ""}),
				Description: `Determines whether to include cross project annotations in the logs.
This field is available only for organization configurations. If not
specified in org configs will be set to CROSS_PROJECT_METADATA_ENABLED.
Possible values:
CROSS_PROJECT_METADATA_ENABLED
CROSS_PROJECT_METADATA_DISABLED Possible values: ["CROSS_PROJECT_METADATA_ENABLED", "CROSS_PROJECT_METADATA_DISABLED"]`,
			},
			"description": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Optional. The user-supplied description of the VPC Flow Logs configuration. Maximum
of 512 characters.`,
			},
			"filter_expr": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Optional. Export filter used to define which VPC Flow Logs should be logged.`,
			},
			"flow_sampling": {
				Type:     schema.TypeFloat,
				Computed: true,
				Optional: true,
				Description: `Optional. The value of the field must be in (0, 1]. The sampling rate
of VPC Flow Logs where 1.0 means all collected logs are reported. Setting the
sampling rate to 0.0 is not allowed. If you want to disable VPC Flow Logs, use
the state field instead. Default value is 1.0`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Optional. Resource labels to represent the user-provided metadata.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"metadata": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				Description: `Optional. Configures whether all, none or a subset of metadata fields
should be added to the reported VPC flow logs. Default value is INCLUDE_ALL_METADATA.
  Possible values:  METADATA_UNSPECIFIED INCLUDE_ALL_METADATA EXCLUDE_ALL_METADATA CUSTOM_METADATA`,
			},
			"metadata_fields": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Optional. Custom metadata fields to include in the reported VPC flow
logs. Can only be specified if \"metadata\" was set to CUSTOM_METADATA.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"state": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				Description: `Optional. The state of the VPC Flow Log configuration. Default value
is ENABLED. When creating a new configuration, it must be enabled.
Possible values: ENABLED DISABLED`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The time the config was created.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Identifier. Unique name of the configuration using the form:     'organizations/{org_id}/locations/global/vpcFlowLogsConfigs/{vpc_flow_logs_config_id}'`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The time the config was updated.`,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceNetworkManagementOrganizationVpcFlowLogsConfigCreate(d *schema.ResourceData, meta interface{}) error {
	var project string
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	stateProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigState(d.Get("state"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("state"); !tpgresource.IsEmptyValue(reflect.ValueOf(stateProp)) && (ok || !reflect.DeepEqual(v, stateProp)) {
		obj["state"] = stateProp
	}
	aggregationIntervalProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigAggregationInterval(d.Get("aggregation_interval"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("aggregation_interval"); !tpgresource.IsEmptyValue(reflect.ValueOf(aggregationIntervalProp)) && (ok || !reflect.DeepEqual(v, aggregationIntervalProp)) {
		obj["aggregationInterval"] = aggregationIntervalProp
	}
	flowSamplingProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigFlowSampling(d.Get("flow_sampling"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("flow_sampling"); !tpgresource.IsEmptyValue(reflect.ValueOf(flowSamplingProp)) && (ok || !reflect.DeepEqual(v, flowSamplingProp)) {
		obj["flowSampling"] = flowSamplingProp
	}
	metadataProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigMetadata(d.Get("metadata"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("metadata"); !tpgresource.IsEmptyValue(reflect.ValueOf(metadataProp)) && (ok || !reflect.DeepEqual(v, metadataProp)) {
		obj["metadata"] = metadataProp
	}
	metadataFieldsProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigMetadataFields(d.Get("metadata_fields"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("metadata_fields"); !tpgresource.IsEmptyValue(reflect.ValueOf(metadataFieldsProp)) && (ok || !reflect.DeepEqual(v, metadataFieldsProp)) {
		obj["metadataFields"] = metadataFieldsProp
	}
	filterExprProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigFilterExpr(d.Get("filter_expr"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("filter_expr"); !tpgresource.IsEmptyValue(reflect.ValueOf(filterExprProp)) && (ok || !reflect.DeepEqual(v, filterExprProp)) {
		obj["filterExpr"] = filterExprProp
	}
	crossProjectMetadataProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigCrossProjectMetadata(d.Get("cross_project_metadata"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cross_project_metadata"); !tpgresource.IsEmptyValue(reflect.ValueOf(crossProjectMetadataProp)) && (ok || !reflect.DeepEqual(v, crossProjectMetadataProp)) {
		obj["crossProjectMetadata"] = crossProjectMetadataProp
	}
	effectiveLabelsProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkManagementBasePath}}organizations/{{organization}}/locations/{{location}}/vpcFlowLogsConfigs?vpcFlowLogsConfigId={{vpc_flow_logs_config_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new OrganizationVpcFlowLogsConfig: %#v", obj)
	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating OrganizationVpcFlowLogsConfig: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "organizations/{{organization}}/locations/{{location}}/vpcFlowLogsConfigs/{{vpc_flow_logs_config_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if organizationValue, ok := d.GetOk("organization"); ok && organizationValue.(string) != "" {
			if err = identity.Set("organization", organizationValue.(string)); err != nil {
				return fmt.Errorf("Error setting organization: %s", err)
			}
		}
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if vpcFlowLogsConfigIdValue, ok := d.GetOk("vpc_flow_logs_config_id"); ok && vpcFlowLogsConfigIdValue.(string) != "" {
			if err = identity.Set("vpc_flow_logs_config_id", vpcFlowLogsConfigIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting vpc_flow_logs_config_id: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = NetworkManagementOperationWaitTime(
		config, res, project, "Creating OrganizationVpcFlowLogsConfig", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create OrganizationVpcFlowLogsConfig: %s", err)
	}

	log.Printf("[DEBUG] Finished creating OrganizationVpcFlowLogsConfig %q: %#v", d.Id(), res)

	return resourceNetworkManagementOrganizationVpcFlowLogsConfigRead(d, meta)
}

func resourceNetworkManagementOrganizationVpcFlowLogsConfigRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkManagementBasePath}}organizations/{{organization}}/locations/{{location}}/vpcFlowLogsConfigs/{{vpc_flow_logs_config_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("NetworkManagementOrganizationVpcFlowLogsConfig %q", d.Id()))
	}

	if err := d.Set("name", flattenNetworkManagementOrganizationVpcFlowLogsConfigName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("description", flattenNetworkManagementOrganizationVpcFlowLogsConfigDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("state", flattenNetworkManagementOrganizationVpcFlowLogsConfigState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("aggregation_interval", flattenNetworkManagementOrganizationVpcFlowLogsConfigAggregationInterval(res["aggregationInterval"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("flow_sampling", flattenNetworkManagementOrganizationVpcFlowLogsConfigFlowSampling(res["flowSampling"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("metadata", flattenNetworkManagementOrganizationVpcFlowLogsConfigMetadata(res["metadata"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("metadata_fields", flattenNetworkManagementOrganizationVpcFlowLogsConfigMetadataFields(res["metadataFields"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("filter_expr", flattenNetworkManagementOrganizationVpcFlowLogsConfigFilterExpr(res["filterExpr"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("labels", flattenNetworkManagementOrganizationVpcFlowLogsConfigLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("create_time", flattenNetworkManagementOrganizationVpcFlowLogsConfigCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("update_time", flattenNetworkManagementOrganizationVpcFlowLogsConfigUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("cross_project_metadata", flattenNetworkManagementOrganizationVpcFlowLogsConfigCrossProjectMetadata(res["crossProjectMetadata"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("terraform_labels", flattenNetworkManagementOrganizationVpcFlowLogsConfigTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}
	if err := d.Set("effective_labels", flattenNetworkManagementOrganizationVpcFlowLogsConfigEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading OrganizationVpcFlowLogsConfig: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("organization"); !ok && v == "" {
			err = identity.Set("organization", d.Get("organization").(string))
			if err != nil {
				return fmt.Errorf("Error setting organization: %s", err)
			}
		}
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("vpc_flow_logs_config_id"); !ok && v == "" {
			err = identity.Set("vpc_flow_logs_config_id", d.Get("vpc_flow_logs_config_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting vpc_flow_logs_config_id: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceNetworkManagementOrganizationVpcFlowLogsConfigUpdate(d *schema.ResourceData, meta interface{}) error {
	var project string
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if organizationValue, ok := d.GetOk("organization"); ok && organizationValue.(string) != "" {
			if err = identity.Set("organization", organizationValue.(string)); err != nil {
				return fmt.Errorf("Error setting organization: %s", err)
			}
		}
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if vpcFlowLogsConfigIdValue, ok := d.GetOk("vpc_flow_logs_config_id"); ok && vpcFlowLogsConfigIdValue.(string) != "" {
			if err = identity.Set("vpc_flow_logs_config_id", vpcFlowLogsConfigIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting vpc_flow_logs_config_id: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	obj := make(map[string]interface{})
	descriptionProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	stateProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigState(d.Get("state"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("state"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, stateProp)) {
		obj["state"] = stateProp
	}
	aggregationIntervalProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigAggregationInterval(d.Get("aggregation_interval"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("aggregation_interval"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, aggregationIntervalProp)) {
		obj["aggregationInterval"] = aggregationIntervalProp
	}
	flowSamplingProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigFlowSampling(d.Get("flow_sampling"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("flow_sampling"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, flowSamplingProp)) {
		obj["flowSampling"] = flowSamplingProp
	}
	metadataProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigMetadata(d.Get("metadata"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("metadata"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, metadataProp)) {
		obj["metadata"] = metadataProp
	}
	metadataFieldsProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigMetadataFields(d.Get("metadata_fields"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("metadata_fields"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, metadataFieldsProp)) {
		obj["metadataFields"] = metadataFieldsProp
	}
	filterExprProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigFilterExpr(d.Get("filter_expr"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("filter_expr"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, filterExprProp)) {
		obj["filterExpr"] = filterExprProp
	}
	crossProjectMetadataProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigCrossProjectMetadata(d.Get("cross_project_metadata"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cross_project_metadata"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, crossProjectMetadataProp)) {
		obj["crossProjectMetadata"] = crossProjectMetadataProp
	}
	effectiveLabelsProp, err := expandNetworkManagementOrganizationVpcFlowLogsConfigEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkManagementBasePath}}organizations/{{organization}}/locations/{{location}}/vpcFlowLogsConfigs/{{vpc_flow_logs_config_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating OrganizationVpcFlowLogsConfig %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("state") {
		updateMask = append(updateMask, "state")
	}

	if d.HasChange("aggregation_interval") {
		updateMask = append(updateMask, "aggregationInterval")
	}

	if d.HasChange("flow_sampling") {
		updateMask = append(updateMask, "flowSampling")
	}

	if d.HasChange("metadata") {
		updateMask = append(updateMask, "metadata")
	}

	if d.HasChange("metadata_fields") {
		updateMask = append(updateMask, "metadataFields")
	}

	if d.HasChange("filter_expr") {
		updateMask = append(updateMask, "filterExpr")
	}

	if d.HasChange("cross_project_metadata") {
		updateMask = append(updateMask, "crossProjectMetadata")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating OrganizationVpcFlowLogsConfig %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating OrganizationVpcFlowLogsConfig %q: %#v", d.Id(), res)
		}

		err = NetworkManagementOperationWaitTime(
			config, res, project, "Updating OrganizationVpcFlowLogsConfig", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceNetworkManagementOrganizationVpcFlowLogsConfigRead(d, meta)
}

func resourceNetworkManagementOrganizationVpcFlowLogsConfigDelete(d *schema.ResourceData, meta interface{}) error {
	var project string
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkManagementBasePath}}organizations/{{organization}}/locations/{{location}}/vpcFlowLogsConfigs/{{vpc_flow_logs_config_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting OrganizationVpcFlowLogsConfig %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "OrganizationVpcFlowLogsConfig")
	}

	err = NetworkManagementOperationWaitTime(
		config, res, project, "Deleting OrganizationVpcFlowLogsConfig", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting OrganizationVpcFlowLogsConfig %q: %#v", d.Id(), res)
	return nil
}

func resourceNetworkManagementOrganizationVpcFlowLogsConfigImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^organizations/(?P<organization>[^/]+)/locations/(?P<location>[^/]+)/vpcFlowLogsConfigs/(?P<vpc_flow_logs_config_id>[^/]+)$",
		"^(?P<organization>[^/]+)/(?P<location>[^/]+)/(?P<vpc_flow_logs_config_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "organizations/{{organization}}/locations/{{location}}/vpcFlowLogsConfigs/{{vpc_flow_logs_config_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigAggregationInterval(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigFlowSampling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigMetadata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigMetadataFields(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigFilterExpr(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigCrossProjectMetadata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkManagementOrganizationVpcFlowLogsConfigEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandNetworkManagementOrganizationVpcFlowLogsConfigDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkManagementOrganizationVpcFlowLogsConfigState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkManagementOrganizationVpcFlowLogsConfigAggregationInterval(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkManagementOrganizationVpcFlowLogsConfigFlowSampling(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkManagementOrganizationVpcFlowLogsConfigMetadata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkManagementOrganizationVpcFlowLogsConfigMetadataFields(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkManagementOrganizationVpcFlowLogsConfigFilterExpr(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkManagementOrganizationVpcFlowLogsConfigCrossProjectMetadata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkManagementOrganizationVpcFlowLogsConfigEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
