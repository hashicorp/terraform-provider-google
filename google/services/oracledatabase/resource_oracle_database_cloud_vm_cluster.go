// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package oracledatabase

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceOracleDatabaseCloudVmCluster() *schema.Resource {
	return &schema.Resource{
		Create: resourceOracleDatabaseCloudVmClusterCreate,
		Read:   resourceOracleDatabaseCloudVmClusterRead,
		Update: resourceOracleDatabaseCloudVmClusterUpdate,
		Delete: resourceOracleDatabaseCloudVmClusterDelete,

		Importer: &schema.ResourceImporter{
			State: resourceOracleDatabaseCloudVmClusterImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(120 * time.Minute),
			Update: schema.DefaultTimeout(60 * time.Minute),
			Delete: schema.DefaultTimeout(60 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"backup_subnet_cidr": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `CIDR range of the backup subnet.`,
			},
			"cidr": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Network settings. CIDR to use for cluster IP allocation.`,
			},
			"cloud_vm_cluster_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The ID of the VM Cluster to create. This value is restricted
to (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$) and must be a maximum of 63
characters in length. The value must start with a letter and end with
a letter or a number.`,
			},
			"exadata_infrastructure": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The name of the Exadata Infrastructure resource on which VM cluster
resource is created, in the following format:
projects/{project}/locations/{region}/cloudExadataInfrastuctures/{cloud_extradata_infrastructure}`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. See documentation for resource type 'oracledatabase.googleapis.com/DbNode'.`,
			},
			"network": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The name of the VPC network.
Format: projects/{project}/global/networks/{network}`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `User friendly name for this resource.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Labels or tags associated with the VM Cluster. 

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"properties": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Various properties and settings associated with Exadata VM cluster.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cpu_core_count": {
							Type:        schema.TypeInt,
							Required:    true,
							ForceNew:    true,
							Description: `Number of enabled CPU cores.`,
						},
						"license_type": {
							Type:     schema.TypeString,
							Required: true,
							ForceNew: true,
							Description: `License type of VM Cluster. 
 Possible values:
 LICENSE_TYPE_UNSPECIFIED
LICENSE_INCLUDED
BRING_YOUR_OWN_LICENSE`,
						},
						"cluster_name": {
							Type:        schema.TypeString,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `OCI Cluster name.`,
						},
						"data_storage_size_tb": {
							Type:        schema.TypeFloat,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `The data disk group size to be allocated in TBs.`,
						},
						"db_node_storage_size_gb": {
							Type:        schema.TypeInt,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Local storage per VM`,
						},
						"db_server_ocids": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `OCID of database servers.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"diagnostics_data_collection_options": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Data collection options for diagnostics.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"diagnostics_events_enabled": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: `Indicates whether diagnostic collection is enabled for the VM cluster`,
									},
									"health_monitoring_enabled": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: `Indicates whether health monitoring is enabled for the VM cluster`,
									},
									"incident_logs_enabled": {
										Type:     schema.TypeBool,
										Optional: true,
										ForceNew: true,
										Description: `Indicates whether incident logs and trace collection are enabled for the VM
cluster`,
									},
								},
							},
						},
						"disk_redundancy": {
							Type:     schema.TypeString,
							Computed: true,
							Optional: true,
							ForceNew: true,
							Description: `The type of redundancy. 
 Possible values:
 DISK_REDUNDANCY_UNSPECIFIED
HIGH
NORMAL`,
						},
						"gi_version": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `Grid Infrastructure Version.`,
						},
						"hostname_prefix": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `Prefix for VM cluster host names.`,
						},
						"local_backup_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							ForceNew:    true,
							Description: `Use local backup.`,
						},
						"memory_size_gb": {
							Type:        schema.TypeInt,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Memory allocated in GBs.`,
						},
						"node_count": {
							Type:        schema.TypeInt,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Number of database servers.`,
						},
						"ocpu_count": {
							Type:        schema.TypeFloat,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `OCPU count per VM. Minimum is 0.1.`,
						},
						"sparse_diskgroup_enabled": {
							Type:        schema.TypeBool,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Use exadata sparse snapshots.`,
						},
						"ssh_public_keys": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `SSH public keys to be stored with cluster.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"time_zone": {
							Type:     schema.TypeList,
							Computed: true,
							Optional: true,
							ForceNew: true,
							Description: `Represents a time zone from the
[IANA Time Zone Database](https://www.iana.org/time-zones).`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `IANA Time Zone Database time zone, e.g. "America/New_York".`,
									},
								},
							},
						},
						"compartment_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Compartment ID of cluster.`,
						},
						"dns_listener_ip": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `DNS listener IP.`,
						},
						"domain": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Parent DNS domain where SCAN DNS and hosts names are qualified.
ex: ocispdelegated.ocisp10jvnet.oraclevcn.com`,
						},
						"hostname": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `host name without domain.
format: "-" with some suffix.
ex: sp2-yi0xq where "sp2" is the hostname_prefix.`,
						},
						"oci_url": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Deep link to the OCI console to view this resource.`,
						},
						"ocid": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Oracle Cloud Infrastructure ID of VM Cluster.`,
						},
						"scan_dns": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `SCAN DNS name.
ex: sp2-yi0xq-scan.ocispdelegated.ocisp10jvnet.oraclevcn.com`,
						},
						"scan_dns_record_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `OCID of scan DNS record.`,
						},
						"scan_ip_ids": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `OCIDs of scan IPs.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"scan_listener_port_tcp": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `SCAN listener port - TCP`,
						},
						"scan_listener_port_tcp_ssl": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `SCAN listener port - TLS`,
						},
						"shape": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Shape of VM Cluster.`,
						},
						"state": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `State of the cluster. 
 Possible values:
 STATE_UNSPECIFIED
PROVISIONING
AVAILABLE
UPDATING
TERMINATING
TERMINATED
FAILED
MAINTENANCE_IN_PROGRESS`,
						},
						"storage_size_gb": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The storage allocation for the disk group, in gigabytes (GB).`,
						},
						"system_version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Operating system version of the image.`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The date and time that the VM cluster was created.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				ForceNew:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"gcp_oracle_zone": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `GCP location where Oracle Exadata is hosted. It is same as GCP Oracle zone
of Exadata infrastructure.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The name of the VM Cluster resource with the format:
projects/{project}/locations/{region}/cloudVmClusters/{cloud_vm_cluster}`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"deletion_protection": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Whether Terraform will be prevented from destroying the cluster. Deleting this cluster via terraform destroy or terraform apply will only succeed if this field is false in the Terraform state.`,
				Default:     true,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceOracleDatabaseCloudVmClusterCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	exadataInfrastructureProp, err := expandOracleDatabaseCloudVmClusterExadataInfrastructure(d.Get("exadata_infrastructure"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("exadata_infrastructure"); !tpgresource.IsEmptyValue(reflect.ValueOf(exadataInfrastructureProp)) && (ok || !reflect.DeepEqual(v, exadataInfrastructureProp)) {
		obj["exadataInfrastructure"] = exadataInfrastructureProp
	}
	displayNameProp, err := expandOracleDatabaseCloudVmClusterDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	propertiesProp, err := expandOracleDatabaseCloudVmClusterProperties(d.Get("properties"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("properties"); !tpgresource.IsEmptyValue(reflect.ValueOf(propertiesProp)) && (ok || !reflect.DeepEqual(v, propertiesProp)) {
		obj["properties"] = propertiesProp
	}
	cidrProp, err := expandOracleDatabaseCloudVmClusterCidr(d.Get("cidr"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cidr"); !tpgresource.IsEmptyValue(reflect.ValueOf(cidrProp)) && (ok || !reflect.DeepEqual(v, cidrProp)) {
		obj["cidr"] = cidrProp
	}
	backupSubnetCidrProp, err := expandOracleDatabaseCloudVmClusterBackupSubnetCidr(d.Get("backup_subnet_cidr"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backup_subnet_cidr"); !tpgresource.IsEmptyValue(reflect.ValueOf(backupSubnetCidrProp)) && (ok || !reflect.DeepEqual(v, backupSubnetCidrProp)) {
		obj["backupSubnetCidr"] = backupSubnetCidrProp
	}
	networkProp, err := expandOracleDatabaseCloudVmClusterNetwork(d.Get("network"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network"); !tpgresource.IsEmptyValue(reflect.ValueOf(networkProp)) && (ok || !reflect.DeepEqual(v, networkProp)) {
		obj["network"] = networkProp
	}
	labelsProp, err := expandOracleDatabaseCloudVmClusterEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{OracleDatabaseBasePath}}projects/{{project}}/locations/{{location}}/cloudVmClusters?cloudVmClusterId={{cloud_vm_cluster_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new CloudVmCluster: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for CloudVmCluster: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating CloudVmCluster: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/cloudVmClusters/{{cloud_vm_cluster_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = OracleDatabaseOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating CloudVmCluster", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create CloudVmCluster: %s", err)
	}

	if err := d.Set("name", flattenOracleDatabaseCloudVmClusterName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/cloudVmClusters/{{cloud_vm_cluster_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating CloudVmCluster %q: %#v", d.Id(), res)

	return resourceOracleDatabaseCloudVmClusterRead(d, meta)
}

func resourceOracleDatabaseCloudVmClusterRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{OracleDatabaseBasePath}}projects/{{project}}/locations/{{location}}/cloudVmClusters/{{cloud_vm_cluster_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for CloudVmCluster: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("OracleDatabaseCloudVmCluster %q", d.Id()))
	}

	// Explicitly set virtual fields to default values if unset
	if _, ok := d.GetOkExists("deletion_protection"); !ok {
		if err := d.Set("deletion_protection", true); err != nil {
			return fmt.Errorf("Error setting deletion_protection: %s", err)
		}
	}
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}

	if err := d.Set("name", flattenOracleDatabaseCloudVmClusterName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}
	if err := d.Set("exadata_infrastructure", flattenOracleDatabaseCloudVmClusterExadataInfrastructure(res["exadataInfrastructure"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}
	if err := d.Set("display_name", flattenOracleDatabaseCloudVmClusterDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}
	if err := d.Set("gcp_oracle_zone", flattenOracleDatabaseCloudVmClusterGcpOracleZone(res["gcpOracleZone"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}
	if err := d.Set("properties", flattenOracleDatabaseCloudVmClusterProperties(res["properties"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}
	if err := d.Set("labels", flattenOracleDatabaseCloudVmClusterLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}
	if err := d.Set("create_time", flattenOracleDatabaseCloudVmClusterCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}
	if err := d.Set("cidr", flattenOracleDatabaseCloudVmClusterCidr(res["cidr"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}
	if err := d.Set("backup_subnet_cidr", flattenOracleDatabaseCloudVmClusterBackupSubnetCidr(res["backupSubnetCidr"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}
	if err := d.Set("network", flattenOracleDatabaseCloudVmClusterNetwork(res["network"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}
	if err := d.Set("terraform_labels", flattenOracleDatabaseCloudVmClusterTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}
	if err := d.Set("effective_labels", flattenOracleDatabaseCloudVmClusterEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading CloudVmCluster: %s", err)
	}

	return nil
}

func resourceOracleDatabaseCloudVmClusterUpdate(d *schema.ResourceData, meta interface{}) error {
	// Only the root field "labels" and "terraform_labels" are mutable
	return resourceOracleDatabaseCloudVmClusterRead(d, meta)
}

func resourceOracleDatabaseCloudVmClusterDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for CloudVmCluster: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{OracleDatabaseBasePath}}projects/{{project}}/locations/{{location}}/cloudVmClusters/{{cloud_vm_cluster_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	if d.Get("deletion_protection").(bool) {
		return fmt.Errorf("cannot destroy google_oracle_database_cloud_vm_cluster resource with id : %q  without setting deletion_protection=false and running `terraform apply`", d.Id())
	}

	log.Printf("[DEBUG] Deleting CloudVmCluster %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "CloudVmCluster")
	}

	err = OracleDatabaseOperationWaitTime(
		config, res, project, "Deleting CloudVmCluster", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting CloudVmCluster %q: %#v", d.Id(), res)
	return nil
}

func resourceOracleDatabaseCloudVmClusterImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/cloudVmClusters/(?P<cloud_vm_cluster_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<cloud_vm_cluster_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<cloud_vm_cluster_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/cloudVmClusters/{{cloud_vm_cluster_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Explicitly set virtual fields to default values on import
	if err := d.Set("deletion_protection", true); err != nil {
		return nil, fmt.Errorf("Error setting deletion_protection: %s", err)
	}

	return []*schema.ResourceData{d}, nil
}

func flattenOracleDatabaseCloudVmClusterName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterExadataInfrastructure(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterGcpOracleZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ocid"] =
		flattenOracleDatabaseCloudVmClusterPropertiesOcid(original["ocid"], d, config)
	transformed["license_type"] =
		flattenOracleDatabaseCloudVmClusterPropertiesLicenseType(original["licenseType"], d, config)
	transformed["gi_version"] =
		flattenOracleDatabaseCloudVmClusterPropertiesGiVersion(original["giVersion"], d, config)
	transformed["time_zone"] =
		flattenOracleDatabaseCloudVmClusterPropertiesTimeZone(original["timeZone"], d, config)
	transformed["ssh_public_keys"] =
		flattenOracleDatabaseCloudVmClusterPropertiesSshPublicKeys(original["sshPublicKeys"], d, config)
	transformed["node_count"] =
		flattenOracleDatabaseCloudVmClusterPropertiesNodeCount(original["nodeCount"], d, config)
	transformed["shape"] =
		flattenOracleDatabaseCloudVmClusterPropertiesShape(original["shape"], d, config)
	transformed["ocpu_count"] =
		flattenOracleDatabaseCloudVmClusterPropertiesOcpuCount(original["ocpuCount"], d, config)
	transformed["memory_size_gb"] =
		flattenOracleDatabaseCloudVmClusterPropertiesMemorySizeGb(original["memorySizeGb"], d, config)
	transformed["db_node_storage_size_gb"] =
		flattenOracleDatabaseCloudVmClusterPropertiesDbNodeStorageSizeGb(original["dbNodeStorageSizeGb"], d, config)
	transformed["storage_size_gb"] =
		flattenOracleDatabaseCloudVmClusterPropertiesStorageSizeGb(original["storageSizeGb"], d, config)
	transformed["data_storage_size_tb"] =
		flattenOracleDatabaseCloudVmClusterPropertiesDataStorageSizeTb(original["dataStorageSizeTb"], d, config)
	transformed["disk_redundancy"] =
		flattenOracleDatabaseCloudVmClusterPropertiesDiskRedundancy(original["diskRedundancy"], d, config)
	transformed["sparse_diskgroup_enabled"] =
		flattenOracleDatabaseCloudVmClusterPropertiesSparseDiskgroupEnabled(original["sparseDiskgroupEnabled"], d, config)
	transformed["local_backup_enabled"] =
		flattenOracleDatabaseCloudVmClusterPropertiesLocalBackupEnabled(original["localBackupEnabled"], d, config)
	transformed["hostname_prefix"] =
		flattenOracleDatabaseCloudVmClusterPropertiesHostnamePrefix(original["hostnamePrefix"], d, config)
	transformed["diagnostics_data_collection_options"] =
		flattenOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptions(original["diagnosticsDataCollectionOptions"], d, config)
	transformed["state"] =
		flattenOracleDatabaseCloudVmClusterPropertiesState(original["state"], d, config)
	transformed["scan_listener_port_tcp"] =
		flattenOracleDatabaseCloudVmClusterPropertiesScanListenerPortTcp(original["scanListenerPortTcp"], d, config)
	transformed["scan_listener_port_tcp_ssl"] =
		flattenOracleDatabaseCloudVmClusterPropertiesScanListenerPortTcpSsl(original["scanListenerPortTcpSsl"], d, config)
	transformed["domain"] =
		flattenOracleDatabaseCloudVmClusterPropertiesDomain(original["domain"], d, config)
	transformed["scan_dns"] =
		flattenOracleDatabaseCloudVmClusterPropertiesScanDns(original["scanDns"], d, config)
	transformed["hostname"] =
		flattenOracleDatabaseCloudVmClusterPropertiesHostname(original["hostname"], d, config)
	transformed["cpu_core_count"] =
		flattenOracleDatabaseCloudVmClusterPropertiesCpuCoreCount(original["cpuCoreCount"], d, config)
	transformed["system_version"] =
		flattenOracleDatabaseCloudVmClusterPropertiesSystemVersion(original["systemVersion"], d, config)
	transformed["scan_ip_ids"] =
		flattenOracleDatabaseCloudVmClusterPropertiesScanIpIds(original["scanIpIds"], d, config)
	transformed["scan_dns_record_id"] =
		flattenOracleDatabaseCloudVmClusterPropertiesScanDnsRecordId(original["scanDnsRecordId"], d, config)
	transformed["oci_url"] =
		flattenOracleDatabaseCloudVmClusterPropertiesOciUrl(original["ociUrl"], d, config)
	transformed["db_server_ocids"] =
		flattenOracleDatabaseCloudVmClusterPropertiesDbServerOcids(original["dbServerOcids"], d, config)
	transformed["compartment_id"] =
		flattenOracleDatabaseCloudVmClusterPropertiesCompartmentId(original["compartmentId"], d, config)
	transformed["dns_listener_ip"] =
		flattenOracleDatabaseCloudVmClusterPropertiesDnsListenerIp(original["dnsListenerIp"], d, config)
	transformed["cluster_name"] =
		flattenOracleDatabaseCloudVmClusterPropertiesClusterName(original["clusterName"], d, config)
	return []interface{}{transformed}
}
func flattenOracleDatabaseCloudVmClusterPropertiesOcid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesLicenseType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesGiVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("properties.0.gi_version")
}

func flattenOracleDatabaseCloudVmClusterPropertiesTimeZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["id"] =
		flattenOracleDatabaseCloudVmClusterPropertiesTimeZoneId(original["id"], d, config)
	return []interface{}{transformed}
}
func flattenOracleDatabaseCloudVmClusterPropertiesTimeZoneId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesSshPublicKeys(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenOracleDatabaseCloudVmClusterPropertiesShape(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesOcpuCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesMemorySizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenOracleDatabaseCloudVmClusterPropertiesDbNodeStorageSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenOracleDatabaseCloudVmClusterPropertiesStorageSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenOracleDatabaseCloudVmClusterPropertiesDataStorageSizeTb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesDiskRedundancy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesSparseDiskgroupEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesLocalBackupEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesHostnamePrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("properties.0.hostname_prefix")
}

func flattenOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["diagnostics_events_enabled"] =
		flattenOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsDiagnosticsEventsEnabled(original["diagnosticsEventsEnabled"], d, config)
	transformed["health_monitoring_enabled"] =
		flattenOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsHealthMonitoringEnabled(original["healthMonitoringEnabled"], d, config)
	transformed["incident_logs_enabled"] =
		flattenOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsIncidentLogsEnabled(original["incidentLogsEnabled"], d, config)
	return []interface{}{transformed}
}
func flattenOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsDiagnosticsEventsEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsHealthMonitoringEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsIncidentLogsEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesScanListenerPortTcp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenOracleDatabaseCloudVmClusterPropertiesScanListenerPortTcpSsl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenOracleDatabaseCloudVmClusterPropertiesDomain(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesScanDns(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesCpuCoreCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenOracleDatabaseCloudVmClusterPropertiesSystemVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesScanIpIds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesScanDnsRecordId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesOciUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesDbServerOcids(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesCompartmentId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesDnsListenerIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterPropertiesClusterName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenOracleDatabaseCloudVmClusterCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterCidr(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterBackupSubnetCidr(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOracleDatabaseCloudVmClusterTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenOracleDatabaseCloudVmClusterEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandOracleDatabaseCloudVmClusterExadataInfrastructure(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOcid, err := expandOracleDatabaseCloudVmClusterPropertiesOcid(original["ocid"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOcid); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ocid"] = transformedOcid
	}

	transformedLicenseType, err := expandOracleDatabaseCloudVmClusterPropertiesLicenseType(original["license_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLicenseType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["licenseType"] = transformedLicenseType
	}

	transformedGiVersion, err := expandOracleDatabaseCloudVmClusterPropertiesGiVersion(original["gi_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGiVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["giVersion"] = transformedGiVersion
	}

	transformedTimeZone, err := expandOracleDatabaseCloudVmClusterPropertiesTimeZone(original["time_zone"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeZone); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["timeZone"] = transformedTimeZone
	}

	transformedSshPublicKeys, err := expandOracleDatabaseCloudVmClusterPropertiesSshPublicKeys(original["ssh_public_keys"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSshPublicKeys); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sshPublicKeys"] = transformedSshPublicKeys
	}

	transformedNodeCount, err := expandOracleDatabaseCloudVmClusterPropertiesNodeCount(original["node_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nodeCount"] = transformedNodeCount
	}

	transformedShape, err := expandOracleDatabaseCloudVmClusterPropertiesShape(original["shape"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedShape); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["shape"] = transformedShape
	}

	transformedOcpuCount, err := expandOracleDatabaseCloudVmClusterPropertiesOcpuCount(original["ocpu_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOcpuCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ocpuCount"] = transformedOcpuCount
	}

	transformedMemorySizeGb, err := expandOracleDatabaseCloudVmClusterPropertiesMemorySizeGb(original["memory_size_gb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMemorySizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["memorySizeGb"] = transformedMemorySizeGb
	}

	transformedDbNodeStorageSizeGb, err := expandOracleDatabaseCloudVmClusterPropertiesDbNodeStorageSizeGb(original["db_node_storage_size_gb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDbNodeStorageSizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dbNodeStorageSizeGb"] = transformedDbNodeStorageSizeGb
	}

	transformedStorageSizeGb, err := expandOracleDatabaseCloudVmClusterPropertiesStorageSizeGb(original["storage_size_gb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStorageSizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["storageSizeGb"] = transformedStorageSizeGb
	}

	transformedDataStorageSizeTb, err := expandOracleDatabaseCloudVmClusterPropertiesDataStorageSizeTb(original["data_storage_size_tb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataStorageSizeTb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataStorageSizeTb"] = transformedDataStorageSizeTb
	}

	transformedDiskRedundancy, err := expandOracleDatabaseCloudVmClusterPropertiesDiskRedundancy(original["disk_redundancy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDiskRedundancy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["diskRedundancy"] = transformedDiskRedundancy
	}

	transformedSparseDiskgroupEnabled, err := expandOracleDatabaseCloudVmClusterPropertiesSparseDiskgroupEnabled(original["sparse_diskgroup_enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSparseDiskgroupEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sparseDiskgroupEnabled"] = transformedSparseDiskgroupEnabled
	}

	transformedLocalBackupEnabled, err := expandOracleDatabaseCloudVmClusterPropertiesLocalBackupEnabled(original["local_backup_enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalBackupEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["localBackupEnabled"] = transformedLocalBackupEnabled
	}

	transformedHostnamePrefix, err := expandOracleDatabaseCloudVmClusterPropertiesHostnamePrefix(original["hostname_prefix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostnamePrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostnamePrefix"] = transformedHostnamePrefix
	}

	transformedDiagnosticsDataCollectionOptions, err := expandOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptions(original["diagnostics_data_collection_options"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDiagnosticsDataCollectionOptions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["diagnosticsDataCollectionOptions"] = transformedDiagnosticsDataCollectionOptions
	}

	transformedState, err := expandOracleDatabaseCloudVmClusterPropertiesState(original["state"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["state"] = transformedState
	}

	transformedScanListenerPortTcp, err := expandOracleDatabaseCloudVmClusterPropertiesScanListenerPortTcp(original["scan_listener_port_tcp"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScanListenerPortTcp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scanListenerPortTcp"] = transformedScanListenerPortTcp
	}

	transformedScanListenerPortTcpSsl, err := expandOracleDatabaseCloudVmClusterPropertiesScanListenerPortTcpSsl(original["scan_listener_port_tcp_ssl"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScanListenerPortTcpSsl); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scanListenerPortTcpSsl"] = transformedScanListenerPortTcpSsl
	}

	transformedDomain, err := expandOracleDatabaseCloudVmClusterPropertiesDomain(original["domain"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDomain); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["domain"] = transformedDomain
	}

	transformedScanDns, err := expandOracleDatabaseCloudVmClusterPropertiesScanDns(original["scan_dns"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScanDns); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scanDns"] = transformedScanDns
	}

	transformedHostname, err := expandOracleDatabaseCloudVmClusterPropertiesHostname(original["hostname"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostname"] = transformedHostname
	}

	transformedCpuCoreCount, err := expandOracleDatabaseCloudVmClusterPropertiesCpuCoreCount(original["cpu_core_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCpuCoreCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cpuCoreCount"] = transformedCpuCoreCount
	}

	transformedSystemVersion, err := expandOracleDatabaseCloudVmClusterPropertiesSystemVersion(original["system_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSystemVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["systemVersion"] = transformedSystemVersion
	}

	transformedScanIpIds, err := expandOracleDatabaseCloudVmClusterPropertiesScanIpIds(original["scan_ip_ids"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScanIpIds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scanIpIds"] = transformedScanIpIds
	}

	transformedScanDnsRecordId, err := expandOracleDatabaseCloudVmClusterPropertiesScanDnsRecordId(original["scan_dns_record_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScanDnsRecordId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scanDnsRecordId"] = transformedScanDnsRecordId
	}

	transformedOciUrl, err := expandOracleDatabaseCloudVmClusterPropertiesOciUrl(original["oci_url"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOciUrl); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ociUrl"] = transformedOciUrl
	}

	transformedDbServerOcids, err := expandOracleDatabaseCloudVmClusterPropertiesDbServerOcids(original["db_server_ocids"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDbServerOcids); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dbServerOcids"] = transformedDbServerOcids
	}

	transformedCompartmentId, err := expandOracleDatabaseCloudVmClusterPropertiesCompartmentId(original["compartment_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCompartmentId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["compartmentId"] = transformedCompartmentId
	}

	transformedDnsListenerIp, err := expandOracleDatabaseCloudVmClusterPropertiesDnsListenerIp(original["dns_listener_ip"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDnsListenerIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dnsListenerIp"] = transformedDnsListenerIp
	}

	transformedClusterName, err := expandOracleDatabaseCloudVmClusterPropertiesClusterName(original["cluster_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClusterName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clusterName"] = transformedClusterName
	}

	return transformed, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesOcid(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesLicenseType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesGiVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesTimeZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedId, err := expandOracleDatabaseCloudVmClusterPropertiesTimeZoneId(original["id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["id"] = transformedId
	}

	return transformed, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesTimeZoneId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesSshPublicKeys(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesShape(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesOcpuCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesMemorySizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesDbNodeStorageSizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesStorageSizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesDataStorageSizeTb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesDiskRedundancy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesSparseDiskgroupEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesLocalBackupEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesHostnamePrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDiagnosticsEventsEnabled, err := expandOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsDiagnosticsEventsEnabled(original["diagnostics_events_enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDiagnosticsEventsEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["diagnosticsEventsEnabled"] = transformedDiagnosticsEventsEnabled
	}

	transformedHealthMonitoringEnabled, err := expandOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsHealthMonitoringEnabled(original["health_monitoring_enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHealthMonitoringEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["healthMonitoringEnabled"] = transformedHealthMonitoringEnabled
	}

	transformedIncidentLogsEnabled, err := expandOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsIncidentLogsEnabled(original["incident_logs_enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIncidentLogsEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["incidentLogsEnabled"] = transformedIncidentLogsEnabled
	}

	return transformed, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsDiagnosticsEventsEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsHealthMonitoringEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesDiagnosticsDataCollectionOptionsIncidentLogsEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesScanListenerPortTcp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesScanListenerPortTcpSsl(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesDomain(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesScanDns(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesCpuCoreCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesSystemVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesScanIpIds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesScanDnsRecordId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesOciUrl(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesDbServerOcids(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesCompartmentId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesDnsListenerIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterPropertiesClusterName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterCidr(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterBackupSubnetCidr(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOracleDatabaseCloudVmClusterEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
