// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/osconfigv2/PolicyOrchestrator.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package osconfigv2

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceOSConfigV2PolicyOrchestrator() *schema.Resource {
	return &schema.Resource{
		Create: resourceOSConfigV2PolicyOrchestratorCreate,
		Read:   resourceOSConfigV2PolicyOrchestratorRead,
		Update: resourceOSConfigV2PolicyOrchestratorUpdate,
		Delete: resourceOSConfigV2PolicyOrchestratorDelete,

		Importer: &schema.ResourceImporter{
			State: resourceOSConfigV2PolicyOrchestratorImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"action": {
				Type:     schema.TypeString,
				Required: true,
				Description: `Required. Action to be done by the orchestrator in
'projects/{project_id}/zones/{zone_id}' locations defined by the
'orchestration_scope'. Allowed values:
- 'UPSERT' - Orchestrator will create or update target resources.
- 'DELETE' - Orchestrator will delete target resources, if they exist`,
			},
			"orchestrated_resource": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `Represents a resource that is being orchestrated by the policy orchestrator.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"id": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `Optional. ID of the resource to be used while generating set of affected resources.

For UPSERT action the value is auto-generated during PolicyOrchestrator
creation when not set. When the value is set it should following next
restrictions:

* Must contain only lowercase letters, numbers, and hyphens.
* Must start with a letter.
* Must be between 1-63 characters.
* Must end with a number or a letter.
* Must be unique within the project.

For DELETE action, ID must be specified explicitly during
PolicyOrchestrator creation.`,
						},
						"os_policy_assignment_v1_payload": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `OS policy assignment is an API resource that is used to
apply a set of OS policies to a dynamically targeted group of Compute Engine
VM instances.

An OS policy is used to define the desired state configuration for a
Compute Engine VM instance through a set of configuration resources that
provide capabilities such as installing or removing software packages, or
executing a script.

For more information about the OS policy resource definitions and examples,
see
[OS policy and OS policy
assignment](https://cloud.google.com/compute/docs/os-configuration-management/working-with-os-policies).`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"instance_filter": {
										Type:     schema.TypeList,
										Required: true,
										Description: `Filters to select target VMs for an assignment.

If more than one filter criteria is specified below, a VM will be selected
if and only if it satisfies all of them.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"all": {
													Type:     schema.TypeBool,
													Optional: true,
													Description: `Target all VMs in the project. If true, no other criteria is
permitted.`,
												},
												"exclusion_labels": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `List of label sets used for VM exclusion.

If the list has more than one label set, the VM is excluded if any
of the label sets are applicable for the VM.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
																Description: `Labels are identified by key/value pairs in this map.
A VM should contain all the key/value pairs specified in this
map to be selected.`,
																Elem: &schema.Schema{Type: schema.TypeString},
															},
														},
													},
												},
												"inclusion_labels": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `List of label sets used for VM inclusion.

If the list has more than one 'LabelSet', the VM is included if any
of the label sets are applicable for the VM.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
																Description: `Labels are identified by key/value pairs in this map.
A VM should contain all the key/value pairs specified in this
map to be selected.`,
																Elem: &schema.Schema{Type: schema.TypeString},
															},
														},
													},
												},
												"inventories": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `List of inventories to select VMs.

A VM is selected if its inventory data matches at least one of the
following inventories.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"os_short_name": {
																Type:        schema.TypeString,
																Required:    true,
																Description: `Required. The OS short name`,
															},
															"os_version": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The OS version

Prefix matches are supported if asterisk(*) is provided as the
last character. For example, to match all versions with a major
version of '7', specify the following value for this field '7.*'

An empty string matches all OS versions.`,
															},
														},
													},
												},
											},
										},
									},
									"os_policies": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `Required. List of OS policies to be applied to the VMs.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"id": {
													Type:     schema.TypeString,
													Required: true,
													Description: `Required. The id of the OS policy with the following restrictions:

* Must contain only lowercase letters, numbers, and hyphens.
* Must start with a letter.
* Must be between 1-63 characters.
* Must end with a number or a letter.
* Must be unique within the assignment.`,
												},
												"mode": {
													Type:     schema.TypeString,
													Required: true,
													Description: `Required. Policy mode
Possible values:
MODE_UNSPECIFIED
VALIDATION
ENFORCEMENT`,
												},
												"resource_groups": {
													Type:     schema.TypeList,
													Required: true,
													Description: `Required. List of resource groups for the policy.
For a particular VM, resource groups are evaluated in the order specified
and the first resource group that is applicable is selected and the rest
are ignored.

If none of the resource groups are applicable for a VM, the VM is
considered to be non-compliant w.r.t this policy. This behavior can be
toggled by the flag 'allow_no_resource_group_match'`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"resources": {
																Type:     schema.TypeList,
																Required: true,
																Description: `Required. List of resources configured for this resource group.
The resources are executed in the exact order specified here.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"id": {
																			Type:     schema.TypeString,
																			Required: true,
																			Description: `Required. The id of the resource with the following restrictions:

* Must contain only lowercase letters, numbers, and hyphens.
* Must start with a letter.
* Must be between 1-63 characters.
* Must end with a number or a letter.
* Must be unique within the OS policy.`,
																		},
																		"exec": {
																			Type:     schema.TypeList,
																			Optional: true,
																			Description: `A resource that allows executing scripts on the VM.

The 'ExecResource' has 2 stages: 'validate' and 'enforce' and both stages
accept a script as an argument to execute.

When the 'ExecResource' is applied by the agent, it first executes the
script in the 'validate' stage. The 'validate' stage can signal that the
'ExecResource' is already in the desired state by returning an exit code
of '100'. If the 'ExecResource' is not in the desired state, it should
return an exit code of '101'. Any other exit code returned by this stage
is considered an error.

If the 'ExecResource' is not in the desired state based on the exit code
from the 'validate' stage, the agent proceeds to execute the script from
the 'enforce' stage. If the 'ExecResource' is already in the desired
state, the 'enforce' stage will not be run.
Similar to 'validate' stage, the 'enforce' stage should return an exit
code of '100' to indicate that the resource in now in its desired state.
Any other exit code is considered an error.

NOTE: An exit code of '100' was chosen over '0' (and '101' vs '1') to
have an explicit indicator of 'in desired state', 'not in desired state'
and errors. Because, for example, Powershell will always return an exit
code of '0' unless an 'exit' statement is provided in the script. So, for
reasons of consistency and being explicit, exit codes '100' and '101'
were chosen.`,
																			MaxItems: 1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"validate": {
																						Type:        schema.TypeList,
																						Required:    true,
																						Description: `A file or script to execute.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"interpreter": {
																									Type:     schema.TypeString,
																									Required: true,
																									Description: `Required. The script interpreter to use.
Possible values:
INTERPRETER_UNSPECIFIED
NONE
SHELL
POWERSHELL`,
																								},
																								"args": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `Optional arguments to pass to the source during execution.`,
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},
																								"file": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `A remote or local file.`,
																									MaxItems:    1,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"allow_insecure": {
																												Type:     schema.TypeBool,
																												Optional: true,
																												Description: `Defaults to false. When false, files are subject to validations
based on the file type:

Remote: A checksum must be specified.
Cloud Storage: An object generation number must be specified.`,
																											},
																											"gcs": {
																												Type:        schema.TypeList,
																												Optional:    true,
																												Description: `Specifies a file available as a Cloud Storage Object.`,
																												MaxItems:    1,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{
																														"bucket": {
																															Type:        schema.TypeString,
																															Required:    true,
																															Description: `Required. Bucket of the Cloud Storage object.`,
																														},
																														"object": {
																															Type:        schema.TypeString,
																															Required:    true,
																															Description: `Required. Name of the Cloud Storage object.`,
																														},
																														"generation": {
																															Type:        schema.TypeString,
																															Optional:    true,
																															Description: `Generation number of the Cloud Storage object.`,
																														},
																													},
																												},
																											},
																											"local_path": {
																												Type:        schema.TypeString,
																												Optional:    true,
																												Description: `A local path within the VM to use.`,
																											},
																											"remote": {
																												Type:        schema.TypeList,
																												Optional:    true,
																												Description: `Specifies a file available via some URI.`,
																												MaxItems:    1,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{
																														"uri": {
																															Type:     schema.TypeString,
																															Required: true,
																															Description: `Required. URI from which to fetch the object. It should contain both the
protocol and path following the format '{protocol}://{location}'.`,
																														},
																														"sha256_checksum": {
																															Type:        schema.TypeString,
																															Optional:    true,
																															Description: `SHA256 checksum of the remote file.`,
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																								"output_file_path": {
																									Type:     schema.TypeString,
																									Optional: true,
																									Description: `Only recorded for enforce Exec.
Path to an output file (that is created by this Exec) whose
content will be recorded in OSPolicyResourceCompliance after a
successful run. Absence or failure to read this file will result in
this ExecResource being non-compliant. Output file size is limited to
500K bytes.`,
																								},
																								"script": {
																									Type:     schema.TypeString,
																									Optional: true,
																									Description: `An inline script.
The size of the script is limited to 32KiB.`,
																								},
																							},
																						},
																					},
																					"enforce": {
																						Type:        schema.TypeList,
																						Optional:    true,
																						Description: `A file or script to execute.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"interpreter": {
																									Type:     schema.TypeString,
																									Required: true,
																									Description: `Required. The script interpreter to use.
Possible values:
INTERPRETER_UNSPECIFIED
NONE
SHELL
POWERSHELL`,
																								},
																								"args": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `Optional arguments to pass to the source during execution.`,
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},
																								"file": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `A remote or local file.`,
																									MaxItems:    1,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"allow_insecure": {
																												Type:     schema.TypeBool,
																												Optional: true,
																												Description: `Defaults to false. When false, files are subject to validations
based on the file type:

Remote: A checksum must be specified.
Cloud Storage: An object generation number must be specified.`,
																											},
																											"gcs": {
																												Type:        schema.TypeList,
																												Optional:    true,
																												Description: `Specifies a file available as a Cloud Storage Object.`,
																												MaxItems:    1,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{
																														"bucket": {
																															Type:        schema.TypeString,
																															Required:    true,
																															Description: `Required. Bucket of the Cloud Storage object.`,
																														},
																														"object": {
																															Type:        schema.TypeString,
																															Required:    true,
																															Description: `Required. Name of the Cloud Storage object.`,
																														},
																														"generation": {
																															Type:        schema.TypeString,
																															Optional:    true,
																															Description: `Generation number of the Cloud Storage object.`,
																														},
																													},
																												},
																											},
																											"local_path": {
																												Type:        schema.TypeString,
																												Optional:    true,
																												Description: `A local path within the VM to use.`,
																											},
																											"remote": {
																												Type:        schema.TypeList,
																												Optional:    true,
																												Description: `Specifies a file available via some URI.`,
																												MaxItems:    1,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{
																														"uri": {
																															Type:     schema.TypeString,
																															Required: true,
																															Description: `Required. URI from which to fetch the object. It should contain both the
protocol and path following the format '{protocol}://{location}'.`,
																														},
																														"sha256_checksum": {
																															Type:        schema.TypeString,
																															Optional:    true,
																															Description: `SHA256 checksum of the remote file.`,
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																								"output_file_path": {
																									Type:     schema.TypeString,
																									Optional: true,
																									Description: `Only recorded for enforce Exec.
Path to an output file (that is created by this Exec) whose
content will be recorded in OSPolicyResourceCompliance after a
successful run. Absence or failure to read this file will result in
this ExecResource being non-compliant. Output file size is limited to
500K bytes.`,
																								},
																								"script": {
																									Type:     schema.TypeString,
																									Optional: true,
																									Description: `An inline script.
The size of the script is limited to 32KiB.`,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"file": {
																			Type:        schema.TypeList,
																			Optional:    true,
																			Description: `A resource that manages the state of a file.`,
																			MaxItems:    1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"path": {
																						Type:        schema.TypeString,
																						Required:    true,
																						Description: `Required. The absolute path of the file within the VM.`,
																					},
																					"state": {
																						Type:     schema.TypeString,
																						Required: true,
																						Description: `Required. Desired state of the file.
Possible values:
DESIRED_STATE_UNSPECIFIED
PRESENT
ABSENT
CONTENTS_MATCH`,
																					},
																					"content": {
																						Type:     schema.TypeString,
																						Optional: true,
																						Description: `A a file with this content.
The size of the content is limited to 32KiB.`,
																					},
																					"file": {
																						Type:        schema.TypeList,
																						Optional:    true,
																						Description: `A remote or local file.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"allow_insecure": {
																									Type:     schema.TypeBool,
																									Optional: true,
																									Description: `Defaults to false. When false, files are subject to validations
based on the file type:

Remote: A checksum must be specified.
Cloud Storage: An object generation number must be specified.`,
																								},
																								"gcs": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `Specifies a file available as a Cloud Storage Object.`,
																									MaxItems:    1,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"bucket": {
																												Type:        schema.TypeString,
																												Required:    true,
																												Description: `Required. Bucket of the Cloud Storage object.`,
																											},
																											"object": {
																												Type:        schema.TypeString,
																												Required:    true,
																												Description: `Required. Name of the Cloud Storage object.`,
																											},
																											"generation": {
																												Type:        schema.TypeString,
																												Optional:    true,
																												Description: `Generation number of the Cloud Storage object.`,
																											},
																										},
																									},
																								},
																								"local_path": {
																									Type:        schema.TypeString,
																									Optional:    true,
																									Description: `A local path within the VM to use.`,
																								},
																								"remote": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `Specifies a file available via some URI.`,
																									MaxItems:    1,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"uri": {
																												Type:     schema.TypeString,
																												Required: true,
																												Description: `Required. URI from which to fetch the object. It should contain both the
protocol and path following the format '{protocol}://{location}'.`,
																											},
																											"sha256_checksum": {
																												Type:        schema.TypeString,
																												Optional:    true,
																												Description: `SHA256 checksum of the remote file.`,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																					"permissions": {
																						Type:     schema.TypeString,
																						Optional: true,
																						Description: `Consists of three octal digits which represent, in
order, the permissions of the owner, group, and other users for the
file (similarly to the numeric mode used in the linux chmod
utility). Each digit represents a three bit number with the 4 bit
corresponding to the read permissions, the 2 bit corresponds to the
write bit, and the one bit corresponds to the execute permission.
Default behavior is 755.

Below are some examples of permissions and their associated values:
read, write, and execute: 7
read and execute: 5
read and write: 6
read only: 4`,
																					},
																				},
																			},
																		},
																		"pkg": {
																			Type:        schema.TypeList,
																			Optional:    true,
																			Description: `A resource that manages a system package.`,
																			MaxItems:    1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"desired_state": {
																						Type:     schema.TypeString,
																						Required: true,
																						Description: `Required. The desired state the agent should maintain for this package.
Possible values:
DESIRED_STATE_UNSPECIFIED
INSTALLED
REMOVED`,
																					},
																					"apt": {
																						Type:     schema.TypeList,
																						Optional: true,
																						Description: `A package managed by APT.
- install: 'apt-get update && apt-get -y install [name]'
- remove: 'apt-get -y remove [name]'`,
																						MaxItems: 1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"name": {
																									Type:        schema.TypeString,
																									Required:    true,
																									Description: `Required. Package name.`,
																								},
																							},
																						},
																					},
																					"deb": {
																						Type:        schema.TypeList,
																						Optional:    true,
																						Description: `A deb package file. dpkg packages only support INSTALLED state.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"source": {
																									Type:        schema.TypeList,
																									Required:    true,
																									Description: `A remote or local file.`,
																									MaxItems:    1,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"allow_insecure": {
																												Type:     schema.TypeBool,
																												Optional: true,
																												Description: `Defaults to false. When false, files are subject to validations
based on the file type:

Remote: A checksum must be specified.
Cloud Storage: An object generation number must be specified.`,
																											},
																											"gcs": {
																												Type:        schema.TypeList,
																												Optional:    true,
																												Description: `Specifies a file available as a Cloud Storage Object.`,
																												MaxItems:    1,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{
																														"bucket": {
																															Type:        schema.TypeString,
																															Required:    true,
																															Description: `Required. Bucket of the Cloud Storage object.`,
																														},
																														"object": {
																															Type:        schema.TypeString,
																															Required:    true,
																															Description: `Required. Name of the Cloud Storage object.`,
																														},
																														"generation": {
																															Type:        schema.TypeString,
																															Optional:    true,
																															Description: `Generation number of the Cloud Storage object.`,
																														},
																													},
																												},
																											},
																											"local_path": {
																												Type:        schema.TypeString,
																												Optional:    true,
																												Description: `A local path within the VM to use.`,
																											},
																											"remote": {
																												Type:        schema.TypeList,
																												Optional:    true,
																												Description: `Specifies a file available via some URI.`,
																												MaxItems:    1,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{
																														"uri": {
																															Type:     schema.TypeString,
																															Required: true,
																															Description: `Required. URI from which to fetch the object. It should contain both the
protocol and path following the format '{protocol}://{location}'.`,
																														},
																														"sha256_checksum": {
																															Type:        schema.TypeString,
																															Optional:    true,
																															Description: `SHA256 checksum of the remote file.`,
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																								"pull_deps": {
																									Type:     schema.TypeBool,
																									Optional: true,
																									Description: `Whether dependencies should also be installed.
- install when false: 'dpkg -i package'
- install when true: 'apt-get update && apt-get -y install
package.deb'`,
																								},
																							},
																						},
																					},
																					"googet": {
																						Type:     schema.TypeList,
																						Optional: true,
																						Description: `A package managed by GooGet.
- install: 'googet -noconfirm install package'
- remove: 'googet -noconfirm remove package'`,
																						MaxItems: 1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"name": {
																									Type:        schema.TypeString,
																									Required:    true,
																									Description: `Required. Package name.`,
																								},
																							},
																						},
																					},
																					"msi": {
																						Type:        schema.TypeList,
																						Optional:    true,
																						Description: `An MSI package. MSI packages only support INSTALLED state.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"source": {
																									Type:        schema.TypeList,
																									Required:    true,
																									Description: `A remote or local file.`,
																									MaxItems:    1,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"allow_insecure": {
																												Type:     schema.TypeBool,
																												Optional: true,
																												Description: `Defaults to false. When false, files are subject to validations
based on the file type:

Remote: A checksum must be specified.
Cloud Storage: An object generation number must be specified.`,
																											},
																											"gcs": {
																												Type:        schema.TypeList,
																												Optional:    true,
																												Description: `Specifies a file available as a Cloud Storage Object.`,
																												MaxItems:    1,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{
																														"bucket": {
																															Type:        schema.TypeString,
																															Required:    true,
																															Description: `Required. Bucket of the Cloud Storage object.`,
																														},
																														"object": {
																															Type:        schema.TypeString,
																															Required:    true,
																															Description: `Required. Name of the Cloud Storage object.`,
																														},
																														"generation": {
																															Type:        schema.TypeString,
																															Optional:    true,
																															Description: `Generation number of the Cloud Storage object.`,
																														},
																													},
																												},
																											},
																											"local_path": {
																												Type:        schema.TypeString,
																												Optional:    true,
																												Description: `A local path within the VM to use.`,
																											},
																											"remote": {
																												Type:        schema.TypeList,
																												Optional:    true,
																												Description: `Specifies a file available via some URI.`,
																												MaxItems:    1,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{
																														"uri": {
																															Type:     schema.TypeString,
																															Required: true,
																															Description: `Required. URI from which to fetch the object. It should contain both the
protocol and path following the format '{protocol}://{location}'.`,
																														},
																														"sha256_checksum": {
																															Type:        schema.TypeString,
																															Optional:    true,
																															Description: `SHA256 checksum of the remote file.`,
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																								"properties": {
																									Type:     schema.TypeList,
																									Optional: true,
																									Description: `Additional properties to use during installation.
This should be in the format of Property=Setting.
Appended to the defaults of 'ACTION=INSTALL
REBOOT=ReallySuppress'.`,
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},
																							},
																						},
																					},
																					"rpm": {
																						Type:        schema.TypeList,
																						Optional:    true,
																						Description: `An RPM package file. RPM packages only support INSTALLED state.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"source": {
																									Type:        schema.TypeList,
																									Required:    true,
																									Description: `A remote or local file.`,
																									MaxItems:    1,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"allow_insecure": {
																												Type:     schema.TypeBool,
																												Optional: true,
																												Description: `Defaults to false. When false, files are subject to validations
based on the file type:

Remote: A checksum must be specified.
Cloud Storage: An object generation number must be specified.`,
																											},
																											"gcs": {
																												Type:        schema.TypeList,
																												Optional:    true,
																												Description: `Specifies a file available as a Cloud Storage Object.`,
																												MaxItems:    1,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{
																														"bucket": {
																															Type:        schema.TypeString,
																															Required:    true,
																															Description: `Required. Bucket of the Cloud Storage object.`,
																														},
																														"object": {
																															Type:        schema.TypeString,
																															Required:    true,
																															Description: `Required. Name of the Cloud Storage object.`,
																														},
																														"generation": {
																															Type:        schema.TypeString,
																															Optional:    true,
																															Description: `Generation number of the Cloud Storage object.`,
																														},
																													},
																												},
																											},
																											"local_path": {
																												Type:        schema.TypeString,
																												Optional:    true,
																												Description: `A local path within the VM to use.`,
																											},
																											"remote": {
																												Type:        schema.TypeList,
																												Optional:    true,
																												Description: `Specifies a file available via some URI.`,
																												MaxItems:    1,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{
																														"uri": {
																															Type:     schema.TypeString,
																															Required: true,
																															Description: `Required. URI from which to fetch the object. It should contain both the
protocol and path following the format '{protocol}://{location}'.`,
																														},
																														"sha256_checksum": {
																															Type:        schema.TypeString,
																															Optional:    true,
																															Description: `SHA256 checksum of the remote file.`,
																														},
																													},
																												},
																											},
																										},
																									},
																								},
																								"pull_deps": {
																									Type:     schema.TypeBool,
																									Optional: true,
																									Description: `Whether dependencies should also be installed.
- install when false: 'rpm --upgrade --replacepkgs package.rpm'
- install when true: 'yum -y install package.rpm' or
'zypper -y install package.rpm'`,
																								},
																							},
																						},
																					},
																					"yum": {
																						Type:     schema.TypeList,
																						Optional: true,
																						Description: `A package managed by YUM.
- install: 'yum -y install package'
- remove: 'yum -y remove package'`,
																						MaxItems: 1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"name": {
																									Type:        schema.TypeString,
																									Required:    true,
																									Description: `Required. Package name.`,
																								},
																							},
																						},
																					},
																					"zypper": {
																						Type:     schema.TypeList,
																						Optional: true,
																						Description: `A package managed by Zypper.
- install: 'zypper -y install package'
- remove: 'zypper -y rm package'`,
																						MaxItems: 1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"name": {
																									Type:        schema.TypeString,
																									Required:    true,
																									Description: `Required. Package name.`,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"repository": {
																			Type:        schema.TypeList,
																			Optional:    true,
																			Description: `A resource that manages a package repository.`,
																			MaxItems:    1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"apt": {
																						Type:     schema.TypeList,
																						Optional: true,
																						Description: `Represents a single apt package repository. These will be added to
a repo file that will be managed at
'/etc/apt/sources.list.d/google_osconfig.list'.`,
																						MaxItems: 1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"archive_type": {
																									Type:     schema.TypeString,
																									Required: true,
																									Description: `Required. Type of archive files in this repository.
Possible values:
ARCHIVE_TYPE_UNSPECIFIED
DEB
DEB_SRC`,
																								},
																								"components": {
																									Type:     schema.TypeList,
																									Required: true,
																									Description: `Required. List of components for this repository. Must contain at least one
item.`,
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},
																								"distribution": {
																									Type:        schema.TypeString,
																									Required:    true,
																									Description: `Required. Distribution of this repository.`,
																								},
																								"uri": {
																									Type:        schema.TypeString,
																									Required:    true,
																									Description: `Required. URI for this repository.`,
																								},
																								"gpg_key": {
																									Type:     schema.TypeString,
																									Optional: true,
																									Description: `URI of the key file for this repository. The agent maintains a
keyring at '/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg'.`,
																								},
																							},
																						},
																					},
																					"goo": {
																						Type:     schema.TypeList,
																						Optional: true,
																						Description: `Represents a Goo package repository. These are added to a repo file
that is managed at
'C:/ProgramData/GooGet/repos/google_osconfig.repo'.`,
																						MaxItems: 1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"name": {
																									Type:        schema.TypeString,
																									Required:    true,
																									Description: `Required. The name of the repository.`,
																								},
																								"url": {
																									Type:        schema.TypeString,
																									Required:    true,
																									Description: `Required. The url of the repository.`,
																								},
																							},
																						},
																					},
																					"yum": {
																						Type:     schema.TypeList,
																						Optional: true,
																						Description: `Represents a single yum package repository. These are added to a
repo file that is managed at
'/etc/yum.repos.d/google_osconfig.repo'.`,
																						MaxItems: 1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"base_url": {
																									Type:        schema.TypeString,
																									Required:    true,
																									Description: `Required. The location of the repository directory.`,
																								},
																								"id": {
																									Type:     schema.TypeString,
																									Required: true,
																									Description: `Required. A one word, unique name for this repository. This is  the 'repo
id' in the yum config file and also the 'display_name' if
'display_name' is omitted. This id is also used as the unique
identifier when checking for resource conflicts.`,
																								},
																								"display_name": {
																									Type:        schema.TypeString,
																									Optional:    true,
																									Description: `The display name of the repository.`,
																								},
																								"gpg_keys": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `URIs of GPG keys.`,
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},
																							},
																						},
																					},
																					"zypper": {
																						Type:     schema.TypeList,
																						Optional: true,
																						Description: `Represents a single zypper package repository. These are added to a
repo file that is managed at
'/etc/zypp/repos.d/google_osconfig.repo'.`,
																						MaxItems: 1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"base_url": {
																									Type:        schema.TypeString,
																									Required:    true,
																									Description: `Required. The location of the repository directory.`,
																								},
																								"id": {
																									Type:     schema.TypeString,
																									Required: true,
																									Description: `Required. A one word, unique name for this repository. This is the 'repo
id' in the zypper config file and also the 'display_name' if
'display_name' is omitted. This id is also used as the unique
identifier when checking for GuestPolicy conflicts.`,
																								},
																								"display_name": {
																									Type:        schema.TypeString,
																									Optional:    true,
																									Description: `The display name of the repository.`,
																								},
																								"gpg_keys": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `URIs of GPG keys.`,
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															"inventory_filters": {
																Type:     schema.TypeList,
																Optional: true,
																Description: `List of inventory filters for the resource group.

The resources in this resource group are applied to the target VM if it
satisfies at least one of the following inventory filters.

For example, to apply this resource group to VMs running either 'RHEL' or
'CentOS' operating systems, specify 2 items for the list with following
values:
inventory_filters[0].os_short_name='rhel' and
inventory_filters[1].os_short_name='centos'

If the list is empty, this resource group will be applied to the target
VM unconditionally.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"os_short_name": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: `Required. The OS short name`,
																		},
																		"os_version": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The OS version

Prefix matches are supported if asterisk(*) is provided as the
last character. For example, to match all versions with a major
version of '7', specify the following value for this field '7.*'

An empty string matches all OS versions.`,
																		},
																	},
																},
															},
														},
													},
												},
												"allow_no_resource_group_match": {
													Type:     schema.TypeBool,
													Optional: true,
													Description: `This flag determines the OS policy compliance status when none of the
resource groups within the policy are applicable for a VM. Set this value
to 'true' if the policy needs to be reported as compliant even if the
policy has nothing to validate or enforce.`,
												},
												"description": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `Policy description.
Length of the description is limited to 1024 characters.`,
												},
											},
										},
									},
									"rollout": {
										Type:     schema.TypeList,
										Required: true,
										Description: `Message to configure the rollout at the zonal level for the OS policy
assignment.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"disruption_budget": {
													Type:     schema.TypeList,
													Required: true,
													Description: `Message encapsulating a value that can be either absolute ("fixed") or
relative ("percent") to a value.`,
													MaxItems: 1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"fixed": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: `Specifies a fixed value.`,
															},
															"percent": {
																Type:     schema.TypeInt,
																Optional: true,
																Description: `Specifies the relative value defined as a percentage, which will be
multiplied by a reference value.`,
															},
														},
													},
												},
												"min_wait_duration": {
													Type:     schema.TypeString,
													Required: true,
													Description: `Required. This determines the minimum duration of time to wait after the
configuration changes are applied through the current rollout. A
VM continues to count towards the 'disruption_budget' at least
until this duration of time has passed after configuration changes are
applied.`,
												},
											},
										},
									},
									"description": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `OS policy assignment description.
Length of the description is limited to 1024 characters.`,
									},
									"name": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Resource name.

Format:
'projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id}'

This field is ignored when you create an OS policy assignment.`,
									},
									"baseline": {
										Type:     schema.TypeBool,
										Computed: true,
										Description: `Output only. Indicates that this revision has been successfully rolled out in this zone
and new VMs will be assigned OS policies from this revision.

For a given OS policy assignment, there is only one revision with a value
of 'true' for this field.`,
									},
									"deleted": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Output only. Indicates that this revision deletes the OS policy assignment.`,
									},
									"reconciling": {
										Type:     schema.TypeBool,
										Computed: true,
										Description: `Output only. Indicates that reconciliation is in progress for the revision.
This value is 'true' when the 'rollout_state' is one of:
* IN_PROGRESS
* CANCELLING`,
									},
									"revision_create_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. The timestamp that the revision was created.`,
									},
									"revision_id": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Output only. The assignment revision ID
A new revision is committed whenever a rollout is triggered for a OS policy
assignment`,
									},
									"rollout_state": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Output only. OS policy assignment rollout state
Possible values:
ROLLOUT_STATE_UNSPECIFIED
IN_PROGRESS
CANCELLING
CANCELLED
SUCCEEDED`,
									},
									"uid": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. Server generated unique id for the OS policy assignment resource.`,
									},
								},
							},
						},
					},
				},
			},
			"policy_orchestrator_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Required. The logical identifier of the policy orchestrator, with the following
restrictions:

* Must contain only lowercase letters, numbers, and hyphens.
* Must start with a letter.
* Must be between 1-63 characters.
* Must end with a number or a letter.
* Must be unique within the parent.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Optional. Freeform text describing the purpose of the resource.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Optional. Labels as key value pairs

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"orchestration_scope": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Defines a set of selectors which drive which resources are in scope of policy
orchestration.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"selectors": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Optional. Selectors of the orchestration scope. There is a logical AND between each
selector defined.

When there is no explicit 'ResourceHierarchySelector' selector specified,
the scope is by default bounded to the parent of the policy orchestrator
resource.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"location_selector": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Selector containing locations in scope.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"included_locations": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `Optional. Names of the locations in scope.
Format: 'us-central1-a'`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"resource_hierarchy_selector": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Selector containing Cloud Resource Manager resource hierarchy nodes.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"included_folders": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `Optional. Names of the folders in scope.
Format: 'folders/{folder_id}'`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"included_projects": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `Optional. Names of the projects in scope.
Format: 'projects/{project_number}'`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"state": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Optional. State of the orchestrator. Can be updated to change orchestrator behaviour.
Allowed values:
- 'ACTIVE' - orchestrator is actively looking for actions to be taken.
- 'STOPPED' - orchestrator won't make any changes.

Note: There might be more states added in the future. We use string here
instead of an enum, to avoid the need of propagating new states to all the
client code.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Timestamp when the policy orchestrator resource was created.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Immutable. Identifier. In form of
* 'organizations/{organization_id}/locations/global/policyOrchestrators/{orchestrator_id}'
* 'folders/{folder_id}/locations/global/policyOrchestrators/{orchestrator_id}'
* 'projects/{project_id_or_number}/locations/global/policyOrchestrators/{orchestrator_id}'`,
			},
			"orchestration_state": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Describes the state of the orchestration process.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"previous_iteration_state": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Describes the state of a single iteration of the orchestrator.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"error": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `The 'Status' type defines a logical error model that is suitable for
different programming environments, including REST APIs and RPC APIs. It is
used by [gRPC](https://github.com/grpc). Each 'Status' message contains
three pieces of data: error code, error message, and error details.

You can find out more about this error model and how to work with it in the
[API Design Guide](https://cloud.google.com/apis/design/errors).`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"code": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `The status code, which should be an enum value of google.rpc.Code.`,
												},
												"details": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `A list of messages that carry the error details.  There is a common set of
message types for APIs to use.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"type_url": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `A URL/resource name that uniquely identifies the type of the serialized protocol buffer message`,
															},
															"value": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: ``,
															},
														},
													},
												},
												"message": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `A developer-facing error message, which should be in English. Any
user-facing error message should be localized and sent in the
google.rpc.Status.details field, or localized by the client.`,
												},
											},
										},
									},
									"failed_actions": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Output only. Number of orchestration actions which failed so far. For more details,
query the Cloud Logs.`,
									},
									"finish_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. Finish time of the wave iteration.`,
									},
									"performed_actions": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. Overall number of actions done by the orchestrator so far.`,
									},
									"progress": {
										Type:        schema.TypeFloat,
										Computed:    true,
										Description: `Output only. An estimated percentage of the progress. Number between 0 and 100.`,
									},
									"rollout_resource": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Output only. Handle to the Progressive Rollouts API rollout resource, which contains
detailed information about a particular orchestration iteration.`,
									},
									"start_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. Start time of the wave iteration.`,
									},
									"state": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Output only. State of the iteration.
Possible values:
STATE_UNSPECIFIED
PROCESSING
COMPLETED
FAILED
CANCELLED
UNKNOWN`,
									},
								},
							},
						},
						"current_iteration_state": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Describes the state of a single iteration of the orchestrator.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"error": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `The 'Status' type defines a logical error model that is suitable for
different programming environments, including REST APIs and RPC APIs. It is
used by [gRPC](https://github.com/grpc). Each 'Status' message contains
three pieces of data: error code, error message, and error details.

You can find out more about this error model and how to work with it in the
[API Design Guide](https://cloud.google.com/apis/design/errors).`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"code": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `The status code, which should be an enum value of google.rpc.Code.`,
												},
												"details": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `A list of messages that carry the error details.  There is a common set of
message types for APIs to use.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"type_url": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `A URL/resource name that uniquely identifies the type of the serialized protocol buffer message`,
															},
															"value": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: ``,
															},
														},
													},
												},
												"message": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `A developer-facing error message, which should be in English. Any
user-facing error message should be localized and sent in the
google.rpc.Status.details field, or localized by the client.`,
												},
											},
										},
									},
									"failed_actions": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Output only. Number of orchestration actions which failed so far. For more details,
query the Cloud Logs.`,
									},
									"finish_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. Finish time of the wave iteration.`,
									},
									"performed_actions": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. Overall number of actions done by the orchestrator so far.`,
									},
									"progress": {
										Type:        schema.TypeFloat,
										Computed:    true,
										Description: `Output only. An estimated percentage of the progress. Number between 0 and 100.`,
									},
									"rollout_resource": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Output only. Handle to the Progressive Rollouts API rollout resource, which contains
detailed information about a particular orchestration iteration.`,
									},
									"start_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. Start time of the wave iteration.`,
									},
									"state": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Output only. State of the iteration.
Possible values:
STATE_UNSPECIFIED
PROCESSING
COMPLETED
FAILED
CANCELLED
UNKNOWN`,
									},
								},
							},
						},
					},
				},
			},
			"reconciling": {
				Type:     schema.TypeBool,
				Computed: true,
				Description: `Output only. Set to true, if the there are ongoing changes being applied by the
orchestrator.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Timestamp when the policy orchestrator resource was last modified.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceOSConfigV2PolicyOrchestratorCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandOSConfigV2PolicyOrchestratorDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	actionProp, err := expandOSConfigV2PolicyOrchestratorAction(d.Get("action"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("action"); !tpgresource.IsEmptyValue(reflect.ValueOf(actionProp)) && (ok || !reflect.DeepEqual(v, actionProp)) {
		obj["action"] = actionProp
	}
	orchestratedResourceProp, err := expandOSConfigV2PolicyOrchestratorOrchestratedResource(d.Get("orchestrated_resource"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("orchestrated_resource"); !tpgresource.IsEmptyValue(reflect.ValueOf(orchestratedResourceProp)) && (ok || !reflect.DeepEqual(v, orchestratedResourceProp)) {
		obj["orchestratedResource"] = orchestratedResourceProp
	}
	stateProp, err := expandOSConfigV2PolicyOrchestratorState(d.Get("state"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("state"); !tpgresource.IsEmptyValue(reflect.ValueOf(stateProp)) && (ok || !reflect.DeepEqual(v, stateProp)) {
		obj["state"] = stateProp
	}
	orchestrationScopeProp, err := expandOSConfigV2PolicyOrchestratorOrchestrationScope(d.Get("orchestration_scope"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("orchestration_scope"); !tpgresource.IsEmptyValue(reflect.ValueOf(orchestrationScopeProp)) && (ok || !reflect.DeepEqual(v, orchestrationScopeProp)) {
		obj["orchestrationScope"] = orchestrationScopeProp
	}
	labelsProp, err := expandOSConfigV2PolicyOrchestratorEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{OSConfigV2BasePath}}projects/{{project}}/locations/global/policyOrchestrators?policyOrchestratorId={{policy_orchestrator_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new PolicyOrchestrator: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PolicyOrchestrator: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating PolicyOrchestrator: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/global/policyOrchestrators/{{policy_orchestrator_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = OSConfigV2OperationWaitTime(
		config, res, project, "Creating PolicyOrchestrator", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create PolicyOrchestrator: %s", err)
	}

	log.Printf("[DEBUG] Finished creating PolicyOrchestrator %q: %#v", d.Id(), res)

	return resourceOSConfigV2PolicyOrchestratorRead(d, meta)
}

func resourceOSConfigV2PolicyOrchestratorRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{OSConfigV2BasePath}}projects/{{project}}/locations/global/policyOrchestrators/{{policy_orchestrator_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PolicyOrchestrator: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("OSConfigV2PolicyOrchestrator %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}

	if err := d.Set("name", flattenOSConfigV2PolicyOrchestratorName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("description", flattenOSConfigV2PolicyOrchestratorDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("reconciling", flattenOSConfigV2PolicyOrchestratorReconciling(res["reconciling"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("action", flattenOSConfigV2PolicyOrchestratorAction(res["action"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("orchestrated_resource", flattenOSConfigV2PolicyOrchestratorOrchestratedResource(res["orchestratedResource"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("orchestration_state", flattenOSConfigV2PolicyOrchestratorOrchestrationState(res["orchestrationState"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("update_time", flattenOSConfigV2PolicyOrchestratorUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("state", flattenOSConfigV2PolicyOrchestratorState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("orchestration_scope", flattenOSConfigV2PolicyOrchestratorOrchestrationScope(res["orchestrationScope"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("create_time", flattenOSConfigV2PolicyOrchestratorCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("labels", flattenOSConfigV2PolicyOrchestratorLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("terraform_labels", flattenOSConfigV2PolicyOrchestratorTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}
	if err := d.Set("effective_labels", flattenOSConfigV2PolicyOrchestratorEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading PolicyOrchestrator: %s", err)
	}

	return nil
}

func resourceOSConfigV2PolicyOrchestratorUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PolicyOrchestrator: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandOSConfigV2PolicyOrchestratorDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	actionProp, err := expandOSConfigV2PolicyOrchestratorAction(d.Get("action"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("action"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, actionProp)) {
		obj["action"] = actionProp
	}
	orchestratedResourceProp, err := expandOSConfigV2PolicyOrchestratorOrchestratedResource(d.Get("orchestrated_resource"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("orchestrated_resource"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, orchestratedResourceProp)) {
		obj["orchestratedResource"] = orchestratedResourceProp
	}
	stateProp, err := expandOSConfigV2PolicyOrchestratorState(d.Get("state"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("state"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, stateProp)) {
		obj["state"] = stateProp
	}
	orchestrationScopeProp, err := expandOSConfigV2PolicyOrchestratorOrchestrationScope(d.Get("orchestration_scope"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("orchestration_scope"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, orchestrationScopeProp)) {
		obj["orchestrationScope"] = orchestrationScopeProp
	}
	labelsProp, err := expandOSConfigV2PolicyOrchestratorEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{OSConfigV2BasePath}}projects/{{project}}/locations/global/policyOrchestrators/{{policy_orchestrator_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating PolicyOrchestrator %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("action") {
		updateMask = append(updateMask, "action")
	}

	if d.HasChange("orchestrated_resource") {
		updateMask = append(updateMask, "orchestratedResource")
	}

	if d.HasChange("state") {
		updateMask = append(updateMask, "state")
	}

	if d.HasChange("orchestration_scope") {
		updateMask = append(updateMask, "orchestrationScope")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating PolicyOrchestrator %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating PolicyOrchestrator %q: %#v", d.Id(), res)
		}

		err = OSConfigV2OperationWaitTime(
			config, res, project, "Updating PolicyOrchestrator", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceOSConfigV2PolicyOrchestratorRead(d, meta)
}

func resourceOSConfigV2PolicyOrchestratorDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PolicyOrchestrator: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{OSConfigV2BasePath}}projects/{{project}}/locations/global/policyOrchestrators/{{policy_orchestrator_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting PolicyOrchestrator %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "PolicyOrchestrator")
	}

	err = OSConfigV2OperationWaitTime(
		config, res, project, "Deleting PolicyOrchestrator", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting PolicyOrchestrator %q: %#v", d.Id(), res)
	return nil
}

func resourceOSConfigV2PolicyOrchestratorImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/global/policyOrchestrators/(?P<policy_orchestrator_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<policy_orchestrator_id>[^/]+)$",
		"^(?P<policy_orchestrator_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/global/policyOrchestrators/{{policy_orchestrator_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenOSConfigV2PolicyOrchestratorName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorReconciling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorAction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["os_policy_assignment_v1_payload"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1Payload(original["osPolicyAssignmentV1Payload"], d, config)
	transformed["id"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceId(original["id"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1Payload(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uid"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadUid(original["uid"], d, config)
	transformed["name"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadName(original["name"], d, config)
	transformed["description"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadDescription(original["description"], d, config)
	transformed["os_policies"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicies(original["osPolicies"], d, config)
	transformed["revision_id"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRevisionId(original["revisionId"], d, config)
	transformed["baseline"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadBaseline(original["baseline"], d, config)
	transformed["deleted"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadDeleted(original["deleted"], d, config)
	transformed["instance_filter"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilter(original["instanceFilter"], d, config)
	transformed["rollout"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRollout(original["rollout"], d, config)
	transformed["revision_create_time"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRevisionCreateTime(original["revisionCreateTime"], d, config)
	transformed["rollout_state"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutState(original["rolloutState"], d, config)
	transformed["reconciling"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadReconciling(original["reconciling"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicies(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"mode":                          flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesMode(original["mode"], d, config),
			"resource_groups":               flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroups(original["resourceGroups"], d, config),
			"allow_no_resource_group_match": flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesAllowNoResourceGroupMatch(original["allowNoResourceGroupMatch"], d, config),
			"id":                            flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesId(original["id"], d, config),
			"description":                   flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesDescription(original["description"], d, config),
		})
	}
	return transformed
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroups(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"inventory_filters": flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFilters(original["inventoryFilters"], d, config),
			"resources":         flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResources(original["resources"], d, config),
		})
	}
	return transformed
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFilters(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"os_short_name": flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFiltersOsShortName(original["osShortName"], d, config),
			"os_version":    flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFiltersOsVersion(original["osVersion"], d, config),
		})
	}
	return transformed
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFiltersOsShortName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFiltersOsVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"repository": flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepository(original["repository"], d, config),
			"exec":       flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExec(original["exec"], d, config),
			"file":       flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFile(original["file"], d, config),
			"id":         flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesId(original["id"], d, config),
			"pkg":        flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkg(original["pkg"], d, config),
		})
	}
	return transformed
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepository(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["yum"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYum(original["yum"], d, config)
	transformed["zypper"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypper(original["zypper"], d, config)
	transformed["goo"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGoo(original["goo"], d, config)
	transformed["apt"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryApt(original["apt"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["id"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumId(original["id"], d, config)
	transformed["display_name"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumDisplayName(original["displayName"], d, config)
	transformed["base_url"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumBaseUrl(original["baseUrl"], d, config)
	transformed["gpg_keys"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumGpgKeys(original["gpgKeys"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumBaseUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumGpgKeys(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypper(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["id"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperId(original["id"], d, config)
	transformed["display_name"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperDisplayName(original["displayName"], d, config)
	transformed["base_url"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperBaseUrl(original["baseUrl"], d, config)
	transformed["gpg_keys"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperGpgKeys(original["gpgKeys"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperBaseUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperGpgKeys(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGoo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGooName(original["name"], d, config)
	transformed["url"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGooUrl(original["url"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGooName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGooUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryApt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptUri(original["uri"], d, config)
	transformed["distribution"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptDistribution(original["distribution"], d, config)
	transformed["components"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptComponents(original["components"], d, config)
	transformed["gpg_key"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptGpgKey(original["gpgKey"], d, config)
	transformed["archive_type"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptArchiveType(original["archiveType"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptDistribution(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptComponents(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptGpgKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptArchiveType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enforce"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforce(original["enforce"], d, config)
	transformed["validate"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidate(original["validate"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforce(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["script"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceScript(original["script"], d, config)
	transformed["args"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceArgs(original["args"], d, config)
	transformed["interpreter"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceInterpreter(original["interpreter"], d, config)
	transformed["output_file_path"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceOutputFilePath(original["outputFilePath"], d, config)
	transformed["file"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFile(original["file"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceScript(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceArgs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceInterpreter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceOutputFilePath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["remote"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemote(original["remote"], d, config)
	transformed["gcs"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcs(original["gcs"], d, config)
	transformed["local_path"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileLocalPath(original["localPath"], d, config)
	transformed["allow_insecure"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileAllowInsecure(original["allowInsecure"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemote(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemoteUri(original["uri"], d, config)
	transformed["sha256_checksum"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemoteSha256Checksum(original["sha256Checksum"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemoteUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemoteSha256Checksum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["bucket"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsBucket(original["bucket"], d, config)
	transformed["object"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsObject(original["object"], d, config)
	transformed["generation"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsGeneration(original["generation"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsObject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsGeneration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileLocalPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileAllowInsecure(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["file"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFile(original["file"], d, config)
	transformed["script"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateScript(original["script"], d, config)
	transformed["args"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateArgs(original["args"], d, config)
	transformed["interpreter"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateInterpreter(original["interpreter"], d, config)
	transformed["output_file_path"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateOutputFilePath(original["outputFilePath"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["gcs"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcs(original["gcs"], d, config)
	transformed["local_path"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileLocalPath(original["localPath"], d, config)
	transformed["allow_insecure"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileAllowInsecure(original["allowInsecure"], d, config)
	transformed["remote"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemote(original["remote"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["bucket"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsBucket(original["bucket"], d, config)
	transformed["object"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsObject(original["object"], d, config)
	transformed["generation"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsGeneration(original["generation"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsObject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsGeneration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileLocalPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileAllowInsecure(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemote(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemoteUri(original["uri"], d, config)
	transformed["sha256_checksum"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemoteSha256Checksum(original["sha256Checksum"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemoteUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemoteSha256Checksum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateScript(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateArgs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateInterpreter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateOutputFilePath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["file"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFile(original["file"], d, config)
	transformed["content"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileContent(original["content"], d, config)
	transformed["path"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFilePath(original["path"], d, config)
	transformed["state"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileState(original["state"], d, config)
	transformed["permissions"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFilePermissions(original["permissions"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["remote"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemote(original["remote"], d, config)
	transformed["gcs"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcs(original["gcs"], d, config)
	transformed["local_path"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileLocalPath(original["localPath"], d, config)
	transformed["allow_insecure"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileAllowInsecure(original["allowInsecure"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemote(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemoteUri(original["uri"], d, config)
	transformed["sha256_checksum"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemoteSha256Checksum(original["sha256Checksum"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemoteUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemoteSha256Checksum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["object"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsObject(original["object"], d, config)
	transformed["generation"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsGeneration(original["generation"], d, config)
	transformed["bucket"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsBucket(original["bucket"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsObject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsGeneration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileLocalPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileAllowInsecure(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileContent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFilePath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFilePermissions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkg(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["msi"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsi(original["msi"], d, config)
	transformed["desired_state"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDesiredState(original["desiredState"], d, config)
	transformed["apt"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgApt(original["apt"], d, config)
	transformed["deb"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDeb(original["deb"], d, config)
	transformed["yum"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgYum(original["yum"], d, config)
	transformed["zypper"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgZypper(original["zypper"], d, config)
	transformed["rpm"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpm(original["rpm"], d, config)
	transformed["googet"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgGooget(original["googet"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsi(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["source"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSource(original["source"], d, config)
	transformed["properties"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiProperties(original["properties"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["gcs"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs(original["gcs"], d, config)
	transformed["local_path"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceLocalPath(original["localPath"], d, config)
	transformed["allow_insecure"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceAllowInsecure(original["allowInsecure"], d, config)
	transformed["remote"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote(original["remote"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["generation"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsGeneration(original["generation"], d, config)
	transformed["bucket"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsBucket(original["bucket"], d, config)
	transformed["object"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsObject(original["object"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsGeneration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsObject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceLocalPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceAllowInsecure(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemoteUri(original["uri"], d, config)
	transformed["sha256_checksum"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemoteSha256Checksum(original["sha256Checksum"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemoteUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemoteSha256Checksum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDesiredState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgApt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgAptName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgAptName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDeb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["source"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSource(original["source"], d, config)
	transformed["pull_deps"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebPullDeps(original["pullDeps"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["remote"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemote(original["remote"], d, config)
	transformed["gcs"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcs(original["gcs"], d, config)
	transformed["local_path"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceLocalPath(original["localPath"], d, config)
	transformed["allow_insecure"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceAllowInsecure(original["allowInsecure"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemote(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemoteUri(original["uri"], d, config)
	transformed["sha256_checksum"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemoteSha256Checksum(original["sha256Checksum"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemoteUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemoteSha256Checksum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["bucket"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsBucket(original["bucket"], d, config)
	transformed["object"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsObject(original["object"], d, config)
	transformed["generation"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsGeneration(original["generation"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsObject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsGeneration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceLocalPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceAllowInsecure(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebPullDeps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgYum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgYumName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgYumName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgZypper(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgZypperName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgZypperName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpm(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["source"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSource(original["source"], d, config)
	transformed["pull_deps"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmPullDeps(original["pullDeps"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["remote"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote(original["remote"], d, config)
	transformed["gcs"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs(original["gcs"], d, config)
	transformed["local_path"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceLocalPath(original["localPath"], d, config)
	transformed["allow_insecure"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceAllowInsecure(original["allowInsecure"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemoteUri(original["uri"], d, config)
	transformed["sha256_checksum"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemoteSha256Checksum(original["sha256Checksum"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemoteUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemoteSha256Checksum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["generation"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsGeneration(original["generation"], d, config)
	transformed["bucket"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsBucket(original["bucket"], d, config)
	transformed["object"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsObject(original["object"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsGeneration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsObject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceLocalPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceAllowInsecure(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmPullDeps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgGooget(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgGoogetName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgGoogetName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesAllowNoResourceGroupMatch(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRevisionId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadBaseline(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadDeleted(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["inclusion_labels"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabels(original["inclusionLabels"], d, config)
	transformed["exclusion_labels"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabels(original["exclusionLabels"], d, config)
	transformed["inventories"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventories(original["inventories"], d, config)
	transformed["all"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterAll(original["all"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"labels": flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabelsLabels(original["labels"], d, config),
		})
	}
	return transformed
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabelsLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"labels": flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabelsLabels(original["labels"], d, config),
		})
	}
	return transformed
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabelsLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventories(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"os_short_name": flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventoriesOsShortName(original["osShortName"], d, config),
			"os_version":    flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventoriesOsVersion(original["osVersion"], d, config),
		})
	}
	return transformed
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventoriesOsShortName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventoriesOsVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterAll(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRollout(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disruption_budget"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudget(original["disruptionBudget"], d, config)
	transformed["min_wait_duration"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutMinWaitDuration(original["minWaitDuration"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudget(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["fixed"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudgetFixed(original["fixed"], d, config)
	transformed["percent"] =
		flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudgetPercent(original["percent"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudgetFixed(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudgetPercent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutMinWaitDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRevisionCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadReconciling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestratedResourceId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["current_iteration_state"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationState(original["currentIterationState"], d, config)
	transformed["previous_iteration_state"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationState(original["previousIterationState"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateError(original["error"], d, config)
	transformed["state"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateState(original["state"], d, config)
	transformed["rollout_resource"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateRolloutResource(original["rolloutResource"], d, config)
	transformed["progress"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateProgress(original["progress"], d, config)
	transformed["performed_actions"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStatePerformedActions(original["performedActions"], d, config)
	transformed["failed_actions"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateFailedActions(original["failedActions"], d, config)
	transformed["start_time"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateStartTime(original["startTime"], d, config)
	transformed["finish_time"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateFinishTime(original["finishTime"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateError(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["details"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorDetails(original["details"], d, config)
	transformed["code"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorCode(original["code"], d, config)
	transformed["message"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorMessage(original["message"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type_url": flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorDetailsTypeUrl(original["type_url"], d, config),
			"value":    flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorDetailsValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorDetailsTypeUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorDetailsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateErrorMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateRolloutResource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateProgress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStatePerformedActions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateFailedActions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStateCurrentIterationStateFinishTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["failed_actions"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateFailedActions(original["failedActions"], d, config)
	transformed["start_time"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateStartTime(original["startTime"], d, config)
	transformed["finish_time"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateFinishTime(original["finishTime"], d, config)
	transformed["error"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateError(original["error"], d, config)
	transformed["state"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateState(original["state"], d, config)
	transformed["rollout_resource"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateRolloutResource(original["rolloutResource"], d, config)
	transformed["progress"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateProgress(original["progress"], d, config)
	transformed["performed_actions"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStatePerformedActions(original["performedActions"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateFailedActions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateFinishTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateError(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["code"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorCode(original["code"], d, config)
	transformed["message"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorMessage(original["message"], d, config)
	transformed["details"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorDetails(original["details"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type_url": flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorDetailsTypeUrl(original["type_url"], d, config),
			"value":    flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorDetailsValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorDetailsTypeUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateErrorDetailsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateRolloutResource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStateProgress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationStatePreviousIterationStatePerformedActions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["selectors"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectors(original["selectors"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectors(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"resource_hierarchy_selector": flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelector(original["resourceHierarchySelector"], d, config),
			"location_selector":           flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsLocationSelector(original["locationSelector"], d, config),
		})
	}
	return transformed
}
func flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelector(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["included_projects"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelectorIncludedProjects(original["includedProjects"], d, config)
	transformed["included_folders"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelectorIncludedFolders(original["includedFolders"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelectorIncludedProjects(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelectorIncludedFolders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsLocationSelector(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["included_locations"] =
		flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsLocationSelectorIncludedLocations(original["includedLocations"], d, config)
	return []interface{}{transformed}
}
func flattenOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsLocationSelectorIncludedLocations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenOSConfigV2PolicyOrchestratorLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenOSConfigV2PolicyOrchestratorTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenOSConfigV2PolicyOrchestratorEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandOSConfigV2PolicyOrchestratorDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorAction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOsPolicyAssignmentV1Payload, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1Payload(original["os_policy_assignment_v1_payload"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOsPolicyAssignmentV1Payload); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["osPolicyAssignmentV1Payload"] = transformedOsPolicyAssignmentV1Payload
	}

	transformedId, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceId(original["id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["id"] = transformedId
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1Payload(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUid, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadUid(original["uid"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUid); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uid"] = transformedUid
	}

	transformedName, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedDescription, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedOsPolicies, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicies(original["os_policies"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOsPolicies); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["osPolicies"] = transformedOsPolicies
	}

	transformedRevisionId, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRevisionId(original["revision_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRevisionId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["revisionId"] = transformedRevisionId
	}

	transformedBaseline, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadBaseline(original["baseline"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBaseline); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["baseline"] = transformedBaseline
	}

	transformedDeleted, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadDeleted(original["deleted"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDeleted); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["deleted"] = transformedDeleted
	}

	transformedInstanceFilter, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilter(original["instance_filter"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstanceFilter); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instanceFilter"] = transformedInstanceFilter
	}

	transformedRollout, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRollout(original["rollout"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRollout); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rollout"] = transformedRollout
	}

	transformedRevisionCreateTime, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRevisionCreateTime(original["revision_create_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRevisionCreateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["revisionCreateTime"] = transformedRevisionCreateTime
	}

	transformedRolloutState, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutState(original["rollout_state"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRolloutState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rolloutState"] = transformedRolloutState
	}

	transformedReconciling, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadReconciling(original["reconciling"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReconciling); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["reconciling"] = transformedReconciling
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadUid(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPolicies(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedMode, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesMode(original["mode"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["mode"] = transformedMode
		}

		transformedResourceGroups, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroups(original["resource_groups"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResourceGroups); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resourceGroups"] = transformedResourceGroups
		}

		transformedAllowNoResourceGroupMatch, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesAllowNoResourceGroupMatch(original["allow_no_resource_group_match"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAllowNoResourceGroupMatch); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["allowNoResourceGroupMatch"] = transformedAllowNoResourceGroupMatch
		}

		transformedId, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesId(original["id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["id"] = transformedId
		}

		transformedDescription, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesDescription(original["description"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["description"] = transformedDescription
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroups(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedInventoryFilters, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFilters(original["inventory_filters"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInventoryFilters); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["inventoryFilters"] = transformedInventoryFilters
		}

		transformedResources, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResources(original["resources"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResources); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resources"] = transformedResources
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFilters(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedOsShortName, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFiltersOsShortName(original["os_short_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOsShortName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["osShortName"] = transformedOsShortName
		}

		transformedOsVersion, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFiltersOsVersion(original["os_version"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOsVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["osVersion"] = transformedOsVersion
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFiltersOsShortName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsInventoryFiltersOsVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedRepository, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepository(original["repository"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedRepository); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["repository"] = transformedRepository
		}

		transformedExec, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExec(original["exec"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["exec"] = transformedExec
		}

		transformedFile, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFile(original["file"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFile); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["file"] = transformedFile
		}

		transformedId, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesId(original["id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["id"] = transformedId
		}

		transformedPkg, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkg(original["pkg"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPkg); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["pkg"] = transformedPkg
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepository(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedYum, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYum(original["yum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedYum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["yum"] = transformedYum
	}

	transformedZypper, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypper(original["zypper"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedZypper); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["zypper"] = transformedZypper
	}

	transformedGoo, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGoo(original["goo"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGoo); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["goo"] = transformedGoo
	}

	transformedApt, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryApt(original["apt"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApt); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["apt"] = transformedApt
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedId, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumId(original["id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["id"] = transformedId
	}

	transformedDisplayName, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumDisplayName(original["display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayName"] = transformedDisplayName
	}

	transformedBaseUrl, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumBaseUrl(original["base_url"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBaseUrl); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["baseUrl"] = transformedBaseUrl
	}

	transformedGpgKeys, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumGpgKeys(original["gpg_keys"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGpgKeys); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gpgKeys"] = transformedGpgKeys
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumBaseUrl(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryYumGpgKeys(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypper(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedId, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperId(original["id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["id"] = transformedId
	}

	transformedDisplayName, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperDisplayName(original["display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayName"] = transformedDisplayName
	}

	transformedBaseUrl, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperBaseUrl(original["base_url"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBaseUrl); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["baseUrl"] = transformedBaseUrl
	}

	transformedGpgKeys, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperGpgKeys(original["gpg_keys"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGpgKeys); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gpgKeys"] = transformedGpgKeys
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperBaseUrl(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryZypperGpgKeys(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGoo(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGooName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedUrl, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGooUrl(original["url"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUrl); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["url"] = transformedUrl
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGooName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryGooUrl(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryApt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedDistribution, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptDistribution(original["distribution"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDistribution); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["distribution"] = transformedDistribution
	}

	transformedComponents, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptComponents(original["components"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedComponents); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["components"] = transformedComponents
	}

	transformedGpgKey, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptGpgKey(original["gpg_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGpgKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gpgKey"] = transformedGpgKey
	}

	transformedArchiveType, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptArchiveType(original["archive_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedArchiveType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["archiveType"] = transformedArchiveType
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptDistribution(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptComponents(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptGpgKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesRepositoryAptArchiveType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnforce, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforce(original["enforce"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnforce); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enforce"] = transformedEnforce
	}

	transformedValidate, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidate(original["validate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedValidate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["validate"] = transformedValidate
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforce(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedScript, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceScript(original["script"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScript); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["script"] = transformedScript
	}

	transformedArgs, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceArgs(original["args"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedArgs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["args"] = transformedArgs
	}

	transformedInterpreter, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceInterpreter(original["interpreter"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInterpreter); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["interpreter"] = transformedInterpreter
	}

	transformedOutputFilePath, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceOutputFilePath(original["output_file_path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputFilePath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputFilePath"] = transformedOutputFilePath
	}

	transformedFile, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFile(original["file"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFile); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["file"] = transformedFile
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceScript(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceArgs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceInterpreter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceOutputFilePath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRemote, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemote(original["remote"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRemote); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["remote"] = transformedRemote
	}

	transformedGcs, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcs(original["gcs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcs"] = transformedGcs
	}

	transformedLocalPath, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileLocalPath(original["local_path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["localPath"] = transformedLocalPath
	}

	transformedAllowInsecure, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileAllowInsecure(original["allow_insecure"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowInsecure); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allowInsecure"] = transformedAllowInsecure
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemote(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemoteUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedSha256Checksum, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemoteSha256Checksum(original["sha256_checksum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSha256Checksum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sha256Checksum"] = transformedSha256Checksum
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemoteUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileRemoteSha256Checksum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBucket, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsBucket(original["bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bucket"] = transformedBucket
	}

	transformedObject, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsObject(original["object"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedObject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["object"] = transformedObject
	}

	transformedGeneration, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsGeneration(original["generation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGeneration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["generation"] = transformedGeneration
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsObject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileGcsGeneration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileLocalPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecEnforceFileAllowInsecure(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFile, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFile(original["file"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFile); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["file"] = transformedFile
	}

	transformedScript, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateScript(original["script"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScript); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["script"] = transformedScript
	}

	transformedArgs, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateArgs(original["args"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedArgs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["args"] = transformedArgs
	}

	transformedInterpreter, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateInterpreter(original["interpreter"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInterpreter); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["interpreter"] = transformedInterpreter
	}

	transformedOutputFilePath, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateOutputFilePath(original["output_file_path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputFilePath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputFilePath"] = transformedOutputFilePath
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGcs, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcs(original["gcs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcs"] = transformedGcs
	}

	transformedLocalPath, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileLocalPath(original["local_path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["localPath"] = transformedLocalPath
	}

	transformedAllowInsecure, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileAllowInsecure(original["allow_insecure"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowInsecure); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allowInsecure"] = transformedAllowInsecure
	}

	transformedRemote, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemote(original["remote"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRemote); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["remote"] = transformedRemote
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBucket, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsBucket(original["bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bucket"] = transformedBucket
	}

	transformedObject, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsObject(original["object"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedObject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["object"] = transformedObject
	}

	transformedGeneration, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsGeneration(original["generation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGeneration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["generation"] = transformedGeneration
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsObject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileGcsGeneration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileLocalPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileAllowInsecure(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemote(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemoteUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedSha256Checksum, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemoteSha256Checksum(original["sha256_checksum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSha256Checksum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sha256Checksum"] = transformedSha256Checksum
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemoteUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateFileRemoteSha256Checksum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateScript(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateArgs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateInterpreter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesExecValidateOutputFilePath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFile, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFile(original["file"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFile); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["file"] = transformedFile
	}

	transformedContent, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileContent(original["content"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContent); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["content"] = transformedContent
	}

	transformedPath, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFilePath(original["path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["path"] = transformedPath
	}

	transformedState, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileState(original["state"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["state"] = transformedState
	}

	transformedPermissions, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFilePermissions(original["permissions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPermissions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["permissions"] = transformedPermissions
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRemote, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemote(original["remote"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRemote); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["remote"] = transformedRemote
	}

	transformedGcs, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcs(original["gcs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcs"] = transformedGcs
	}

	transformedLocalPath, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileLocalPath(original["local_path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["localPath"] = transformedLocalPath
	}

	transformedAllowInsecure, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileAllowInsecure(original["allow_insecure"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowInsecure); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allowInsecure"] = transformedAllowInsecure
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemote(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemoteUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedSha256Checksum, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemoteSha256Checksum(original["sha256_checksum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSha256Checksum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sha256Checksum"] = transformedSha256Checksum
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemoteUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileRemoteSha256Checksum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedObject, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsObject(original["object"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedObject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["object"] = transformedObject
	}

	transformedGeneration, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsGeneration(original["generation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGeneration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["generation"] = transformedGeneration
	}

	transformedBucket, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsBucket(original["bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bucket"] = transformedBucket
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsObject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsGeneration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileGcsBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileLocalPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileFileAllowInsecure(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileContent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFilePath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFileState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesFilePermissions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkg(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMsi, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsi(original["msi"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMsi); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["msi"] = transformedMsi
	}

	transformedDesiredState, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDesiredState(original["desired_state"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDesiredState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["desiredState"] = transformedDesiredState
	}

	transformedApt, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgApt(original["apt"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApt); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["apt"] = transformedApt
	}

	transformedDeb, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDeb(original["deb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDeb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["deb"] = transformedDeb
	}

	transformedYum, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgYum(original["yum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedYum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["yum"] = transformedYum
	}

	transformedZypper, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgZypper(original["zypper"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedZypper); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["zypper"] = transformedZypper
	}

	transformedRpm, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpm(original["rpm"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRpm); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rpm"] = transformedRpm
	}

	transformedGooget, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgGooget(original["googet"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGooget); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["googet"] = transformedGooget
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsi(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSource, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSource(original["source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["source"] = transformedSource
	}

	transformedProperties, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiProperties(original["properties"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProperties); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["properties"] = transformedProperties
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGcs, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs(original["gcs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcs"] = transformedGcs
	}

	transformedLocalPath, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceLocalPath(original["local_path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["localPath"] = transformedLocalPath
	}

	transformedAllowInsecure, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceAllowInsecure(original["allow_insecure"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowInsecure); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allowInsecure"] = transformedAllowInsecure
	}

	transformedRemote, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote(original["remote"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRemote); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["remote"] = transformedRemote
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGeneration, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsGeneration(original["generation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGeneration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["generation"] = transformedGeneration
	}

	transformedBucket, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsBucket(original["bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bucket"] = transformedBucket
	}

	transformedObject, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsObject(original["object"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedObject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["object"] = transformedObject
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsGeneration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceGcsObject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceLocalPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceAllowInsecure(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemote(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemoteUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedSha256Checksum, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemoteSha256Checksum(original["sha256_checksum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSha256Checksum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sha256Checksum"] = transformedSha256Checksum
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemoteUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiSourceRemoteSha256Checksum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgMsiProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDesiredState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgApt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgAptName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgAptName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDeb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSource, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSource(original["source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["source"] = transformedSource
	}

	transformedPullDeps, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebPullDeps(original["pull_deps"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPullDeps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pullDeps"] = transformedPullDeps
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRemote, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemote(original["remote"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRemote); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["remote"] = transformedRemote
	}

	transformedGcs, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcs(original["gcs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcs"] = transformedGcs
	}

	transformedLocalPath, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceLocalPath(original["local_path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["localPath"] = transformedLocalPath
	}

	transformedAllowInsecure, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceAllowInsecure(original["allow_insecure"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowInsecure); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allowInsecure"] = transformedAllowInsecure
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemote(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemoteUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedSha256Checksum, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemoteSha256Checksum(original["sha256_checksum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSha256Checksum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sha256Checksum"] = transformedSha256Checksum
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemoteUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceRemoteSha256Checksum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBucket, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsBucket(original["bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bucket"] = transformedBucket
	}

	transformedObject, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsObject(original["object"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedObject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["object"] = transformedObject
	}

	transformedGeneration, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsGeneration(original["generation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGeneration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["generation"] = transformedGeneration
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsObject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceGcsGeneration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceLocalPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebSourceAllowInsecure(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgDebPullDeps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgYum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgYumName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgYumName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgZypper(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgZypperName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgZypperName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpm(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSource, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSource(original["source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["source"] = transformedSource
	}

	transformedPullDeps, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmPullDeps(original["pull_deps"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPullDeps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pullDeps"] = transformedPullDeps
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRemote, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote(original["remote"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRemote); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["remote"] = transformedRemote
	}

	transformedGcs, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs(original["gcs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcs"] = transformedGcs
	}

	transformedLocalPath, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceLocalPath(original["local_path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["localPath"] = transformedLocalPath
	}

	transformedAllowInsecure, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceAllowInsecure(original["allow_insecure"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowInsecure); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allowInsecure"] = transformedAllowInsecure
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemote(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemoteUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedSha256Checksum, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemoteSha256Checksum(original["sha256_checksum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSha256Checksum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sha256Checksum"] = transformedSha256Checksum
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemoteUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceRemoteSha256Checksum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGeneration, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsGeneration(original["generation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGeneration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["generation"] = transformedGeneration
	}

	transformedBucket, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsBucket(original["bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bucket"] = transformedBucket
	}

	transformedObject, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsObject(original["object"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedObject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["object"] = transformedObject
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsGeneration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceGcsObject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceLocalPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmSourceAllowInsecure(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgRpmPullDeps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgGooget(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgGoogetName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesResourceGroupsResourcesPkgGoogetName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesAllowNoResourceGroupMatch(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadOsPoliciesDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRevisionId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadBaseline(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadDeleted(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInclusionLabels, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabels(original["inclusion_labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInclusionLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inclusionLabels"] = transformedInclusionLabels
	}

	transformedExclusionLabels, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabels(original["exclusion_labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExclusionLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["exclusionLabels"] = transformedExclusionLabels
	}

	transformedInventories, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventories(original["inventories"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInventories); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inventories"] = transformedInventories
	}

	transformedAll, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterAll(original["all"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAll); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["all"] = transformedAll
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedLabels, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabelsLabels(original["labels"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["labels"] = transformedLabels
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInclusionLabelsLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedLabels, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabelsLabels(original["labels"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["labels"] = transformedLabels
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterExclusionLabelsLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventories(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedOsShortName, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventoriesOsShortName(original["os_short_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOsShortName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["osShortName"] = transformedOsShortName
		}

		transformedOsVersion, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventoriesOsVersion(original["os_version"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOsVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["osVersion"] = transformedOsVersion
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventoriesOsShortName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterInventoriesOsVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadInstanceFilterAll(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRollout(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDisruptionBudget, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudget(original["disruption_budget"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisruptionBudget); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disruptionBudget"] = transformedDisruptionBudget
	}

	transformedMinWaitDuration, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutMinWaitDuration(original["min_wait_duration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinWaitDuration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minWaitDuration"] = transformedMinWaitDuration
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudget(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFixed, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudgetFixed(original["fixed"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFixed); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fixed"] = transformedFixed
	}

	transformedPercent, err := expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudgetPercent(original["percent"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPercent); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["percent"] = transformedPercent
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudgetFixed(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutDisruptionBudgetPercent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutMinWaitDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRevisionCreateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadRolloutState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceOsPolicyAssignmentV1PayloadReconciling(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestratedResourceId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestrationScope(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSelectors, err := expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectors(original["selectors"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSelectors); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["selectors"] = transformedSelectors
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectors(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedResourceHierarchySelector, err := expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelector(original["resource_hierarchy_selector"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResourceHierarchySelector); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resourceHierarchySelector"] = transformedResourceHierarchySelector
		}

		transformedLocationSelector, err := expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsLocationSelector(original["location_selector"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLocationSelector); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["locationSelector"] = transformedLocationSelector
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelector(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIncludedProjects, err := expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelectorIncludedProjects(original["included_projects"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIncludedProjects); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["includedProjects"] = transformedIncludedProjects
	}

	transformedIncludedFolders, err := expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelectorIncludedFolders(original["included_folders"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIncludedFolders); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["includedFolders"] = transformedIncludedFolders
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelectorIncludedProjects(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsResourceHierarchySelectorIncludedFolders(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsLocationSelector(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIncludedLocations, err := expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsLocationSelectorIncludedLocations(original["included_locations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIncludedLocations); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["includedLocations"] = transformedIncludedLocations
	}

	return transformed, nil
}

func expandOSConfigV2PolicyOrchestratorOrchestrationScopeSelectorsLocationSelectorIncludedLocations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandOSConfigV2PolicyOrchestratorEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
