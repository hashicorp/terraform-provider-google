// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/gkehub2/ScopeRBACRoleBinding.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package gkehub2

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceGKEHub2ScopeRBACRoleBinding() *schema.Resource {
	return &schema.Resource{
		Create: resourceGKEHub2ScopeRBACRoleBindingCreate,
		Read:   resourceGKEHub2ScopeRBACRoleBindingRead,
		Update: resourceGKEHub2ScopeRBACRoleBindingUpdate,
		Delete: resourceGKEHub2ScopeRBACRoleBindingDelete,

		Importer: &schema.ResourceImporter{
			State: resourceGKEHub2ScopeRBACRoleBindingImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"scope_rbac_role_binding_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"scope_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"role": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `Role to bind to the principal.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"custom_role": {
							Type:         schema.TypeString,
							Optional:     true,
							Description:  `CustomRole is the custom Kubernetes ClusterRole to be used. The custom role format must be allowlisted in the rbacrolebindingactuation feature and RFC 1123 compliant.`,
							ExactlyOneOf: []string{"role.0.custom_role", "role.0.predefined_role"},
						},
						"predefined_role": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"UNKNOWN", "ADMIN", "EDIT", "VIEW", ""}),
							Description:  `PredefinedRole is an ENUM representation of the default Kubernetes Roles Possible values: ["UNKNOWN", "ADMIN", "EDIT", "VIEW"]`,
							ExactlyOneOf: []string{"role.0.custom_role", "role.0.predefined_role"},
						},
					},
				},
			},
			"scope_rbac_role_binding_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The client-provided identifier of the RBAC Role Binding.`,
			},
			"scope_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Id of the scope`,
			},
			"group": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Principal that is be authorized in the cluster (at least of one the oneof
is required). Updating one will unset the other automatically.
group is the group, as seen by the kubernetes cluster.`,
				ExactlyOneOf: []string{"group", "user"},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Labels for this ScopeRBACRoleBinding.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"user": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Principal that is be authorized in the cluster (at least of one the oneof
is required). Updating one will unset the other automatically.
user is the name of the user as seen by the kubernetes cluster, example
"alice" or "alice@domain.tld"`,
				ExactlyOneOf: []string{"group", "user"},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time the RBAC Role Binding was created in UTC.`,
			},
			"delete_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time the RBAC Role Binding was deleted in UTC.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The resource name for the RBAC Role Binding`,
			},
			"state": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `State of the RBAC Role Binding resource.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"code": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Code describes the state of a RBAC Role Binding resource.`,
						},
					},
				},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Google-generated UUID for this resource.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time the RBAC Role Binding was updated in UTC.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceGKEHub2ScopeRBACRoleBindingCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	userProp, err := expandGKEHub2ScopeRBACRoleBindingUser(d.Get("user"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("user"); !tpgresource.IsEmptyValue(reflect.ValueOf(userProp)) && (ok || !reflect.DeepEqual(v, userProp)) {
		obj["user"] = userProp
	}
	groupProp, err := expandGKEHub2ScopeRBACRoleBindingGroup(d.Get("group"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("group"); !tpgresource.IsEmptyValue(reflect.ValueOf(groupProp)) && (ok || !reflect.DeepEqual(v, groupProp)) {
		obj["group"] = groupProp
	}
	roleProp, err := expandGKEHub2ScopeRBACRoleBindingRole(d.Get("role"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("role"); !tpgresource.IsEmptyValue(reflect.ValueOf(roleProp)) && (ok || !reflect.DeepEqual(v, roleProp)) {
		obj["role"] = roleProp
	}
	effectiveLabelsProp, err := expandGKEHub2ScopeRBACRoleBindingEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GKEHub2BasePath}}projects/{{project}}/locations/global/scopes/{{scope_id}}/rbacrolebindings/?rbacrolebinding_id={{scope_rbac_role_binding_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new ScopeRBACRoleBinding: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ScopeRBACRoleBinding: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating ScopeRBACRoleBinding: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/global/scopes/{{scope_id}}/rbacrolebindings/{{scope_rbac_role_binding_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if scopeRbacRoleBindingIdValue, ok := d.GetOk("scope_rbac_role_binding_id"); ok && scopeRbacRoleBindingIdValue.(string) != "" {
			if err = identity.Set("scope_rbac_role_binding_id", scopeRbacRoleBindingIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting scope_rbac_role_binding_id: %s", err)
			}
		}
		if scopeIdValue, ok := d.GetOk("scope_id"); ok && scopeIdValue.(string) != "" {
			if err = identity.Set("scope_id", scopeIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting scope_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = GKEHub2OperationWaitTime(
		config, res, project, "Creating ScopeRBACRoleBinding", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create ScopeRBACRoleBinding: %s", err)
	}

	log.Printf("[DEBUG] Finished creating ScopeRBACRoleBinding %q: %#v", d.Id(), res)

	return resourceGKEHub2ScopeRBACRoleBindingRead(d, meta)
}

func resourceGKEHub2ScopeRBACRoleBindingRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GKEHub2BasePath}}projects/{{project}}/locations/global/scopes/{{scope_id}}/rbacrolebindings/{{scope_rbac_role_binding_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ScopeRBACRoleBinding: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("GKEHub2ScopeRBACRoleBinding %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}

	if err := d.Set("name", flattenGKEHub2ScopeRBACRoleBindingName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}
	if err := d.Set("uid", flattenGKEHub2ScopeRBACRoleBindingUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}
	if err := d.Set("create_time", flattenGKEHub2ScopeRBACRoleBindingCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}
	if err := d.Set("update_time", flattenGKEHub2ScopeRBACRoleBindingUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}
	if err := d.Set("delete_time", flattenGKEHub2ScopeRBACRoleBindingDeleteTime(res["deleteTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}
	if err := d.Set("state", flattenGKEHub2ScopeRBACRoleBindingState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}
	if err := d.Set("user", flattenGKEHub2ScopeRBACRoleBindingUser(res["user"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}
	if err := d.Set("group", flattenGKEHub2ScopeRBACRoleBindingGroup(res["group"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}
	if err := d.Set("role", flattenGKEHub2ScopeRBACRoleBindingRole(res["role"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}
	if err := d.Set("labels", flattenGKEHub2ScopeRBACRoleBindingLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}
	if err := d.Set("terraform_labels", flattenGKEHub2ScopeRBACRoleBindingTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}
	if err := d.Set("effective_labels", flattenGKEHub2ScopeRBACRoleBindingEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading ScopeRBACRoleBinding: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("scope_rbac_role_binding_id"); !ok && v == "" {
			err = identity.Set("scope_rbac_role_binding_id", d.Get("scope_rbac_role_binding_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting scope_rbac_role_binding_id: %s", err)
			}
		}
		if v, ok := identity.GetOk("scope_id"); !ok && v == "" {
			err = identity.Set("scope_id", d.Get("scope_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting scope_id: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceGKEHub2ScopeRBACRoleBindingUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if scopeRbacRoleBindingIdValue, ok := d.GetOk("scope_rbac_role_binding_id"); ok && scopeRbacRoleBindingIdValue.(string) != "" {
			if err = identity.Set("scope_rbac_role_binding_id", scopeRbacRoleBindingIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting scope_rbac_role_binding_id: %s", err)
			}
		}
		if scopeIdValue, ok := d.GetOk("scope_id"); ok && scopeIdValue.(string) != "" {
			if err = identity.Set("scope_id", scopeIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting scope_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ScopeRBACRoleBinding: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	userProp, err := expandGKEHub2ScopeRBACRoleBindingUser(d.Get("user"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("user"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, userProp)) {
		obj["user"] = userProp
	}
	groupProp, err := expandGKEHub2ScopeRBACRoleBindingGroup(d.Get("group"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("group"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, groupProp)) {
		obj["group"] = groupProp
	}
	roleProp, err := expandGKEHub2ScopeRBACRoleBindingRole(d.Get("role"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("role"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, roleProp)) {
		obj["role"] = roleProp
	}
	effectiveLabelsProp, err := expandGKEHub2ScopeRBACRoleBindingEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GKEHub2BasePath}}projects/{{project}}/locations/global/scopes/{{scope_id}}/rbacrolebindings/{{scope_rbac_role_binding_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating ScopeRBACRoleBinding %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("user") {
		updateMask = append(updateMask, "user")
	}

	if d.HasChange("group") {
		updateMask = append(updateMask, "group")
	}

	if d.HasChange("role") {
		updateMask = append(updateMask, "role")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating ScopeRBACRoleBinding %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating ScopeRBACRoleBinding %q: %#v", d.Id(), res)
		}

		err = GKEHub2OperationWaitTime(
			config, res, project, "Updating ScopeRBACRoleBinding", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceGKEHub2ScopeRBACRoleBindingRead(d, meta)
}

func resourceGKEHub2ScopeRBACRoleBindingDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ScopeRBACRoleBinding: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{GKEHub2BasePath}}projects/{{project}}/locations/global/scopes/{{scope_id}}/rbacrolebindings/{{scope_rbac_role_binding_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting ScopeRBACRoleBinding %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "ScopeRBACRoleBinding")
	}

	err = GKEHub2OperationWaitTime(
		config, res, project, "Deleting ScopeRBACRoleBinding", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting ScopeRBACRoleBinding %q: %#v", d.Id(), res)
	return nil
}

func resourceGKEHub2ScopeRBACRoleBindingImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/global/scopes/(?P<scope_id>[^/]+)/rbacrolebindings/(?P<scope_rbac_role_binding_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<scope_id>[^/]+)/(?P<scope_rbac_role_binding_id>[^/]+)$",
		"^(?P<scope_id>[^/]+)/(?P<scope_rbac_role_binding_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/global/scopes/{{scope_id}}/rbacrolebindings/{{scope_rbac_role_binding_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenGKEHub2ScopeRBACRoleBindingName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEHub2ScopeRBACRoleBindingUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEHub2ScopeRBACRoleBindingCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEHub2ScopeRBACRoleBindingUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEHub2ScopeRBACRoleBindingDeleteTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEHub2ScopeRBACRoleBindingState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["code"] =
		flattenGKEHub2ScopeRBACRoleBindingStateCode(original["code"], d, config)
	return []interface{}{transformed}
}
func flattenGKEHub2ScopeRBACRoleBindingStateCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEHub2ScopeRBACRoleBindingUser(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEHub2ScopeRBACRoleBindingGroup(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEHub2ScopeRBACRoleBindingRole(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["predefined_role"] =
		flattenGKEHub2ScopeRBACRoleBindingRolePredefinedRole(original["predefinedRole"], d, config)
	transformed["custom_role"] =
		flattenGKEHub2ScopeRBACRoleBindingRoleCustomRole(original["customRole"], d, config)
	return []interface{}{transformed}
}
func flattenGKEHub2ScopeRBACRoleBindingRolePredefinedRole(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEHub2ScopeRBACRoleBindingRoleCustomRole(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEHub2ScopeRBACRoleBindingLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenGKEHub2ScopeRBACRoleBindingTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenGKEHub2ScopeRBACRoleBindingEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandGKEHub2ScopeRBACRoleBindingUser(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEHub2ScopeRBACRoleBindingGroup(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEHub2ScopeRBACRoleBindingRole(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPredefinedRole, err := expandGKEHub2ScopeRBACRoleBindingRolePredefinedRole(original["predefined_role"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPredefinedRole); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["predefinedRole"] = transformedPredefinedRole
	}

	transformedCustomRole, err := expandGKEHub2ScopeRBACRoleBindingRoleCustomRole(original["custom_role"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCustomRole); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["customRole"] = transformedCustomRole
	}

	return transformed, nil
}

func expandGKEHub2ScopeRBACRoleBindingRolePredefinedRole(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEHub2ScopeRBACRoleBindingRoleCustomRole(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEHub2ScopeRBACRoleBindingEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
