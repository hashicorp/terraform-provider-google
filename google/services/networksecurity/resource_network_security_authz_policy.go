// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/networksecurity/AuthzPolicy.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package networksecurity

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceNetworkSecurityAuthzPolicy() *schema.Resource {
	return &schema.Resource{
		Create: resourceNetworkSecurityAuthzPolicyCreate,
		Read:   resourceNetworkSecurityAuthzPolicyRead,
		Update: resourceNetworkSecurityAuthzPolicyUpdate,
		Delete: resourceNetworkSecurityAuthzPolicyDelete,

		Importer: &schema.ResourceImporter{
			State: resourceNetworkSecurityAuthzPolicyImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(30 * time.Minute),
			Update: schema.DefaultTimeout(30 * time.Minute),
			Delete: schema.DefaultTimeout(30 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"action": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: verify.ValidateEnum([]string{"ALLOW", "DENY", "CUSTOM"}),
				Description: `When the action is CUSTOM, customProvider must be specified.
When the action is ALLOW, only requests matching the policy will be allowed.
When the action is DENY, only requests matching the policy will be denied.

When a request arrives, the policies are evaluated in the following order:
1. If there is a CUSTOM policy that matches the request, the CUSTOM policy is evaluated using the custom authorization providers and the request is denied if the provider rejects the request.
2. If there are any DENY policies that match the request, the request is denied.
3. If there are no ALLOW policies for the resource or if any of the ALLOW policies match the request, the request is allowed.
4. Else the request is denied by default if none of the configured AuthzPolicies with ALLOW action match the request. Possible values: ["ALLOW", "DENY", "CUSTOM"]`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The location of the resource.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Identifier. Name of the AuthzPolicy resource.`,
			},
			"target": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `Specifies the set of resources to which this policy should be applied to.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"load_balancing_scheme": {
							Type:         schema.TypeString,
							Required:     true,
							ValidateFunc: verify.ValidateEnum([]string{"INTERNAL_MANAGED", "EXTERNAL_MANAGED", "INTERNAL_SELF_MANAGED"}),
							Description: `All gateways and forwarding rules referenced by this policy and extensions must share the same load balancing scheme.
For more information, refer to [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service). Possible values: ["INTERNAL_MANAGED", "EXTERNAL_MANAGED", "INTERNAL_SELF_MANAGED"]`,
						},
						"resources": {
							Type:             schema.TypeList,
							Optional:         true,
							DiffSuppressFunc: tpgresource.ProjectNumberDiffSuppress,
							Description:      `A list of references to the Forwarding Rules on which this policy will be applied.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},
			"custom_provider": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Required if the action is CUSTOM. Allows delegating authorization decisions to Cloud IAP or to Service Extensions. One of cloudIap or authzExtension must be specified.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"authz_extension": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Delegate authorization decision to user authored Service Extension. Only one of cloudIap or authzExtension can be specified.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"resources": {
										Type:             schema.TypeList,
										Required:         true,
										DiffSuppressFunc: tpgresource.ProjectNumberDiffSuppress,
										Description:      `A list of references to authorization extensions that will be invoked for requests matching this policy. Limited to 1 custom provider.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"cloud_iap": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Delegates authorization decisions to Cloud IAP. Applicable only for managed load balancers. Enabling Cloud IAP at the AuthzPolicy level is not compatible with Cloud IAP settings in the BackendService. Enabling IAP in both places will result in request failure. Ensure that IAP is enabled in either the AuthzPolicy or the BackendService but not in both places.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enabled": {
										Type:        schema.TypeBool,
										Required:    true,
										Description: `Enable Cloud IAP at the AuthzPolicy level.`,
									},
								},
							},
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `A human-readable description of the resource.`,
			},
			"http_rules": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `A list of authorization HTTP rules to match against the incoming request.A policy match occurs when at least one HTTP rule matches the request or when no HTTP rules are specified in the policy. At least one HTTP Rule is required for Allow or Deny Action.
Limited to 5 rules.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"from": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Describes properties of one or more sources of a request.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"not_sources": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Describes the properties of a request's sources. At least one of sources or notSources must be specified. Limited to 5 sources. A match occurs when ANY source (in sources or notSources) matches the request. Within a single source, the match follows AND semantics across fields and OR semantics within a single field, i.e. a match occurs when ANY principal matches AND ANY ipBlocks match.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"principals": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `A list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
Limited to 5 principals.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"contains": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def`,
															},
															"exact": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.`,
															},
															"ignore_case": {
																Type:        schema.TypeBool,
																Optional:    true,
																Description: `If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.`,
															},
															"prefix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz`,
															},
															"suffix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc`,
															},
														},
													},
												},
												"resources": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `A list of resources to match against the resource of the source VM of a request.
Limited to 5 resources.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"iam_service_account": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `An IAM service account to match against the source service account of the VM sending the request.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"contains": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def`,
																		},
																		"exact": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.`,
																		},
																		"ignore_case": {
																			Type:        schema.TypeBool,
																			Optional:    true,
																			Description: `If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.`,
																		},
																		"prefix": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz`,
																		},
																		"suffix": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc`,
																		},
																	},
																},
															},
															"tag_value_id_set": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"ids": {
																			Type:     schema.TypeList,
																			Optional: true,
																			Description: `A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
Limited to 5 matches.`,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"sources": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Describes the properties of a request's sources. At least one of sources or notSources must be specified. Limited to 5 sources. A match occurs when ANY source (in sources or notSources) matches the request. Within a single source, the match follows AND semantics across fields and OR semantics within a single field, i.e. a match occurs when ANY principal matches AND ANY ipBlocks match.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"principals": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `A list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
Limited to 5 principals.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"contains": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def`,
															},
															"exact": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.`,
															},
															"ignore_case": {
																Type:        schema.TypeBool,
																Optional:    true,
																Description: `If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.`,
															},
															"prefix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz`,
															},
															"suffix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc`,
															},
														},
													},
												},
												"resources": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `A list of resources to match against the resource of the source VM of a request.
Limited to 5 resources.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"iam_service_account": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `An IAM service account to match against the source service account of the VM sending the request.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"contains": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def`,
																		},
																		"exact": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.`,
																		},
																		"ignore_case": {
																			Type:        schema.TypeBool,
																			Optional:    true,
																			Description: `If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.`,
																		},
																		"prefix": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz`,
																		},
																		"suffix": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc`,
																		},
																	},
																},
															},
															"tag_value_id_set": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"ids": {
																			Type:     schema.TypeList,
																			Optional: true,
																			Description: `A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
Limited to 5 matches.`,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"to": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Describes properties of one or more targets of a request`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"not_operations": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Describes the negated properties of the targets of a request. Matches requests for operations that do not match the criteria specified in this field. At least one of operations or notOperations must be specified.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"header_set": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `A list of headers to match against in http header.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"headers": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `A list of headers to match against in http header. The match can be one of exact, prefix, suffix, or contains (substring match). The match follows AND semantics which means all the headers must match. Matches are always case sensitive unless the ignoreCase is set. Limited to 5 matches.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"name": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: `Specifies the name of the header in the request.`,
																		},
																		"value": {
																			Type:        schema.TypeList,
																			Optional:    true,
																			Description: `Specifies how the header match will be performed.`,
																			MaxItems:    1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"contains": {
																						Type:     schema.TypeString,
																						Optional: true,
																						Description: `The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def`,
																					},
																					"exact": {
																						Type:     schema.TypeString,
																						Optional: true,
																						Description: `The input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.`,
																					},
																					"ignore_case": {
																						Type:        schema.TypeBool,
																						Optional:    true,
																						Description: `If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.`,
																					},
																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																						Description: `The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz`,
																					},
																					"suffix": {
																						Type:     schema.TypeString,
																						Optional: true,
																						Description: `The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc`,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												"hosts": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `A list of HTTP Hosts to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
Limited to 5 matches.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"contains": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def`,
															},
															"exact": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.`,
															},
															"ignore_case": {
																Type:        schema.TypeBool,
																Optional:    true,
																Description: `If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.`,
															},
															"prefix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz`,
															},
															"suffix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc`,
															},
														},
													},
												},
												"methods": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `A list of HTTP methods to match against. Each entry must be a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE, OPTIONS). It only allows exact match and is always case sensitive.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"paths": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `A list of paths to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
Limited to 5 matches.
Note that this path match includes the query parameters. For gRPC services, this should be a fully-qualified name of the form /package.service/method.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"contains": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def`,
															},
															"exact": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.`,
															},
															"ignore_case": {
																Type:        schema.TypeBool,
																Optional:    true,
																Description: `If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.`,
															},
															"prefix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz`,
															},
															"suffix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc`,
															},
														},
													},
												},
											},
										},
									},
									"operations": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Describes properties of one or more targets of a request. At least one of operations or notOperations must be specified. Limited to 5 operations. A match occurs when ANY operation (in operations or notOperations) matches. Within an operation, the match follows AND semantics across fields and OR semantics within a field, i.e. a match occurs when ANY path matches AND ANY header matches and ANY method matches.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"header_set": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `A list of headers to match against in http header.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"headers": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `A list of headers to match against in http header. The match can be one of exact, prefix, suffix, or contains (substring match). The match follows AND semantics which means all the headers must match. Matches are always case sensitive unless the ignoreCase is set. Limited to 5 matches.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"name": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: `Specifies the name of the header in the request.`,
																		},
																		"value": {
																			Type:        schema.TypeList,
																			Optional:    true,
																			Description: `Specifies how the header match will be performed.`,
																			MaxItems:    1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"contains": {
																						Type:     schema.TypeString,
																						Optional: true,
																						Description: `The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def`,
																					},
																					"exact": {
																						Type:     schema.TypeString,
																						Optional: true,
																						Description: `The input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.`,
																					},
																					"ignore_case": {
																						Type:        schema.TypeBool,
																						Optional:    true,
																						Description: `If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.`,
																					},
																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																						Description: `The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz`,
																					},
																					"suffix": {
																						Type:     schema.TypeString,
																						Optional: true,
																						Description: `The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc`,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												"hosts": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `A list of HTTP Hosts to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
Limited to 5 matches.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"contains": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def`,
															},
															"exact": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.`,
															},
															"ignore_case": {
																Type:        schema.TypeBool,
																Optional:    true,
																Description: `If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.`,
															},
															"prefix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz`,
															},
															"suffix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc`,
															},
														},
													},
												},
												"methods": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `A list of HTTP methods to match against. Each entry must be a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE, OPTIONS). It only allows exact match and is always case sensitive.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"paths": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `A list of paths to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
Limited to 5 matches.
Note that this path match includes the query parameters. For gRPC services, this should be a fully-qualified name of the form /package.service/method.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"contains": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def`,
															},
															"exact": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.`,
															},
															"ignore_case": {
																Type:        schema.TypeBool,
																Optional:    true,
																Description: `If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.`,
															},
															"prefix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz`,
															},
															"suffix": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc`,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"when": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `CEL expression that describes the conditions to be satisfied for the action. The result of the CEL expression is ANDed with the from and to. Refer to the CEL language reference for a list of available attributes.`,
						},
					},
				},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Set of labels associated with the AuthzExtension resource.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The timestamp when the resource was created.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The timestamp when the resource was updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceNetworkSecurityAuthzPolicyCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandNetworkSecurityAuthzPolicyDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	targetProp, err := expandNetworkSecurityAuthzPolicyTarget(d.Get("target"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("target"); !tpgresource.IsEmptyValue(reflect.ValueOf(targetProp)) && (ok || !reflect.DeepEqual(v, targetProp)) {
		obj["target"] = targetProp
	}
	httpRulesProp, err := expandNetworkSecurityAuthzPolicyHttpRules(d.Get("http_rules"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("http_rules"); !tpgresource.IsEmptyValue(reflect.ValueOf(httpRulesProp)) && (ok || !reflect.DeepEqual(v, httpRulesProp)) {
		obj["httpRules"] = httpRulesProp
	}
	actionProp, err := expandNetworkSecurityAuthzPolicyAction(d.Get("action"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("action"); !tpgresource.IsEmptyValue(reflect.ValueOf(actionProp)) && (ok || !reflect.DeepEqual(v, actionProp)) {
		obj["action"] = actionProp
	}
	customProviderProp, err := expandNetworkSecurityAuthzPolicyCustomProvider(d.Get("custom_provider"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("custom_provider"); !tpgresource.IsEmptyValue(reflect.ValueOf(customProviderProp)) && (ok || !reflect.DeepEqual(v, customProviderProp)) {
		obj["customProvider"] = customProviderProp
	}
	labelsProp, err := expandNetworkSecurityAuthzPolicyEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	nameProp, err := expandNetworkSecurityAuthzPolicyName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkSecurityBasePath}}projects/{{project}}/locations/{{location}}/authzPolicies?authzPolicyId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new AuthzPolicy: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for AuthzPolicy: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating AuthzPolicy: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/authzPolicies/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = NetworkSecurityOperationWaitTime(
		config, res, project, "Creating AuthzPolicy", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create AuthzPolicy: %s", err)
	}

	log.Printf("[DEBUG] Finished creating AuthzPolicy %q: %#v", d.Id(), res)

	return resourceNetworkSecurityAuthzPolicyRead(d, meta)
}

func resourceNetworkSecurityAuthzPolicyRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkSecurityBasePath}}projects/{{project}}/locations/{{location}}/authzPolicies/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for AuthzPolicy: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("NetworkSecurityAuthzPolicy %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}

	if err := d.Set("create_time", flattenNetworkSecurityAuthzPolicyCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}
	if err := d.Set("update_time", flattenNetworkSecurityAuthzPolicyUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}
	if err := d.Set("description", flattenNetworkSecurityAuthzPolicyDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}
	if err := d.Set("labels", flattenNetworkSecurityAuthzPolicyLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}
	if err := d.Set("target", flattenNetworkSecurityAuthzPolicyTarget(res["target"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}
	if err := d.Set("http_rules", flattenNetworkSecurityAuthzPolicyHttpRules(res["httpRules"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}
	if err := d.Set("action", flattenNetworkSecurityAuthzPolicyAction(res["action"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}
	if err := d.Set("custom_provider", flattenNetworkSecurityAuthzPolicyCustomProvider(res["customProvider"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}
	if err := d.Set("terraform_labels", flattenNetworkSecurityAuthzPolicyTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}
	if err := d.Set("effective_labels", flattenNetworkSecurityAuthzPolicyEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}
	if err := d.Set("name", flattenNetworkSecurityAuthzPolicyName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading AuthzPolicy: %s", err)
	}

	return nil
}

func resourceNetworkSecurityAuthzPolicyUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for AuthzPolicy: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandNetworkSecurityAuthzPolicyDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	targetProp, err := expandNetworkSecurityAuthzPolicyTarget(d.Get("target"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("target"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, targetProp)) {
		obj["target"] = targetProp
	}
	httpRulesProp, err := expandNetworkSecurityAuthzPolicyHttpRules(d.Get("http_rules"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("http_rules"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, httpRulesProp)) {
		obj["httpRules"] = httpRulesProp
	}
	actionProp, err := expandNetworkSecurityAuthzPolicyAction(d.Get("action"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("action"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, actionProp)) {
		obj["action"] = actionProp
	}
	customProviderProp, err := expandNetworkSecurityAuthzPolicyCustomProvider(d.Get("custom_provider"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("custom_provider"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, customProviderProp)) {
		obj["customProvider"] = customProviderProp
	}
	labelsProp, err := expandNetworkSecurityAuthzPolicyEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	nameProp, err := expandNetworkSecurityAuthzPolicyName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkSecurityBasePath}}projects/{{project}}/locations/{{location}}/authzPolicies/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating AuthzPolicy %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("target") {
		updateMask = append(updateMask, "target")
	}

	if d.HasChange("http_rules") {
		updateMask = append(updateMask, "httpRules")
	}

	if d.HasChange("action") {
		updateMask = append(updateMask, "action")
	}

	if d.HasChange("custom_provider") {
		updateMask = append(updateMask, "customProvider")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}

	if d.HasChange("name") {
		updateMask = append(updateMask, "name")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating AuthzPolicy %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating AuthzPolicy %q: %#v", d.Id(), res)
		}

		err = NetworkSecurityOperationWaitTime(
			config, res, project, "Updating AuthzPolicy", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceNetworkSecurityAuthzPolicyRead(d, meta)
}

func resourceNetworkSecurityAuthzPolicyDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for AuthzPolicy: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkSecurityBasePath}}projects/{{project}}/locations/{{location}}/authzPolicies/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting AuthzPolicy %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "AuthzPolicy")
	}

	err = NetworkSecurityOperationWaitTime(
		config, res, project, "Deleting AuthzPolicy", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting AuthzPolicy %q: %#v", d.Id(), res)
	return nil
}

func resourceNetworkSecurityAuthzPolicyImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/authzPolicies/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/authzPolicies/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenNetworkSecurityAuthzPolicyCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkSecurityAuthzPolicyTarget(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["load_balancing_scheme"] =
		flattenNetworkSecurityAuthzPolicyTargetLoadBalancingScheme(original["loadBalancingScheme"], d, config)
	transformed["resources"] =
		flattenNetworkSecurityAuthzPolicyTargetResources(original["resources"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyTargetLoadBalancingScheme(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyTargetResources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRules(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"from": flattenNetworkSecurityAuthzPolicyHttpRulesFrom(original["from"], d, config),
			"to":   flattenNetworkSecurityAuthzPolicyHttpRulesTo(original["to"], d, config),
			"when": flattenNetworkSecurityAuthzPolicyHttpRulesWhen(original["when"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFrom(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["sources"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromSources(original["sources"], d, config)
	transformed["not_sources"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSources(original["notSources"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFromSources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"principals": flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipals(original["principals"], d, config),
			"resources":  flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResources(original["resources"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipals(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ignore_case": flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsIgnoreCase(original["ignoreCase"], d, config),
			"exact":       flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsExact(original["exact"], d, config),
			"prefix":      flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsPrefix(original["prefix"], d, config),
			"suffix":      flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsSuffix(original["suffix"], d, config),
			"contains":    flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsContains(original["contains"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsIgnoreCase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsExact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsSuffix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsContains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"tag_value_id_set":    flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesTagValueIdSet(original["tagValueIdSet"], d, config),
			"iam_service_account": flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccount(original["iamServiceAccount"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesTagValueIdSet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ids"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesTagValueIdSetIds(original["ids"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesTagValueIdSetIds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ignore_case"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountIgnoreCase(original["ignoreCase"], d, config)
	transformed["exact"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountExact(original["exact"], d, config)
	transformed["prefix"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountPrefix(original["prefix"], d, config)
	transformed["suffix"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountSuffix(original["suffix"], d, config)
	transformed["contains"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountContains(original["contains"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountIgnoreCase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountExact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountSuffix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountContains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"principals": flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipals(original["principals"], d, config),
			"resources":  flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResources(original["resources"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipals(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ignore_case": flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsIgnoreCase(original["ignoreCase"], d, config),
			"exact":       flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsExact(original["exact"], d, config),
			"prefix":      flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsPrefix(original["prefix"], d, config),
			"suffix":      flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsSuffix(original["suffix"], d, config),
			"contains":    flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsContains(original["contains"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsIgnoreCase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsExact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsSuffix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsContains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"tag_value_id_set":    flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesTagValueIdSet(original["tagValueIdSet"], d, config),
			"iam_service_account": flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccount(original["iamServiceAccount"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesTagValueIdSet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ids"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesTagValueIdSetIds(original["ids"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesTagValueIdSetIds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ignore_case"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountIgnoreCase(original["ignoreCase"], d, config)
	transformed["exact"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountExact(original["exact"], d, config)
	transformed["prefix"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountPrefix(original["prefix"], d, config)
	transformed["suffix"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountSuffix(original["suffix"], d, config)
	transformed["contains"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountContains(original["contains"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountIgnoreCase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountExact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountSuffix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountContains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesTo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["operations"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToOperations(original["operations"], d, config)
	transformed["not_operations"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperations(original["notOperations"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToOperations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"header_set": flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSet(original["headerSet"], d, config),
			"hosts":      flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHosts(original["hosts"], d, config),
			"paths":      flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPaths(original["paths"], d, config),
			"methods":    flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsMethods(original["methods"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["headers"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeaders(original["headers"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeaders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":  flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersName(original["name"], d, config),
			"value": flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ignore_case"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueIgnoreCase(original["ignoreCase"], d, config)
	transformed["exact"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueExact(original["exact"], d, config)
	transformed["prefix"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValuePrefix(original["prefix"], d, config)
	transformed["suffix"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueSuffix(original["suffix"], d, config)
	transformed["contains"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueContains(original["contains"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueIgnoreCase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueExact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValuePrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueSuffix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueContains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHosts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ignore_case": flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsIgnoreCase(original["ignoreCase"], d, config),
			"exact":       flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsExact(original["exact"], d, config),
			"prefix":      flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsPrefix(original["prefix"], d, config),
			"suffix":      flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsSuffix(original["suffix"], d, config),
			"contains":    flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsContains(original["contains"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsIgnoreCase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsExact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsSuffix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsContains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPaths(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ignore_case": flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsIgnoreCase(original["ignoreCase"], d, config),
			"exact":       flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsExact(original["exact"], d, config),
			"prefix":      flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsPrefix(original["prefix"], d, config),
			"suffix":      flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsSuffix(original["suffix"], d, config),
			"contains":    flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsContains(original["contains"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsIgnoreCase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsExact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsSuffix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsContains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToOperationsMethods(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"header_set": flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSet(original["headerSet"], d, config),
			"hosts":      flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHosts(original["hosts"], d, config),
			"paths":      flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPaths(original["paths"], d, config),
			"methods":    flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsMethods(original["methods"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["headers"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeaders(original["headers"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeaders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":  flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersName(original["name"], d, config),
			"value": flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ignore_case"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueIgnoreCase(original["ignoreCase"], d, config)
	transformed["exact"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueExact(original["exact"], d, config)
	transformed["prefix"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValuePrefix(original["prefix"], d, config)
	transformed["suffix"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueSuffix(original["suffix"], d, config)
	transformed["contains"] =
		flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueContains(original["contains"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueIgnoreCase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueExact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValuePrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueSuffix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueContains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHosts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ignore_case": flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsIgnoreCase(original["ignoreCase"], d, config),
			"exact":       flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsExact(original["exact"], d, config),
			"prefix":      flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsPrefix(original["prefix"], d, config),
			"suffix":      flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsSuffix(original["suffix"], d, config),
			"contains":    flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsContains(original["contains"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsIgnoreCase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsExact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsSuffix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsContains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPaths(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ignore_case": flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsIgnoreCase(original["ignoreCase"], d, config),
			"exact":       flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsExact(original["exact"], d, config),
			"prefix":      flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsPrefix(original["prefix"], d, config),
			"suffix":      flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsSuffix(original["suffix"], d, config),
			"contains":    flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsContains(original["contains"], d, config),
		})
	}
	return transformed
}
func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsIgnoreCase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsExact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsSuffix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsContains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesToNotOperationsMethods(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyHttpRulesWhen(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyAction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyCustomProvider(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cloud_iap"] =
		flattenNetworkSecurityAuthzPolicyCustomProviderCloudIap(original["cloudIap"], d, config)
	transformed["authz_extension"] =
		flattenNetworkSecurityAuthzPolicyCustomProviderAuthzExtension(original["authzExtension"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyCustomProviderCloudIap(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] = true
	return []interface{}{transformed}
}

func flattenNetworkSecurityAuthzPolicyCustomProviderAuthzExtension(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["resources"] =
		flattenNetworkSecurityAuthzPolicyCustomProviderAuthzExtensionResources(original["resources"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkSecurityAuthzPolicyCustomProviderAuthzExtensionResources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkSecurityAuthzPolicyEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkSecurityAuthzPolicyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.NameFromSelfLinkStateFunc(v)
}

func expandNetworkSecurityAuthzPolicyDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyTarget(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLoadBalancingScheme, err := expandNetworkSecurityAuthzPolicyTargetLoadBalancingScheme(original["load_balancing_scheme"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLoadBalancingScheme); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["loadBalancingScheme"] = transformedLoadBalancingScheme
	}

	transformedResources, err := expandNetworkSecurityAuthzPolicyTargetResources(original["resources"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResources); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["resources"] = transformedResources
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyTargetLoadBalancingScheme(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyTargetResources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRules(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedFrom, err := expandNetworkSecurityAuthzPolicyHttpRulesFrom(original["from"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFrom); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["from"] = transformedFrom
		}

		transformedTo, err := expandNetworkSecurityAuthzPolicyHttpRulesTo(original["to"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTo); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["to"] = transformedTo
		}

		transformedWhen, err := expandNetworkSecurityAuthzPolicyHttpRulesWhen(original["when"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedWhen); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["when"] = transformedWhen
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFrom(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSources, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSources(original["sources"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSources); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sources"] = transformedSources
	}

	transformedNotSources, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSources(original["not_sources"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNotSources); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["notSources"] = transformedNotSources
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedPrincipals, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipals(original["principals"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrincipals); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["principals"] = transformedPrincipals
		}

		transformedResources, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResources(original["resources"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResources); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resources"] = transformedResources
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipals(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedIgnoreCase, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsIgnoreCase(original["ignore_case"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIgnoreCase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ignoreCase"] = transformedIgnoreCase
		}

		transformedExact, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsExact(original["exact"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["exact"] = transformedExact
		}

		transformedPrefix, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsPrefix(original["prefix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["prefix"] = transformedPrefix
		}

		transformedSuffix, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsSuffix(original["suffix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSuffix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["suffix"] = transformedSuffix
		}

		transformedContains, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsContains(original["contains"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["contains"] = transformedContains
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsIgnoreCase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsExact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsSuffix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesPrincipalsContains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedTagValueIdSet, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesTagValueIdSet(original["tag_value_id_set"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTagValueIdSet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["tagValueIdSet"] = transformedTagValueIdSet
		}

		transformedIamServiceAccount, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccount(original["iam_service_account"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIamServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["iamServiceAccount"] = transformedIamServiceAccount
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesTagValueIdSet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIds, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesTagValueIdSetIds(original["ids"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ids"] = transformedIds
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesTagValueIdSetIds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIgnoreCase, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountIgnoreCase(original["ignore_case"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIgnoreCase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ignoreCase"] = transformedIgnoreCase
	}

	transformedExact, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountExact(original["exact"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["exact"] = transformedExact
	}

	transformedPrefix, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountPrefix(original["prefix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prefix"] = transformedPrefix
	}

	transformedSuffix, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountSuffix(original["suffix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSuffix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["suffix"] = transformedSuffix
	}

	transformedContains, err := expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountContains(original["contains"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["contains"] = transformedContains
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountIgnoreCase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountExact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountSuffix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromSourcesResourcesIamServiceAccountContains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedPrincipals, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipals(original["principals"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrincipals); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["principals"] = transformedPrincipals
		}

		transformedResources, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResources(original["resources"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResources); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resources"] = transformedResources
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipals(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedIgnoreCase, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsIgnoreCase(original["ignore_case"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIgnoreCase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ignoreCase"] = transformedIgnoreCase
		}

		transformedExact, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsExact(original["exact"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["exact"] = transformedExact
		}

		transformedPrefix, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsPrefix(original["prefix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["prefix"] = transformedPrefix
		}

		transformedSuffix, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsSuffix(original["suffix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSuffix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["suffix"] = transformedSuffix
		}

		transformedContains, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsContains(original["contains"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["contains"] = transformedContains
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsIgnoreCase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsExact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsSuffix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesPrincipalsContains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedTagValueIdSet, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesTagValueIdSet(original["tag_value_id_set"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTagValueIdSet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["tagValueIdSet"] = transformedTagValueIdSet
		}

		transformedIamServiceAccount, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccount(original["iam_service_account"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIamServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["iamServiceAccount"] = transformedIamServiceAccount
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesTagValueIdSet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIds, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesTagValueIdSetIds(original["ids"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ids"] = transformedIds
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesTagValueIdSetIds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIgnoreCase, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountIgnoreCase(original["ignore_case"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIgnoreCase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ignoreCase"] = transformedIgnoreCase
	}

	transformedExact, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountExact(original["exact"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["exact"] = transformedExact
	}

	transformedPrefix, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountPrefix(original["prefix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prefix"] = transformedPrefix
	}

	transformedSuffix, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountSuffix(original["suffix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSuffix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["suffix"] = transformedSuffix
	}

	transformedContains, err := expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountContains(original["contains"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["contains"] = transformedContains
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountIgnoreCase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountExact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountSuffix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesFromNotSourcesResourcesIamServiceAccountContains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesTo(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOperations, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperations(original["operations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOperations); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["operations"] = transformedOperations
	}

	transformedNotOperations, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperations(original["not_operations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNotOperations); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["notOperations"] = transformedNotOperations
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedHeaderSet, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSet(original["header_set"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHeaderSet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["headerSet"] = transformedHeaderSet
		}

		transformedHosts, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHosts(original["hosts"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHosts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hosts"] = transformedHosts
		}

		transformedPaths, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPaths(original["paths"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPaths); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["paths"] = transformedPaths
		}

		transformedMethods, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsMethods(original["methods"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMethods); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["methods"] = transformedMethods
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHeaders, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeaders(original["headers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHeaders); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["headers"] = transformedHeaders
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeaders(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIgnoreCase, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueIgnoreCase(original["ignore_case"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIgnoreCase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ignoreCase"] = transformedIgnoreCase
	}

	transformedExact, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueExact(original["exact"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["exact"] = transformedExact
	}

	transformedPrefix, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValuePrefix(original["prefix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prefix"] = transformedPrefix
	}

	transformedSuffix, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueSuffix(original["suffix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSuffix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["suffix"] = transformedSuffix
	}

	transformedContains, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueContains(original["contains"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["contains"] = transformedContains
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueIgnoreCase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueExact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValuePrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueSuffix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHeaderSetHeadersValueContains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHosts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedIgnoreCase, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsIgnoreCase(original["ignore_case"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIgnoreCase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ignoreCase"] = transformedIgnoreCase
		}

		transformedExact, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsExact(original["exact"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["exact"] = transformedExact
		}

		transformedPrefix, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsPrefix(original["prefix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["prefix"] = transformedPrefix
		}

		transformedSuffix, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsSuffix(original["suffix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSuffix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["suffix"] = transformedSuffix
		}

		transformedContains, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsContains(original["contains"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["contains"] = transformedContains
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsIgnoreCase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsExact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsSuffix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsHostsContains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPaths(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedIgnoreCase, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsIgnoreCase(original["ignore_case"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIgnoreCase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ignoreCase"] = transformedIgnoreCase
		}

		transformedExact, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsExact(original["exact"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["exact"] = transformedExact
		}

		transformedPrefix, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsPrefix(original["prefix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["prefix"] = transformedPrefix
		}

		transformedSuffix, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsSuffix(original["suffix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSuffix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["suffix"] = transformedSuffix
		}

		transformedContains, err := expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsContains(original["contains"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["contains"] = transformedContains
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsIgnoreCase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsExact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsSuffix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsPathsContains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToOperationsMethods(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedHeaderSet, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSet(original["header_set"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHeaderSet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["headerSet"] = transformedHeaderSet
		}

		transformedHosts, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHosts(original["hosts"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHosts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hosts"] = transformedHosts
		}

		transformedPaths, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPaths(original["paths"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPaths); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["paths"] = transformedPaths
		}

		transformedMethods, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsMethods(original["methods"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMethods); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["methods"] = transformedMethods
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHeaders, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeaders(original["headers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHeaders); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["headers"] = transformedHeaders
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeaders(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIgnoreCase, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueIgnoreCase(original["ignore_case"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIgnoreCase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ignoreCase"] = transformedIgnoreCase
	}

	transformedExact, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueExact(original["exact"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["exact"] = transformedExact
	}

	transformedPrefix, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValuePrefix(original["prefix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prefix"] = transformedPrefix
	}

	transformedSuffix, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueSuffix(original["suffix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSuffix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["suffix"] = transformedSuffix
	}

	transformedContains, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueContains(original["contains"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["contains"] = transformedContains
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueIgnoreCase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueExact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValuePrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueSuffix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHeaderSetHeadersValueContains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHosts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedIgnoreCase, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsIgnoreCase(original["ignore_case"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIgnoreCase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ignoreCase"] = transformedIgnoreCase
		}

		transformedExact, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsExact(original["exact"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["exact"] = transformedExact
		}

		transformedPrefix, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsPrefix(original["prefix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["prefix"] = transformedPrefix
		}

		transformedSuffix, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsSuffix(original["suffix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSuffix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["suffix"] = transformedSuffix
		}

		transformedContains, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsContains(original["contains"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["contains"] = transformedContains
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsIgnoreCase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsExact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsSuffix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsHostsContains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPaths(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedIgnoreCase, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsIgnoreCase(original["ignore_case"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIgnoreCase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ignoreCase"] = transformedIgnoreCase
		}

		transformedExact, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsExact(original["exact"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["exact"] = transformedExact
		}

		transformedPrefix, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsPrefix(original["prefix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["prefix"] = transformedPrefix
		}

		transformedSuffix, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsSuffix(original["suffix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSuffix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["suffix"] = transformedSuffix
		}

		transformedContains, err := expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsContains(original["contains"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["contains"] = transformedContains
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsIgnoreCase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsExact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsSuffix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsPathsContains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesToNotOperationsMethods(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyHttpRulesWhen(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyAction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyCustomProvider(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCloudIap, err := expandNetworkSecurityAuthzPolicyCustomProviderCloudIap(original["cloud_iap"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["cloudIap"] = transformedCloudIap
	}

	transformedAuthzExtension, err := expandNetworkSecurityAuthzPolicyCustomProviderAuthzExtension(original["authz_extension"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthzExtension); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authzExtension"] = transformedAuthzExtension
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyCustomProviderCloudIap(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})

	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	if isEnabled, ok := original["enabled"]; ok {
		if !isEnabled.(bool) {
			return nil, nil
		}
	}
	transformed := make(map[string]interface{})
	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyCustomProviderAuthzExtension(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedResources, err := expandNetworkSecurityAuthzPolicyCustomProviderAuthzExtensionResources(original["resources"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResources); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["resources"] = transformedResources
	}

	return transformed, nil
}

func expandNetworkSecurityAuthzPolicyCustomProviderAuthzExtensionResources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkSecurityAuthzPolicyEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandNetworkSecurityAuthzPolicyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return fmt.Sprintf("projects/%s/locations/%s/authzPolicies/%s", d.Get("project"), d.Get("location"), v), nil
}
