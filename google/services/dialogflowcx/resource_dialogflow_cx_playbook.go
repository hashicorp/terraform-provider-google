// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/dialogflowcx/Playbook.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package dialogflowcx

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceDialogflowCXPlaybook() *schema.Resource {
	return &schema.Resource{
		Create: resourceDialogflowCXPlaybookCreate,
		Read:   resourceDialogflowCXPlaybookRead,
		Update: resourceDialogflowCXPlaybookUpdate,
		Delete: resourceDialogflowCXPlaybookDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDialogflowCXPlaybookImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"parent": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The human-readable name of the playbook, unique within an agent.`,
			},
			"goal": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `High level description of the goal the playbook intend to accomplish. A goal should be concise since it's visible to other playbooks that may reference this playbook.`,
			},
			"instruction": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Instruction to accomplish target goal.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"guidelines": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `General guidelines for the playbook. These are unstructured instructions that are not directly part of the goal, e.g. "Always be polite". It's valid for this text to be long and used instead of steps altogether.`,
						},
						"steps": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Ordered list of step by step execution instructions to accomplish target goal.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"steps": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description: `Sub-processing needed to execute the current step.

This field uses JSON data as a string. The value provided must be a valid JSON representation documented in [Step](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.playbooks#step).`,
									},
									"text": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Step instruction in text format.`,
									},
								},
							},
						},
					},
				},
			},
			"llm_model_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Llm model settings for the playbook.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"model": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The selected LLM model.`,
						},
						"prompt_text": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The custom prompt to use.`,
						},
					},
				},
			},
			"parent": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `The agent to create a Playbook for.
Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>.`,
			},
			"playbook_type": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"PLAYBOOK_TYPE_UNSPECIFIED", "TASK", "ROUTINE", ""}),
				Description:  `Type of the playbook. Possible values: ["PLAYBOOK_TYPE_UNSPECIFIED", "TASK", "ROUTINE"]`,
			},
			"referenced_tools": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The resource name of tools referenced by the current playbook in the instructions. If not provided explicitly, they are will be implied using the tool being referenced in goal and steps.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"create_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The timestamp of initial playbook creation.

Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits. Offsets other than "Z" are also accepted. Examples: "2014-10-02T15:01:23Z", "2014-10-02T15:01:23.045123456Z" or "2014-10-02T15:01:23+05:30".`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The unique identifier of the Playbook.
Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/playbooks/<Playbook ID>.`,
			},
			"referenced_flows": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The resource name of flows referenced by the current playbook in the instructions.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"referenced_playbooks": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The resource name of other playbooks referenced by the current playbook in the instructions.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"token_count": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Estimated number of tokes current playbook takes when sent to the LLM.`,
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Last time the playbook version was updated.

Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits. Offsets other than "Z" are also accepted. Examples: "2014-10-02T15:01:23Z", "2014-10-02T15:01:23.045123456Z" or "2014-10-02T15:01:23+05:30".`,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDialogflowCXPlaybookCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandDialogflowCXPlaybookDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	goalProp, err := expandDialogflowCXPlaybookGoal(d.Get("goal"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("goal"); !tpgresource.IsEmptyValue(reflect.ValueOf(goalProp)) && (ok || !reflect.DeepEqual(v, goalProp)) {
		obj["goal"] = goalProp
	}
	instructionProp, err := expandDialogflowCXPlaybookInstruction(d.Get("instruction"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("instruction"); !tpgresource.IsEmptyValue(reflect.ValueOf(instructionProp)) && (ok || !reflect.DeepEqual(v, instructionProp)) {
		obj["instruction"] = instructionProp
	}
	referencedToolsProp, err := expandDialogflowCXPlaybookReferencedTools(d.Get("referenced_tools"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("referenced_tools"); !tpgresource.IsEmptyValue(reflect.ValueOf(referencedToolsProp)) && (ok || !reflect.DeepEqual(v, referencedToolsProp)) {
		obj["referencedTools"] = referencedToolsProp
	}
	llmModelSettingsProp, err := expandDialogflowCXPlaybookLlmModelSettings(d.Get("llm_model_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("llm_model_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(llmModelSettingsProp)) && (ok || !reflect.DeepEqual(v, llmModelSettingsProp)) {
		obj["llmModelSettings"] = llmModelSettingsProp
	}
	playbookTypeProp, err := expandDialogflowCXPlaybookPlaybookType(d.Get("playbook_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("playbook_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(playbookTypeProp)) && (ok || !reflect.DeepEqual(v, playbookTypeProp)) {
		obj["playbookType"] = playbookTypeProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/playbooks")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Playbook: %#v", obj)
	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3beta1/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3beta1/") {
		url = strings.Replace(url, "https://-dialogflow", fmt.Sprintf("https://%s-dialogflow", location), 1)
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Playbook: %s", err)
	}
	// Set computed resource properties from create API response so that they're available on the subsequent Read
	// call.
	err = resourceDialogflowCXPlaybookPostCreateSetComputedFields(d, meta, res)
	if err != nil {
		return fmt.Errorf("setting computed ID format fields: %w", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "{{parent}}/playbooks/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if parentValue, ok := d.GetOk("parent"); ok && parentValue.(string) != "" {
			if err = identity.Set("parent", parentValue.(string)); err != nil {
				return fmt.Errorf("Error setting parent: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Playbook %q: %#v", d.Id(), res)

	return resourceDialogflowCXPlaybookRead(d, meta)
}

func resourceDialogflowCXPlaybookRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/playbooks/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3beta1/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3beta1/") {
		url = strings.Replace(url, "https://-dialogflow", fmt.Sprintf("https://%s-dialogflow", location), 1)
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DialogflowCXPlaybook %q", d.Id()))
	}

	if err := d.Set("name", flattenDialogflowCXPlaybookName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Playbook: %s", err)
	}
	if err := d.Set("display_name", flattenDialogflowCXPlaybookDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Playbook: %s", err)
	}
	if err := d.Set("goal", flattenDialogflowCXPlaybookGoal(res["goal"], d, config)); err != nil {
		return fmt.Errorf("Error reading Playbook: %s", err)
	}
	if err := d.Set("instruction", flattenDialogflowCXPlaybookInstruction(res["instruction"], d, config)); err != nil {
		return fmt.Errorf("Error reading Playbook: %s", err)
	}
	if err := d.Set("token_count", flattenDialogflowCXPlaybookTokenCount(res["tokenCount"], d, config)); err != nil {
		return fmt.Errorf("Error reading Playbook: %s", err)
	}
	if err := d.Set("create_time", flattenDialogflowCXPlaybookCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Playbook: %s", err)
	}
	if err := d.Set("update_time", flattenDialogflowCXPlaybookUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Playbook: %s", err)
	}
	if err := d.Set("referenced_playbooks", flattenDialogflowCXPlaybookReferencedPlaybooks(res["referencedPlaybooks"], d, config)); err != nil {
		return fmt.Errorf("Error reading Playbook: %s", err)
	}
	if err := d.Set("referenced_flows", flattenDialogflowCXPlaybookReferencedFlows(res["referencedFlows"], d, config)); err != nil {
		return fmt.Errorf("Error reading Playbook: %s", err)
	}
	if err := d.Set("referenced_tools", flattenDialogflowCXPlaybookReferencedTools(res["referencedTools"], d, config)); err != nil {
		return fmt.Errorf("Error reading Playbook: %s", err)
	}
	if err := d.Set("llm_model_settings", flattenDialogflowCXPlaybookLlmModelSettings(res["llmModelSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading Playbook: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("name"); !ok && v == "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("parent"); !ok && v == "" {
			err = identity.Set("parent", d.Get("parent").(string))
			if err != nil {
				return fmt.Errorf("Error setting parent: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceDialogflowCXPlaybookUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if parentValue, ok := d.GetOk("parent"); ok && parentValue.(string) != "" {
			if err = identity.Set("parent", parentValue.(string)); err != nil {
				return fmt.Errorf("Error setting parent: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	obj := make(map[string]interface{})
	displayNameProp, err := expandDialogflowCXPlaybookDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	goalProp, err := expandDialogflowCXPlaybookGoal(d.Get("goal"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("goal"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, goalProp)) {
		obj["goal"] = goalProp
	}
	instructionProp, err := expandDialogflowCXPlaybookInstruction(d.Get("instruction"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("instruction"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, instructionProp)) {
		obj["instruction"] = instructionProp
	}
	referencedToolsProp, err := expandDialogflowCXPlaybookReferencedTools(d.Get("referenced_tools"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("referenced_tools"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, referencedToolsProp)) {
		obj["referencedTools"] = referencedToolsProp
	}
	llmModelSettingsProp, err := expandDialogflowCXPlaybookLlmModelSettings(d.Get("llm_model_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("llm_model_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, llmModelSettingsProp)) {
		obj["llmModelSettings"] = llmModelSettingsProp
	}
	playbookTypeProp, err := expandDialogflowCXPlaybookPlaybookType(d.Get("playbook_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("playbook_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, playbookTypeProp)) {
		obj["playbookType"] = playbookTypeProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/playbooks/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Playbook %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("goal") {
		updateMask = append(updateMask, "goal")
	}

	if d.HasChange("instruction") {
		updateMask = append(updateMask, "instruction")
	}

	if d.HasChange("referenced_tools") {
		updateMask = append(updateMask, "referencedTools")
	}

	if d.HasChange("llm_model_settings") {
		updateMask = append(updateMask, "llmModelSettings")
	}

	if d.HasChange("playbook_type") {
		updateMask = append(updateMask, "playbookType")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3beta1/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3beta1/") {
		url = strings.Replace(url, "https://-dialogflow", fmt.Sprintf("https://%s-dialogflow", location), 1)
	}

	// The generated code sets the wrong masks for the following fields.
	newUpdateMask := []string{}
	if d.HasChange("instruction.0.steps") {
		newUpdateMask = append(newUpdateMask, "instruction.steps")
	}
	if d.HasChange("instruction.0.guidelines") {
		newUpdateMask = append(newUpdateMask, "instruction.guidelines")
	}
	// Pull out any other set fields from the generated mask.
	for _, mask := range updateMask {
		if mask == "instruction" {
			continue
		}
		newUpdateMask = append(newUpdateMask, mask)
	}
	// Overwrite the previously set mask.
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(newUpdateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Playbook %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Playbook %q: %#v", d.Id(), res)
		}

	}

	return resourceDialogflowCXPlaybookRead(d, meta)
}

func resourceDialogflowCXPlaybookDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/playbooks/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3beta1/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3beta1/") {
		url = strings.Replace(url, "https://-dialogflow", fmt.Sprintf("https://%s-dialogflow", location), 1)
	}

	log.Printf("[DEBUG] Deleting Playbook %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Playbook")
	}

	log.Printf("[DEBUG] Finished deleting Playbook %q: %#v", d.Id(), res)
	return nil
}

func resourceDialogflowCXPlaybookImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)

	// current import_formats can't import fields with forward slashes in their value and parent contains slashes
	if err := tpgresource.ParseImportId([]string{
		"(?P<parent>.+)/playbooks/(?P<name>[^/]+)",
		"(?P<parent>.+)/(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "{{parent}}/playbooks/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenDialogflowCXPlaybookName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenDialogflowCXPlaybookDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXPlaybookGoal(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXPlaybookInstruction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["guidelines"] =
		flattenDialogflowCXPlaybookInstructionGuidelines(original["guidelines"], d, config)
	transformed["steps"] =
		flattenDialogflowCXPlaybookInstructionSteps(original["steps"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXPlaybookInstructionGuidelines(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXPlaybookInstructionSteps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"steps": flattenDialogflowCXPlaybookInstructionStepsSteps(original["steps"], d, config),
			"text":  flattenDialogflowCXPlaybookInstructionStepsText(original["text"], d, config),
		})
	}
	return transformed
}
func flattenDialogflowCXPlaybookInstructionStepsSteps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenDialogflowCXPlaybookInstructionStepsText(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXPlaybookTokenCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXPlaybookCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXPlaybookUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXPlaybookReferencedPlaybooks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXPlaybookReferencedFlows(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXPlaybookReferencedTools(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXPlaybookLlmModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenDialogflowCXPlaybookLlmModelSettingsModel(original["model"], d, config)
	transformed["prompt_text"] =
		flattenDialogflowCXPlaybookLlmModelSettingsPromptText(original["promptText"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXPlaybookLlmModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXPlaybookLlmModelSettingsPromptText(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandDialogflowCXPlaybookDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXPlaybookGoal(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXPlaybookInstruction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGuidelines, err := expandDialogflowCXPlaybookInstructionGuidelines(original["guidelines"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGuidelines); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["guidelines"] = transformedGuidelines
	}

	transformedSteps, err := expandDialogflowCXPlaybookInstructionSteps(original["steps"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSteps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["steps"] = transformedSteps
	}

	return transformed, nil
}

func expandDialogflowCXPlaybookInstructionGuidelines(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXPlaybookInstructionSteps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedSteps, err := expandDialogflowCXPlaybookInstructionStepsSteps(original["steps"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSteps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["steps"] = transformedSteps
		}

		transformedText, err := expandDialogflowCXPlaybookInstructionStepsText(original["text"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedText); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["text"] = transformedText
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDialogflowCXPlaybookInstructionStepsSteps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandDialogflowCXPlaybookInstructionStepsText(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXPlaybookReferencedTools(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXPlaybookLlmModelSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedModel, err := expandDialogflowCXPlaybookLlmModelSettingsModel(original["model"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["model"] = transformedModel
	}

	transformedPromptText, err := expandDialogflowCXPlaybookLlmModelSettingsPromptText(original["prompt_text"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPromptText); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["promptText"] = transformedPromptText
	}

	return transformed, nil
}

func expandDialogflowCXPlaybookLlmModelSettingsModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXPlaybookLlmModelSettingsPromptText(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXPlaybookPlaybookType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceDialogflowCXPlaybookPostCreateSetComputedFields(d *schema.ResourceData, meta interface{}, res map[string]interface{}) error {
	config := meta.(*transport_tpg.Config)
	if err := d.Set("name", flattenDialogflowCXPlaybookName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}
	return nil
}
