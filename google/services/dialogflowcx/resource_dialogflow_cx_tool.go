// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/dialogflowcx/Tool.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package dialogflowcx

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceDialogflowCXTool() *schema.Resource {
	return &schema.Resource{
		Create: resourceDialogflowCXToolCreate,
		Read:   resourceDialogflowCXToolRead,
		Update: resourceDialogflowCXToolUpdate,
		Delete: resourceDialogflowCXToolDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDialogflowCXToolImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(40 * time.Minute),
			Update: schema.DefaultTimeout(40 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"description": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `High level description of the Tool and its usage.`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The human-readable name of the tool, unique within the agent.`,
			},
			"data_store_spec": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Data store search tool specification.
This field is part of a union field 'specification': Only one of 'openApiSpec', 'dataStoreSpec', or 'functionSpec' may be set.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"data_store_connections": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `List of data stores to search.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"data_store": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}`,
									},
									"data_store_type": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The type of the connected data store.
See [DataStoreType](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/DataStoreConnection#datastoretype) for valid values.`,
									},
									"document_processing_mode": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
See [DocumentProcessingMode](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/DataStoreConnection#documentprocessingmode) for valid values.`,
									},
								},
							},
						},
						"fallback_prompt": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Fallback prompt configurations to use.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},
					},
				},
			},
			"function_spec": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Client side executed function specification.
This field is part of a union field 'specification': Only one of 'openApiSpec', 'dataStoreSpec', or 'functionSpec' may be set.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"input_schema": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: validation.StringIsJSON,
							StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
							Description: `Optional. The JSON schema is encapsulated in a [google.protobuf.Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct) to describe the input of the function.
This input is a JSON object that contains the function's parameters as properties of the object`,
						},
						"output_schema": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: validation.StringIsJSON,
							StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
							Description: `Optional. The JSON schema is encapsulated in a [google.protobuf.Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct) to describe the output of the function.
This output is a JSON object that contains the function's parameters as properties of the object`,
						},
					},
				},
			},
			"open_api_spec": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `OpenAPI specification of the Tool.
This field is part of a union field 'specification': Only one of 'openApiSpec', 'dataStoreSpec', or 'functionSpec' may be set.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"text_schema": {
							Type:     schema.TypeString,
							Required: true,
							Description: `The OpenAPI schema specified as a text.
This field is part of a union field 'schema': only one of 'textSchema' may be set.`,
						},
						"authentication": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Optional. Authentication information required by the API.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"api_key_config": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Config for API key auth.
This field is part of a union field 'auth_config': Only one of 'apiKeyConfig', 'oauthConfig', 'serviceAgentAuthConfig', or 'bearerTokenConfig' may be set.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"key_name": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The parameter name or the header name of the API key.
E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.`,
												},
												"request_location": {
													Type:     schema.TypeString,
													Required: true,
													Description: `Key location in the request.
See [RequestLocation](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#requestlocation) for valid values.`,
												},
												"api_key": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Optional. The API key. If the 'secretVersionForApiKey'' field is set, this field will be ignored.`,
													Sensitive:   true,
												},
												"secret_version_for_api_key": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `Optional. The name of the SecretManager secret version resource storing the API key.
If this field is set, the apiKey field will be ignored.
Format: projects/{project}/secrets/{secret}/versions/{version}`,
												},
											},
										},
									},
									"bearer_token_config": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Config for bearer token auth.
This field is part of a union field 'auth_config': Only one of 'apiKeyConfig', 'oauthConfig', 'serviceAgentAuthConfig', or 'bearerTokenConfig' may be set.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version_for_token": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `Optional. The name of the SecretManager secret version resource storing the Bearer token. If this field is set, the 'token' field will be ignored.
Format: projects/{project}/secrets/{secret}/versions/{version}`,
												},
												"token": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `Optional. The text token appended to the text Bearer to the request Authorization header.
[Session parameters reference](https://cloud.google.com/dialogflow/cx/docs/concept/parameter#session-ref) can be used to pass the token dynamically, e.g. '$session.params.parameter-id'.`,
													Sensitive: true,
												},
											},
										},
									},
									"oauth_config": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Config for OAuth.
This field is part of a union field 'auth_config': Only one of 'apiKeyConfig', 'oauthConfig', 'serviceAgentAuthConfig', or 'bearerTokenConfig' may be set.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"client_id": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The client ID from the OAuth provider.`,
												},
												"oauth_grant_type": {
													Type:     schema.TypeString,
													Required: true,
													Description: `OAuth grant types.
See [OauthGrantType](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#oauthgranttype) for valid values`,
												},
												"token_endpoint": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The token endpoint in the OAuth provider to exchange for an access token.`,
												},
												"client_secret": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Optional. The client secret from the OAuth provider. If the 'secretVersionForClientSecret' field is set, this field will be ignored.`,
													Sensitive:   true,
												},
												"scopes": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Optional. The OAuth scopes to grant.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"secret_version_for_client_secret": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `Optional. The name of the SecretManager secret version resource storing the client secret.
If this field is set, the clientSecret field will be ignored.
Format: projects/{project}/secrets/{secret}/versions/{version}`,
												},
											},
										},
									},
									"service_agent_auth_config": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Config for [Diglogflow service agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent) auth.
This field is part of a union field 'auth_config': Only one of 'apiKeyConfig', 'oauthConfig', 'serviceAgentAuthConfig', or 'bearerTokenConfig' may be set.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"service_agent_auth": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `Optional. Indicate the auth token type generated from the Diglogflow service agent.
The generated token is sent in the Authorization header.
See [ServiceAgentAuth](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#serviceagentauth) for valid values.`,
												},
											},
										},
									},
								},
							},
						},
						"service_directory_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Optional. Service Directory configuration.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"service": {
										Type:     schema.TypeString,
										Required: true,
										Description: `The name of [Service Directory](https://cloud.google.com/service-directory/docs) service.
Format: projects/<ProjectID>/locations/<LocationID>/namespaces/<NamespaceID>/services/<ServiceID>. LocationID of the service directory must be the same as the location of the agent.`,
									},
								},
							},
						},
						"tls_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Optional. TLS configuration for the HTTPS verification.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_certs": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `Specifies a list of allowed custom CA certificates for HTTPS verification.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"cert": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The allowed custom CA certificates (in DER format) for HTTPS verification. This overrides the default SSL trust store.
If this is empty or unspecified, Dialogflow will use Google's default trust store to verify certificates.
N.B. Make sure the HTTPS server certificates are signed with "subject alt name".
For instance a certificate can be self-signed using the following command:
'''
  openssl x509 -req -days 200 -in example.com.csr \
    -signkey example.com.key \
    -out example.com.crt \
    -extfile <(printf "\nsubjectAltName='DNS:www.example.com'")
'''
A base64-encoded string.`,
												},
												"display_name": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The name of the allowed custom CA certificates. This can be used to disambiguate the custom CA certificates.`,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"parent": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `The agent to create a Tool for.
Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The unique identifier of the Tool.
Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/tools/<Tool ID>.`,
			},
			"tool_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The tool type.`,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDialogflowCXToolCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandDialogflowCXToolDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	descriptionProp, err := expandDialogflowCXToolDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	openApiSpecProp, err := expandDialogflowCXToolOpenApiSpec(d.Get("open_api_spec"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("open_api_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(openApiSpecProp)) && (ok || !reflect.DeepEqual(v, openApiSpecProp)) {
		obj["openApiSpec"] = openApiSpecProp
	}
	dataStoreSpecProp, err := expandDialogflowCXToolDataStoreSpec(d.Get("data_store_spec"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_store_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(dataStoreSpecProp)) && (ok || !reflect.DeepEqual(v, dataStoreSpecProp)) {
		obj["dataStoreSpec"] = dataStoreSpecProp
	}
	functionSpecProp, err := expandDialogflowCXToolFunctionSpec(d.Get("function_spec"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("function_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(functionSpecProp)) && (ok || !reflect.DeepEqual(v, functionSpecProp)) {
		obj["functionSpec"] = functionSpecProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/tools")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Tool: %#v", obj)
	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") {
		url = strings.Replace(url, "-dialogflow", fmt.Sprintf("%s-dialogflow", location), 1)
	}

	// if it's a default object Dialogflow creates for you, "Update" instead of "Create"
	// Note: below we try to access fields that aren't present in the resource, because this custom code is reused across multiple Dialogflow resources that contain different fields. When the field isn't present, we deliberately ignore the error and the boolean is false.
	isDefaultStartFlow, _ := d.Get("is_default_start_flow").(bool)
	isDefaultWelcomeIntent, _ := d.Get("is_default_welcome_intent").(bool)
	isDefaultNegativeIntent, _ := d.Get("is_default_negative_intent").(bool)
	if isDefaultStartFlow || isDefaultWelcomeIntent || isDefaultNegativeIntent {
		// hardcode the default object ID:
		var defaultObjName string
		if isDefaultStartFlow || isDefaultWelcomeIntent {
			defaultObjName = "00000000-0000-0000-0000-000000000000"
		}
		if isDefaultNegativeIntent {
			defaultObjName = "00000000-0000-0000-0000-000000000001"
		}

		// Store the ID
		d.Set("name", defaultObjName)
		id, err := tpgresource.ReplaceVars(d, config, "{{parent}}/tools/{{name}}")
		if err != nil {
			return fmt.Errorf("Error constructing id: %s", err)
		}
		d.SetId(id)

		// and defer to the Update method:
		log.Printf("[DEBUG] Updating default DialogflowCXTool")
		return resourceDialogflowCXToolUpdate(d, meta)
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Tool: %s", err)
	}
	// Set computed resource properties from create API response so that they're available on the subsequent Read
	// call.
	err = resourceDialogflowCXToolPostCreateSetComputedFields(d, meta, res)
	if err != nil {
		return fmt.Errorf("setting computed ID format fields: %w", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "{{parent}}/tools/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Tool %q: %#v", d.Id(), res)

	return resourceDialogflowCXToolRead(d, meta)
}

func resourceDialogflowCXToolRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/tools/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") {
		url = strings.Replace(url, "-dialogflow", fmt.Sprintf("%s-dialogflow", location), 1)
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DialogflowCXTool %q", d.Id()))
	}

	if err := d.Set("name", flattenDialogflowCXToolName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("display_name", flattenDialogflowCXToolDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("description", flattenDialogflowCXToolDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("tool_type", flattenDialogflowCXToolToolType(res["toolType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("open_api_spec", flattenDialogflowCXToolOpenApiSpec(res["openApiSpec"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("data_store_spec", flattenDialogflowCXToolDataStoreSpec(res["dataStoreSpec"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("function_spec", flattenDialogflowCXToolFunctionSpec(res["functionSpec"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}

	return nil
}

func resourceDialogflowCXToolUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	obj := make(map[string]interface{})
	displayNameProp, err := expandDialogflowCXToolDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	descriptionProp, err := expandDialogflowCXToolDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	openApiSpecProp, err := expandDialogflowCXToolOpenApiSpec(d.Get("open_api_spec"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("open_api_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, openApiSpecProp)) {
		obj["openApiSpec"] = openApiSpecProp
	}
	dataStoreSpecProp, err := expandDialogflowCXToolDataStoreSpec(d.Get("data_store_spec"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_store_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dataStoreSpecProp)) {
		obj["dataStoreSpec"] = dataStoreSpecProp
	}
	functionSpecProp, err := expandDialogflowCXToolFunctionSpec(d.Get("function_spec"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("function_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, functionSpecProp)) {
		obj["functionSpec"] = functionSpecProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/tools/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Tool %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("open_api_spec") {
		updateMask = append(updateMask, "openApiSpec")
	}

	if d.HasChange("data_store_spec") {
		updateMask = append(updateMask, "dataStoreSpec")
	}

	if d.HasChange("function_spec") {
		updateMask = append(updateMask, "functionSpec")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") {
		url = strings.Replace(url, "-dialogflow", fmt.Sprintf("%s-dialogflow", location), 1)
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Tool %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Tool %q: %#v", d.Id(), res)
		}

	}

	return resourceDialogflowCXToolRead(d, meta)
}

func resourceDialogflowCXToolDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/tools/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	url = strings.Replace(url, "-dialogflow", fmt.Sprintf("%s-dialogflow", location), 1)

	// if it's a default object Dialogflow creates for you, skip deletion
	// Note: below we try to access fields that aren't present in the resource, because this custom code is reused across multiple Dialogflow resources that contain different fields. When the field isn't present, we deliberately ignore the error and the boolean is false.
	isDefaultStartFlow, _ := d.Get("is_default_start_flow").(bool)
	isDefaultWelcomeIntent, _ := d.Get("is_default_welcome_intent").(bool)
	isDefaultNegativeIntent, _ := d.Get("is_default_negative_intent").(bool)
	if isDefaultStartFlow || isDefaultWelcomeIntent || isDefaultNegativeIntent {
		// we can't delete these resources so do nothing
		log.Printf("[DEBUG] Not deleting default DialogflowCXTool")
		return nil
	}

	log.Printf("[DEBUG] Deleting Tool %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Tool")
	}

	log.Printf("[DEBUG] Finished deleting Tool %q: %#v", d.Id(), res)
	return nil
}

func resourceDialogflowCXToolImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)

	// current import_formats can't import fields with forward slashes in their value and parent contains slashes
	if err := tpgresource.ParseImportId([]string{
		"(?P<parent>.+)/tools/(?P<name>[^/]+)",
		"(?P<parent>.+)/(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "{{parent}}/tools/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenDialogflowCXToolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenDialogflowCXToolDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolToolType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["authentication"] =
		flattenDialogflowCXToolOpenApiSpecAuthentication(original["authentication"], d, config)
	transformed["tls_config"] =
		flattenDialogflowCXToolOpenApiSpecTlsConfig(original["tlsConfig"], d, config)
	transformed["service_directory_config"] =
		flattenDialogflowCXToolOpenApiSpecServiceDirectoryConfig(original["serviceDirectoryConfig"], d, config)
	transformed["text_schema"] =
		flattenDialogflowCXToolOpenApiSpecTextSchema(original["textSchema"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolOpenApiSpecAuthentication(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_key_config"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfig(original["apiKeyConfig"], d, config)
	transformed["oauth_config"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfig(original["oauthConfig"], d, config)
	transformed["service_agent_auth_config"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationServiceAgentAuthConfig(original["serviceAgentAuthConfig"], d, config)
	transformed["bearer_token_config"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfig(original["bearerTokenConfig"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["key_name"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigKeyName(original["keyName"], d, config)
	transformed["api_key"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigApiKey(original["apiKey"], d, config)
	transformed["secret_version_for_api_key"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigSecretVersionForApiKey(original["secretVersionForApiKey"], d, config)
	transformed["request_location"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigRequestLocation(original["requestLocation"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigApiKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("open_api_spec.0.authentication.0.api_key_config.0.api_key")
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigSecretVersionForApiKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigRequestLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["oauth_grant_type"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigOauthGrantType(original["oauthGrantType"], d, config)
	transformed["client_id"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigClientId(original["clientId"], d, config)
	transformed["client_secret"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigClientSecret(original["clientSecret"], d, config)
	transformed["secret_version_for_client_secret"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigSecretVersionForClientSecret(original["secretVersionForClientSecret"], d, config)
	transformed["token_endpoint"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigTokenEndpoint(original["tokenEndpoint"], d, config)
	transformed["scopes"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigScopes(original["scopes"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigOauthGrantType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigClientId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigClientSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("open_api_spec.0.authentication.0.oauth_config.0.client_secret")
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigSecretVersionForClientSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigTokenEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationOauthConfigScopes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationServiceAgentAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_agent_auth"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationServiceAgentAuthConfigServiceAgentAuth(original["serviceAgentAuth"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolOpenApiSpecAuthenticationServiceAgentAuthConfigServiceAgentAuth(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["token"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfigToken(original["token"], d, config)
	transformed["secret_version_for_token"] =
		flattenDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfigSecretVersionForToken(original["secretVersionForToken"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfigToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("open_api_spec.0.authentication.0.bearer_token_config.0.token")
}

func flattenDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfigSecretVersionForToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecTlsConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ca_certs"] =
		flattenDialogflowCXToolOpenApiSpecTlsConfigCaCerts(original["caCerts"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolOpenApiSpecTlsConfigCaCerts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"display_name": flattenDialogflowCXToolOpenApiSpecTlsConfigCaCertsDisplayName(original["displayName"], d, config),
			"cert":         flattenDialogflowCXToolOpenApiSpecTlsConfigCaCertsCert(original["cert"], d, config),
		})
	}
	return transformed
}
func flattenDialogflowCXToolOpenApiSpecTlsConfigCaCertsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecTlsConfigCaCertsCert(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecServiceDirectoryConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service"] =
		flattenDialogflowCXToolOpenApiSpecServiceDirectoryConfigService(original["service"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolOpenApiSpecServiceDirectoryConfigService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolOpenApiSpecTextSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolDataStoreSpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["data_store_connections"] =
		flattenDialogflowCXToolDataStoreSpecDataStoreConnections(original["dataStoreConnections"], d, config)
	transformed["fallback_prompt"] =
		flattenDialogflowCXToolDataStoreSpecFallbackPrompt(original["fallbackPrompt"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolDataStoreSpecDataStoreConnections(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"data_store_type":          flattenDialogflowCXToolDataStoreSpecDataStoreConnectionsDataStoreType(original["dataStoreType"], d, config),
			"data_store":               flattenDialogflowCXToolDataStoreSpecDataStoreConnectionsDataStore(original["dataStore"], d, config),
			"document_processing_mode": flattenDialogflowCXToolDataStoreSpecDataStoreConnectionsDocumentProcessingMode(original["documentProcessingMode"], d, config),
		})
	}
	return transformed
}
func flattenDialogflowCXToolDataStoreSpecDataStoreConnectionsDataStoreType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolDataStoreSpecDataStoreConnectionsDataStore(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolDataStoreSpecDataStoreConnectionsDocumentProcessingMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolDataStoreSpecFallbackPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDialogflowCXToolFunctionSpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["input_schema"] =
		flattenDialogflowCXToolFunctionSpecInputSchema(original["inputSchema"], d, config)
	transformed["output_schema"] =
		flattenDialogflowCXToolFunctionSpecOutputSchema(original["outputSchema"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolFunctionSpecInputSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenDialogflowCXToolFunctionSpecOutputSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func expandDialogflowCXToolDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAuthentication, err := expandDialogflowCXToolOpenApiSpecAuthentication(original["authentication"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthentication); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authentication"] = transformedAuthentication
	}

	transformedTlsConfig, err := expandDialogflowCXToolOpenApiSpecTlsConfig(original["tls_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTlsConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tlsConfig"] = transformedTlsConfig
	}

	transformedServiceDirectoryConfig, err := expandDialogflowCXToolOpenApiSpecServiceDirectoryConfig(original["service_directory_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceDirectoryConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceDirectoryConfig"] = transformedServiceDirectoryConfig
	}

	transformedTextSchema, err := expandDialogflowCXToolOpenApiSpecTextSchema(original["text_schema"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTextSchema); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["textSchema"] = transformedTextSchema
	}

	return transformed, nil
}

func expandDialogflowCXToolOpenApiSpecAuthentication(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedApiKeyConfig, err := expandDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfig(original["api_key_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApiKeyConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["apiKeyConfig"] = transformedApiKeyConfig
	}

	transformedOauthConfig, err := expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfig(original["oauth_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauthConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauthConfig"] = transformedOauthConfig
	}

	transformedServiceAgentAuthConfig, err := expandDialogflowCXToolOpenApiSpecAuthenticationServiceAgentAuthConfig(original["service_agent_auth_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAgentAuthConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAgentAuthConfig"] = transformedServiceAgentAuthConfig
	}

	transformedBearerTokenConfig, err := expandDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfig(original["bearer_token_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBearerTokenConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bearerTokenConfig"] = transformedBearerTokenConfig
	}

	return transformed, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKeyName, err := expandDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigKeyName(original["key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["keyName"] = transformedKeyName
	}

	transformedApiKey, err := expandDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigApiKey(original["api_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApiKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["apiKey"] = transformedApiKey
	}

	transformedSecretVersionForApiKey, err := expandDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigSecretVersionForApiKey(original["secret_version_for_api_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersionForApiKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersionForApiKey"] = transformedSecretVersionForApiKey
	}

	transformedRequestLocation, err := expandDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigRequestLocation(original["request_location"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRequestLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["requestLocation"] = transformedRequestLocation
	}

	return transformed, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigApiKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigSecretVersionForApiKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationApiKeyConfigRequestLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOauthGrantType, err := expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigOauthGrantType(original["oauth_grant_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauthGrantType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauthGrantType"] = transformedOauthGrantType
	}

	transformedClientId, err := expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigClientId(original["client_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientId"] = transformedClientId
	}

	transformedClientSecret, err := expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigClientSecret(original["client_secret"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientSecret"] = transformedClientSecret
	}

	transformedSecretVersionForClientSecret, err := expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigSecretVersionForClientSecret(original["secret_version_for_client_secret"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersionForClientSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersionForClientSecret"] = transformedSecretVersionForClientSecret
	}

	transformedTokenEndpoint, err := expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigTokenEndpoint(original["token_endpoint"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTokenEndpoint); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tokenEndpoint"] = transformedTokenEndpoint
	}

	transformedScopes, err := expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigScopes(original["scopes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScopes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scopes"] = transformedScopes
	}

	return transformed, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigOauthGrantType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigClientId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigClientSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigSecretVersionForClientSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigTokenEndpoint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationOauthConfigScopes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationServiceAgentAuthConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServiceAgentAuth, err := expandDialogflowCXToolOpenApiSpecAuthenticationServiceAgentAuthConfigServiceAgentAuth(original["service_agent_auth"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAgentAuth); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAgentAuth"] = transformedServiceAgentAuth
	}

	return transformed, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationServiceAgentAuthConfigServiceAgentAuth(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedToken, err := expandDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfigToken(original["token"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedToken); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["token"] = transformedToken
	}

	transformedSecretVersionForToken, err := expandDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfigSecretVersionForToken(original["secret_version_for_token"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersionForToken); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersionForToken"] = transformedSecretVersionForToken
	}

	return transformed, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfigToken(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecAuthenticationBearerTokenConfigSecretVersionForToken(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecTlsConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCaCerts, err := expandDialogflowCXToolOpenApiSpecTlsConfigCaCerts(original["ca_certs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCerts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCerts"] = transformedCaCerts
	}

	return transformed, nil
}

func expandDialogflowCXToolOpenApiSpecTlsConfigCaCerts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDisplayName, err := expandDialogflowCXToolOpenApiSpecTlsConfigCaCertsDisplayName(original["display_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["displayName"] = transformedDisplayName
		}

		transformedCert, err := expandDialogflowCXToolOpenApiSpecTlsConfigCaCertsCert(original["cert"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCert); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["cert"] = transformedCert
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDialogflowCXToolOpenApiSpecTlsConfigCaCertsDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecTlsConfigCaCertsCert(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecServiceDirectoryConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedService, err := expandDialogflowCXToolOpenApiSpecServiceDirectoryConfigService(original["service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["service"] = transformedService
	}

	return transformed, nil
}

func expandDialogflowCXToolOpenApiSpecServiceDirectoryConfigService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolOpenApiSpecTextSchema(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolDataStoreSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDataStoreConnections, err := expandDialogflowCXToolDataStoreSpecDataStoreConnections(original["data_store_connections"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataStoreConnections); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataStoreConnections"] = transformedDataStoreConnections
	}

	transformedFallbackPrompt, err := expandDialogflowCXToolDataStoreSpecFallbackPrompt(original["fallback_prompt"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["fallbackPrompt"] = transformedFallbackPrompt
	}

	return transformed, nil
}

func expandDialogflowCXToolDataStoreSpecDataStoreConnections(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDataStoreType, err := expandDialogflowCXToolDataStoreSpecDataStoreConnectionsDataStoreType(original["data_store_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDataStoreType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["dataStoreType"] = transformedDataStoreType
		}

		transformedDataStore, err := expandDialogflowCXToolDataStoreSpecDataStoreConnectionsDataStore(original["data_store"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDataStore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["dataStore"] = transformedDataStore
		}

		transformedDocumentProcessingMode, err := expandDialogflowCXToolDataStoreSpecDataStoreConnectionsDocumentProcessingMode(original["document_processing_mode"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDocumentProcessingMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["documentProcessingMode"] = transformedDocumentProcessingMode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDialogflowCXToolDataStoreSpecDataStoreConnectionsDataStoreType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolDataStoreSpecDataStoreConnectionsDataStore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolDataStoreSpecDataStoreConnectionsDocumentProcessingMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolDataStoreSpecFallbackPrompt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDialogflowCXToolFunctionSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInputSchema, err := expandDialogflowCXToolFunctionSpecInputSchema(original["input_schema"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInputSchema); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inputSchema"] = transformedInputSchema
	}

	transformedOutputSchema, err := expandDialogflowCXToolFunctionSpecOutputSchema(original["output_schema"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputSchema); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputSchema"] = transformedOutputSchema
	}

	return transformed, nil
}

func expandDialogflowCXToolFunctionSpecInputSchema(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	m := make(map[string]interface{})
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	return m, nil
}

func expandDialogflowCXToolFunctionSpecOutputSchema(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	m := make(map[string]interface{})
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	return m, nil
}

func resourceDialogflowCXToolPostCreateSetComputedFields(d *schema.ResourceData, meta interface{}, res map[string]interface{}) error {
	config := meta.(*transport_tpg.Config)
	if err := d.Set("name", flattenDialogflowCXToolName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}
	return nil
}
