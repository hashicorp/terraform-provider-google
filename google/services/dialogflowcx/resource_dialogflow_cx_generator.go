// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/dialogflowcx/Generator.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package dialogflowcx

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceDialogflowCXGenerator() *schema.Resource {
	return &schema.Resource{
		Create: resourceDialogflowCXGeneratorCreate,
		Read:   resourceDialogflowCXGeneratorRead,
		Update: resourceDialogflowCXGeneratorUpdate,
		Delete: resourceDialogflowCXGeneratorDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDialogflowCXGeneratorImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(40 * time.Minute),
			Update: schema.DefaultTimeout(40 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The human-readable name of the generator, unique within the agent.`,
			},
			"prompt_text": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `Prompt for the LLM model.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"text": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Text input which can be used for prompt or banned phrases.`,
						},
					},
				},
			},
			"language_code": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `The language to create generators for the following fields:
* Generator.prompt_text.text
If not specified, the agent's default language is used.`,
			},
			"llm_model_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The LLM model settings.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"model": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The selected LLM model.`,
						},
						"prompt_text": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The custom prompt to use.`,
						},
					},
				},
			},
			"model_parameter": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Parameters passed to the LLM to configure its behavior.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"max_decode_steps": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `The maximum number of tokens to generate.`,
						},
						"temperature": {
							Type:     schema.TypeFloat,
							Optional: true,
							Description: `The temperature used for sampling. Temperature sampling occurs after both topP and topK have been applied.
Valid range: [0.0, 1.0] Low temperature = less random. High temperature = more random.`,
						},
						"top_k": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `If set, the sampling process in each step is limited to the topK tokens with highest probabilities.
Valid range: [1, 40] or 1000+. Small topK = less random. Large topK = more random.`,
						},
						"top_p": {
							Type:     schema.TypeFloat,
							Optional: true,
							Description: `If set, only the tokens comprising the top topP probability mass are considered.
If both topP and topK are set, topP will be used for further refining candidates selected with topK.
Valid range: (0.0, 1.0]. Small topP = less random. Large topP = more random.`,
						},
					},
				},
			},
			"parent": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `The agent to create a Generator for.
Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>.`,
			},
			"placeholders": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `List of custom placeholders in the prompt text.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Unique ID used to map custom placeholder to parameters in fulfillment.`,
						},
						"name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Custom placeholder value in the prompt text.`,
						},
					},
				},
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The unique identifier of the Generator.
Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/generators/<Generator ID>.`,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDialogflowCXGeneratorCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandDialogflowCXGeneratorDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	llmModelSettingsProp, err := expandDialogflowCXGeneratorLlmModelSettings(d.Get("llm_model_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("llm_model_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(llmModelSettingsProp)) && (ok || !reflect.DeepEqual(v, llmModelSettingsProp)) {
		obj["llmModelSettings"] = llmModelSettingsProp
	}
	modelParameterProp, err := expandDialogflowCXGeneratorModelParameter(d.Get("model_parameter"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("model_parameter"); !tpgresource.IsEmptyValue(reflect.ValueOf(modelParameterProp)) && (ok || !reflect.DeepEqual(v, modelParameterProp)) {
		obj["modelParameter"] = modelParameterProp
	}
	placeholdersProp, err := expandDialogflowCXGeneratorPlaceholders(d.Get("placeholders"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("placeholders"); !tpgresource.IsEmptyValue(reflect.ValueOf(placeholdersProp)) && (ok || !reflect.DeepEqual(v, placeholdersProp)) {
		obj["placeholders"] = placeholdersProp
	}
	promptTextProp, err := expandDialogflowCXGeneratorPromptText(d.Get("prompt_text"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("prompt_text"); !tpgresource.IsEmptyValue(reflect.ValueOf(promptTextProp)) && (ok || !reflect.DeepEqual(v, promptTextProp)) {
		obj["promptText"] = promptTextProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/generators")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Generator: %#v", obj)
	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") {
		url = strings.Replace(url, "-dialogflow", fmt.Sprintf("%s-dialogflow", location), 1)
	}

	if v, ok := d.GetOk("language_code"); ok {
		url, err = transport_tpg.AddQueryParams(url, map[string]string{"languageCode": fmt.Sprintf("%v", v)})
		if err != nil {
			return err
		}
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Generator: %s", err)
	}
	// Set computed resource properties from create API response so that they're available on the subsequent Read
	// call.
	err = resourceDialogflowCXGeneratorPostCreateSetComputedFields(d, meta, res)
	if err != nil {
		return fmt.Errorf("setting computed ID format fields: %w", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "{{parent}}/generators/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Generator %q: %#v", d.Id(), res)

	return resourceDialogflowCXGeneratorRead(d, meta)
}

func resourceDialogflowCXGeneratorRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/generators/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") {
		url = strings.Replace(url, "-dialogflow", fmt.Sprintf("%s-dialogflow", location), 1)
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DialogflowCXGenerator %q", d.Id()))
	}

	if err := d.Set("name", flattenDialogflowCXGeneratorName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Generator: %s", err)
	}
	if err := d.Set("display_name", flattenDialogflowCXGeneratorDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Generator: %s", err)
	}
	if err := d.Set("llm_model_settings", flattenDialogflowCXGeneratorLlmModelSettings(res["llmModelSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading Generator: %s", err)
	}
	if err := d.Set("model_parameter", flattenDialogflowCXGeneratorModelParameter(res["modelParameter"], d, config)); err != nil {
		return fmt.Errorf("Error reading Generator: %s", err)
	}
	if err := d.Set("placeholders", flattenDialogflowCXGeneratorPlaceholders(res["placeholders"], d, config)); err != nil {
		return fmt.Errorf("Error reading Generator: %s", err)
	}

	return nil
}

func resourceDialogflowCXGeneratorUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	obj := make(map[string]interface{})
	displayNameProp, err := expandDialogflowCXGeneratorDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	llmModelSettingsProp, err := expandDialogflowCXGeneratorLlmModelSettings(d.Get("llm_model_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("llm_model_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, llmModelSettingsProp)) {
		obj["llmModelSettings"] = llmModelSettingsProp
	}
	modelParameterProp, err := expandDialogflowCXGeneratorModelParameter(d.Get("model_parameter"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("model_parameter"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, modelParameterProp)) {
		obj["modelParameter"] = modelParameterProp
	}
	placeholdersProp, err := expandDialogflowCXGeneratorPlaceholders(d.Get("placeholders"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("placeholders"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, placeholdersProp)) {
		obj["placeholders"] = placeholdersProp
	}
	promptTextProp, err := expandDialogflowCXGeneratorPromptText(d.Get("prompt_text"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("prompt_text"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, promptTextProp)) {
		obj["promptText"] = promptTextProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/generators/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Generator %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("llm_model_settings") {
		updateMask = append(updateMask, "llmModelSettings")
	}

	if d.HasChange("model_parameter") {
		updateMask = append(updateMask, "modelParameter")
	}

	if d.HasChange("placeholders") {
		updateMask = append(updateMask, "placeholders")
	}

	if d.HasChange("prompt_text") {
		updateMask = append(updateMask, "promptText")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") {
		url = strings.Replace(url, "-dialogflow", fmt.Sprintf("%s-dialogflow", location), 1)
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Generator %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Generator %q: %#v", d.Id(), res)
		}

	}

	return resourceDialogflowCXGeneratorRead(d, meta)
}

func resourceDialogflowCXGeneratorDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/generators/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	url = strings.Replace(url, "-dialogflow", fmt.Sprintf("%s-dialogflow", location), 1)

	// if it's a default object Dialogflow creates for you, skip deletion
	// Note: below we try to access fields that aren't present in the resource, because this custom code is reused across multiple Dialogflow resources that contain different fields. When the field isn't present, we deliberately ignore the error and the boolean is false.
	isDefaultStartFlow, _ := d.Get("is_default_start_flow").(bool)
	isDefaultWelcomeIntent, _ := d.Get("is_default_welcome_intent").(bool)
	isDefaultNegativeIntent, _ := d.Get("is_default_negative_intent").(bool)
	if isDefaultStartFlow || isDefaultWelcomeIntent || isDefaultNegativeIntent {
		// we can't delete these resources so do nothing
		log.Printf("[DEBUG] Not deleting default DialogflowCXGenerator")
		return nil
	}

	log.Printf("[DEBUG] Deleting Generator %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Generator")
	}

	log.Printf("[DEBUG] Finished deleting Generator %q: %#v", d.Id(), res)
	return nil
}

func resourceDialogflowCXGeneratorImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)

	// current import_formats can't import fields with forward slashes in their value and parent contains slashes
	if err := tpgresource.ParseImportId([]string{
		"(?P<parent>.+)/generators/(?P<name>[^/]+)",
		"(?P<parent>.+)/(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "{{parent}}/generators/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenDialogflowCXGeneratorName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenDialogflowCXGeneratorDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXGeneratorLlmModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenDialogflowCXGeneratorLlmModelSettingsModel(original["model"], d, config)
	transformed["prompt_text"] =
		flattenDialogflowCXGeneratorLlmModelSettingsPromptText(original["promptText"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXGeneratorLlmModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXGeneratorLlmModelSettingsPromptText(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXGeneratorModelParameter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["temperature"] =
		flattenDialogflowCXGeneratorModelParameterTemperature(original["temperature"], d, config)
	transformed["max_decode_steps"] =
		flattenDialogflowCXGeneratorModelParameterMaxDecodeSteps(original["maxDecodeSteps"], d, config)
	transformed["top_p"] =
		flattenDialogflowCXGeneratorModelParameterTopP(original["topP"], d, config)
	transformed["top_k"] =
		flattenDialogflowCXGeneratorModelParameterTopK(original["topK"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXGeneratorModelParameterTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXGeneratorModelParameterMaxDecodeSteps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDialogflowCXGeneratorModelParameterTopP(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXGeneratorModelParameterTopK(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDialogflowCXGeneratorPlaceholders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"id":   flattenDialogflowCXGeneratorPlaceholdersId(original["id"], d, config),
			"name": flattenDialogflowCXGeneratorPlaceholdersName(original["name"], d, config),
		})
	}
	return transformed
}
func flattenDialogflowCXGeneratorPlaceholdersId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXGeneratorPlaceholdersName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandDialogflowCXGeneratorDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXGeneratorLlmModelSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedModel, err := expandDialogflowCXGeneratorLlmModelSettingsModel(original["model"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["model"] = transformedModel
	}

	transformedPromptText, err := expandDialogflowCXGeneratorLlmModelSettingsPromptText(original["prompt_text"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPromptText); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["promptText"] = transformedPromptText
	}

	return transformed, nil
}

func expandDialogflowCXGeneratorLlmModelSettingsModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXGeneratorLlmModelSettingsPromptText(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXGeneratorModelParameter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTemperature, err := expandDialogflowCXGeneratorModelParameterTemperature(original["temperature"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTemperature); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["temperature"] = transformedTemperature
	}

	transformedMaxDecodeSteps, err := expandDialogflowCXGeneratorModelParameterMaxDecodeSteps(original["max_decode_steps"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxDecodeSteps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxDecodeSteps"] = transformedMaxDecodeSteps
	}

	transformedTopP, err := expandDialogflowCXGeneratorModelParameterTopP(original["top_p"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTopP); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["topP"] = transformedTopP
	}

	transformedTopK, err := expandDialogflowCXGeneratorModelParameterTopK(original["top_k"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTopK); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["topK"] = transformedTopK
	}

	return transformed, nil
}

func expandDialogflowCXGeneratorModelParameterTemperature(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXGeneratorModelParameterMaxDecodeSteps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXGeneratorModelParameterTopP(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXGeneratorModelParameterTopK(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXGeneratorPlaceholders(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedId, err := expandDialogflowCXGeneratorPlaceholdersId(original["id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["id"] = transformedId
		}

		transformedName, err := expandDialogflowCXGeneratorPlaceholdersName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDialogflowCXGeneratorPlaceholdersId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXGeneratorPlaceholdersName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXGeneratorPromptText(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedText, err := expandDialogflowCXGeneratorPromptTextText(original["text"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedText); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["text"] = transformedText
	}

	return transformed, nil
}

func expandDialogflowCXGeneratorPromptTextText(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceDialogflowCXGeneratorPostCreateSetComputedFields(d *schema.ResourceData, meta interface{}, res map[string]interface{}) error {
	config := meta.(*transport_tpg.Config)
	if err := d.Set("name", flattenDialogflowCXGeneratorName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}
	return nil
}
