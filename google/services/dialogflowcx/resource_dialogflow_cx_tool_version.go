// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/dialogflowcx/ToolVersion.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package dialogflowcx

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/registry"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func init() {
	registry.Schema{
		Name:        "google_dialogflow_cx_tool_version",
		ProductName: "dialogflowcx",
		Type:        registry.SchemaTypeResource,
		Schema:      ResourceDialogflowCXToolVersion(),
	}.Register()
}

func ResourceDialogflowCXToolVersion() *schema.Resource {
	return &schema.Resource{
		Create: resourceDialogflowCXToolVersionCreate,
		Read:   resourceDialogflowCXToolVersionRead,
		Delete: resourceDialogflowCXToolVersionDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDialogflowCXToolVersionImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(40 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The display name of the tool version.`,
			},
			"parent": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The tool to create a Version for.
Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/tools/<Tool ID>.`,
			},
			"tool": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `Snapshot of the tool to be associated with this version.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"description": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `High level description of the Tool and its usage.`,
						},
						"display_name": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `The human-readable name of the tool, unique within the agent.`,
						},
						"data_store_spec": {
							Type:     schema.TypeList,
							Optional: true,
							ForceNew: true,
							Description: `Data store search tool specification.
This field is part of a union field 'specification': Only one of 'openApiSpec', 'dataStoreSpec', or 'functionSpec' may be set.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"data_store_connections": {
										Type:        schema.TypeList,
										Required:    true,
										ForceNew:    true,
										Description: `List of data stores to search.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"data_store": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}`,
												},
												"data_store_type": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `The type of the connected data store.
See [DataStoreType](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/DataStoreConnection#datastoretype) for valid values.`,
												},
												"document_processing_mode": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
See [DocumentProcessingMode](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/DataStoreConnection#documentprocessingmode) for valid values.`,
												},
											},
										},
									},
									"fallback_prompt": {
										Type:        schema.TypeList,
										Required:    true,
										ForceNew:    true,
										Description: `Fallback prompt configurations to use.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},
								},
							},
						},
						"function_spec": {
							Type:     schema.TypeList,
							Optional: true,
							ForceNew: true,
							Description: `Client side executed function specification.
This field is part of a union field 'specification': Only one of 'openApiSpec', 'dataStoreSpec', or 'functionSpec' may be set.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"input_schema": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description: `Optional. The JSON schema is encapsulated in a [google.protobuf.Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct) to describe the input of the function.
This input is a JSON object that contains the function's parameters as properties of the object`,
									},
									"output_schema": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description: `Optional. The JSON schema is encapsulated in a [google.protobuf.Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct) to describe the output of the function.
This output is a JSON object that contains the function's parameters as properties of the object`,
									},
								},
							},
						},
						"open_api_spec": {
							Type:     schema.TypeList,
							Optional: true,
							ForceNew: true,
							Description: `OpenAPI specification of the Tool.
This field is part of a union field 'specification': Only one of 'openApiSpec', 'dataStoreSpec', or 'functionSpec' may be set.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"text_schema": {
										Type:     schema.TypeString,
										Required: true,
										ForceNew: true,
										Description: `The OpenAPI schema specified as a text.
This field is part of a union field 'schema': only one of 'textSchema' may be set.`,
									},
									"authentication": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Authentication information required by the API.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"api_key_config": {
													Type:     schema.TypeList,
													Optional: true,
													ForceNew: true,
													Description: `Config for API key auth.
This field is part of a union field 'auth_config': Only one of 'apiKeyConfig', 'oauthConfig', 'serviceAgentAuthConfig', or 'bearerTokenConfig' may be set.`,
													MaxItems: 1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"key_name": {
																Type:     schema.TypeString,
																Required: true,
																ForceNew: true,
																Description: `The parameter name or the header name of the API key.
E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.`,
															},
															"request_location": {
																Type:     schema.TypeString,
																Required: true,
																ForceNew: true,
																Description: `Key location in the request.
See [RequestLocation](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#requestlocation) for valid values.`,
															},
															"api_key": {
																Type:        schema.TypeString,
																Optional:    true,
																ForceNew:    true,
																Description: `Optional. The API key. If the 'secretVersionForApiKey'' field is set, this field will be ignored.`,
																Sensitive:   true,
															},
															"secret_version_for_api_key": {
																Type:     schema.TypeString,
																Optional: true,
																ForceNew: true,
																Description: `Optional. The name of the SecretManager secret version resource storing the API key.
If this field is set, the apiKey field will be ignored.
Format: projects/{project}/secrets/{secret}/versions/{version}`,
															},
														},
													},
												},
												"bearer_token_config": {
													Type:     schema.TypeList,
													Optional: true,
													ForceNew: true,
													Description: `Config for bearer token auth.
This field is part of a union field 'auth_config': Only one of 'apiKeyConfig', 'oauthConfig', 'serviceAgentAuthConfig', or 'bearerTokenConfig' may be set.`,
													MaxItems: 1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"secret_version_for_token": {
																Type:     schema.TypeString,
																Optional: true,
																ForceNew: true,
																Description: `Optional. The name of the SecretManager secret version resource storing the Bearer token. If this field is set, the 'token' field will be ignored.
Format: projects/{project}/secrets/{secret}/versions/{version}`,
															},
															"token": {
																Type:     schema.TypeString,
																Optional: true,
																ForceNew: true,
																Description: `Optional. The text token appended to the text Bearer to the request Authorization header.
[Session parameters reference](https://cloud.google.com/dialogflow/cx/docs/concept/parameter#session-ref) can be used to pass the token dynamically, e.g. '$session.params.parameter-id'.`,
																Sensitive: true,
															},
														},
													},
												},
												"oauth_config": {
													Type:     schema.TypeList,
													Optional: true,
													ForceNew: true,
													Description: `Config for OAuth.
This field is part of a union field 'auth_config': Only one of 'apiKeyConfig', 'oauthConfig', 'serviceAgentAuthConfig', or 'bearerTokenConfig' may be set.`,
													MaxItems: 1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"client_id": {
																Type:        schema.TypeString,
																Required:    true,
																ForceNew:    true,
																Description: `The client ID from the OAuth provider.`,
															},
															"oauth_grant_type": {
																Type:     schema.TypeString,
																Required: true,
																ForceNew: true,
																Description: `OAuth grant types.
See [OauthGrantType](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#oauthgranttype) for valid values`,
															},
															"token_endpoint": {
																Type:        schema.TypeString,
																Required:    true,
																ForceNew:    true,
																Description: `The token endpoint in the OAuth provider to exchange for an access token.`,
															},
															"client_secret": {
																Type:        schema.TypeString,
																Optional:    true,
																ForceNew:    true,
																Description: `Optional. The client secret from the OAuth provider. If the 'secretVersionForClientSecret' field is set, this field will be ignored.`,
																Sensitive:   true,
															},
															"scopes": {
																Type:        schema.TypeList,
																Optional:    true,
																ForceNew:    true,
																Description: `Optional. The OAuth scopes to grant.`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"secret_version_for_client_secret": {
																Type:     schema.TypeString,
																Optional: true,
																ForceNew: true,
																Description: `Optional. The name of the SecretManager secret version resource storing the client secret.
If this field is set, the clientSecret field will be ignored.
Format: projects/{project}/secrets/{secret}/versions/{version}`,
															},
														},
													},
												},
												"service_agent_auth_config": {
													Type:     schema.TypeList,
													Optional: true,
													ForceNew: true,
													Description: `Config for [Diglogflow service agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent) auth.
This field is part of a union field 'auth_config': Only one of 'apiKeyConfig', 'oauthConfig', 'serviceAgentAuthConfig', or 'bearerTokenConfig' may be set.`,
													MaxItems: 1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"service_agent_auth": {
																Type:     schema.TypeString,
																Optional: true,
																ForceNew: true,
																Description: `Optional. Indicate the auth token type generated from the Diglogflow service agent.
The generated token is sent in the Authorization header.
See [ServiceAgentAuth](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#serviceagentauth) for valid values.`,
															},
														},
													},
												},
											},
										},
									},
									"service_directory_config": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Service Directory configuration.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"service": {
													Type:     schema.TypeString,
													Required: true,
													ForceNew: true,
													Description: `The name of [Service Directory](https://cloud.google.com/service-directory/docs) service.
Format: projects/<ProjectID>/locations/<LocationID>/namespaces/<NamespaceID>/services/<ServiceID>. LocationID of the service directory must be the same as the location of the agent.`,
												},
											},
										},
									},
									"tls_config": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. TLS configuration for the HTTPS verification.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"ca_certs": {
													Type:        schema.TypeList,
													Required:    true,
													ForceNew:    true,
													Description: `Specifies a list of allowed custom CA certificates for HTTPS verification.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"cert": {
																Type:     schema.TypeString,
																Required: true,
																ForceNew: true,
																Description: `The allowed custom CA certificates (in DER format) for HTTPS verification. This overrides the default SSL trust store.
If this is empty or unspecified, Dialogflow will use Google's default trust store to verify certificates.
N.B. Make sure the HTTPS server certificates are signed with "subject alt name".
For instance a certificate can be self-signed using the following command:
'''
  openssl x509 -req -days 200 -in example.com.csr \
    -signkey example.com.key \
    -out example.com.crt \
    -extfile <(printf "\nsubjectAltName='DNS:www.example.com'")
'''
A base64-encoded string.`,
															},
															"display_name": {
																Type:        schema.TypeString,
																Required:    true,
																ForceNew:    true,
																Description: `The name of the allowed custom CA certificates. This can be used to disambiguate the custom CA certificates.`,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"name": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The unique identifier of the Tool.
Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/tools/<Tool ID>.`,
						},
						"tool_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The tool type.`,
						},
					},
				},
			},
			"create_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Last time the tool version was created or modified.
Uses RFC 3339, where generated output will always be Z-normalized and use 0, 3, 6 or 9 fractional digits.
Offsets other than "Z" are also accepted.
Examples: "2014-10-02T15:01:23Z", "2014-10-02T15:01:23.045123456Z" or "2014-10-02T15:01:23+05:30".`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The unique identifier of the tool version.
Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/tools/<ToolID>/versions/<VersionID>.`,
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Last time the tool version was created or modified.
Uses RFC 3339, where generated output will always be Z-normalized and use 0, 3, 6 or 9 fractional digits.
Offsets other than "Z" are also accepted.
Examples: "2014-10-02T15:01:23Z", "2014-10-02T15:01:23.045123456Z" or "2014-10-02T15:01:23+05:30".`,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDialogflowCXToolVersionCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandDialogflowCXToolVersionDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	toolProp, err := expandDialogflowCXToolVersionTool(d.Get("tool"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("tool"); !tpgresource.IsEmptyValue(reflect.ValueOf(toolProp)) && (ok || !reflect.DeepEqual(v, toolProp)) {
		obj["tool"] = toolProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/versions")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new ToolVersion: %#v", obj)
	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3beta1/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3beta1/") {
		url = strings.Replace(url, "https://-dialogflow", fmt.Sprintf("https://%s-dialogflow", location), 1)
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating ToolVersion: %s", err)
	}
	// Set computed resource properties from create API response so that they're available on the subsequent Read
	// call.
	err = resourceDialogflowCXToolVersionPostCreateSetComputedFields(d, meta, res)
	if err != nil {
		return fmt.Errorf("setting computed ID format fields: %w", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "{{parent}}/versions/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating ToolVersion %q: %#v", d.Id(), res)

	return resourceDialogflowCXToolVersionRead(d, meta)
}

func resourceDialogflowCXToolVersionRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/versions/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	// only insert location into url if the base_url in products/dialogflowcx/product.yaml is used
	if strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3/") ||
		strings.HasPrefix(url, "https://-dialogflow.googleapis.com/v3beta1/") ||
		strings.HasPrefix(url, "https://-dialogflow."+config.UniverseDomain+"/v3beta1/") {
		url = strings.Replace(url, "https://-dialogflow", fmt.Sprintf("https://%s-dialogflow", location), 1)
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DialogflowCXToolVersion %q", d.Id()))
	}

	if err := d.Set("name", flattenDialogflowCXToolVersionName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading ToolVersion: %s", err)
	}
	if err := d.Set("display_name", flattenDialogflowCXToolVersionDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading ToolVersion: %s", err)
	}
	if err := d.Set("tool", flattenDialogflowCXToolVersionTool(res["tool"], d, config)); err != nil {
		return fmt.Errorf("Error reading ToolVersion: %s", err)
	}
	if err := d.Set("create_time", flattenDialogflowCXToolVersionCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading ToolVersion: %s", err)
	}
	if err := d.Set("update_time", flattenDialogflowCXToolVersionUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading ToolVersion: %s", err)
	}

	return nil
}

func resourceDialogflowCXToolVersionDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	url, err := tpgresource.ReplaceVars(d, config, "{{DialogflowCXBasePath}}{{parent}}/versions/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// extract location from the parent
	location := ""

	if parts := regexp.MustCompile(`locations\/([^\/]*)\/`).FindStringSubmatch(d.Get("parent").(string)); parts != nil {
		location = parts[1]
	} else {
		return fmt.Errorf(
			"Saw %s when the parent is expected to contains location %s",
			d.Get("parent"),
			"projects/{{project}}/locations/{{location}}/...",
		)
	}

	url = strings.Replace(url, "-dialogflow", fmt.Sprintf("%s-dialogflow", location), 1)

	// if it's a default object Dialogflow creates for you, skip deletion
	// Note: below we try to access fields that aren't present in the resource, because this custom code is reused across multiple Dialogflow resources that contain different fields. When the field isn't present, we deliberately ignore the error and the boolean is false.
	isDefaultStartFlow, _ := d.Get("is_default_start_flow").(bool)
	isDefaultWelcomeIntent, _ := d.Get("is_default_welcome_intent").(bool)
	isDefaultNegativeIntent, _ := d.Get("is_default_negative_intent").(bool)
	if isDefaultStartFlow || isDefaultWelcomeIntent || isDefaultNegativeIntent {
		// we can't delete these resources so do nothing
		log.Printf("[DEBUG] Not deleting default DialogflowCXToolVersion")
		return nil
	}

	log.Printf("[DEBUG] Deleting ToolVersion %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "ToolVersion")
	}

	log.Printf("[DEBUG] Finished deleting ToolVersion %q: %#v", d.Id(), res)
	return nil
}

func resourceDialogflowCXToolVersionImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)

	// current import_formats can't import fields with forward slashes in their value and parent contains slashes
	if err := tpgresource.ParseImportId([]string{
		"(?P<parent>.+)/versions/(?P<name>[^/]+)",
		"(?P<parent>.+)/(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "{{parent}}/versions/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenDialogflowCXToolVersionName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenDialogflowCXToolVersionDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenDialogflowCXToolVersionToolName(original["name"], d, config)
	transformed["display_name"] =
		flattenDialogflowCXToolVersionToolDisplayName(original["displayName"], d, config)
	transformed["description"] =
		flattenDialogflowCXToolVersionToolDescription(original["description"], d, config)
	transformed["tool_type"] =
		flattenDialogflowCXToolVersionToolToolType(original["toolType"], d, config)
	transformed["open_api_spec"] =
		flattenDialogflowCXToolVersionToolOpenApiSpec(original["openApiSpec"], d, config)
	transformed["data_store_spec"] =
		flattenDialogflowCXToolVersionToolDataStoreSpec(original["dataStoreSpec"], d, config)
	transformed["function_spec"] =
		flattenDialogflowCXToolVersionToolFunctionSpec(original["functionSpec"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolVersionToolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenDialogflowCXToolVersionToolDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolToolType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["authentication"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthentication(original["authentication"], d, config)
	transformed["tls_config"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecTlsConfig(original["tlsConfig"], d, config)
	transformed["service_directory_config"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecServiceDirectoryConfig(original["serviceDirectoryConfig"], d, config)
	transformed["text_schema"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecTextSchema(original["textSchema"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolVersionToolOpenApiSpecAuthentication(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_key_config"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfig(original["apiKeyConfig"], d, config)
	transformed["oauth_config"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfig(original["oauthConfig"], d, config)
	transformed["service_agent_auth_config"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationServiceAgentAuthConfig(original["serviceAgentAuthConfig"], d, config)
	transformed["bearer_token_config"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfig(original["bearerTokenConfig"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["key_name"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigKeyName(original["keyName"], d, config)
	transformed["api_key"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigApiKey(original["apiKey"], d, config)
	transformed["secret_version_for_api_key"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigSecretVersionForApiKey(original["secretVersionForApiKey"], d, config)
	transformed["request_location"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigRequestLocation(original["requestLocation"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigApiKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("tool.0.open_api_spec.0.authentication.0.api_key_config.0.api_key")
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigSecretVersionForApiKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigRequestLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["oauth_grant_type"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigOauthGrantType(original["oauthGrantType"], d, config)
	transformed["client_id"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigClientId(original["clientId"], d, config)
	transformed["client_secret"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigClientSecret(original["clientSecret"], d, config)
	transformed["secret_version_for_client_secret"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigSecretVersionForClientSecret(original["secretVersionForClientSecret"], d, config)
	transformed["token_endpoint"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigTokenEndpoint(original["tokenEndpoint"], d, config)
	transformed["scopes"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigScopes(original["scopes"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigOauthGrantType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigClientId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigClientSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("tool.0.open_api_spec.0.authentication.0.oauth_config.0.client_secret")
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigSecretVersionForClientSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigTokenEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigScopes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationServiceAgentAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_agent_auth"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationServiceAgentAuthConfigServiceAgentAuth(original["serviceAgentAuth"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationServiceAgentAuthConfigServiceAgentAuth(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["token"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfigToken(original["token"], d, config)
	transformed["secret_version_for_token"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfigSecretVersionForToken(original["secretVersionForToken"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfigToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("tool.0.open_api_spec.0.authentication.0.bearer_token_config.0.token")
}

func flattenDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfigSecretVersionForToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecTlsConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ca_certs"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCerts(original["caCerts"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCerts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"display_name": flattenDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCertsDisplayName(original["displayName"], d, config),
			"cert":         flattenDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCertsCert(original["cert"], d, config),
		})
	}
	return transformed
}
func flattenDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCertsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCertsCert(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecServiceDirectoryConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service"] =
		flattenDialogflowCXToolVersionToolOpenApiSpecServiceDirectoryConfigService(original["service"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolVersionToolOpenApiSpecServiceDirectoryConfigService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolOpenApiSpecTextSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolDataStoreSpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["data_store_connections"] =
		flattenDialogflowCXToolVersionToolDataStoreSpecDataStoreConnections(original["dataStoreConnections"], d, config)
	transformed["fallback_prompt"] =
		flattenDialogflowCXToolVersionToolDataStoreSpecFallbackPrompt(original["fallbackPrompt"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolVersionToolDataStoreSpecDataStoreConnections(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"data_store_type":          flattenDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDataStoreType(original["dataStoreType"], d, config),
			"data_store":               flattenDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDataStore(original["dataStore"], d, config),
			"document_processing_mode": flattenDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDocumentProcessingMode(original["documentProcessingMode"], d, config),
		})
	}
	return transformed
}
func flattenDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDataStoreType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDataStore(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDocumentProcessingMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionToolDataStoreSpecFallbackPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDialogflowCXToolVersionToolFunctionSpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["input_schema"] =
		flattenDialogflowCXToolVersionToolFunctionSpecInputSchema(original["inputSchema"], d, config)
	transformed["output_schema"] =
		flattenDialogflowCXToolVersionToolFunctionSpecOutputSchema(original["outputSchema"], d, config)
	return []interface{}{transformed}
}
func flattenDialogflowCXToolVersionToolFunctionSpecInputSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenDialogflowCXToolVersionToolFunctionSpecOutputSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenDialogflowCXToolVersionCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDialogflowCXToolVersionUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandDialogflowCXToolVersionDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionTool(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandDialogflowCXToolVersionToolName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedDisplayName, err := expandDialogflowCXToolVersionToolDisplayName(original["display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayName"] = transformedDisplayName
	}

	transformedDescription, err := expandDialogflowCXToolVersionToolDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedToolType, err := expandDialogflowCXToolVersionToolToolType(original["tool_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedToolType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["toolType"] = transformedToolType
	}

	transformedOpenApiSpec, err := expandDialogflowCXToolVersionToolOpenApiSpec(original["open_api_spec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOpenApiSpec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["openApiSpec"] = transformedOpenApiSpec
	}

	transformedDataStoreSpec, err := expandDialogflowCXToolVersionToolDataStoreSpec(original["data_store_spec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataStoreSpec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataStoreSpec"] = transformedDataStoreSpec
	}

	transformedFunctionSpec, err := expandDialogflowCXToolVersionToolFunctionSpec(original["function_spec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFunctionSpec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["functionSpec"] = transformedFunctionSpec
	}

	return transformed, nil
}

func expandDialogflowCXToolVersionToolName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolToolType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAuthentication, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthentication(original["authentication"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthentication); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authentication"] = transformedAuthentication
	}

	transformedTlsConfig, err := expandDialogflowCXToolVersionToolOpenApiSpecTlsConfig(original["tls_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTlsConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tlsConfig"] = transformedTlsConfig
	}

	transformedServiceDirectoryConfig, err := expandDialogflowCXToolVersionToolOpenApiSpecServiceDirectoryConfig(original["service_directory_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceDirectoryConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceDirectoryConfig"] = transformedServiceDirectoryConfig
	}

	transformedTextSchema, err := expandDialogflowCXToolVersionToolOpenApiSpecTextSchema(original["text_schema"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTextSchema); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["textSchema"] = transformedTextSchema
	}

	return transformed, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthentication(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedApiKeyConfig, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfig(original["api_key_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApiKeyConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["apiKeyConfig"] = transformedApiKeyConfig
	}

	transformedOauthConfig, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfig(original["oauth_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauthConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauthConfig"] = transformedOauthConfig
	}

	transformedServiceAgentAuthConfig, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationServiceAgentAuthConfig(original["service_agent_auth_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAgentAuthConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAgentAuthConfig"] = transformedServiceAgentAuthConfig
	}

	transformedBearerTokenConfig, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfig(original["bearer_token_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBearerTokenConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bearerTokenConfig"] = transformedBearerTokenConfig
	}

	return transformed, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKeyName, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigKeyName(original["key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["keyName"] = transformedKeyName
	}

	transformedApiKey, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigApiKey(original["api_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApiKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["apiKey"] = transformedApiKey
	}

	transformedSecretVersionForApiKey, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigSecretVersionForApiKey(original["secret_version_for_api_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersionForApiKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersionForApiKey"] = transformedSecretVersionForApiKey
	}

	transformedRequestLocation, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigRequestLocation(original["request_location"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRequestLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["requestLocation"] = transformedRequestLocation
	}

	return transformed, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigApiKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigSecretVersionForApiKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationApiKeyConfigRequestLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOauthGrantType, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigOauthGrantType(original["oauth_grant_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauthGrantType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauthGrantType"] = transformedOauthGrantType
	}

	transformedClientId, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigClientId(original["client_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientId"] = transformedClientId
	}

	transformedClientSecret, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigClientSecret(original["client_secret"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientSecret"] = transformedClientSecret
	}

	transformedSecretVersionForClientSecret, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigSecretVersionForClientSecret(original["secret_version_for_client_secret"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersionForClientSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersionForClientSecret"] = transformedSecretVersionForClientSecret
	}

	transformedTokenEndpoint, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigTokenEndpoint(original["token_endpoint"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTokenEndpoint); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tokenEndpoint"] = transformedTokenEndpoint
	}

	transformedScopes, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigScopes(original["scopes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScopes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scopes"] = transformedScopes
	}

	return transformed, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigOauthGrantType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigClientId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigClientSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigSecretVersionForClientSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigTokenEndpoint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationOauthConfigScopes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationServiceAgentAuthConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServiceAgentAuth, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationServiceAgentAuthConfigServiceAgentAuth(original["service_agent_auth"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAgentAuth); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAgentAuth"] = transformedServiceAgentAuth
	}

	return transformed, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationServiceAgentAuthConfigServiceAgentAuth(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedToken, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfigToken(original["token"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedToken); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["token"] = transformedToken
	}

	transformedSecretVersionForToken, err := expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfigSecretVersionForToken(original["secret_version_for_token"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersionForToken); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersionForToken"] = transformedSecretVersionForToken
	}

	return transformed, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfigToken(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecAuthenticationBearerTokenConfigSecretVersionForToken(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecTlsConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCaCerts, err := expandDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCerts(original["ca_certs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCerts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCerts"] = transformedCaCerts
	}

	return transformed, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCerts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDisplayName, err := expandDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCertsDisplayName(original["display_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["displayName"] = transformedDisplayName
		}

		transformedCert, err := expandDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCertsCert(original["cert"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCert); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["cert"] = transformedCert
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCertsDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecTlsConfigCaCertsCert(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecServiceDirectoryConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedService, err := expandDialogflowCXToolVersionToolOpenApiSpecServiceDirectoryConfigService(original["service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["service"] = transformedService
	}

	return transformed, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecServiceDirectoryConfigService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolOpenApiSpecTextSchema(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolDataStoreSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDataStoreConnections, err := expandDialogflowCXToolVersionToolDataStoreSpecDataStoreConnections(original["data_store_connections"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataStoreConnections); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataStoreConnections"] = transformedDataStoreConnections
	}

	transformedFallbackPrompt, err := expandDialogflowCXToolVersionToolDataStoreSpecFallbackPrompt(original["fallback_prompt"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["fallbackPrompt"] = transformedFallbackPrompt
	}

	return transformed, nil
}

func expandDialogflowCXToolVersionToolDataStoreSpecDataStoreConnections(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDataStoreType, err := expandDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDataStoreType(original["data_store_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDataStoreType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["dataStoreType"] = transformedDataStoreType
		}

		transformedDataStore, err := expandDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDataStore(original["data_store"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDataStore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["dataStore"] = transformedDataStore
		}

		transformedDocumentProcessingMode, err := expandDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDocumentProcessingMode(original["document_processing_mode"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDocumentProcessingMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["documentProcessingMode"] = transformedDocumentProcessingMode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDataStoreType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDataStore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolDataStoreSpecDataStoreConnectionsDocumentProcessingMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDialogflowCXToolVersionToolDataStoreSpecFallbackPrompt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDialogflowCXToolVersionToolFunctionSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInputSchema, err := expandDialogflowCXToolVersionToolFunctionSpecInputSchema(original["input_schema"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInputSchema); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inputSchema"] = transformedInputSchema
	}

	transformedOutputSchema, err := expandDialogflowCXToolVersionToolFunctionSpecOutputSchema(original["output_schema"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputSchema); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputSchema"] = transformedOutputSchema
	}

	return transformed, nil
}

func expandDialogflowCXToolVersionToolFunctionSpecInputSchema(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	m := make(map[string]interface{})
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	return m, nil
}

func expandDialogflowCXToolVersionToolFunctionSpecOutputSchema(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	m := make(map[string]interface{})
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	return m, nil
}

func resourceDialogflowCXToolVersionPostCreateSetComputedFields(d *schema.ResourceData, meta interface{}, res map[string]interface{}) error {
	config := meta.(*transport_tpg.Config)
	if err := d.Set("name", flattenDialogflowCXToolVersionName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}
	return nil
}
