// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/backupdr/RestoreWorkload.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package backupdr

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/registry"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func init() {
	registry.Schema{
		Name:        "google_backup_dr_restore_workload",
		ProductName: "backupdr",
		Type:        registry.SchemaTypeResource,
		Schema:      ResourceBackupDRRestoreWorkload(),
	}.Register()
}

func ResourceBackupDRRestoreWorkload() *schema.Resource {
	return &schema.Resource{
		Create: resourceBackupDRRestoreWorkloadCreate,
		Read:   resourceBackupDRRestoreWorkloadRead,
		Delete: resourceBackupDRRestoreWorkloadDelete,

		Importer: &schema.ResourceImporter{
			State: resourceBackupDRRestoreWorkloadImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"backup_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Required. The ID of the backup to restore from.`,
			},
			"backup_vault_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Required. The ID of the backup vault.`,
			},
			"data_source_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Required. The ID of the data source.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Required. The location for the backup vault.`,
			},
			"clear_overrides_field_mask": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `Optional. A field mask used to clear server-side default values during restore.`,
			},
			"compute_instance_restore_properties": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Optional. Compute Engine instance properties to be overridden during restore.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Required. Name of the compute instance.`,
						},
						"advanced_machine_features": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Controls for advanced machine-related behavior features.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enable_nested_virtualization": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Whether to enable nested virtualization or not (default is false).`,
									},
									"enable_uefi_networking": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Whether to enable UEFI networking for instance creation.`,
									},
									"threads_per_core": {
										Type:        schema.TypeInt,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. The number of threads per physical core.`,
									},
									"visible_core_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. The number of physical cores to expose to an instance.`,
									},
								},
							},
						},
						"allocation_affinity": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Specifies the reservations that this instance can consume from.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"consume_allocation_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"TYPE_UNSPECIFIED", "NO_RESERVATION", "ANY_RESERVATION", "SPECIFIC_RESERVATION", ""}),
										Description:  ` Possible values: ["TYPE_UNSPECIFIED", "NO_RESERVATION", "ANY_RESERVATION", "SPECIFIC_RESERVATION"]`,
									},
									"key": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"values": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"can_ip_forward": {
							Type:        schema.TypeBool,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Allows this instance to send and receive packets with non-matching destination or source IPs.`,
						},
						"confidential_instance_config": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Controls Confidential compute options on the instance.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enable_confidential_compute": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Defines whether the instance should have confidential compute enabled.`,
									},
								},
							},
						},
						"deletion_protection": {
							Type:        schema.TypeBool,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Whether the resource should be protected against deletion.`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. An optional description of this resource.`,
						},
						"disks": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Array of disks associated with this instance.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auto_delete": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Specifies whether the disk will be auto-deleted when the instance is deleted.`,
									},
									"boot": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Indicates that this is a boot disk.`,
									},
									"device_name": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. This is used as an identifier for the disks.`,
									},
									"disk_encryption_key": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Encrypts or decrypts a disk using a customer-supplied encryption key.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"kms_key_name": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Optional. The name of the encryption key that is stored in Google Cloud KMS.`,
												},
												"kms_key_service_account": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Optional. The service account being used for the encryption request.`,
												},
												"raw_key": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Optional. Specifies a 256-bit customer-supplied encryption key.`,
												},
												"rsa_encrypted_key": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Optional. RSA-wrapped 2048-bit customer-supplied encryption key.`,
												},
											},
										},
									},
									"disk_interface": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"DISK_INTERFACE_UNSPECIFIED", "SCSI", "NVME", "NVDIMM", "ISCSI", ""}),
										Description:  `Optional. Specifies the disk interface to use for attaching this disk. Possible values: ["DISK_INTERFACE_UNSPECIFIED", "SCSI", "NVME", "NVDIMM", "ISCSI"]`,
									},
									"disk_size_gb": {
										Type:        schema.TypeInt,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. The size of the disk in GB.`,
									},
									"disk_type": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Output only. The URI of the disk type resource.`,
									},
									"guest_os_feature": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. A list of features to enable on the guest operating system.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"type": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"FEATURE_TYPE_UNSPECIFIED", "VIRTIO_SCSI_MULTIQUEUE", "WINDOWS", "MULTI_IP_SUBNET", "UEFI_COMPATIBLE", "SECURE_BOOT", "GVNIC", "SEV_CAPABLE", "BARE_METAL_LINUX_COMPATIBLE", "SUSPEND_RESUME_COMPATIBLE", "SEV_LIVE_MIGRATABLE", "SEV_SNP_CAPABLE", "TDX_CAPABLE", "IDPF", "SEV_LIVE_MIGRATABLE_V2", ""}),
													Description:  `Optional. The ID of a supported feature. Possible values: ["FEATURE_TYPE_UNSPECIFIED", "VIRTIO_SCSI_MULTIQUEUE", "WINDOWS", "MULTI_IP_SUBNET", "UEFI_COMPATIBLE", "SECURE_BOOT", "GVNIC", "SEV_CAPABLE", "BARE_METAL_LINUX_COMPATIBLE", "SUSPEND_RESUME_COMPATIBLE", "SEV_LIVE_MIGRATABLE", "SEV_SNP_CAPABLE", "TDX_CAPABLE", "IDPF", "SEV_LIVE_MIGRATABLE_V2"]`,
												},
											},
										},
									},
									"index": {
										Type:        schema.TypeInt,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. A zero-based index to this disk, where 0 is reserved for the boot disk.`,
									},
									"initialize_params": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Specifies the parameters to initialize this disk.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"disk_name": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Optional. Specifies the disk name.`,
												},
												"replica_zones": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Optional. URL of the zone where the disk should be created.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"kind": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Type of the resource.`,
									},
									"license": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Any valid publicly visible licenses.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"mode": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"DISK_MODE_UNSPECIFIED", "READ_WRITE", "READ_ONLY", "LOCKED", ""}),
										Description:  `Optional. The mode in which to attach this disk. Possible values: ["DISK_MODE_UNSPECIFIED", "READ_WRITE", "READ_ONLY", "LOCKED"]`,
									},
									"saved_state": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"DISK_SAVED_STATE_UNSPECIFIED", "PRESERVED", ""}),
										Description:  `Optional. Specifies the saved state of the disk. Possible values: ["DISK_SAVED_STATE_UNSPECIFIED", "PRESERVED"]`,
									},
									"source": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Specifies a valid partial or full URL to an existing Persistent Disk resource.`,
									},
									"type": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"DISK_TYPE_UNSPECIFIED", "SCRATCH", "PERSISTENT", ""}),
										Description:  `Optional. Specifies the type of the disk. Possible values: ["DISK_TYPE_UNSPECIFIED", "SCRATCH", "PERSISTENT"]`,
									},
								},
							},
						},
						"display_device": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Enables display device for the instance.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enable_display": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Enables display for the Compute Engine VM.`,
									},
								},
							},
						},
						"guest_accelerators": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. A list of the type and count of accelerator cards attached to the instance.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"accelerator_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. The number of the guest accelerator cards exposed to this instance.`,
									},
									"accelerator_type": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Full or partial URL of the accelerator type resource.`,
									},
								},
							},
						},
						"hostname": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Specifies the hostname of the instance.`,
						},
						"instance_encryption_key": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Encrypts suspended data for an instance with a customer-managed encryption key.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"kms_key_name": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"kms_key_service_account": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"raw_key": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"rsa_encrypted_key": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
								},
							},
						},
						"key_revocation_action_type": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED", "NONE", "STOP", ""}),
							Description:  `Optional. KeyRevocationActionType of the instance. Possible values: ["KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED", "NONE", "STOP"]`,
						},
						"labels": {
							Type:        schema.TypeSet,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Labels to apply to this instance.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:     schema.TypeString,
										Required: true,
										ForceNew: true,
									},
									"value": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
								},
							},
						},
						"machine_type": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Full or partial URL of the machine type resource to use for this instance.`,
						},
						"metadata": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. This includes custom metadata and predefined keys.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"items": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"key": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"value": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
											},
										},
									},
								},
							},
						},
						"min_cpu_platform": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Minimum CPU platform to use for this instance.`,
						},
						"network_interfaces": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. An array of network configurations for this instance.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"access_configs": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"external_ip": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"external_ipv6": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"external_ipv6_prefix_length": {
													Type:        schema.TypeInt,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"name": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Optional. The name of this access configuration.`,
												},
												"network_tier": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"NETWORK_TIER_UNSPECIFIED", "PREMIUM", "STANDARD", ""}),
													Description:  ` Possible values: ["NETWORK_TIER_UNSPECIFIED", "PREMIUM", "STANDARD"]`,
												},
												"public_ptr_domain_name": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"set_public_ptr": {
													Type:        schema.TypeBool,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"type": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"ACCESS_TYPE_UNSPECIFIED", "ONE_TO_ONE_NAT", "DIRECT_IPV6", ""}),
													Description:  `Optional. The type of configuration. Possible values: ["ACCESS_TYPE_UNSPECIFIED", "ONE_TO_ONE_NAT", "DIRECT_IPV6"]`,
												},
											},
										},
									},
									"alias_ip_ranges": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"ip_cidr_range": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"subnetwork_range_name": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
											},
										},
									},
									"internal_ipv6_prefix_length": {
										Type:        schema.TypeInt,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. The prefix length of the primary internal IPv6 range.`,
									},
									"ip_address": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. An IPv4 internal IP address to assign to the instance.`,
									},
									"ipv6_access_configs": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"external_ip": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"external_ipv6": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"external_ipv6_prefix_length": {
													Type:        schema.TypeInt,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"name": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Optional. The name of this access configuration.`,
												},
												"network_tier": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"NETWORK_TIER_UNSPECIFIED", "PREMIUM", "STANDARD", ""}),
													Description:  ` Possible values: ["NETWORK_TIER_UNSPECIFIED", "PREMIUM", "STANDARD"]`,
												},
												"public_ptr_domain_name": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"set_public_ptr": {
													Type:        schema.TypeBool,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"type": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"ACCESS_TYPE_UNSPECIFIED", "ONE_TO_ONE_NAT", "DIRECT_IPV6", ""}),
													Description:  `Optional. The type of configuration. Possible values: ["ACCESS_TYPE_UNSPECIFIED", "ONE_TO_ONE_NAT", "DIRECT_IPV6"]`,
												},
											},
										},
									},
									"ipv6_access_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"UNSPECIFIED_IPV6_ACCESS_TYPE", "INTERNAL", "EXTERNAL", ""}),
										Description:  ` Possible values: ["UNSPECIFIED_IPV6_ACCESS_TYPE", "INTERNAL", "EXTERNAL"]`,
									},
									"ipv6_address": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. An IPv6 internal network address for this network interface.`,
									},
									"network": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. URL of the VPC network resource for this instance.`,
									},
									"network_attachment": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"nic_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"NIC_TYPE_UNSPECIFIED", "VIRTIO_NET", "GVNIC", ""}),
										Description:  ` Possible values: ["NIC_TYPE_UNSPECIFIED", "VIRTIO_NET", "GVNIC"]`,
									},
									"queue_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"stack_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"STACK_TYPE_UNSPECIFIED", "IPV4_ONLY", "IPV4_IPV6", ""}),
										Description:  ` Possible values: ["STACK_TYPE_UNSPECIFIED", "IPV4_ONLY", "IPV4_IPV6"]`,
									},
									"subnetwork": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. The URL of the Subnetwork resource for this instance.`,
									},
								},
							},
						},
						"network_performance_config": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Configure network performance such as egress bandwidth tier.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"total_egress_bandwidth_tier": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"TIER_UNSPECIFIED", "DEFAULT", "TIER_1", ""}),
										Description:  ` Possible values: ["TIER_UNSPECIFIED", "DEFAULT", "TIER_1"]`,
									},
								},
							},
						},
						"params": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Input only. Additional params passed with the request.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"resource_manager_tags": {
										Type:        schema.TypeSet,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"key": {
													Type:     schema.TypeString,
													Required: true,
													ForceNew: true,
												},
												"value": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
											},
										},
									},
								},
							},
						},
						"private_ipv6_google_access": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED", "INHERIT_FROM_SUBNETWORK", "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE", "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE", ""}),
							Description:  `Optional. The private IPv6 google access type for the VM. Possible values: ["INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED", "INHERIT_FROM_SUBNETWORK", "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE", "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE"]`,
						},
						"resource_policies": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Resource policies applied to this instance.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"scheduling": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Sets the scheduling options for this instance.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"automatic_restart": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"instance_termination_action": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"INSTANCE_TERMINATION_ACTION_UNSPECIFIED", "DELETE", "STOP", ""}),
										Description:  ` Possible values: ["INSTANCE_TERMINATION_ACTION_UNSPECIFIED", "DELETE", "STOP"]`,
									},
									"local_ssd_recovery_timeout": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `A nested object resource.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"nanos": {
													Type:        schema.TypeInt,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"seconds": {
													Type:        schema.TypeInt,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
											},
										},
									},
									"max_run_duration": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `A nested object resource.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"nanos": {
													Type:        schema.TypeInt,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"seconds": {
													Type:        schema.TypeInt,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
											},
										},
									},
									"min_node_cpus": {
										Type:        schema.TypeInt,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"node_affinities": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"key": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
												},
												"operator": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"OPERATOR_UNSPECIFIED", "IN", "NOT_IN", ""}),
													Description:  ` Possible values: ["OPERATOR_UNSPECIFIED", "IN", "NOT_IN"]`,
												},
												"values": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: ``,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"on_host_maintenance": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"ON_HOST_MAINTENANCE_UNSPECIFIED", "TERMINATE", "MIGRATE", ""}),
										Description:  ` Possible values: ["ON_HOST_MAINTENANCE_UNSPECIFIED", "TERMINATE", "MIGRATE"]`,
									},
									"preemptible": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"provisioning_model": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"PROVISIONING_MODEL_UNSPECIFIED", "STANDARD", "SPOT", ""}),
										Description:  ` Possible values: ["PROVISIONING_MODEL_UNSPECIFIED", "STANDARD", "SPOT"]`,
									},
									"termination_time": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
								},
							},
						},
						"service_accounts": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. A list of service accounts, with their specified scopes, authorized for this instance.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"email": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"scopes": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"shielded_instance_config": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Controls Shielded compute options on the instance.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enable_integrity_monitoring": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"enable_secure_boot": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"enable_vtpm": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
								},
							},
						},
						"tags": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Tags to apply to this instance.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"items": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
					},
				},
			},
			"compute_instance_target_environment": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Optional. The destination environment for GCE VM restoration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"project": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Required. Target project for the Compute Engine instance.`,
						},
						"zone": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Required. The zone of the Compute Engine instance.`,
						},
					},
				},
			},
			"delete_restored_instance": {
				Type:     schema.TypeBool,
				Optional: true,
				ForceNew: true,
				Description: `Optional. If true (default), running terraform destroy will delete the live resource in GCP.
If false, only the restore record is removed from the state, leaving the resource active.`,
				Default: true,
			},
			"disk_restore_properties": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Optional. Disk properties to be overridden during restore.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Required. Name of the disk.`,
						},
						"size_gb": {
							Type:        schema.TypeInt,
							Required:    true,
							ForceNew:    true,
							Description: `Required. The size of the disk in GB.`,
						},
						"type": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Required. URL of the disk type resource describing which disk type to use.`,
						},
						"access_mode": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"READ_WRITE_SINGLE", "READ_WRITE_MANY", "READ_ONLY_MANY", ""}),
							Description:  `Optional. The access mode of the disk. Possible values: ["READ_WRITE_SINGLE", "READ_WRITE_MANY", "READ_ONLY_MANY"]`,
						},
						"architecture": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"ARCHITECTURE_UNSPECIFIED", "X86_64", "ARM64", ""}),
							Description:  `Optional. The architecture of the source disk. Possible values: ["ARCHITECTURE_UNSPECIFIED", "X86_64", "ARM64"]`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. An optional description of this resource.`,
						},
						"disk_encryption_key": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Encrypts the disk using a customer-supplied encryption key.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"kms_key_name": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"kms_key_service_account": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"raw_key": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
									"rsa_encrypted_key": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
								},
							},
						},
						"enable_confidential_compute": {
							Type:        schema.TypeBool,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Indicates whether this disk is using confidential compute mode.`,
						},
						"guest_os_feature": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. A list of features to enable in the guest operating system.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"type": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"FEATURE_TYPE_UNSPECIFIED", "VIRTIO_SCSI_MULTIQUEUE", "WINDOWS", "MULTI_IP_SUBNET", "UEFI_COMPATIBLE", "SECURE_BOOT", "GVNIC", "SEV_CAPABLE", "BARE_METAL_LINUX_COMPATIBLE", "SUSPEND_RESUME_COMPATIBLE", "SEV_LIVE_MIGRATABLE", "SEV_SNP_CAPABLE", "TDX_CAPABLE", "IDPF", "SEV_LIVE_MIGRATABLE_V2", ""}),
										Description:  ` Possible values: ["FEATURE_TYPE_UNSPECIFIED", "VIRTIO_SCSI_MULTIQUEUE", "WINDOWS", "MULTI_IP_SUBNET", "UEFI_COMPATIBLE", "SECURE_BOOT", "GVNIC", "SEV_CAPABLE", "BARE_METAL_LINUX_COMPATIBLE", "SUSPEND_RESUME_COMPATIBLE", "SEV_LIVE_MIGRATABLE", "SEV_SNP_CAPABLE", "TDX_CAPABLE", "IDPF", "SEV_LIVE_MIGRATABLE_V2"]`,
									},
								},
							},
						},
						"labels": {
							Type:        schema.TypeSet,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Labels to apply to this disk.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:     schema.TypeString,
										Required: true,
										ForceNew: true,
									},
									"value": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
								},
							},
						},
						"licenses": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. A list of publicly available licenses that are applicable to this backup.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"physical_block_size_bytes": {
							Type:        schema.TypeInt,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Physical block size of the persistent disk, in bytes.`,
						},
						"provisioned_iops": {
							Type:        schema.TypeInt,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Indicates how many IOPS to provision for the disk.`,
						},
						"provisioned_throughput": {
							Type:        schema.TypeInt,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Indicates how much throughput to provision for the disk.`,
						},
						"resource_manager_tags": {
							Type:        schema.TypeSet,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Resource manager tags to be bound to the disk.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:     schema.TypeString,
										Required: true,
										ForceNew: true,
									},
									"value": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: ``,
									},
								},
							},
						},
						"resource_policy": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. Resource policies applied to this disk.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"storage_pool": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. The storage pool in which the new disk is created.`,
						},
					},
				},
			},
			"disk_target_environment": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Optional. The destination environment for zonal disk restoration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"project": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Required. Target project for the disk.`,
						},
						"zone": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Required. Target zone for the disk.`,
						},
					},
				},
			},
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				Deprecated:  "`name` is deprecated and will be removed in a future major release. The backup is identified by the parameters (location, backup_vault_id, data_source_id, backup_id).",
				ForceNew:    true,
				Description: `The resource name of the backup instance.`,
			},
			"region_disk_target_environment": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Optional. The destination environment for regional disk restoration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"project": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Required. Target project for the disk.`,
						},
						"region": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Required. Target region for the disk.`,
						},
						"replica_zones": {
							Type:        schema.TypeList,
							Required:    true,
							ForceNew:    true,
							Description: `Required. Target URLs of the replica zones for the disk.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},
			"request_id": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `Optional. An optional request ID to identify requests. Specify a unique request ID
so that if you must retry your request, the server will know to ignore
the request if it has already been completed.`,
			},
			"target_resource": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. Details of the target resource created/modified as part of restore.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"gcp_resource": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Output only. Details of the native Google Cloud resource created as part of restore.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"gcp_resourcename": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Output only. Name of the Google Cloud resource.`,
									},
									"location": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Output only. Location of the resource.`,
									},
									"type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Output only. Type of the resource.`,
									},
								},
							},
						},
					},
				},
			},
		},
		UseJSONNumber: true,
	}
}

func resourceBackupDRRestoreWorkloadCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	// Helper functions for repeated patterns
	processEncryptionKey := func(ekList []interface{}) map[string]interface{} {
		if len(ekList) == 0 || ekList[0] == nil {
			return nil
		}
		ek := ekList[0].(map[string]interface{})
		ekObj := make(map[string]interface{})
		if rk, ok := ek["raw_key"]; ok && rk != "" {
			ekObj["rawKey"] = rk.(string)
		}
		if rek, ok := ek["rsa_encrypted_key"]; ok && rek != "" {
			ekObj["rsaEncryptedKey"] = rek.(string)
		}
		if kn, ok := ek["kms_key_name"]; ok && kn != "" {
			ekObj["kmsKeyName"] = kn.(string)
		}
		if ksa, ok := ek["kms_key_service_account"]; ok && ksa != "" {
			ekObj["kmsKeyServiceAccount"] = ksa.(string)
		}
		if len(ekObj) > 0 {
			return ekObj
		}
		return nil
	}

	processGuestOsFeatures := func(gofList []interface{}) []map[string]interface{} {
		if len(gofList) == 0 {
			return nil
		}
		gofArr := []map[string]interface{}{}
		for _, gof := range gofList {
			if gof == nil {
				continue
			}
			gofMap := gof.(map[string]interface{})
			gofObj := make(map[string]interface{})
			if t, ok := gofMap["type"]; ok && t != "" {
				gofObj["type"] = t.(string)
			}
			if len(gofObj) > 0 {
				gofArr = append(gofArr, gofObj)
			}
		}
		if len(gofArr) > 0 {
			return gofArr
		}
		return nil
	}

	processLabels := func(val interface{}) map[string]string {
		labels := make(map[string]string)
		if labelMap, isMap := val.(map[string]interface{}); isMap {
			for k, v := range labelMap {
				if vStr, ok := v.(string); ok {
					labels[k] = vStr
				}
			}
		}
		if len(labels) > 0 {
			return labels
		}
		return nil
	}

	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RestoreWorkload: %s", err)
	}
	billingProject := project

	obj := make(map[string]interface{})

	// ==================== Top-Level Request Fields ====================
	if v, ok := d.GetOk("request_id"); ok && v.(string) != "" {
		obj["requestId"] = v.(string)
	}
	if v, ok := d.GetOk("clear_overrides_field_mask"); ok && v.(string) != "" {
		obj["clearOverridesFieldMask"] = v.(string)
	}

	// ==================== Target Environments ====================
	if v, ok := d.GetOkExists("compute_instance_target_environment"); ok {
		list := v.([]interface{})
		if len(list) > 0 {
			m := list[0].(map[string]interface{})
			env := make(map[string]interface{})
			if val, ok := m["project"]; ok {
				env["project"] = val.(string)
			}
			if val, ok := m["zone"]; ok {
				env["zone"] = val.(string)
			}
			if len(env) > 0 {
				obj["computeInstanceTargetEnvironment"] = env
			}
		}
	}

	// Disk target environment block
	if v, ok := d.GetOkExists("disk_target_environment"); ok {
		list := v.([]interface{})
		if len(list) > 0 {
			m := list[0].(map[string]interface{})
			env := make(map[string]interface{})
			if val, ok := m["project"]; ok {
				env["project"] = val.(string)
			}
			if val, ok := m["zone"]; ok {
				env["zone"] = val.(string)
			}
			if len(env) > 0 {
				obj["diskTargetEnvironment"] = env
			}
		}
	}

	// Region disk target environment block
	if v, ok := d.GetOkExists("region_disk_target_environment"); ok {
		list := v.([]interface{})
		if len(list) > 0 {
			m := list[0].(map[string]interface{})
			env := make(map[string]interface{})
			if val, ok := m["project"]; ok {
				env["project"] = val.(string)
			}
			if val, ok := m["region"]; ok {
				env["region"] = val.(string)
			}
			if zones, ok := m["replica_zones"]; ok {
				env["replicaZones"] = zones
			}
			if len(env) > 0 {
				obj["regionDiskTargetEnvironment"] = env
			}
		}
	}

	// ==================== Compute Instance Restore Properties ====================
	if v, ok := d.GetOkExists("compute_instance_restore_properties"); ok {
		list := v.([]interface{})
		if len(list) > 0 {
			m := list[0].(map[string]interface{})
			props := make(map[string]interface{})

			// --- Basic Properties ---
			if val, ok := m["name"]; ok && val != "" {
				props["name"] = val.(string)
			}
			if val, ok := m["description"]; ok && val != "" {
				props["description"] = val.(string)
			}
			if val, ok := m["hostname"]; ok && val != "" {
				props["hostname"] = val.(string)
			}
			if val, ok := m["machine_type"]; ok && val != "" {
				props["machineType"] = val.(string)
			}
			if val, ok := m["min_cpu_platform"]; ok && val != "" {
				props["minCpuPlatform"] = val.(string)
			}

			// --- Boolean Flags ---
			if val, ok := m["can_ip_forward"]; ok {
				props["canIpForward"] = val.(bool)
			}
			if val, ok := m["deletion_protection"]; ok {
				props["deletionProtection"] = val.(bool)
			}

			// --- Enum Properties ---
			if val, ok := m["private_ipv6_google_access"]; ok && val != "" {
				props["privateIpv6GoogleAccess"] = val.(string)
			}
			if val, ok := m["key_revocation_action_type"]; ok && val != "" {
				props["keyRevocationActionType"] = val.(string)
			}

			// --- Advanced Machine Features ---
			if val, ok := m["advanced_machine_features"]; ok && len(val.([]interface{})) > 0 {
				amfList := val.([]interface{})
				if amfList[0] != nil {
					amf := amfList[0].(map[string]interface{})
					amfObj := make(map[string]interface{})
					if v, ok := amf["enable_nested_virtualization"]; ok {
						amfObj["enableNestedVirtualization"] = v.(bool)
					}
					if v, ok := amf["threads_per_core"]; ok && v.(int) > 0 {
						amfObj["threadsPerCore"] = v.(int)
					}
					if v, ok := amf["visible_core_count"]; ok && v.(int) > 0 {
						amfObj["visibleCoreCount"] = v.(int)
					}
					if v, ok := amf["enable_uefi_networking"]; ok {
						amfObj["enableUefiNetworking"] = v.(bool)
					}
					if len(amfObj) > 0 {
						props["advancedMachineFeatures"] = amfObj
					}
				}
			}

			// --- Confidential Instance Config ---
			if val, ok := m["confidential_instance_config"]; ok && len(val.([]interface{})) > 0 {
				cicList := val.([]interface{})
				if cicList[0] != nil {
					cic := cicList[0].(map[string]interface{})
					cicObj := make(map[string]interface{})
					if v, ok := cic["enable_confidential_compute"]; ok {
						cicObj["enableConfidentialCompute"] = v.(bool)
					}
					if len(cicObj) > 0 {
						props["confidentialInstanceConfig"] = cicObj
					}
				}
			}

			// --- Disks Configuration ---
			if val, ok := m["disks"]; ok && len(val.([]interface{})) > 0 {
				disksList := val.([]interface{})
				disks := []map[string]interface{}{}
				for _, disk := range disksList {
					if disk == nil {
						continue
					}
					diskMap := disk.(map[string]interface{})
					diskObj := make(map[string]interface{})

					if v, ok := diskMap["device_name"]; ok && v != "" {
						diskObj["deviceName"] = v.(string)
					}
					if v, ok := diskMap["kind"]; ok && v != "" {
						diskObj["kind"] = v.(string)
					}
					if v, ok := diskMap["mode"]; ok && v != "" {
						diskObj["mode"] = v.(string)
					}
					if v, ok := diskMap["source"]; ok && v != "" {
						diskObj["source"] = v.(string)
					}
					if v, ok := diskMap["index"]; ok {
						diskObj["index"] = v.(int)
					}
					if v, ok := diskMap["boot"]; ok {
						diskObj["boot"] = v.(bool)
					}
					if v, ok := diskMap["auto_delete"]; ok {
						diskObj["autoDelete"] = v.(bool)
					}
					if v, ok := diskMap["license"]; ok && len(v.([]interface{})) > 0 {
						diskObj["license"] = v.([]interface{})
					}
					if v, ok := diskMap["disk_interface"]; ok && v != "" {
						diskObj["diskInterface"] = v.(string)
					}
					if v, ok := diskMap["disk_size_gb"]; ok && v.(int) > 0 {
						diskObj["diskSizeGb"] = v.(int)
					}
					if v, ok := diskMap["saved_state"]; ok && v != "" {
						diskObj["savedState"] = v.(string)
					}
					if v, ok := diskMap["disk_type"]; ok && v != "" {
						diskObj["diskType"] = v.(string)
					}
					if v, ok := diskMap["type"]; ok && v != "" {
						diskObj["type"] = v.(string)
					}

					// Initialize params
					if v, ok := diskMap["initialize_params"]; ok && len(v.([]interface{})) > 0 {
						ipList := v.([]interface{})
						if ipList[0] != nil {
							ip := ipList[0].(map[string]interface{})
							ipObj := make(map[string]interface{})
							if dn, ok := ip["disk_name"]; ok && dn != "" {
								ipObj["diskName"] = dn.(string)
							}
							if rz, ok := ip["replica_zones"]; ok && len(rz.([]interface{})) > 0 {
								ipObj["replicaZones"] = rz.([]interface{})
							}
							if len(ipObj) > 0 {
								diskObj["initializeParams"] = ipObj
							}
						}
					}

					// Guest OS features
					if v, ok := diskMap["guest_os_feature"]; ok && len(v.([]interface{})) > 0 {
						if gofArr := processGuestOsFeatures(v.([]interface{})); gofArr != nil {
							diskObj["guestOsFeature"] = gofArr
						}
					}

					// Disk encryption key
					if v, ok := diskMap["disk_encryption_key"]; ok && len(v.([]interface{})) > 0 {
						if dekObj := processEncryptionKey(v.([]interface{})); dekObj != nil {
							diskObj["diskEncryptionKey"] = dekObj
						}
					}

					if len(diskObj) > 0 {
						disks = append(disks, diskObj)
					}
				}
				if len(disks) > 0 {
					props["disks"] = disks
				}
			}

			// --- Display & Accelerators ---
			// Display device
			if val, ok := m["display_device"]; ok && len(val.([]interface{})) > 0 {
				ddList := val.([]interface{})
				if ddList[0] != nil {
					dd := ddList[0].(map[string]interface{})
					ddObj := make(map[string]interface{})
					if v, ok := dd["enable_display"]; ok {
						ddObj["enableDisplay"] = v.(bool)
					}
					if len(ddObj) > 0 {
						props["displayDevice"] = ddObj
					}
				}
			}

			// Guest accelerators
			if val, ok := m["guest_accelerators"]; ok && len(val.([]interface{})) > 0 {
				gaList := val.([]interface{})
				gaArr := []map[string]interface{}{}
				for _, ga := range gaList {
					if ga == nil {
						continue
					}
					gaMap := ga.(map[string]interface{})
					gaObj := make(map[string]interface{})
					if at, ok := gaMap["accelerator_type"]; ok && at != "" {
						gaObj["acceleratorType"] = at.(string)
					}
					if ac, ok := gaMap["accelerator_count"]; ok {
						gaObj["acceleratorCount"] = ac.(int)
					}
					if len(gaObj) > 0 {
						gaArr = append(gaArr, gaObj)
					}
				}
				if len(gaArr) > 0 {
					props["guestAccelerators"] = gaArr
				}
			}

			// --- Security & Encryption ---
			// Instance encryption key
			if val, ok := m["instance_encryption_key"]; ok && len(val.([]interface{})) > 0 {
				if iekObj := processEncryptionKey(val.([]interface{})); iekObj != nil {
					props["instanceEncryptionKey"] = iekObj
				}
			}

			// --- Metadata & Labels ---
			// Labels
			if val, ok := m["labels"]; ok {
				if labels := processLabels(val); labels != nil {
					props["labels"] = labels
				}
			}

			// Metadata
			if val, ok := m["metadata"]; ok && len(val.([]interface{})) > 0 {
				mdList := val.([]interface{})
				if mdList[0] != nil {
					md := mdList[0].(map[string]interface{})
					mdObj := make(map[string]interface{})
					if items, ok := md["items"]; ok && len(items.([]interface{})) > 0 {
						itemsList := items.([]interface{})
						itemsArr := []map[string]interface{}{}
						for _, item := range itemsList {
							if item == nil {
								continue
							}
							itemMap := item.(map[string]interface{})
							itemObj := make(map[string]interface{})
							if k, ok := itemMap["key"]; ok && k != "" {
								itemObj["key"] = k.(string)
							}
							if v, ok := itemMap["value"]; ok && v != "" {
								itemObj["value"] = v.(string)
							}
							if len(itemObj) > 0 {
								itemsArr = append(itemsArr, itemObj)
							}
						}
						if len(itemsArr) > 0 {
							mdObj["items"] = itemsArr
						}
					}
					if len(mdObj) > 0 {
						props["metadata"] = mdObj
					}
				}
			}

			// --- Networking ---
			// Network interfaces
			if val, ok := m["network_interfaces"]; ok && len(val.([]interface{})) > 0 {
				niList := val.([]interface{})
				niArr := []map[string]interface{}{}
				for _, ni := range niList {
					if ni == nil {
						continue
					}
					niMap := ni.(map[string]interface{})
					niObj := make(map[string]interface{})

					if v, ok := niMap["network"]; ok && v != "" {
						niObj["network"] = v.(string)
					}
					if v, ok := niMap["subnetwork"]; ok && v != "" {
						niObj["subnetwork"] = v.(string)
					}
					if v, ok := niMap["ip_address"]; ok && v != "" {
						niObj["ipAddress"] = v.(string)
					}
					if v, ok := niMap["ipv6_address"]; ok && v != "" {
						niObj["ipv6Address"] = v.(string)
					}
					if v, ok := niMap["internal_ipv6_prefix_length"]; ok && v.(int) > 0 {
						niObj["internalIpv6PrefixLength"] = v.(int)
					}
					if v, ok := niMap["stack_type"]; ok && v != "" {
						niObj["stackType"] = v.(string)
					}
					if v, ok := niMap["ipv6_access_type"]; ok && v != "" {
						niObj["ipv6AccessType"] = v.(string)
					}
					if v, ok := niMap["queue_count"]; ok && v.(int) > 0 {
						niObj["queueCount"] = v.(int)
					}
					if v, ok := niMap["nic_type"]; ok && v != "" {
						niObj["nicType"] = v.(string)
					}
					if v, ok := niMap["network_attachment"]; ok && v != "" {
						niObj["networkAttachment"] = v.(string)
					}

					// Access configs
					if ac, ok := niMap["access_configs"]; ok && len(ac.([]interface{})) > 0 {
						acList := ac.([]interface{})
						acArr := []map[string]interface{}{}
						for _, acItem := range acList {
							if acItem == nil {
								continue
							}
							acMap := acItem.(map[string]interface{})
							acObj := make(map[string]interface{})
							if t, ok := acMap["type"]; ok && t != "" {
								acObj["type"] = t.(string)
							}
							if n, ok := acMap["name"]; ok && n != "" {
								acObj["name"] = n.(string)
							}
							if ei, ok := acMap["external_ip"]; ok && ei != "" {
								acObj["externalIp"] = ei.(string)
							}
							if eiv6, ok := acMap["external_ipv6"]; ok && eiv6 != "" {
								acObj["externalIpv6"] = eiv6.(string)
							}
							if eiv6pl, ok := acMap["external_ipv6_prefix_length"]; ok && eiv6pl.(int) > 0 {
								acObj["externalIpv6PrefixLength"] = eiv6pl.(int)
							}
							if spp, ok := acMap["set_public_ptr"]; ok {
								acObj["setPublicPtr"] = spp.(bool)
							}
							if ppdn, ok := acMap["public_ptr_domain_name"]; ok && ppdn != "" {
								acObj["publicPtrDomainName"] = ppdn.(string)
							}
							if nt, ok := acMap["network_tier"]; ok && nt != "" {
								acObj["networkTier"] = nt.(string)
							}
							if len(acObj) > 0 {
								acArr = append(acArr, acObj)
							}
						}
						if len(acArr) > 0 {
							niObj["accessConfigs"] = acArr
						}
					}

					// IPv6 access configs
					if iac, ok := niMap["ipv6_access_configs"]; ok && len(iac.([]interface{})) > 0 {
						iacList := iac.([]interface{})
						iacArr := []map[string]interface{}{}
						for _, iacItem := range iacList {
							if iacItem == nil {
								continue
							}
							iacMap := iacItem.(map[string]interface{})
							iacObj := make(map[string]interface{})
							if t, ok := iacMap["type"]; ok && t != "" {
								iacObj["type"] = t.(string)
							}
							if n, ok := iacMap["name"]; ok && n != "" {
								iacObj["name"] = n.(string)
							}
							if ei, ok := iacMap["external_ip"]; ok && ei != "" {
								iacObj["externalIp"] = ei.(string)
							}
							if eiv6, ok := iacMap["external_ipv6"]; ok && eiv6 != "" {
								iacObj["externalIpv6"] = eiv6.(string)
							}
							if eiv6pl, ok := iacMap["external_ipv6_prefix_length"]; ok && eiv6pl.(int) > 0 {
								iacObj["externalIpv6PrefixLength"] = eiv6pl.(int)
							}
							if spp, ok := iacMap["set_public_ptr"]; ok {
								iacObj["setPublicPtr"] = spp.(bool)
							}
							if ppdn, ok := iacMap["public_ptr_domain_name"]; ok && ppdn != "" {
								iacObj["publicPtrDomainName"] = ppdn.(string)
							}
							if nt, ok := iacMap["network_tier"]; ok && nt != "" {
								iacObj["networkTier"] = nt.(string)
							}
							if len(iacObj) > 0 {
								iacArr = append(iacArr, iacObj)
							}
						}
						if len(iacArr) > 0 {
							niObj["ipv6AccessConfigs"] = iacArr
						}
					}

					// Alias IP ranges
					if air, ok := niMap["alias_ip_ranges"]; ok && len(air.([]interface{})) > 0 {
						airList := air.([]interface{})
						airArr := []map[string]interface{}{}
						for _, airItem := range airList {
							if airItem == nil {
								continue
							}
							airMap := airItem.(map[string]interface{})
							airObj := make(map[string]interface{})
							if icr, ok := airMap["ip_cidr_range"]; ok && icr != "" {
								airObj["ipCidrRange"] = icr.(string)
							}
							if srn, ok := airMap["subnetwork_range_name"]; ok && srn != "" {
								airObj["subnetworkRangeName"] = srn.(string)
							}
							if len(airObj) > 0 {
								airArr = append(airArr, airObj)
							}
						}
						if len(airArr) > 0 {
							niObj["aliasIpRanges"] = airArr
						}
					}

					if len(niObj) > 0 {
						niArr = append(niArr, niObj)
					}
				}
				if len(niArr) > 0 {
					props["networkInterfaces"] = niArr
				}
			}

			// Network performance config
			if val, ok := m["network_performance_config"]; ok && len(val.([]interface{})) > 0 {
				npcList := val.([]interface{})
				if npcList[0] != nil {
					npc := npcList[0].(map[string]interface{})
					npcObj := make(map[string]interface{})
					if tebt, ok := npc["total_egress_bandwidth_tier"]; ok && tebt != "" {
						npcObj["totalEgressBandwidthTier"] = tebt.(string)
					}
					if len(npcObj) > 0 {
						props["networkPerformanceConfig"] = npcObj
					}
				}
			}

			// --- Resource Management ---
			// Params
			if val, ok := m["params"]; ok && len(val.([]interface{})) > 0 {
				pList := val.([]interface{})
				if pList[0] != nil {
					p := pList[0].(map[string]interface{})
					pObj := make(map[string]interface{})
					if rmt, ok := p["resource_manager_tags"]; ok {
						rmtMap := make(map[string]string)
						if rmtMapVal, isMap := rmt.(map[string]interface{}); isMap {
							for k, v := range rmtMapVal {
								if vStr, ok := v.(string); ok {
									rmtMap[k] = vStr
								}
							}
						}
						if len(rmtMap) > 0 {
							pObj["resourceManagerTags"] = rmtMap
						}
					}
					if len(pObj) > 0 {
						props["params"] = pObj
					}
				}
			}

			// Allocation affinity
			if val, ok := m["allocation_affinity"]; ok && len(val.([]interface{})) > 0 {
				aaList := val.([]interface{})
				if aaList[0] != nil {
					aa := aaList[0].(map[string]interface{})
					aaObj := make(map[string]interface{})
					if cat, ok := aa["consume_allocation_type"]; ok && cat != "" {
						aaObj["consumeAllocationType"] = cat.(string)
					}
					if k, ok := aa["key"]; ok && k != "" {
						aaObj["key"] = k.(string)
					}
					if v, ok := aa["values"]; ok && len(v.([]interface{})) > 0 {
						aaObj["values"] = v.([]interface{})
					}
					if len(aaObj) > 0 {
						props["allocationAffinity"] = aaObj
					}
				}
			}

			// Resource policies
			if val, ok := m["resource_policies"]; ok && len(val.([]interface{})) > 0 {
				props["resourcePolicies"] = val.([]interface{})
			}

			// Scheduling
			if val, ok := m["scheduling"]; ok && len(val.([]interface{})) > 0 {
				schedList := val.([]interface{})
				if schedList[0] != nil {
					sched := schedList[0].(map[string]interface{})
					schedObj := make(map[string]interface{})

					if ohm, ok := sched["on_host_maintenance"]; ok && ohm != "" {
						schedObj["onHostMaintenance"] = ohm.(string)
					}
					if ar, ok := sched["automatic_restart"]; ok {
						schedObj["automaticRestart"] = ar.(bool)
					}
					if p, ok := sched["preemptible"]; ok {
						schedObj["preemptible"] = p.(bool)
					}
					if mnc, ok := sched["min_node_cpus"]; ok && mnc.(int) > 0 {
						schedObj["minNodeCpus"] = mnc.(int)
					}
					if pm, ok := sched["provisioning_model"]; ok && pm != "" {
						schedObj["provisioningModel"] = pm.(string)
					}
					if ita, ok := sched["instance_termination_action"]; ok && ita != "" {
						schedObj["instanceTerminationAction"] = ita.(string)
					}
					if tt, ok := sched["termination_time"]; ok && tt != "" {
						schedObj["terminationTime"] = tt.(string)
					}

					// Node affinities
					if na, ok := sched["node_affinities"]; ok && len(na.([]interface{})) > 0 {
						naList := na.([]interface{})
						naArr := []map[string]interface{}{}
						for _, naItem := range naList {
							if naItem == nil {
								continue
							}
							naMap := naItem.(map[string]interface{})
							naObj := make(map[string]interface{})
							if k, ok := naMap["key"]; ok && k != "" {
								naObj["key"] = k.(string)
							}
							if op, ok := naMap["operator"]; ok && op != "" {
								naObj["operator"] = op.(string)
							}
							if v, ok := naMap["values"]; ok && len(v.([]interface{})) > 0 {
								naObj["values"] = v.([]interface{})
							}
							if len(naObj) > 0 {
								naArr = append(naArr, naObj)
							}
						}
						if len(naArr) > 0 {
							schedObj["nodeAffinities"] = naArr
						}
					}

					// Local SSD recovery timeout
					if lsrt, ok := sched["local_ssd_recovery_timeout"]; ok && len(lsrt.([]interface{})) > 0 {
						lsrtList := lsrt.([]interface{})
						if lsrtList[0] != nil {
							lsrtMap := lsrtList[0].(map[string]interface{})
							lsrtObj := make(map[string]interface{})
							if s, ok := lsrtMap["seconds"]; ok && s.(int) > 0 {
								lsrtObj["seconds"] = s.(int)
							}
							if n, ok := lsrtMap["nanos"]; ok && n.(int) > 0 {
								lsrtObj["nanos"] = n.(int)
							}
							if len(lsrtObj) > 0 {
								schedObj["localSsdRecoveryTimeout"] = lsrtObj
							}
						}
					}

					// Max run duration
					if mrd, ok := sched["max_run_duration"]; ok && len(mrd.([]interface{})) > 0 {
						mrdList := mrd.([]interface{})
						if mrdList[0] != nil {
							mrdMap := mrdList[0].(map[string]interface{})
							mrdObj := make(map[string]interface{})
							if s, ok := mrdMap["seconds"]; ok && s.(int) > 0 {
								mrdObj["seconds"] = s.(int)
							}
							if n, ok := mrdMap["nanos"]; ok && n.(int) > 0 {
								mrdObj["nanos"] = n.(int)
							}
							if len(mrdObj) > 0 {
								schedObj["maxRunDuration"] = mrdObj
							}
						}
					}

					if len(schedObj) > 0 {
						props["scheduling"] = schedObj
					}
				}
			}

			// Service accounts
			if val, ok := m["service_accounts"]; ok && len(val.([]interface{})) > 0 {
				saList := val.([]interface{})
				saArr := []map[string]interface{}{}
				for _, sa := range saList {
					if sa == nil {
						continue
					}
					saMap := sa.(map[string]interface{})
					saObj := make(map[string]interface{})
					if email, ok := saMap["email"]; ok && email != "" {
						saObj["email"] = email.(string)
					}
					if scopes, ok := saMap["scopes"]; ok && len(scopes.([]interface{})) > 0 {
						saObj["scopes"] = scopes.([]interface{})
					}
					if len(saObj) > 0 {
						saArr = append(saArr, saObj)
					}
				}
				if len(saArr) > 0 {
					props["serviceAccounts"] = saArr
				}
			}

			// Shielded instance config
			if val, ok := m["shielded_instance_config"]; ok && len(val.([]interface{})) > 0 {
				sicList := val.([]interface{})
				if sicList[0] != nil {
					sic := sicList[0].(map[string]interface{})
					sicObj := make(map[string]interface{})
					if esb, ok := sic["enable_secure_boot"]; ok {
						sicObj["enableSecureBoot"] = esb.(bool)
					}
					if ev, ok := sic["enable_vtpm"]; ok {
						sicObj["enableVtpm"] = ev.(bool)
					}
					if eim, ok := sic["enable_integrity_monitoring"]; ok {
						sicObj["enableIntegrityMonitoring"] = eim.(bool)
					}
					if len(sicObj) > 0 {
						props["shieldedInstanceConfig"] = sicObj
					}
				}
			}

			// Tags
			if val, ok := m["tags"]; ok && len(val.([]interface{})) > 0 {
				tagsList := val.([]interface{})
				if tagsList[0] != nil {
					tags := tagsList[0].(map[string]interface{})
					tagsObj := make(map[string]interface{})
					if items, ok := tags["items"]; ok && len(items.([]interface{})) > 0 {
						tagsObj["items"] = items.([]interface{})
					}
					if len(tagsObj) > 0 {
						props["tags"] = tagsObj
					}
				}
			}

			if len(props) > 0 {
				obj["computeInstanceRestoreProperties"] = props
			}
		}
	}

	// ==================== Disk Restore Properties ====================
	if v, ok := d.GetOkExists("disk_restore_properties"); ok {
		list := v.([]interface{})
		if len(list) > 0 {
			m := list[0].(map[string]interface{})
			props := make(map[string]interface{})

			// Required fields
			if val, ok := m["name"]; ok && val != "" {
				props["name"] = val.(string)
			}
			if val, ok := m["size_gb"]; ok && val.(int) > 0 {
				props["sizeGb"] = val.(int)
			}
			if val, ok := m["type"]; ok && val != "" {
				props["type"] = val.(string)
			}

			// Optional string fields
			if val, ok := m["description"]; ok && val != "" {
				props["description"] = val.(string)
			}
			if val, ok := m["storage_pool"]; ok && val != "" {
				props["storagePool"] = val.(string)
			}
			if val, ok := m["access_mode"]; ok && val != "" {
				props["accessMode"] = val.(string)
			}
			if val, ok := m["architecture"]; ok && val != "" {
				props["architecture"] = val.(string)
			}

			// Boolean fields
			if val, ok := m["enable_confidential_compute"]; ok {
				props["enableConfidentialCompute"] = val.(bool)
			}

			// Integer fields
			if val, ok := m["provisioned_iops"]; ok && val.(int) > 0 {
				props["provisionedIops"] = val.(int)
			}
			if val, ok := m["provisioned_throughput"]; ok && val.(int) > 0 {
				props["provisionedThroughput"] = val.(int)
			}
			if val, ok := m["physical_block_size_bytes"]; ok && val.(int) > 0 {
				props["physicalBlockSizeBytes"] = val.(int)
			}

			// Array fields
			if val, ok := m["licenses"]; ok && len(val.([]interface{})) > 0 {
				props["licenses"] = val.([]interface{})
			}
			if val, ok := m["resource_policy"]; ok && len(val.([]interface{})) > 0 {
				props["resourcePolicy"] = val.([]interface{})
			}

			// Guest OS features
			if val, ok := m["guest_os_feature"]; ok && len(val.([]interface{})) > 0 {
				if gofArr := processGuestOsFeatures(val.([]interface{})); gofArr != nil {
					props["guestOsFeature"] = gofArr
				}
			}

			// Disk encryption key
			if val, ok := m["disk_encryption_key"]; ok && len(val.([]interface{})) > 0 {
				if dekObj := processEncryptionKey(val.([]interface{})); dekObj != nil {
					props["diskEncryptionKey"] = dekObj
				}
			}

			// Labels
			if val, ok := m["labels"]; ok {
				if labels := processLabels(val); labels != nil {
					props["labels"] = labels
				}
			}

			// Resource manager tags
			if val, ok := m["resource_manager_tags"]; ok {
				if rmtMap := processLabels(val); rmtMap != nil {
					props["resourceManagerTags"] = rmtMap
				}
			}

			if len(props) > 0 {
				obj["diskRestoreProperties"] = props
			}
		}
	}

	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// ==================== Build Restore URL & Execute Request ====================
	// Construct the restore URL using base path and url params
	url := fmt.Sprintf("%sprojects/%s/locations/%s/backupVaults/%s/dataSources/%s/backups/%s:restore",
		config.BackupDRBasePath,
		project,
		d.Get("location").(string),
		d.Get("backup_vault_id").(string),
		d.Get("data_source_id").(string),
		d.Get("backup_id").(string),
	)

	log.Printf("[DEBUG] Creating RestoreWorkload (restore): %#v", obj)

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating RestoreWorkload (restore): %s", err)
	}

	// Wait for the LRO to complete and provide the operation response in opRes
	var opRes map[string]interface{}
	err = BackupDROperationWaitTimeWithResponse(
		config, res, &opRes, billingProject, "Restoring Workload", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// Attempt to cancel the LRO if the op self link is present
		opSelfLink, ok := res["selfLink"].(string)
		if ok {
			log.Printf("[DEBUG] Cancelling LRO: %s", opSelfLink)
			opCancelUrl := fmt.Sprintf("%s/cancel", opSelfLink)
			_, opCancelErr := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
				Config:    config,
				Method:    "POST",
				RawURL:    opCancelUrl,
				UserAgent: userAgent,
			})
			if opCancelErr != nil {
				return fmt.Errorf("Error cancelling the LRO: %s", opCancelErr)
			}
		}
		return err
	}

	// ==================== Process Response & Set State ====================
	// Use the gcp resource name from the operation response as the resource ID
	if opRes != nil {
		var tr map[string]interface{}
		if v, ok := opRes["targetResource"].(map[string]interface{}); ok {
			tr = v
		} else if v, ok := opRes["target_resource"].(map[string]interface{}); ok {
			tr = v
		}

		if tr != nil {
			var gr map[string]interface{}
			if v, ok := tr["gcpResource"].(map[string]interface{}); ok {
				gr = v
			} else if v, ok := tr["gcp_resource"].(map[string]interface{}); ok {
				gr = v
			}

			if gr != nil {
				// Set ID from response
				if val, ok := gr["gcpResourcename"].(string); ok {
					d.SetId(val)
				} else if val, ok := gr["gcp_resourcename"].(string); ok {
					d.SetId(val)
				}

				// Populate computed fields
				g := make(map[string]interface{})
				if val, ok := gr["gcpResourcename"].(string); ok {
					g["gcp_resourcename"] = val
				} else if val, ok := gr["gcp_resourcename"].(string); ok {
					g["gcp_resourcename"] = val
				}
				if val, ok := gr["location"].(string); ok {
					g["location"] = val
				}
				if val, ok := gr["type"].(string); ok {
					g["type"] = val
				}

				if len(g) > 0 {
					trMap := map[string]interface{}{
						"gcp_resource": []interface{}{g},
					}
					if err := d.Set("target_resource", []interface{}{trMap}); err != nil {
						return fmt.Errorf("Error setting target_resource from operation response: %s", err)
					}
				}
			}
		}
	}

	log.Printf("[DEBUG] Finished restoring RestoreWorkload %q: %#v", d.Id(), opRes)

	return nil
}

func resourceBackupDRRestoreWorkloadRead(d *schema.ResourceData, meta interface{}) error {
	// This resource could not be read from the API.
	return nil
}

func resourceBackupDRRestoreWorkloadDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RestoreWorkload: %s", err)
	}
	billingProject := project

	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	deleteInstance := true
	if v, ok := d.GetOkExists("delete_restored_instance"); ok {
		deleteInstance = v.(bool)
	}

	// If the caller asked us to keep the restored resource, exit immediately and only clear state.
	if !deleteInstance {
		log.Printf("[DEBUG] Skipping deletion of restored resource (deleteRestoredInstance=%v)", deleteInstance)
		d.SetId("")
		return nil
	}

	// If deleteRestoredInstance is true, delete the actual restored resource from GCP
	if deleteInstance {
		// Get the gcp_resourcename from target_resource
		var resourceId string
		if v, ok := d.GetOk("target_resource"); ok {
			targetResourceList := v.([]interface{})
			if len(targetResourceList) > 0 {
				targetResourceMap := targetResourceList[0].(map[string]interface{})
				if gcpResourceList, ok := targetResourceMap["gcp_resource"].([]interface{}); ok && len(gcpResourceList) > 0 {
					gcpResourceMap := gcpResourceList[0].(map[string]interface{})
					if gcpResourceName, ok := gcpResourceMap["gcp_resourcename"].(string); ok {
						resourceId = gcpResourceName
					}
				}
			}
		}

		if resourceId != "" {
			log.Printf("[DEBUG] Deleting restored resource: %s", resourceId)

			// Parse the resource ID to determine the resource type
			// For compute instances: projects/PROJECT/zones/ZONE/instances/INSTANCE_NAME
			if strings.Contains(resourceId, "/instances/") {
				// This is a Compute Engine instance - delete it
				deleteUrl := fmt.Sprintf("https://compute.googleapis.com/compute/v1/%s", resourceId)

				opRes, deleteErr := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
					Config:    config,
					Method:    "DELETE",
					Project:   billingProject,
					RawURL:    deleteUrl,
					UserAgent: userAgent,
					Timeout:   d.Timeout(schema.TimeoutDelete),
					Headers:   make(http.Header),
				})

				if deleteErr != nil {
					log.Printf("[WARN] Error deleting restored instance %s: %v", resourceId, deleteErr)
				} else if opRes != nil {
					// Wait for the compute LRO to finish by polling the operation
					if opName, ok := opRes["name"].(string); ok && opName != "" {
						// Simple polling loop
						timeout := d.Timeout(schema.TimeoutDelete)
						pollStart := time.Now()
						for {
							if time.Since(pollStart) > timeout {
								log.Printf("[WARN] Timeout waiting for delete operation %s", opName)
								break
							}

							// Get operation status
							opUrl := fmt.Sprintf("https://compute.googleapis.com/compute/v1/projects/%s/global/operations/%s", billingProject, opName)
							pollRes, pollErr := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
								Config:    config,
								Method:    "GET",
								Project:   billingProject,
								RawURL:    opUrl,
								UserAgent: userAgent,
								Timeout:   timeout,
								Headers:   make(http.Header),
							})

							if pollErr != nil {
								log.Printf("[WARN] Error polling operation status: %v", pollErr)
								break
							}

							if status, ok := pollRes["status"].(string); ok && status == "DONE" {
								log.Printf("[DEBUG] Delete operation %s completed", opName)
								break
							}

							time.Sleep(time.Second)
						}
					}
				}
			} else if strings.Contains(resourceId, "/disks/") {
				// This is a Compute Engine disk - delete it
				deleteUrl := fmt.Sprintf("https://compute.googleapis.com/compute/v1/%s", resourceId)

				deleteOpRes, deleteErr := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
					Config:    config,
					Method:    "DELETE",
					Project:   billingProject,
					RawURL:    deleteUrl,
					UserAgent: userAgent,
					Timeout:   d.Timeout(schema.TimeoutDelete),
					Headers:   make(http.Header),
				})

				if deleteErr != nil {
					log.Printf("[WARN] Error deleting restored disk %s: %v", resourceId, deleteErr)
				} else if deleteOpRes != nil {
					// Wait for the compute LRO to finish by polling the operation
					if opName, ok := deleteOpRes["name"].(string); ok && opName != "" {
						// Simple polling loop
						timeout := d.Timeout(schema.TimeoutDelete)
						pollStart := time.Now()
						for {
							if time.Since(pollStart) > timeout {
								log.Printf("[WARN] Timeout waiting for delete operation %s", opName)
								break
							}

							// Get operation status
							opUrl := fmt.Sprintf("https://compute.googleapis.com/compute/v1/projects/%s/global/operations/%s", billingProject, opName)
							pollRes, pollErr := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
								Config:    config,
								Method:    "GET",
								Project:   billingProject,
								RawURL:    opUrl,
								UserAgent: userAgent,
								Timeout:   timeout,
								Headers:   make(http.Header),
							})

							if pollErr != nil {
								log.Printf("[WARN] Error polling operation status: %v", pollErr)
								break
							}

							if status, ok := pollRes["status"].(string); ok && status == "DONE" {
								log.Printf("[DEBUG] Delete operation %s completed", opName)
								break
							}

							time.Sleep(time.Second)
						}
					}
				}
			}
		} else {
			log.Printf("[DEBUG] No resource ID found in target_resource, skipping deletion")
		}
	}

	// Always remove from Terraform state
	d.SetId("")

	log.Printf("[DEBUG] Finished deleting RestoreWorkload")

	return nil
}

func resourceBackupDRRestoreWorkloadImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^/(?P<name>[^/]+)$",
		"^(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenBackupDRRestoreWorkloadRequestId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceTargetEnvironment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["project"] =
		flattenBackupDRRestoreWorkloadComputeInstanceTargetEnvironmentProject(original["project"], d, config)
	transformed["zone"] =
		flattenBackupDRRestoreWorkloadComputeInstanceTargetEnvironmentZone(original["zone"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceTargetEnvironmentProject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceTargetEnvironmentZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskTargetEnvironment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["project"] =
		flattenBackupDRRestoreWorkloadDiskTargetEnvironmentProject(original["project"], d, config)
	transformed["zone"] =
		flattenBackupDRRestoreWorkloadDiskTargetEnvironmentZone(original["zone"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadDiskTargetEnvironmentProject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskTargetEnvironmentZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadRegionDiskTargetEnvironment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["project"] =
		flattenBackupDRRestoreWorkloadRegionDiskTargetEnvironmentProject(original["project"], d, config)
	transformed["region"] =
		flattenBackupDRRestoreWorkloadRegionDiskTargetEnvironmentRegion(original["region"], d, config)
	transformed["replica_zones"] =
		flattenBackupDRRestoreWorkloadRegionDiskTargetEnvironmentReplicaZones(original["replicaZones"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadRegionDiskTargetEnvironmentProject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadRegionDiskTargetEnvironmentRegion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadRegionDiskTargetEnvironmentReplicaZones(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestoreProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesName(original["name"], d, config)
	transformed["advanced_machine_features"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeatures(original["advancedMachineFeatures"], d, config)
	transformed["can_ip_forward"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesCanIpForward(original["canIpForward"], d, config)
	transformed["confidential_instance_config"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesConfidentialInstanceConfig(original["confidentialInstanceConfig"], d, config)
	transformed["deletion_protection"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDeletionProtection(original["deletionProtection"], d, config)
	transformed["description"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDescription(original["description"], d, config)
	transformed["disks"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisks(original["disks"], d, config)
	transformed["display_device"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisplayDevice(original["displayDevice"], d, config)
	transformed["guest_accelerators"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAccelerators(original["guestAccelerators"], d, config)
	transformed["hostname"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesHostname(original["hostname"], d, config)
	transformed["instance_encryption_key"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKey(original["instanceEncryptionKey"], d, config)
	transformed["key_revocation_action_type"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesKeyRevocationActionType(original["keyRevocationActionType"], d, config)
	transformed["labels"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesLabels(original["labels"], d, config)
	transformed["machine_type"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMachineType(original["machineType"], d, config)
	transformed["metadata"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadata(original["metadata"], d, config)
	transformed["min_cpu_platform"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMinCpuPlatform(original["minCpuPlatform"], d, config)
	transformed["network_interfaces"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfaces(original["networkInterfaces"], d, config)
	transformed["network_performance_config"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkPerformanceConfig(original["networkPerformanceConfig"], d, config)
	transformed["params"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParams(original["params"], d, config)
	transformed["private_ipv6_google_access"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesPrivateIpv6GoogleAccess(original["privateIpv6GoogleAccess"], d, config)
	transformed["allocation_affinity"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinity(original["allocationAffinity"], d, config)
	transformed["resource_policies"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesResourcePolicies(original["resourcePolicies"], d, config)
	transformed["scheduling"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesScheduling(original["scheduling"], d, config)
	transformed["service_accounts"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccounts(original["serviceAccounts"], d, config)
	transformed["shielded_instance_config"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfig(original["shieldedInstanceConfig"], d, config)
	transformed["tags"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesTags(original["tags"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeatures(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enable_nested_virtualization"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesEnableNestedVirtualization(original["enableNestedVirtualization"], d, config)
	transformed["threads_per_core"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesThreadsPerCore(original["threadsPerCore"], d, config)
	transformed["visible_core_count"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesVisibleCoreCount(original["visibleCoreCount"], d, config)
	transformed["enable_uefi_networking"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesEnableUefiNetworking(original["enableUefiNetworking"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesEnableNestedVirtualization(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesThreadsPerCore(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesVisibleCoreCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesEnableUefiNetworking(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesCanIpForward(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesConfidentialInstanceConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enable_confidential_compute"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesConfidentialInstanceConfigEnableConfidentialCompute(original["enableConfidentialCompute"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesConfidentialInstanceConfigEnableConfidentialCompute(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDeletionProtection(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"initialize_params":   flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParams(original["initializeParams"], d, config),
			"device_name":         flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDeviceName(original["deviceName"], d, config),
			"kind":                flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksKind(original["kind"], d, config),
			"mode":                flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksMode(original["mode"], d, config),
			"source":              flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksSource(original["source"], d, config),
			"index":               flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksIndex(original["index"], d, config),
			"boot":                flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksBoot(original["boot"], d, config),
			"auto_delete":         flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksAutoDelete(original["autoDelete"], d, config),
			"license":             flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksLicense(original["license"], d, config),
			"disk_interface":      flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskInterface(original["diskInterface"], d, config),
			"guest_os_feature":    flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksGuestOsFeature(original["guestOsFeature"], d, config),
			"disk_encryption_key": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKey(original["diskEncryptionKey"], d, config),
			"disk_size_gb":        flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskSizeGb(original["diskSizeGb"], d, config),
			"saved_state":         flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksSavedState(original["savedState"], d, config),
			"disk_type":           flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskType(original["diskType"], d, config),
			"type":                flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disk_name"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParamsDiskName(original["diskName"], d, config)
	transformed["replica_zones"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParamsReplicaZones(original["replicaZones"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParamsDiskName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParamsReplicaZones(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDeviceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksKind(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksIndex(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksBoot(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksAutoDelete(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksLicense(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskInterface(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksGuestOsFeature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksGuestOsFeatureType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksGuestOsFeatureType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["raw_key"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyRawKey(original["rawKey"], d, config)
	transformed["rsa_encrypted_key"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyRsaEncryptedKey(original["rsaEncryptedKey"], d, config)
	transformed["kms_key_name"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyKmsKeyName(original["kmsKeyName"], d, config)
	transformed["kms_key_service_account"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyKmsKeyServiceAccount(original["kmsKeyServiceAccount"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyRawKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyRsaEncryptedKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyKmsKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyKmsKeyServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksSavedState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisplayDevice(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enable_display"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisplayDeviceEnableDisplay(original["enableDisplay"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisplayDeviceEnableDisplay(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAccelerators(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"accelerator_type":  flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAcceleratorsAcceleratorType(original["acceleratorType"], d, config),
			"accelerator_count": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAcceleratorsAcceleratorCount(original["acceleratorCount"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAcceleratorsAcceleratorType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAcceleratorsAcceleratorCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["raw_key"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyRawKey(original["rawKey"], d, config)
	transformed["rsa_encrypted_key"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyRsaEncryptedKey(original["rsaEncryptedKey"], d, config)
	transformed["kms_key_name"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyKmsKeyName(original["kmsKeyName"], d, config)
	transformed["kms_key_service_account"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyKmsKeyServiceAccount(original["kmsKeyServiceAccount"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyRawKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyRsaEncryptedKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyKmsKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyKmsKeyServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesKeyRevocationActionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"key":   k,
			"value": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesLabelsValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesLabelsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMachineType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["items"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItems(original["items"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":   flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItemsKey(original["key"], d, config),
			"value": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItemsValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItemsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItemsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMinCpuPlatform(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfaces(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"network":                     flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNetwork(original["network"], d, config),
			"subnetwork":                  flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesSubnetwork(original["subnetwork"], d, config),
			"ip_address":                  flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpAddress(original["ipAddress"], d, config),
			"ipv6_address":                flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6Address(original["ipv6Address"], d, config),
			"internal_ipv6_prefix_length": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesInternalIpv6PrefixLength(original["internalIpv6PrefixLength"], d, config),
			"access_configs":              flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigs(original["accessConfigs"], d, config),
			"ipv6_access_configs":         flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigs(original["ipv6AccessConfigs"], d, config),
			"alias_ip_ranges":             flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRanges(original["aliasIpRanges"], d, config),
			"stack_type":                  flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesStackType(original["stackType"], d, config),
			"ipv6_access_type":            flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessType(original["ipv6AccessType"], d, config),
			"queue_count":                 flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesQueueCount(original["queueCount"], d, config),
			"nic_type":                    flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNicType(original["nicType"], d, config),
			"network_attachment":          flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNetworkAttachment(original["networkAttachment"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesSubnetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6Address(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesInternalIpv6PrefixLength(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":                        flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsType(original["type"], d, config),
			"name":                        flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsName(original["name"], d, config),
			"external_ip":                 flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIp(original["externalIp"], d, config),
			"external_ipv6":               flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIpv6(original["externalIpv6"], d, config),
			"external_ipv6_prefix_length": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIpv6PrefixLength(original["externalIpv6PrefixLength"], d, config),
			"set_public_ptr":              flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsSetPublicPtr(original["setPublicPtr"], d, config),
			"public_ptr_domain_name":      flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsPublicPtrDomainName(original["publicPtrDomainName"], d, config),
			"network_tier":                flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsNetworkTier(original["networkTier"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIpv6(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIpv6PrefixLength(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsSetPublicPtr(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsPublicPtrDomainName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsNetworkTier(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":                        flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsType(original["type"], d, config),
			"name":                        flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsName(original["name"], d, config),
			"external_ip":                 flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIp(original["externalIp"], d, config),
			"external_ipv6":               flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIpv6(original["externalIpv6"], d, config),
			"external_ipv6_prefix_length": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIpv6PrefixLength(original["externalIpv6PrefixLength"], d, config),
			"set_public_ptr":              flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsSetPublicPtr(original["setPublicPtr"], d, config),
			"public_ptr_domain_name":      flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsPublicPtrDomainName(original["publicPtrDomainName"], d, config),
			"network_tier":                flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsNetworkTier(original["networkTier"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIpv6(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIpv6PrefixLength(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsSetPublicPtr(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsPublicPtrDomainName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsNetworkTier(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRanges(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ip_cidr_range":         flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRangesIpCidrRange(original["ipCidrRange"], d, config),
			"subnetwork_range_name": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRangesSubnetworkRangeName(original["subnetworkRangeName"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRangesIpCidrRange(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRangesSubnetworkRangeName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesStackType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesQueueCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNicType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNetworkAttachment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkPerformanceConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["total_egress_bandwidth_tier"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkPerformanceConfigTotalEgressBandwidthTier(original["totalEgressBandwidthTier"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkPerformanceConfigTotalEgressBandwidthTier(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["resource_manager_tags"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParamsResourceManagerTags(original["resourceManagerTags"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParamsResourceManagerTags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"key":   k,
			"value": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParamsResourceManagerTagsValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParamsResourceManagerTagsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesPrivateIpv6GoogleAccess(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["consume_allocation_type"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityConsumeAllocationType(original["consumeAllocationType"], d, config)
	transformed["key"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityKey(original["key"], d, config)
	transformed["values"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityValues(original["values"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityConsumeAllocationType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityValues(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesResourcePolicies(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesScheduling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["on_host_maintenance"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingOnHostMaintenance(original["onHostMaintenance"], d, config)
	transformed["automatic_restart"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingAutomaticRestart(original["automaticRestart"], d, config)
	transformed["preemptible"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingPreemptible(original["preemptible"], d, config)
	transformed["node_affinities"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinities(original["nodeAffinities"], d, config)
	transformed["min_node_cpus"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMinNodeCpus(original["minNodeCpus"], d, config)
	transformed["provisioning_model"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingProvisioningModel(original["provisioningModel"], d, config)
	transformed["instance_termination_action"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingInstanceTerminationAction(original["instanceTerminationAction"], d, config)
	transformed["local_ssd_recovery_timeout"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeout(original["localSsdRecoveryTimeout"], d, config)
	transformed["max_run_duration"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDuration(original["maxRunDuration"], d, config)
	transformed["termination_time"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingTerminationTime(original["terminationTime"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingOnHostMaintenance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingAutomaticRestart(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingPreemptible(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinities(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":      flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesKey(original["key"], d, config),
			"operator": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesOperator(original["operator"], d, config),
			"values":   flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesValues(original["values"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesOperator(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesValues(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMinNodeCpus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingProvisioningModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingInstanceTerminationAction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeout(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["seconds"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeoutSeconds(original["seconds"], d, config)
	transformed["nanos"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeoutNanos(original["nanos"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeoutSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeoutNanos(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["seconds"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDurationSeconds(original["seconds"], d, config)
	transformed["nanos"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDurationNanos(original["nanos"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDurationSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDurationNanos(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingTerminationTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccounts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"email":  flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccountsEmail(original["email"], d, config),
			"scopes": flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccountsScopes(original["scopes"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccountsEmail(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccountsScopes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enable_secure_boot"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableSecureBoot(original["enableSecureBoot"], d, config)
	transformed["enable_vtpm"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableVtpm(original["enableVtpm"], d, config)
	transformed["enable_integrity_monitoring"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableIntegrityMonitoring(original["enableIntegrityMonitoring"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableSecureBoot(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableVtpm(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableIntegrityMonitoring(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesTags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["items"] =
		flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesTagsItems(original["items"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadComputeInstanceRestorePropertiesTagsItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestoreProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesName(original["name"], d, config)
	transformed["description"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesDescription(original["description"], d, config)
	transformed["size_gb"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesSizeGb(original["sizeGb"], d, config)
	transformed["licenses"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesLicenses(original["licenses"], d, config)
	transformed["guest_os_feature"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesGuestOsFeature(original["guestOsFeature"], d, config)
	transformed["disk_encryption_key"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKey(original["diskEncryptionKey"], d, config)
	transformed["physical_block_size_bytes"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesPhysicalBlockSizeBytes(original["physicalBlockSizeBytes"], d, config)
	transformed["provisioned_iops"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesProvisionedIops(original["provisionedIops"], d, config)
	transformed["provisioned_throughput"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesProvisionedThroughput(original["provisionedThroughput"], d, config)
	transformed["enable_confidential_compute"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesEnableConfidentialCompute(original["enableConfidentialCompute"], d, config)
	transformed["storage_pool"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesStoragePool(original["storagePool"], d, config)
	transformed["access_mode"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesAccessMode(original["accessMode"], d, config)
	transformed["architecture"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesArchitecture(original["architecture"], d, config)
	transformed["resource_policy"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesResourcePolicy(original["resourcePolicy"], d, config)
	transformed["type"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesType(original["type"], d, config)
	transformed["labels"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesLabels(original["labels"], d, config)
	transformed["resource_manager_tags"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesResourceManagerTags(original["resourceManagerTags"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadDiskRestorePropertiesName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesLicenses(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesGuestOsFeature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type": flattenBackupDRRestoreWorkloadDiskRestorePropertiesGuestOsFeatureType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadDiskRestorePropertiesGuestOsFeatureType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["raw_key"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyRawKey(original["rawKey"], d, config)
	transformed["rsa_encrypted_key"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyRsaEncryptedKey(original["rsaEncryptedKey"], d, config)
	transformed["kms_key_name"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyKmsKeyName(original["kmsKeyName"], d, config)
	transformed["kms_key_service_account"] =
		flattenBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyKmsKeyServiceAccount(original["kmsKeyServiceAccount"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyRawKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyRsaEncryptedKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyKmsKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyKmsKeyServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesPhysicalBlockSizeBytes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesProvisionedIops(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesProvisionedThroughput(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesEnableConfidentialCompute(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesStoragePool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesAccessMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesArchitecture(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesResourcePolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"key":   k,
			"value": flattenBackupDRRestoreWorkloadDiskRestorePropertiesLabelsValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadDiskRestorePropertiesLabelsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDiskRestorePropertiesResourceManagerTags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"key":   k,
			"value": flattenBackupDRRestoreWorkloadDiskRestorePropertiesResourceManagerTagsValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRRestoreWorkloadDiskRestorePropertiesResourceManagerTagsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadClearOverridesFieldMask(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadDeleteRestoredInstance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadTargetResource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["gcp_resource"] =
		flattenBackupDRRestoreWorkloadTargetResourceGcpResource(original["gcpResource"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadTargetResourceGcpResource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["gcp_resourcename"] =
		flattenBackupDRRestoreWorkloadTargetResourceGcpResourceGcpResourcename(original["gcpResourcename"], d, config)
	transformed["location"] =
		flattenBackupDRRestoreWorkloadTargetResourceGcpResourceLocation(original["location"], d, config)
	transformed["type"] =
		flattenBackupDRRestoreWorkloadTargetResourceGcpResourceType(original["type"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRRestoreWorkloadTargetResourceGcpResourceGcpResourcename(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadTargetResourceGcpResourceLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRRestoreWorkloadTargetResourceGcpResourceType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandBackupDRRestoreWorkloadName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadRequestId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceTargetEnvironment(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProject, err := expandBackupDRRestoreWorkloadComputeInstanceTargetEnvironmentProject(original["project"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["project"] = transformedProject
	}

	transformedZone, err := expandBackupDRRestoreWorkloadComputeInstanceTargetEnvironmentZone(original["zone"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedZone); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["zone"] = transformedZone
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceTargetEnvironmentProject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceTargetEnvironmentZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskTargetEnvironment(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProject, err := expandBackupDRRestoreWorkloadDiskTargetEnvironmentProject(original["project"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["project"] = transformedProject
	}

	transformedZone, err := expandBackupDRRestoreWorkloadDiskTargetEnvironmentZone(original["zone"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedZone); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["zone"] = transformedZone
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadDiskTargetEnvironmentProject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskTargetEnvironmentZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadRegionDiskTargetEnvironment(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProject, err := expandBackupDRRestoreWorkloadRegionDiskTargetEnvironmentProject(original["project"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["project"] = transformedProject
	}

	transformedRegion, err := expandBackupDRRestoreWorkloadRegionDiskTargetEnvironmentRegion(original["region"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRegion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["region"] = transformedRegion
	}

	transformedReplicaZones, err := expandBackupDRRestoreWorkloadRegionDiskTargetEnvironmentReplicaZones(original["replica_zones"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReplicaZones); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["replicaZones"] = transformedReplicaZones
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadRegionDiskTargetEnvironmentProject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadRegionDiskTargetEnvironmentRegion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadRegionDiskTargetEnvironmentReplicaZones(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestoreProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedAdvancedMachineFeatures, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeatures(original["advanced_machine_features"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdvancedMachineFeatures); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["advancedMachineFeatures"] = transformedAdvancedMachineFeatures
	}

	transformedCanIpForward, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesCanIpForward(original["can_ip_forward"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCanIpForward); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["canIpForward"] = transformedCanIpForward
	}

	transformedConfidentialInstanceConfig, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesConfidentialInstanceConfig(original["confidential_instance_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConfidentialInstanceConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["confidentialInstanceConfig"] = transformedConfidentialInstanceConfig
	}

	transformedDeletionProtection, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDeletionProtection(original["deletion_protection"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDeletionProtection); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["deletionProtection"] = transformedDeletionProtection
	}

	transformedDescription, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedDisks, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisks(original["disks"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disks"] = transformedDisks
	}

	transformedDisplayDevice, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisplayDevice(original["display_device"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayDevice); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayDevice"] = transformedDisplayDevice
	}

	transformedGuestAccelerators, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAccelerators(original["guest_accelerators"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGuestAccelerators); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["guestAccelerators"] = transformedGuestAccelerators
	}

	transformedHostname, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesHostname(original["hostname"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostname"] = transformedHostname
	}

	transformedInstanceEncryptionKey, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKey(original["instance_encryption_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstanceEncryptionKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instanceEncryptionKey"] = transformedInstanceEncryptionKey
	}

	transformedKeyRevocationActionType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesKeyRevocationActionType(original["key_revocation_action_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKeyRevocationActionType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["keyRevocationActionType"] = transformedKeyRevocationActionType
	}

	transformedLabels, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedMachineType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMachineType(original["machine_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMachineType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["machineType"] = transformedMachineType
	}

	transformedMetadata, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadata(original["metadata"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMetadata); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["metadata"] = transformedMetadata
	}

	transformedMinCpuPlatform, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMinCpuPlatform(original["min_cpu_platform"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinCpuPlatform); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minCpuPlatform"] = transformedMinCpuPlatform
	}

	transformedNetworkInterfaces, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfaces(original["network_interfaces"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetworkInterfaces); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["networkInterfaces"] = transformedNetworkInterfaces
	}

	transformedNetworkPerformanceConfig, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkPerformanceConfig(original["network_performance_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetworkPerformanceConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["networkPerformanceConfig"] = transformedNetworkPerformanceConfig
	}

	transformedParams, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParams(original["params"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedParams); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["params"] = transformedParams
	}

	transformedPrivateIpv6GoogleAccess, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesPrivateIpv6GoogleAccess(original["private_ipv6_google_access"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrivateIpv6GoogleAccess); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["privateIpv6GoogleAccess"] = transformedPrivateIpv6GoogleAccess
	}

	transformedAllocationAffinity, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinity(original["allocation_affinity"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllocationAffinity); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allocationAffinity"] = transformedAllocationAffinity
	}

	transformedResourcePolicies, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesResourcePolicies(original["resource_policies"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResourcePolicies); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["resourcePolicies"] = transformedResourcePolicies
	}

	transformedScheduling, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesScheduling(original["scheduling"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScheduling); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scheduling"] = transformedScheduling
	}

	transformedServiceAccounts, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccounts(original["service_accounts"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccounts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccounts"] = transformedServiceAccounts
	}

	transformedShieldedInstanceConfig, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfig(original["shielded_instance_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedShieldedInstanceConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["shieldedInstanceConfig"] = transformedShieldedInstanceConfig
	}

	transformedTags, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesTags(original["tags"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTags); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tags"] = transformedTags
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeatures(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnableNestedVirtualization, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesEnableNestedVirtualization(original["enable_nested_virtualization"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableNestedVirtualization); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableNestedVirtualization"] = transformedEnableNestedVirtualization
	}

	transformedThreadsPerCore, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesThreadsPerCore(original["threads_per_core"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedThreadsPerCore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["threadsPerCore"] = transformedThreadsPerCore
	}

	transformedVisibleCoreCount, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesVisibleCoreCount(original["visible_core_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVisibleCoreCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["visibleCoreCount"] = transformedVisibleCoreCount
	}

	transformedEnableUefiNetworking, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesEnableUefiNetworking(original["enable_uefi_networking"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableUefiNetworking); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableUefiNetworking"] = transformedEnableUefiNetworking
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesEnableNestedVirtualization(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesThreadsPerCore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesVisibleCoreCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAdvancedMachineFeaturesEnableUefiNetworking(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesCanIpForward(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesConfidentialInstanceConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnableConfidentialCompute, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesConfidentialInstanceConfigEnableConfidentialCompute(original["enable_confidential_compute"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableConfidentialCompute); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableConfidentialCompute"] = transformedEnableConfidentialCompute
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesConfidentialInstanceConfigEnableConfidentialCompute(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDeletionProtection(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedInitializeParams, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParams(original["initialize_params"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInitializeParams); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["initializeParams"] = transformedInitializeParams
		}

		transformedDeviceName, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDeviceName(original["device_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDeviceName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["deviceName"] = transformedDeviceName
		}

		transformedKind, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksKind(original["kind"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKind); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["kind"] = transformedKind
		}

		transformedMode, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksMode(original["mode"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["mode"] = transformedMode
		}

		transformedSource, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksSource(original["source"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["source"] = transformedSource
		}

		transformedIndex, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksIndex(original["index"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIndex); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["index"] = transformedIndex
		}

		transformedBoot, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksBoot(original["boot"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedBoot); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["boot"] = transformedBoot
		}

		transformedAutoDelete, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksAutoDelete(original["auto_delete"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAutoDelete); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["autoDelete"] = transformedAutoDelete
		}

		transformedLicense, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksLicense(original["license"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLicense); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["license"] = transformedLicense
		}

		transformedDiskInterface, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskInterface(original["disk_interface"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDiskInterface); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["diskInterface"] = transformedDiskInterface
		}

		transformedGuestOsFeature, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksGuestOsFeature(original["guest_os_feature"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedGuestOsFeature); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["guestOsFeature"] = transformedGuestOsFeature
		}

		transformedDiskEncryptionKey, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKey(original["disk_encryption_key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDiskEncryptionKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["diskEncryptionKey"] = transformedDiskEncryptionKey
		}

		transformedDiskSizeGb, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskSizeGb(original["disk_size_gb"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDiskSizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["diskSizeGb"] = transformedDiskSizeGb
		}

		transformedSavedState, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksSavedState(original["saved_state"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSavedState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["savedState"] = transformedSavedState
		}

		transformedDiskType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskType(original["disk_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDiskType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["diskType"] = transformedDiskType
		}

		transformedType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDiskName, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParamsDiskName(original["disk_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDiskName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["diskName"] = transformedDiskName
	}

	transformedReplicaZones, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParamsReplicaZones(original["replica_zones"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReplicaZones); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["replicaZones"] = transformedReplicaZones
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParamsDiskName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksInitializeParamsReplicaZones(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDeviceName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksKind(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksIndex(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksBoot(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksAutoDelete(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksLicense(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskInterface(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksGuestOsFeature(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksGuestOsFeatureType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksGuestOsFeatureType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRawKey, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyRawKey(original["raw_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRawKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rawKey"] = transformedRawKey
	}

	transformedRsaEncryptedKey, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyRsaEncryptedKey(original["rsa_encrypted_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRsaEncryptedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rsaEncryptedKey"] = transformedRsaEncryptedKey
	}

	transformedKmsKeyName, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	transformedKmsKeyServiceAccount, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyKmsKeyServiceAccount(original["kms_key_service_account"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyServiceAccount"] = transformedKmsKeyServiceAccount
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyRawKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyRsaEncryptedKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskEncryptionKeyKmsKeyServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskSizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksSavedState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksDiskType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisksType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisplayDevice(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnableDisplay, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisplayDeviceEnableDisplay(original["enable_display"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableDisplay); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableDisplay"] = transformedEnableDisplay
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesDisplayDeviceEnableDisplay(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAccelerators(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAcceleratorType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAcceleratorsAcceleratorType(original["accelerator_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAcceleratorType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["acceleratorType"] = transformedAcceleratorType
		}

		transformedAcceleratorCount, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAcceleratorsAcceleratorCount(original["accelerator_count"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAcceleratorCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["acceleratorCount"] = transformedAcceleratorCount
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAcceleratorsAcceleratorType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesGuestAcceleratorsAcceleratorCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRawKey, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyRawKey(original["raw_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRawKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rawKey"] = transformedRawKey
	}

	transformedRsaEncryptedKey, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyRsaEncryptedKey(original["rsa_encrypted_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRsaEncryptedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rsaEncryptedKey"] = transformedRsaEncryptedKey
	}

	transformedKmsKeyName, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	transformedKmsKeyServiceAccount, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyKmsKeyServiceAccount(original["kms_key_service_account"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyServiceAccount"] = transformedKmsKeyServiceAccount
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyRawKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyRsaEncryptedKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesInstanceEncryptionKeyKmsKeyServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesKeyRevocationActionType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedValue, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesLabelsValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedKey, err := tpgresource.ExpandString(original["key"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedKey] = transformed
	}
	return m, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesLabelsValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMachineType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedItems, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItems(original["items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["items"] = transformedItems
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItemsKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedValue, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItemsValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItemsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMetadataItemsValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesMinCpuPlatform(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfaces(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedNetwork, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNetwork(original["network"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["network"] = transformedNetwork
		}

		transformedSubnetwork, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesSubnetwork(original["subnetwork"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSubnetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["subnetwork"] = transformedSubnetwork
		}

		transformedIpAddress, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpAddress(original["ip_address"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIpAddress); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ipAddress"] = transformedIpAddress
		}

		transformedIpv6Address, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6Address(original["ipv6_address"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIpv6Address); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ipv6Address"] = transformedIpv6Address
		}

		transformedInternalIpv6PrefixLength, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesInternalIpv6PrefixLength(original["internal_ipv6_prefix_length"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInternalIpv6PrefixLength); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["internalIpv6PrefixLength"] = transformedInternalIpv6PrefixLength
		}

		transformedAccessConfigs, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigs(original["access_configs"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAccessConfigs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["accessConfigs"] = transformedAccessConfigs
		}

		transformedIpv6AccessConfigs, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigs(original["ipv6_access_configs"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIpv6AccessConfigs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ipv6AccessConfigs"] = transformedIpv6AccessConfigs
		}

		transformedAliasIpRanges, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRanges(original["alias_ip_ranges"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAliasIpRanges); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["aliasIpRanges"] = transformedAliasIpRanges
		}

		transformedStackType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesStackType(original["stack_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStackType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["stackType"] = transformedStackType
		}

		transformedIpv6AccessType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessType(original["ipv6_access_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIpv6AccessType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ipv6AccessType"] = transformedIpv6AccessType
		}

		transformedQueueCount, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesQueueCount(original["queue_count"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedQueueCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["queueCount"] = transformedQueueCount
		}

		transformedNicType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNicType(original["nic_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNicType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["nicType"] = transformedNicType
		}

		transformedNetworkAttachment, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNetworkAttachment(original["network_attachment"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetworkAttachment); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["networkAttachment"] = transformedNetworkAttachment
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesSubnetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpAddress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6Address(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesInternalIpv6PrefixLength(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedName, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedExternalIp, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIp(original["external_ip"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExternalIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["externalIp"] = transformedExternalIp
		}

		transformedExternalIpv6, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIpv6(original["external_ipv6"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExternalIpv6); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["externalIpv6"] = transformedExternalIpv6
		}

		transformedExternalIpv6PrefixLength, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIpv6PrefixLength(original["external_ipv6_prefix_length"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExternalIpv6PrefixLength); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["externalIpv6PrefixLength"] = transformedExternalIpv6PrefixLength
		}

		transformedSetPublicPtr, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsSetPublicPtr(original["set_public_ptr"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSetPublicPtr); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["setPublicPtr"] = transformedSetPublicPtr
		}

		transformedPublicPtrDomainName, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsPublicPtrDomainName(original["public_ptr_domain_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPublicPtrDomainName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["publicPtrDomainName"] = transformedPublicPtrDomainName
		}

		transformedNetworkTier, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsNetworkTier(original["network_tier"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetworkTier); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["networkTier"] = transformedNetworkTier
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIpv6(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsExternalIpv6PrefixLength(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsSetPublicPtr(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsPublicPtrDomainName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAccessConfigsNetworkTier(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedName, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedExternalIp, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIp(original["external_ip"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExternalIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["externalIp"] = transformedExternalIp
		}

		transformedExternalIpv6, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIpv6(original["external_ipv6"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExternalIpv6); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["externalIpv6"] = transformedExternalIpv6
		}

		transformedExternalIpv6PrefixLength, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIpv6PrefixLength(original["external_ipv6_prefix_length"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExternalIpv6PrefixLength); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["externalIpv6PrefixLength"] = transformedExternalIpv6PrefixLength
		}

		transformedSetPublicPtr, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsSetPublicPtr(original["set_public_ptr"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSetPublicPtr); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["setPublicPtr"] = transformedSetPublicPtr
		}

		transformedPublicPtrDomainName, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsPublicPtrDomainName(original["public_ptr_domain_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPublicPtrDomainName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["publicPtrDomainName"] = transformedPublicPtrDomainName
		}

		transformedNetworkTier, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsNetworkTier(original["network_tier"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetworkTier); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["networkTier"] = transformedNetworkTier
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIpv6(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsExternalIpv6PrefixLength(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsSetPublicPtr(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsPublicPtrDomainName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessConfigsNetworkTier(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRanges(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedIpCidrRange, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRangesIpCidrRange(original["ip_cidr_range"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIpCidrRange); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ipCidrRange"] = transformedIpCidrRange
		}

		transformedSubnetworkRangeName, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRangesSubnetworkRangeName(original["subnetwork_range_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSubnetworkRangeName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["subnetworkRangeName"] = transformedSubnetworkRangeName
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRangesIpCidrRange(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesAliasIpRangesSubnetworkRangeName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesStackType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesIpv6AccessType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesQueueCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNicType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkInterfacesNetworkAttachment(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkPerformanceConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTotalEgressBandwidthTier, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkPerformanceConfigTotalEgressBandwidthTier(original["total_egress_bandwidth_tier"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTotalEgressBandwidthTier); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["totalEgressBandwidthTier"] = transformedTotalEgressBandwidthTier
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesNetworkPerformanceConfigTotalEgressBandwidthTier(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedResourceManagerTags, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParamsResourceManagerTags(original["resource_manager_tags"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResourceManagerTags); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["resourceManagerTags"] = transformedResourceManagerTags
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParamsResourceManagerTags(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedValue, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParamsResourceManagerTagsValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedKey, err := tpgresource.ExpandString(original["key"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedKey] = transformed
	}
	return m, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesParamsResourceManagerTagsValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesPrivateIpv6GoogleAccess(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedConsumeAllocationType, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityConsumeAllocationType(original["consume_allocation_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConsumeAllocationType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["consumeAllocationType"] = transformedConsumeAllocationType
	}

	transformedKey, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityKey(original["key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["key"] = transformedKey
	}

	transformedValues, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityValues(original["values"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedValues); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["values"] = transformedValues
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityConsumeAllocationType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesAllocationAffinityValues(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesResourcePolicies(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesScheduling(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOnHostMaintenance, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingOnHostMaintenance(original["on_host_maintenance"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOnHostMaintenance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["onHostMaintenance"] = transformedOnHostMaintenance
	}

	transformedAutomaticRestart, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingAutomaticRestart(original["automatic_restart"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAutomaticRestart); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["automaticRestart"] = transformedAutomaticRestart
	}

	transformedPreemptible, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingPreemptible(original["preemptible"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPreemptible); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["preemptible"] = transformedPreemptible
	}

	transformedNodeAffinities, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinities(original["node_affinities"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNodeAffinities); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nodeAffinities"] = transformedNodeAffinities
	}

	transformedMinNodeCpus, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMinNodeCpus(original["min_node_cpus"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinNodeCpus); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minNodeCpus"] = transformedMinNodeCpus
	}

	transformedProvisioningModel, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingProvisioningModel(original["provisioning_model"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProvisioningModel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["provisioningModel"] = transformedProvisioningModel
	}

	transformedInstanceTerminationAction, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingInstanceTerminationAction(original["instance_termination_action"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstanceTerminationAction); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instanceTerminationAction"] = transformedInstanceTerminationAction
	}

	transformedLocalSsdRecoveryTimeout, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeout(original["local_ssd_recovery_timeout"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalSsdRecoveryTimeout); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["localSsdRecoveryTimeout"] = transformedLocalSsdRecoveryTimeout
	}

	transformedMaxRunDuration, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDuration(original["max_run_duration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxRunDuration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxRunDuration"] = transformedMaxRunDuration
	}

	transformedTerminationTime, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingTerminationTime(original["termination_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTerminationTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["terminationTime"] = transformedTerminationTime
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingOnHostMaintenance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingAutomaticRestart(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingPreemptible(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinities(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedOperator, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesOperator(original["operator"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOperator); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["operator"] = transformedOperator
		}

		transformedValues, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesValues(original["values"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValues); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["values"] = transformedValues
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesOperator(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingNodeAffinitiesValues(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMinNodeCpus(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingProvisioningModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingInstanceTerminationAction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeout(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSeconds, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeoutSeconds(original["seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["seconds"] = transformedSeconds
	}

	transformedNanos, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeoutNanos(original["nanos"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNanos); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nanos"] = transformedNanos
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeoutSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingLocalSsdRecoveryTimeoutNanos(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSeconds, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDurationSeconds(original["seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["seconds"] = transformedSeconds
	}

	transformedNanos, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDurationNanos(original["nanos"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNanos); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nanos"] = transformedNanos
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDurationSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingMaxRunDurationNanos(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesSchedulingTerminationTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccounts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedEmail, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccountsEmail(original["email"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEmail); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["email"] = transformedEmail
		}

		transformedScopes, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccountsScopes(original["scopes"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedScopes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["scopes"] = transformedScopes
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccountsEmail(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesServiceAccountsScopes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnableSecureBoot, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableSecureBoot(original["enable_secure_boot"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableSecureBoot); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableSecureBoot"] = transformedEnableSecureBoot
	}

	transformedEnableVtpm, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableVtpm(original["enable_vtpm"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableVtpm); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableVtpm"] = transformedEnableVtpm
	}

	transformedEnableIntegrityMonitoring, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableIntegrityMonitoring(original["enable_integrity_monitoring"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableIntegrityMonitoring); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableIntegrityMonitoring"] = transformedEnableIntegrityMonitoring
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableSecureBoot(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableVtpm(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesShieldedInstanceConfigEnableIntegrityMonitoring(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesTags(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedItems, err := expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesTagsItems(original["items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["items"] = transformedItems
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadComputeInstanceRestorePropertiesTagsItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestoreProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedDescription, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedSizeGb, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesSizeGb(original["size_gb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sizeGb"] = transformedSizeGb
	}

	transformedLicenses, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesLicenses(original["licenses"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLicenses); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["licenses"] = transformedLicenses
	}

	transformedGuestOsFeature, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesGuestOsFeature(original["guest_os_feature"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGuestOsFeature); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["guestOsFeature"] = transformedGuestOsFeature
	}

	transformedDiskEncryptionKey, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKey(original["disk_encryption_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDiskEncryptionKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["diskEncryptionKey"] = transformedDiskEncryptionKey
	}

	transformedPhysicalBlockSizeBytes, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesPhysicalBlockSizeBytes(original["physical_block_size_bytes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPhysicalBlockSizeBytes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["physicalBlockSizeBytes"] = transformedPhysicalBlockSizeBytes
	}

	transformedProvisionedIops, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesProvisionedIops(original["provisioned_iops"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProvisionedIops); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["provisionedIops"] = transformedProvisionedIops
	}

	transformedProvisionedThroughput, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesProvisionedThroughput(original["provisioned_throughput"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProvisionedThroughput); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["provisionedThroughput"] = transformedProvisionedThroughput
	}

	transformedEnableConfidentialCompute, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesEnableConfidentialCompute(original["enable_confidential_compute"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableConfidentialCompute); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableConfidentialCompute"] = transformedEnableConfidentialCompute
	}

	transformedStoragePool, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesStoragePool(original["storage_pool"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStoragePool); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["storagePool"] = transformedStoragePool
	}

	transformedAccessMode, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesAccessMode(original["access_mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAccessMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["accessMode"] = transformedAccessMode
	}

	transformedArchitecture, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesArchitecture(original["architecture"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedArchitecture); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["architecture"] = transformedArchitecture
	}

	transformedResourcePolicy, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesResourcePolicy(original["resource_policy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResourcePolicy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["resourcePolicy"] = transformedResourcePolicy
	}

	transformedType, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedLabels, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedResourceManagerTags, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesResourceManagerTags(original["resource_manager_tags"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResourceManagerTags); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["resourceManagerTags"] = transformedResourceManagerTags
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesSizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesLicenses(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesGuestOsFeature(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesGuestOsFeatureType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesGuestOsFeatureType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRawKey, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyRawKey(original["raw_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRawKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rawKey"] = transformedRawKey
	}

	transformedRsaEncryptedKey, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyRsaEncryptedKey(original["rsa_encrypted_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRsaEncryptedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rsaEncryptedKey"] = transformedRsaEncryptedKey
	}

	transformedKmsKeyName, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	transformedKmsKeyServiceAccount, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyKmsKeyServiceAccount(original["kms_key_service_account"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyServiceAccount"] = transformedKmsKeyServiceAccount
	}

	return transformed, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyRawKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyRsaEncryptedKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesDiskEncryptionKeyKmsKeyServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesPhysicalBlockSizeBytes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesProvisionedIops(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesProvisionedThroughput(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesEnableConfidentialCompute(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesStoragePool(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesAccessMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesArchitecture(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesResourcePolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedValue, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesLabelsValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedKey, err := tpgresource.ExpandString(original["key"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedKey] = transformed
	}
	return m, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesLabelsValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesResourceManagerTags(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedValue, err := expandBackupDRRestoreWorkloadDiskRestorePropertiesResourceManagerTagsValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedKey, err := tpgresource.ExpandString(original["key"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedKey] = transformed
	}
	return m, nil
}

func expandBackupDRRestoreWorkloadDiskRestorePropertiesResourceManagerTagsValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadClearOverridesFieldMask(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRRestoreWorkloadDeleteRestoredInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
