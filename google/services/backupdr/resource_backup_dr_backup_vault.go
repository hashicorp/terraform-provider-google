// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/backupdr/BackupVault.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package backupdr

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceBackupDRBackupVault() *schema.Resource {
	return &schema.Resource{
		Create: resourceBackupDRBackupVaultCreate,
		Read:   resourceBackupDRBackupVaultRead,
		Update: resourceBackupDRBackupVaultUpdate,
		Delete: resourceBackupDRBackupVaultDelete,

		Importer: &schema.ResourceImporter{
			State: resourceBackupDRBackupVaultImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.SetAnnotationsDiff,
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"backup_vault_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"backup_minimum_enforced_retention_duration": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Required. The default and minimum enforced retention for each backup within the backup vault. The enforced retention for each backup can be extended.`,
			},
			"backup_vault_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Required. ID of the requesting object.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The GCP location for the backup vault.`,
			},
			"access_restriction": {
				Type:         schema.TypeString,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"ACCESS_RESTRICTION_UNSPECIFIED", "WITHIN_PROJECT", "WITHIN_ORGANIZATION", "UNRESTRICTED", "WITHIN_ORG_BUT_UNRESTRICTED_FOR_BA", ""}),
				Description:  `Access restriction for the backup vault. Default value is 'WITHIN_ORGANIZATION' if not provided during creation. Default value: "WITHIN_ORGANIZATION" Possible values: ["ACCESS_RESTRICTION_UNSPECIFIED", "WITHIN_PROJECT", "WITHIN_ORGANIZATION", "UNRESTRICTED", "WITHIN_ORG_BUT_UNRESTRICTED_FOR_BA"]`,
				Default:      "WITHIN_ORGANIZATION",
			},
			"allow_missing": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Allow idempotent deletion of backup vault. The request will still succeed in case the backup vault does not exist.`,
				Default:     false,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Optional. User annotations. See https://google.aip.dev/128#annotations
Stores small amounts of arbitrary data. 

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"backup_retention_inheritance": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"BACKUP_RETENTION_INHERITANCE_UNSPECIFIED", "INHERIT_VAULT_RETENTION", "MATCH_BACKUP_EXPIRE_TIME", ""}),
				Description:  `How a backup's enforced retention end time is inherited. Default value is 'INHERIT_VAULT_RETENTION' if not provided during creation. Possible values: ["BACKUP_RETENTION_INHERITANCE_UNSPECIFIED", "INHERIT_VAULT_RETENTION", "MATCH_BACKUP_EXPIRE_TIME"]`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Optional. The description of the BackupVault instance (2048 characters or less).`,
			},
			"effective_time": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Optional. Time after which the BackupVault resource is locked.`,
			},
			"encryption_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Encryption configuration for the backup vault.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"kms_key_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The Resource name of the Cloud KMS key to be used to encrypt new backups. The key must be in the same location as the backup vault. The key must be a Cloud KMS CryptoKey.`,
						},
					},
				},
			},
			"force_delete": {
				Type:       schema.TypeBool,
				Optional:   true,
				Deprecated: "`force_delete` is deprecated and will be removed in a future major release. Use `ignore_inactive_datasources` instead.",
				Description: `If set, the following restrictions against deletion of the backup vault instance can be overridden:
   * deletion of a backup vault instance containing no backups, but still containing empty datasources.
   * deletion of a backup vault instance that is being referenced by an active backup plan.`,
				Default:       false,
				ConflictsWith: []string{},
			},
			"force_update": {
				Type:     schema.TypeBool,
				Optional: true,
				Description: `If set, allow update to extend the minimum enforced retention for backup vault. This overrides
 the restriction against conflicting retention periods. This conflict may occur when the
 expiration schedule defined by the associated backup plan is shorter than the minimum
 retention set by the backup vault.`,
				Default: false,
			},
			"ignore_backup_plan_references": {
				Type:     schema.TypeBool,
				Optional: true,
				Description: `If set, the following restrictions against deletion of the backup vault instance can be overridden:
   * deletion of a backup vault instance that is being referenced by an active backup plan.`,
				Default: false,
			},
			"ignore_inactive_datasources": {
				Type:     schema.TypeBool,
				Optional: true,
				Description: `If set, the following restrictions against deletion of the backup vault instance can be overridden:
   * deletion of a backup vault instance containing no backups, but still containing empty datasources.`,
				Default:       false,
				ConflictsWith: []string{},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Optional. Resource labels to represent user provided metadata. 

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"backup_count": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The number of backups in this backup vault.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The time when the instance was created.`,
			},
			"deletable": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `Output only. Set to true when there are no backups nested under this resource.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"etag": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Optional. Server specified ETag for the backup vault resource to prevent simultaneous updates from overwiting each other.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Identifier. The resource name.`,
			},
			"service_account": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Service account used by the BackupVault Service for this BackupVault.  The user should grant this account permissions in their workload project to enable the service to run backups and restores there.`,
			},
			"state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Output only. The BackupVault resource instance state. 
 Possible values:
 STATE_UNSPECIFIED
 CREATING
 ACTIVE
 DELETING
 ERROR`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"total_stored_bytes": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Total size of the storage used by all backup resources.`,
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Output only Immutable after resource creation until resource deletion.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The time when the instance was updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceBackupDRBackupVaultCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandBackupDRBackupVaultDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	backupMinimumEnforcedRetentionDurationProp, err := expandBackupDRBackupVaultBackupMinimumEnforcedRetentionDuration(d.Get("backup_minimum_enforced_retention_duration"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backup_minimum_enforced_retention_duration"); !tpgresource.IsEmptyValue(reflect.ValueOf(backupMinimumEnforcedRetentionDurationProp)) && (ok || !reflect.DeepEqual(v, backupMinimumEnforcedRetentionDurationProp)) {
		obj["backupMinimumEnforcedRetentionDuration"] = backupMinimumEnforcedRetentionDurationProp
	}
	effectiveTimeProp, err := expandBackupDRBackupVaultEffectiveTime(d.Get("effective_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveTimeProp)) && (ok || !reflect.DeepEqual(v, effectiveTimeProp)) {
		obj["effectiveTime"] = effectiveTimeProp
	}
	accessRestrictionProp, err := expandBackupDRBackupVaultAccessRestriction(d.Get("access_restriction"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("access_restriction"); !tpgresource.IsEmptyValue(reflect.ValueOf(accessRestrictionProp)) && (ok || !reflect.DeepEqual(v, accessRestrictionProp)) {
		obj["accessRestriction"] = accessRestrictionProp
	}
	backupRetentionInheritanceProp, err := expandBackupDRBackupVaultBackupRetentionInheritance(d.Get("backup_retention_inheritance"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backup_retention_inheritance"); !tpgresource.IsEmptyValue(reflect.ValueOf(backupRetentionInheritanceProp)) && (ok || !reflect.DeepEqual(v, backupRetentionInheritanceProp)) {
		obj["backupRetentionInheritance"] = backupRetentionInheritanceProp
	}
	encryptionConfigProp, err := expandBackupDRBackupVaultEncryptionConfig(d.Get("encryption_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("encryption_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(encryptionConfigProp)) && (ok || !reflect.DeepEqual(v, encryptionConfigProp)) {
		obj["encryptionConfig"] = encryptionConfigProp
	}
	effectiveLabelsProp, err := expandBackupDRBackupVaultEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}
	effectiveAnnotationsProp, err := expandBackupDRBackupVaultEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveAnnotationsProp)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BackupDRBasePath}}projects/{{project}}/locations/{{location}}/backupVaults?backupVaultId={{backup_vault_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new BackupVault: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for BackupVault: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating BackupVault: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/backupVaults/{{backup_vault_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if backupVaultIdValue, ok := d.GetOk("backup_vault_id"); ok && backupVaultIdValue.(string) != "" {
			if err = identity.Set("backup_vault_id", backupVaultIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting backup_vault_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = BackupDROperationWaitTime(
		config, res, project, "Creating BackupVault", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create BackupVault: %s", err)
	}

	log.Printf("[DEBUG] Finished creating BackupVault %q: %#v", d.Id(), res)

	return resourceBackupDRBackupVaultRead(d, meta)
}

func resourceBackupDRBackupVaultRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BackupDRBasePath}}projects/{{project}}/locations/{{location}}/backupVaults/{{backup_vault_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for BackupVault: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("BackupDRBackupVault %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}

	if err := d.Set("name", flattenBackupDRBackupVaultName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("description", flattenBackupDRBackupVaultDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("labels", flattenBackupDRBackupVaultLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("create_time", flattenBackupDRBackupVaultCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("update_time", flattenBackupDRBackupVaultUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("backup_minimum_enforced_retention_duration", flattenBackupDRBackupVaultBackupMinimumEnforcedRetentionDuration(res["backupMinimumEnforcedRetentionDuration"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("deletable", flattenBackupDRBackupVaultDeletable(res["deletable"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("etag", flattenBackupDRBackupVaultEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("state", flattenBackupDRBackupVaultState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("effective_time", flattenBackupDRBackupVaultEffectiveTime(res["effectiveTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("backup_count", flattenBackupDRBackupVaultBackupCount(res["backupCount"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("service_account", flattenBackupDRBackupVaultServiceAccount(res["serviceAccount"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("total_stored_bytes", flattenBackupDRBackupVaultTotalStoredBytes(res["totalStoredBytes"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("uid", flattenBackupDRBackupVaultUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("annotations", flattenBackupDRBackupVaultAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("access_restriction", flattenBackupDRBackupVaultAccessRestriction(res["accessRestriction"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("terraform_labels", flattenBackupDRBackupVaultTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("effective_labels", flattenBackupDRBackupVaultEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}
	if err := d.Set("effective_annotations", flattenBackupDRBackupVaultEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading BackupVault: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("backup_vault_id"); !ok && v == "" {
			err = identity.Set("backup_vault_id", d.Get("backup_vault_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting backup_vault_id: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceBackupDRBackupVaultUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if backupVaultIdValue, ok := d.GetOk("backup_vault_id"); ok && backupVaultIdValue.(string) != "" {
			if err = identity.Set("backup_vault_id", backupVaultIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting backup_vault_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for BackupVault: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandBackupDRBackupVaultDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	backupMinimumEnforcedRetentionDurationProp, err := expandBackupDRBackupVaultBackupMinimumEnforcedRetentionDuration(d.Get("backup_minimum_enforced_retention_duration"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backup_minimum_enforced_retention_duration"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, backupMinimumEnforcedRetentionDurationProp)) {
		obj["backupMinimumEnforcedRetentionDuration"] = backupMinimumEnforcedRetentionDurationProp
	}
	effectiveTimeProp, err := expandBackupDRBackupVaultEffectiveTime(d.Get("effective_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveTimeProp)) {
		obj["effectiveTime"] = effectiveTimeProp
	}
	backupRetentionInheritanceProp, err := expandBackupDRBackupVaultBackupRetentionInheritance(d.Get("backup_retention_inheritance"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backup_retention_inheritance"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, backupRetentionInheritanceProp)) {
		obj["backupRetentionInheritance"] = backupRetentionInheritanceProp
	}
	encryptionConfigProp, err := expandBackupDRBackupVaultEncryptionConfig(d.Get("encryption_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("encryption_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, encryptionConfigProp)) {
		obj["encryptionConfig"] = encryptionConfigProp
	}
	effectiveLabelsProp, err := expandBackupDRBackupVaultEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}
	effectiveAnnotationsProp, err := expandBackupDRBackupVaultEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BackupDRBasePath}}projects/{{project}}/locations/{{location}}/backupVaults/{{backup_vault_id}}?force={{force_update}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating BackupVault %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("backup_minimum_enforced_retention_duration") {
		updateMask = append(updateMask, "backupMinimumEnforcedRetentionDuration")
	}

	if d.HasChange("effective_time") {
		updateMask = append(updateMask, "effectiveTime")
	}

	if d.HasChange("backup_retention_inheritance") {
		updateMask = append(updateMask, "backupRetentionInheritance")
	}

	if d.HasChange("encryption_config") {
		updateMask = append(updateMask, "encryptionConfig")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}

	if d.HasChange("effective_annotations") {
		updateMask = append(updateMask, "annotations")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating BackupVault %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating BackupVault %q: %#v", d.Id(), res)
		}

		err = BackupDROperationWaitTime(
			config, res, project, "Updating BackupVault", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceBackupDRBackupVaultRead(d, meta)
}

func resourceBackupDRBackupVaultDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for BackupVault: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{BackupDRBasePath}}projects/{{project}}/locations/{{location}}/backupVaults/{{backup_vault_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	if v, ok := d.GetOk("ignore_inactive_datasources"); ok {
		url, err = transport_tpg.AddQueryParams(url, map[string]string{"force": fmt.Sprintf("%v", v)})
		if err != nil {
			return err
		}
	}
	if v, ok := d.GetOk("force_delete"); ok {
		url, err = transport_tpg.AddQueryParams(url, map[string]string{"force": fmt.Sprintf("%v", v)})
		if err != nil {
			return err
		}
	}
	if v, ok := d.GetOk("ignore_backup_plan_references"); ok {
		url, err = transport_tpg.AddQueryParams(url, map[string]string{"ignoreBackupPlanReferences": fmt.Sprintf("%v", v)})
		if err != nil {
			return err
		}
	}
	if v, ok := d.GetOk("allow_missing"); ok {
		url, err = transport_tpg.AddQueryParams(url, map[string]string{"allowMissing": fmt.Sprintf("%v", v)})
		if err != nil {
			return err
		}
	}

	log.Printf("[DEBUG] Deleting BackupVault %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "BackupVault")
	}

	err = BackupDROperationWaitTime(
		config, res, project, "Deleting BackupVault", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting BackupVault %q: %#v", d.Id(), res)
	return nil
}

func resourceBackupDRBackupVaultImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/backupVaults/(?P<backup_vault_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<backup_vault_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<backup_vault_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/backupVaults/{{backup_vault_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenBackupDRBackupVaultName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenBackupDRBackupVaultCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultBackupMinimumEnforcedRetentionDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultDeletable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultEffectiveTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultBackupCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultTotalStoredBytes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenBackupDRBackupVaultAccessRestriction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenBackupDRBackupVaultEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupVaultEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandBackupDRBackupVaultDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupVaultBackupMinimumEnforcedRetentionDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupVaultEffectiveTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupVaultAccessRestriction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupVaultBackupRetentionInheritance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupVaultEncryptionConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKmsKeyName, err := expandBackupDRBackupVaultEncryptionConfigKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	return transformed, nil
}

func expandBackupDRBackupVaultEncryptionConfigKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupVaultEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandBackupDRBackupVaultEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
