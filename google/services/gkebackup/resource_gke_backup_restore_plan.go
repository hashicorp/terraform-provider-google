// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package gkebackup

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceGKEBackupRestorePlan() *schema.Resource {
	return &schema.Resource{
		Create: resourceGKEBackupRestorePlanCreate,
		Read:   resourceGKEBackupRestorePlanRead,
		Update: resourceGKEBackupRestorePlanUpdate,
		Delete: resourceGKEBackupRestorePlanDelete,

		Importer: &schema.ResourceImporter{
			State: resourceGKEBackupRestorePlanImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"backup_plan": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `A reference to the BackupPlan from which Backups may be used
as the source for Restores created via this RestorePlan.`,
			},
			"cluster": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The source cluster from which Restores will be created via this RestorePlan.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The region of the Restore Plan.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The full name of the BackupPlan Resource.`,
			},
			"restore_config": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `Defines the configuration of Restores created via this RestorePlan.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"all_namespaces": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `If True, restore all namespaced resources in the Backup.
Setting this field to False will result in an error.`,
							ExactlyOneOf: []string{"restore_config.0.all_namespaces", "restore_config.0.excluded_namespaces", "restore_config.0.selected_namespaces", "restore_config.0.selected_applications", "restore_config.0.no_namespaces"},
						},
						"cluster_resource_conflict_policy": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"USE_EXISTING_VERSION", "USE_BACKUP_VERSION", ""}),
							Description: `Defines the behavior for handling the situation where cluster-scoped resources
being restored already exist in the target cluster.
This MUST be set to a value other than 'CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED'
if 'clusterResourceRestoreScope' is anyting other than 'noGroupKinds'.
See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#clusterresourceconflictpolicy
for more information on each policy option. Possible values: ["USE_EXISTING_VERSION", "USE_BACKUP_VERSION"]`,
						},
						"cluster_resource_restore_scope": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Identifies the cluster-scoped resources to restore from the Backup.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"all_group_kinds": {
										Type:     schema.TypeBool,
										Optional: true,
										Description: `If True, all valid cluster-scoped resources will be restored.
Mutually exclusive to any other field in 'clusterResourceRestoreScope'.`,
										ExactlyOneOf: []string{"restore_config.0.cluster_resource_restore_scope.0.all_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.excluded_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.selected_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.no_group_kinds"},
									},
									"excluded_group_kinds": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `A list of cluster-scoped resource group kinds to NOT restore from the backup.
If specified, all valid cluster-scoped resources will be restored except
for those specified in the list.
Mutually exclusive to any other field in 'clusterResourceRestoreScope'.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"resource_group": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `API Group string of a Kubernetes resource, e.g.
"apiextensions.k8s.io", "storage.k8s.io", etc.
Use empty string for core group.`,
												},
												"resource_kind": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `Kind of a Kubernetes resource, e.g.
"CustomResourceDefinition", "StorageClass", etc.`,
												},
											},
										},
										ExactlyOneOf: []string{"restore_config.0.cluster_resource_restore_scope.0.all_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.excluded_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.selected_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.no_group_kinds"},
									},
									"no_group_kinds": {
										Type:     schema.TypeBool,
										Optional: true,
										Description: `If True, no cluster-scoped resources will be restored.
Mutually exclusive to any other field in 'clusterResourceRestoreScope'.`,
										ExactlyOneOf: []string{"restore_config.0.cluster_resource_restore_scope.0.all_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.excluded_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.selected_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.no_group_kinds"},
									},
									"selected_group_kinds": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `A list of cluster-scoped resource group kinds to restore from the backup.
If specified, only the selected resources will be restored.
Mutually exclusive to any other field in the 'clusterResourceRestoreScope'.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"resource_group": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `API Group string of a Kubernetes resource, e.g.
"apiextensions.k8s.io", "storage.k8s.io", etc.
Use empty string for core group.`,
												},
												"resource_kind": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `Kind of a Kubernetes resource, e.g.
"CustomResourceDefinition", "StorageClass", etc.`,
												},
											},
										},
										ExactlyOneOf: []string{"restore_config.0.cluster_resource_restore_scope.0.all_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.excluded_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.selected_group_kinds", "restore_config.0.cluster_resource_restore_scope.0.no_group_kinds"},
									},
								},
							},
						},
						"excluded_namespaces": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `A list of selected namespaces excluded from restoration.
All namespaces except those in this list will be restored.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"namespaces": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `A list of Kubernetes Namespaces.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
							ExactlyOneOf: []string{"restore_config.0.all_namespaces", "restore_config.0.excluded_namespaces", "restore_config.0.selected_namespaces", "restore_config.0.selected_applications", "restore_config.0.no_namespaces"},
						},
						"namespaced_resource_restore_mode": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"DELETE_AND_RESTORE", "FAIL_ON_CONFLICT", ""}),
							Description: `Defines the behavior for handling the situation where sets of namespaced resources
being restored already exist in the target cluster.
This MUST be set to a value other than 'NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED'
if the 'namespacedResourceRestoreScope' is anything other than 'noNamespaces'.
See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#namespacedresourcerestoremode
for more information on each mode. Possible values: ["DELETE_AND_RESTORE", "FAIL_ON_CONFLICT"]`,
						},
						"no_namespaces": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Do not restore any namespaced resources if set to "True".
Specifying this field to "False" is not allowed.`,
							ExactlyOneOf: []string{"restore_config.0.all_namespaces", "restore_config.0.excluded_namespaces", "restore_config.0.selected_namespaces", "restore_config.0.selected_applications", "restore_config.0.no_namespaces"},
						},
						"selected_applications": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `A list of selected ProtectedApplications to restore.
The listed ProtectedApplications and all the resources
to which they refer will be restored.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"namespaced_names": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `A list of namespaced Kubernetes resources.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"name": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The name of a Kubernetes Resource.`,
												},
												"namespace": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The namespace of a Kubernetes Resource.`,
												},
											},
										},
									},
								},
							},
							ExactlyOneOf: []string{"restore_config.0.all_namespaces", "restore_config.0.excluded_namespaces", "restore_config.0.selected_namespaces", "restore_config.0.selected_applications", "restore_config.0.no_namespaces"},
						},
						"selected_namespaces": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `A list of selected namespaces to restore from the Backup.
The listed Namespaces and all resources contained in them will be restored.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"namespaces": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `A list of Kubernetes Namespaces.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
							ExactlyOneOf: []string{"restore_config.0.all_namespaces", "restore_config.0.excluded_namespaces", "restore_config.0.selected_namespaces", "restore_config.0.selected_applications", "restore_config.0.no_namespaces"},
						},
						"transformation_rules": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `A list of transformation rules to be applied against Kubernetes
resources as they are selected for restoration from a Backup.
Rules are executed in order defined - this order matters,
as changes made by a rule may impact the filtering logic of subsequent
rules. An empty list means no transformation will occur.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"field_actions": {
										Type:     schema.TypeList,
										Required: true,
										Description: `A list of transformation rule actions to take against candidate
resources. Actions are executed in order defined - this order
matters, as they could potentially interfere with each other and
the first operation could affect the outcome of the second operation.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"op": {
													Type:         schema.TypeString,
													Required:     true,
													ValidateFunc: verify.ValidateEnum([]string{"REMOVE", "MOVE", "COPY", "ADD", "TEST", "REPLACE"}),
													Description:  `Specifies the operation to perform. Possible values: ["REMOVE", "MOVE", "COPY", "ADD", "TEST", "REPLACE"]`,
												},
												"from_path": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `A string containing a JSON Pointer value that references the
location in the target document to move the value from.`,
												},
												"path": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `A string containing a JSON-Pointer value that references a
location within the target document where the operation is performed.`,
												},
												"value": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `A string that specifies the desired value in string format
to use for transformation.`,
												},
											},
										},
									},
									"description": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The description is a user specified string description
of the transformation rule.`,
									},
									"resource_filter": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `This field is used to specify a set of fields that should be used to
determine which resources in backup should be acted upon by the
supplied transformation rule actions, and this will ensure that only
specific resources are affected by transformation rule actions.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"group_kinds": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `(Filtering parameter) Any resource subject to transformation must
belong to one of the listed "types". If this field is not provided,
no type filtering will be performed
(all resources of all types matching previous filtering parameters
will be candidates for transformation).`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"resource_group": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `API Group string of a Kubernetes resource, e.g.
"apiextensions.k8s.io", "storage.k8s.io", etc.
Use empty string for core group.`,
															},
															"resource_kind": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `Kind of a Kubernetes resource, e.g.
"CustomResourceDefinition", "StorageClass", etc.`,
															},
														},
													},
												},
												"json_path": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `This is a JSONPath expression that matches specific fields of
candidate resources and it operates as a filtering parameter
(resources that are not matched with this expression will not
be candidates for transformation).`,
												},
												"namespaces": {
													Type:     schema.TypeList,
													Optional: true,
													Description: `(Filtering parameter) Any resource subject to transformation must
be contained within one of the listed Kubernetes Namespace in the
Backup. If this field is not provided, no namespace filtering will
be performed (all resources in all Namespaces, including all
cluster-scoped resources, will be candidates for transformation).
To mix cluster-scoped and namespaced resources in the same rule,
use an empty string ("") as one of the target namespaces.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
								},
							},
						},
						"volume_data_restore_policy": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"RESTORE_VOLUME_DATA_FROM_BACKUP", "REUSE_VOLUME_HANDLE_FROM_BACKUP", "NO_VOLUME_DATA_RESTORATION", ""}),
							Description: `Specifies the mechanism to be used to restore volume data.
This should be set to a value other than 'NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED'
if the 'namespacedResourceRestoreScope' is anything other than 'noNamespaces'.
If not specified, it will be treated as 'NO_VOLUME_DATA_RESTORATION'.
See https://cloud.google.com/kubernetes-engine/docs/add-on/backup-for-gke/reference/rest/v1/RestoreConfig#VolumeDataRestorePolicy
for more information on each policy option. Possible values: ["RESTORE_VOLUME_DATA_FROM_BACKUP", "REUSE_VOLUME_HANDLE_FROM_BACKUP", "NO_VOLUME_DATA_RESTORATION"]`,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `User specified descriptive string for this RestorePlan.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Description: A set of custom labels supplied by the user.
A list of key->value pairs.
Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The State of the RestorePlan.`,
			},
			"state_reason": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Detailed description of why RestorePlan is in its current state.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Server generated, unique identifier of UUID format.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceGKEBackupRestorePlanCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandGKEBackupRestorePlanName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	descriptionProp, err := expandGKEBackupRestorePlanDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	backupPlanProp, err := expandGKEBackupRestorePlanBackupPlan(d.Get("backup_plan"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backup_plan"); !tpgresource.IsEmptyValue(reflect.ValueOf(backupPlanProp)) && (ok || !reflect.DeepEqual(v, backupPlanProp)) {
		obj["backupPlan"] = backupPlanProp
	}
	clusterProp, err := expandGKEBackupRestorePlanCluster(d.Get("cluster"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(clusterProp)) && (ok || !reflect.DeepEqual(v, clusterProp)) {
		obj["cluster"] = clusterProp
	}
	restoreConfigProp, err := expandGKEBackupRestorePlanRestoreConfig(d.Get("restore_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("restore_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(restoreConfigProp)) && (ok || !reflect.DeepEqual(v, restoreConfigProp)) {
		obj["restoreConfig"] = restoreConfigProp
	}
	labelsProp, err := expandGKEBackupRestorePlanEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GKEBackupBasePath}}projects/{{project}}/locations/{{location}}/restorePlans?restorePlanId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new RestorePlan: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RestorePlan: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating RestorePlan: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/restorePlans/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = GKEBackupOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating RestorePlan", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create RestorePlan: %s", err)
	}

	if err := d.Set("name", flattenGKEBackupRestorePlanName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/restorePlans/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating RestorePlan %q: %#v", d.Id(), res)

	return resourceGKEBackupRestorePlanRead(d, meta)
}

func resourceGKEBackupRestorePlanRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GKEBackupBasePath}}projects/{{project}}/locations/{{location}}/restorePlans/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RestorePlan: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("GKEBackupRestorePlan %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}

	if err := d.Set("name", flattenGKEBackupRestorePlanName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}
	if err := d.Set("uid", flattenGKEBackupRestorePlanUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}
	if err := d.Set("description", flattenGKEBackupRestorePlanDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}
	if err := d.Set("labels", flattenGKEBackupRestorePlanLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}
	if err := d.Set("backup_plan", flattenGKEBackupRestorePlanBackupPlan(res["backupPlan"], d, config)); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}
	if err := d.Set("cluster", flattenGKEBackupRestorePlanCluster(res["cluster"], d, config)); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}
	if err := d.Set("restore_config", flattenGKEBackupRestorePlanRestoreConfig(res["restoreConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}
	if err := d.Set("state", flattenGKEBackupRestorePlanState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}
	if err := d.Set("state_reason", flattenGKEBackupRestorePlanStateReason(res["stateReason"], d, config)); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}
	if err := d.Set("terraform_labels", flattenGKEBackupRestorePlanTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}
	if err := d.Set("effective_labels", flattenGKEBackupRestorePlanEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading RestorePlan: %s", err)
	}

	return nil
}

func resourceGKEBackupRestorePlanUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RestorePlan: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandGKEBackupRestorePlanDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	restoreConfigProp, err := expandGKEBackupRestorePlanRestoreConfig(d.Get("restore_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("restore_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, restoreConfigProp)) {
		obj["restoreConfig"] = restoreConfigProp
	}
	labelsProp, err := expandGKEBackupRestorePlanEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GKEBackupBasePath}}projects/{{project}}/locations/{{location}}/restorePlans/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating RestorePlan %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("restore_config") {
		updateMask = append(updateMask, "restoreConfig")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "PATCH",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutUpdate),
	})

	if err != nil {
		return fmt.Errorf("Error updating RestorePlan %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating RestorePlan %q: %#v", d.Id(), res)
	}

	err = GKEBackupOperationWaitTime(
		config, res, project, "Updating RestorePlan", userAgent,
		d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return err
	}

	return resourceGKEBackupRestorePlanRead(d, meta)
}

func resourceGKEBackupRestorePlanDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RestorePlan: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{GKEBackupBasePath}}projects/{{project}}/locations/{{location}}/restorePlans/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting RestorePlan %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "RestorePlan")
	}

	err = GKEBackupOperationWaitTime(
		config, res, project, "Deleting RestorePlan", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting RestorePlan %q: %#v", d.Id(), res)
	return nil
}

func resourceGKEBackupRestorePlanImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/restorePlans/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/restorePlans/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenGKEBackupRestorePlanName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.NameFromSelfLinkStateFunc(v)
}

func flattenGKEBackupRestorePlanUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenGKEBackupRestorePlanBackupPlan(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanCluster(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["all_namespaces"] =
		flattenGKEBackupRestorePlanRestoreConfigAllNamespaces(original["allNamespaces"], d, config)
	transformed["excluded_namespaces"] =
		flattenGKEBackupRestorePlanRestoreConfigExcludedNamespaces(original["excludedNamespaces"], d, config)
	transformed["selected_namespaces"] =
		flattenGKEBackupRestorePlanRestoreConfigSelectedNamespaces(original["selectedNamespaces"], d, config)
	transformed["selected_applications"] =
		flattenGKEBackupRestorePlanRestoreConfigSelectedApplications(original["selectedApplications"], d, config)
	transformed["no_namespaces"] =
		flattenGKEBackupRestorePlanRestoreConfigNoNamespaces(original["noNamespaces"], d, config)
	transformed["namespaced_resource_restore_mode"] =
		flattenGKEBackupRestorePlanRestoreConfigNamespacedResourceRestoreMode(original["namespacedResourceRestoreMode"], d, config)
	transformed["volume_data_restore_policy"] =
		flattenGKEBackupRestorePlanRestoreConfigVolumeDataRestorePolicy(original["volumeDataRestorePolicy"], d, config)
	transformed["cluster_resource_restore_scope"] =
		flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScope(original["clusterResourceRestoreScope"], d, config)
	transformed["cluster_resource_conflict_policy"] =
		flattenGKEBackupRestorePlanRestoreConfigClusterResourceConflictPolicy(original["clusterResourceConflictPolicy"], d, config)
	transformed["transformation_rules"] =
		flattenGKEBackupRestorePlanRestoreConfigTransformationRules(original["transformationRules"], d, config)
	return []interface{}{transformed}
}
func flattenGKEBackupRestorePlanRestoreConfigAllNamespaces(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigExcludedNamespaces(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["namespaces"] =
		flattenGKEBackupRestorePlanRestoreConfigExcludedNamespacesNamespaces(original["namespaces"], d, config)
	return []interface{}{transformed}
}
func flattenGKEBackupRestorePlanRestoreConfigExcludedNamespacesNamespaces(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigSelectedNamespaces(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["namespaces"] =
		flattenGKEBackupRestorePlanRestoreConfigSelectedNamespacesNamespaces(original["namespaces"], d, config)
	return []interface{}{transformed}
}
func flattenGKEBackupRestorePlanRestoreConfigSelectedNamespacesNamespaces(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigSelectedApplications(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["namespaced_names"] =
		flattenGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNames(original["namespacedNames"], d, config)
	return []interface{}{transformed}
}
func flattenGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNames(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"namespace": flattenGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNamesNamespace(original["namespace"], d, config),
			"name":      flattenGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNamesName(original["name"], d, config),
		})
	}
	return transformed
}
func flattenGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNamesNamespace(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNamesName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigNoNamespaces(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigNamespacedResourceRestoreMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigVolumeDataRestorePolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["all_group_kinds"] =
		flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeAllGroupKinds(original["allGroupKinds"], d, config)
	transformed["excluded_group_kinds"] =
		flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKinds(original["excludedGroupKinds"], d, config)
	transformed["selected_group_kinds"] =
		flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKinds(original["selectedGroupKinds"], d, config)
	transformed["no_group_kinds"] =
		flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeNoGroupKinds(original["noGroupKinds"], d, config)
	return []interface{}{transformed}
}
func flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeAllGroupKinds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKinds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"resource_group": flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKindsResourceGroup(original["resourceGroup"], d, config),
			"resource_kind":  flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKindsResourceKind(original["resourceKind"], d, config),
		})
	}
	return transformed
}
func flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKindsResourceGroup(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKindsResourceKind(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKinds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"resource_group": flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKindsResourceGroup(original["resourceGroup"], d, config),
			"resource_kind":  flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKindsResourceKind(original["resourceKind"], d, config),
		})
	}
	return transformed
}
func flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKindsResourceGroup(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKindsResourceKind(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeNoGroupKinds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigClusterResourceConflictPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigTransformationRules(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description":     flattenGKEBackupRestorePlanRestoreConfigTransformationRulesDescription(original["description"], d, config),
			"resource_filter": flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilter(original["resourceFilter"], d, config),
			"field_actions":   flattenGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActions(original["fieldActions"], d, config),
		})
	}
	return transformed
}
func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["namespaces"] =
		flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterNamespaces(original["namespaces"], d, config)
	transformed["group_kinds"] =
		flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKinds(original["groupKinds"], d, config)
	transformed["json_path"] =
		flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterJsonPath(original["jsonPath"], d, config)
	return []interface{}{transformed}
}
func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterNamespaces(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKinds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"resource_group": flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKindsResourceGroup(original["resourceGroup"], d, config),
			"resource_kind":  flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKindsResourceKind(original["resourceKind"], d, config),
		})
	}
	return transformed
}
func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKindsResourceGroup(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKindsResourceKind(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterJsonPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"op":        flattenGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsOp(original["op"], d, config),
			"from_path": flattenGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsFromPath(original["fromPath"], d, config),
			"path":      flattenGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsPath(original["path"], d, config),
			"value":     flattenGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsOp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsFromPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanStateReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGKEBackupRestorePlanTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenGKEBackupRestorePlanEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandGKEBackupRestorePlanName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/restorePlans/{{name}}")
}

func expandGKEBackupRestorePlanDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanBackupPlan(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanCluster(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAllNamespaces, err := expandGKEBackupRestorePlanRestoreConfigAllNamespaces(original["all_namespaces"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllNamespaces); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allNamespaces"] = transformedAllNamespaces
	}

	transformedExcludedNamespaces, err := expandGKEBackupRestorePlanRestoreConfigExcludedNamespaces(original["excluded_namespaces"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExcludedNamespaces); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["excludedNamespaces"] = transformedExcludedNamespaces
	}

	transformedSelectedNamespaces, err := expandGKEBackupRestorePlanRestoreConfigSelectedNamespaces(original["selected_namespaces"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSelectedNamespaces); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["selectedNamespaces"] = transformedSelectedNamespaces
	}

	transformedSelectedApplications, err := expandGKEBackupRestorePlanRestoreConfigSelectedApplications(original["selected_applications"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSelectedApplications); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["selectedApplications"] = transformedSelectedApplications
	}

	transformedNoNamespaces, err := expandGKEBackupRestorePlanRestoreConfigNoNamespaces(original["no_namespaces"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNoNamespaces); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["noNamespaces"] = transformedNoNamespaces
	}

	transformedNamespacedResourceRestoreMode, err := expandGKEBackupRestorePlanRestoreConfigNamespacedResourceRestoreMode(original["namespaced_resource_restore_mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNamespacedResourceRestoreMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["namespacedResourceRestoreMode"] = transformedNamespacedResourceRestoreMode
	}

	transformedVolumeDataRestorePolicy, err := expandGKEBackupRestorePlanRestoreConfigVolumeDataRestorePolicy(original["volume_data_restore_policy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVolumeDataRestorePolicy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["volumeDataRestorePolicy"] = transformedVolumeDataRestorePolicy
	}

	transformedClusterResourceRestoreScope, err := expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScope(original["cluster_resource_restore_scope"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClusterResourceRestoreScope); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clusterResourceRestoreScope"] = transformedClusterResourceRestoreScope
	}

	transformedClusterResourceConflictPolicy, err := expandGKEBackupRestorePlanRestoreConfigClusterResourceConflictPolicy(original["cluster_resource_conflict_policy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClusterResourceConflictPolicy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clusterResourceConflictPolicy"] = transformedClusterResourceConflictPolicy
	}

	transformedTransformationRules, err := expandGKEBackupRestorePlanRestoreConfigTransformationRules(original["transformation_rules"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTransformationRules); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["transformationRules"] = transformedTransformationRules
	}

	return transformed, nil
}

func expandGKEBackupRestorePlanRestoreConfigAllNamespaces(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigExcludedNamespaces(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNamespaces, err := expandGKEBackupRestorePlanRestoreConfigExcludedNamespacesNamespaces(original["namespaces"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNamespaces); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["namespaces"] = transformedNamespaces
	}

	return transformed, nil
}

func expandGKEBackupRestorePlanRestoreConfigExcludedNamespacesNamespaces(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigSelectedNamespaces(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNamespaces, err := expandGKEBackupRestorePlanRestoreConfigSelectedNamespacesNamespaces(original["namespaces"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNamespaces); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["namespaces"] = transformedNamespaces
	}

	return transformed, nil
}

func expandGKEBackupRestorePlanRestoreConfigSelectedNamespacesNamespaces(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigSelectedApplications(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNamespacedNames, err := expandGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNames(original["namespaced_names"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNamespacedNames); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["namespacedNames"] = transformedNamespacedNames
	}

	return transformed, nil
}

func expandGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNames(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedNamespace, err := expandGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNamesNamespace(original["namespace"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNamespace); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["namespace"] = transformedNamespace
		}

		transformedName, err := expandGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNamesName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNamesNamespace(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigSelectedApplicationsNamespacedNamesName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigNoNamespaces(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigNamespacedResourceRestoreMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigVolumeDataRestorePolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScope(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAllGroupKinds, err := expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeAllGroupKinds(original["all_group_kinds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllGroupKinds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allGroupKinds"] = transformedAllGroupKinds
	}

	transformedExcludedGroupKinds, err := expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKinds(original["excluded_group_kinds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExcludedGroupKinds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["excludedGroupKinds"] = transformedExcludedGroupKinds
	}

	transformedSelectedGroupKinds, err := expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKinds(original["selected_group_kinds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSelectedGroupKinds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["selectedGroupKinds"] = transformedSelectedGroupKinds
	}

	transformedNoGroupKinds, err := expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeNoGroupKinds(original["no_group_kinds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNoGroupKinds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["noGroupKinds"] = transformedNoGroupKinds
	}

	return transformed, nil
}

func expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeAllGroupKinds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKinds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedResourceGroup, err := expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKindsResourceGroup(original["resource_group"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResourceGroup); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resourceGroup"] = transformedResourceGroup
		}

		transformedResourceKind, err := expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKindsResourceKind(original["resource_kind"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResourceKind); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resourceKind"] = transformedResourceKind
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKindsResourceGroup(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeExcludedGroupKindsResourceKind(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKinds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedResourceGroup, err := expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKindsResourceGroup(original["resource_group"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResourceGroup); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resourceGroup"] = transformedResourceGroup
		}

		transformedResourceKind, err := expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKindsResourceKind(original["resource_kind"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResourceKind); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resourceKind"] = transformedResourceKind
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKindsResourceGroup(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeSelectedGroupKindsResourceKind(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigClusterResourceRestoreScopeNoGroupKinds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigClusterResourceConflictPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRules(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDescription, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesDescription(original["description"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["description"] = transformedDescription
		}

		transformedResourceFilter, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilter(original["resource_filter"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResourceFilter); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resourceFilter"] = transformedResourceFilter
		}

		transformedFieldActions, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActions(original["field_actions"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFieldActions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["fieldActions"] = transformedFieldActions
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNamespaces, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterNamespaces(original["namespaces"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNamespaces); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["namespaces"] = transformedNamespaces
	}

	transformedGroupKinds, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKinds(original["group_kinds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGroupKinds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["groupKinds"] = transformedGroupKinds
	}

	transformedJsonPath, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterJsonPath(original["json_path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedJsonPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["jsonPath"] = transformedJsonPath
	}

	return transformed, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterNamespaces(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKinds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedResourceGroup, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKindsResourceGroup(original["resource_group"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResourceGroup); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resourceGroup"] = transformedResourceGroup
		}

		transformedResourceKind, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKindsResourceKind(original["resource_kind"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResourceKind); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resourceKind"] = transformedResourceKind
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKindsResourceGroup(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterGroupKindsResourceKind(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesResourceFilterJsonPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedOp, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsOp(original["op"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["op"] = transformedOp
		}

		transformedFromPath, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsFromPath(original["from_path"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFromPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["fromPath"] = transformedFromPath
		}

		transformedPath, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsPath(original["path"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["path"] = transformedPath
		}

		transformedValue, err := expandGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsOp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsFromPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanRestoreConfigTransformationRulesFieldActionsValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGKEBackupRestorePlanEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
