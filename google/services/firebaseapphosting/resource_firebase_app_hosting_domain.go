// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/firebaseapphosting/Domain.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package firebaseapphosting

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceFirebaseAppHostingDomain() *schema.Resource {
	return &schema.Resource{
		Create: resourceFirebaseAppHostingDomainCreate,
		Read:   resourceFirebaseAppHostingDomainRead,
		Update: resourceFirebaseAppHostingDomainUpdate,
		Delete: resourceFirebaseAppHostingDomainDelete,

		Importer: &schema.ResourceImporter{
			State: resourceFirebaseAppHostingDomainImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"backend": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The ID of the Backend that this Domain is associated with`,
			},
			"domain_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Id of the domain to create.
Must be a valid domain name, such as "foo.com"`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the Backend that this Domain is associated with`,
			},
			"serve": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `The serving behavior of the domain. If specified, the domain will
serve content other than its Backend's live content.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"redirect": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Specifies redirect behavior for a domain.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"uri": {
										Type:     schema.TypeString,
										Required: true,
										Description: `The URI of the redirect's intended destination. This URI will be
prepended to the original request path. URI without a scheme are
assumed to be HTTPS.`,
									},
									"status": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The status code to use in a redirect response. Must be a valid HTTP 3XX
status code. Defaults to 302 if not present.`,
									},
								},
							},
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time at which the domain was created.`,
			},
			"custom_domain_status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The status of a custom domain's linkage to the Backend.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cert_state": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Possible values:
CERT_PREPARING
CERT_VALIDATING
CERT_PROPAGATING
CERT_ACTIVE
CERT_EXPIRING_SOON
CERT_EXPIRED`,
						},
						"host_state": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Possible values:
HOST_UNHOSTED
HOST_UNREACHABLE
HOST_NON_FAH
HOST_CONFLICT
HOST_WRONG_SHARD
HOST_ACTIVE`,
						},
						"issues": {
							Type:     schema.TypeList,
							Computed: true,
							Description: `A list of issues with domain configuration. Allows users to self-correct
problems with DNS records.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"code": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `The status code, which should be an enum value of google.rpc.Code.`,
									},
									"details": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `A list of messages that carry the error details.`,
									},
									"message": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `A developer-facing error message, which should be in English. Any
user-facing error message should be localized and sent in the
google.rpc.Status.details field, or localized by the client.`,
									},
								},
							},
						},
						"ownership_state": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Possible values:
OWNERSHIP_MISSING
OWNERSHIP_UNREACHABLE
OWNERSHIP_MISMATCH
OWNERSHIP_CONFLICT
OWNERSHIP_PENDING
OWNERSHIP_ACTIVE`,
						},
						"required_dns_updates": {
							Type:     schema.TypeList,
							Computed: true,
							Description: `Lists the records that must added or removed to a custom domain's DNS
in order to finish setup and start serving content.
Field is present during onboarding. Also present after onboarding if one
or more of the above states is not *_ACTIVE, indicating the domain's DNS
records are in a bad state.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"check_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The last time App Hosting checked your custom domain's DNS records.`,
									},
									"desired": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `The set of DNS records App Hosting needs in order to be able to serve
secure content on the domain.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"check_error": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `The 'Status' type defines a logical error model that is suitable for
different programming environments, including REST APIs and RPC APIs. It is
used by [gRPC](https://github.com/grpc). Each 'Status' message contains
three pieces of data: error code, error message, and error details.

You can find out more about this error model and how to work with it in the
[API Design Guide](https://cloud.google.com/apis/design/errors).`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"code": {
																Type:        schema.TypeInt,
																Computed:    true,
																Description: `The status code, which should be an enum value of google.rpc.Code.`,
															},
															"details": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `A list of messages that carry the error details.`,
															},
															"message": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `A developer-facing error message, which should be in English. Any
user-facing error message should be localized and sent in the
google.rpc.Status.details field, or localized by the client.`,
															},
														},
													},
												},
												"domain_name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The domain name the record set pertains to.`,
												},
												"records": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Records on the domain.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"domain_name": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The domain the record pertains to, e.g. 'foo.bar.com.'.`,
															},
															"rdata": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The data of the record. The meaning of the value depends on record type:
- A and AAAA: IP addresses for the domain.
- CNAME: Another domain to check for records.
- TXT: Arbitrary text strings associated with the domain. App Hosting
uses TXT records to determine which Firebase projects have
permission to act on the domain's behalf.
- CAA: The record's flags, tag, and value, e.g. '0 issue "pki.goog"'.`,
															},
															"relevant_state": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `An enum that indicates which state(s) this DNS record applies to. Populated
for all records with an 'ADD' or 'REMOVE' required action.`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"required_action": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `An enum that indicates the a required action for this record. Populated
when the record is part of a required change in a  'DnsUpdates'
'discovered' or 'desired' record set.
Possible values:
NONE
ADD
REMOVE`,
															},
															"type": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The record's type, which determines what data the record contains.
Possible values:
A
CNAME
TXT
AAAA
CAA`,
															},
														},
													},
												},
											},
										},
									},
									"discovered": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The set of DNS records App Hosting discovered when inspecting a domain.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"check_error": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `The 'Status' type defines a logical error model that is suitable for
different programming environments, including REST APIs and RPC APIs. It is
used by [gRPC](https://github.com/grpc). Each 'Status' message contains
three pieces of data: error code, error message, and error details.

You can find out more about this error model and how to work with it in the
[API Design Guide](https://cloud.google.com/apis/design/errors).`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"code": {
																Type:        schema.TypeInt,
																Computed:    true,
																Description: `The status code, which should be an enum value of google.rpc.Code.`,
															},
															"details": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `A list of messages that carry the error details.`,
															},
															"message": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `A developer-facing error message, which should be in English. Any
user-facing error message should be localized and sent in the
google.rpc.Status.details field, or localized by the client.`,
															},
														},
													},
												},
												"domain_name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The domain name the record set pertains to.`,
												},
												"records": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Records on the domain.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"domain_name": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The domain the record pertains to, e.g. 'foo.bar.com.'.`,
															},
															"rdata": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The data of the record. The meaning of the value depends on record type:
- A and AAAA: IP addresses for the domain.
- CNAME: Another domain to check for records.
- TXT: Arbitrary text strings associated with the domain. App Hosting
uses TXT records to determine which Firebase projects have
permission to act on the domain's behalf.
- CAA: The record's flags, tag, and value, e.g. '0 issue "pki.goog"'.`,
															},
															"relevant_state": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `An enum that indicates which state(s) this DNS record applies to. Populated
for all records with an 'ADD' or 'REMOVE' required action.`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"required_action": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `An enum that indicates the a required action for this record. Populated
when the record is part of a required change in a  'DnsUpdates'
'discovered' or 'desired' record set.
Possible values:
NONE
ADD
REMOVE`,
															},
															"type": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The record's type, which determines what data the record contains.
Possible values:
A
CNAME
TXT
AAAA
CAA`,
															},
														},
													},
												},
											},
										},
									},
									"domain_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The domain name the DNS updates pertain to.`,
									},
								},
							},
						},
					},
				},
			},
			"delete_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time at which the domain was deleted.`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Server-computed checksum based on other values; may be sent
on update or delete to ensure operation is done on expected resource.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The resource name of the domain, e.g.
'projects/{project}/locations/{locationId}/backends/{backendId}/domains/{domainId}'`,
			},
			"purge_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Time at which a soft-deleted domain will be purged, rendering in
permanently deleted.`,
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `System-assigned, unique identifier.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time at which the domain was last updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceFirebaseAppHostingDomainCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	serveProp, err := expandFirebaseAppHostingDomainServe(d.Get("serve"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("serve"); !tpgresource.IsEmptyValue(reflect.ValueOf(serveProp)) && (ok || !reflect.DeepEqual(v, serveProp)) {
		obj["serve"] = serveProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{FirebaseAppHostingBasePath}}projects/{{project}}/locations/{{location}}/backends/{{backend}}/domains?domainId={{domain_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Domain: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Domain: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Domain: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/backends/{{backend}}/domains/{{domain_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Domain %q: %#v", d.Id(), res)

	return resourceFirebaseAppHostingDomainRead(d, meta)
}

func resourceFirebaseAppHostingDomainPollRead(d *schema.ResourceData, meta interface{}) transport_tpg.PollReadFunc {
	return func() (map[string]interface{}, error) {
		config := meta.(*transport_tpg.Config)

		url, err := tpgresource.ReplaceVars(d, config, "{{FirebaseAppHostingBasePath}}projects/{{project}}/locations/{{location}}/backends/{{backend}}/domains/{{domain_id}}")

		if err != nil {
			return nil, err
		}

		billingProject := ""

		project, err := tpgresource.GetProject(d, config)
		if err != nil {
			return nil, fmt.Errorf("Error fetching project for Domain: %s", err)
		}
		billingProject = project

		// err == nil indicates that the billing_project value was found
		if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
			billingProject = bp
		}

		userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
		if err != nil {
			return nil, err
		}

		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "GET",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
		})
		if err != nil {
			return res, err
		}
		return res, nil
	}
}

func resourceFirebaseAppHostingDomainRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{FirebaseAppHostingBasePath}}projects/{{project}}/locations/{{location}}/backends/{{backend}}/domains/{{domain_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Domain: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("FirebaseAppHostingDomain %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Domain: %s", err)
	}

	if err := d.Set("custom_domain_status", flattenFirebaseAppHostingDomainCustomDomainStatus(res["customDomainStatus"], d, config)); err != nil {
		return fmt.Errorf("Error reading Domain: %s", err)
	}
	if err := d.Set("name", flattenFirebaseAppHostingDomainName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Domain: %s", err)
	}
	if err := d.Set("uid", flattenFirebaseAppHostingDomainUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading Domain: %s", err)
	}
	if err := d.Set("etag", flattenFirebaseAppHostingDomainEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Domain: %s", err)
	}
	if err := d.Set("serve", flattenFirebaseAppHostingDomainServe(res["serve"], d, config)); err != nil {
		return fmt.Errorf("Error reading Domain: %s", err)
	}
	if err := d.Set("update_time", flattenFirebaseAppHostingDomainUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Domain: %s", err)
	}
	if err := d.Set("purge_time", flattenFirebaseAppHostingDomainPurgeTime(res["purgeTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Domain: %s", err)
	}
	if err := d.Set("delete_time", flattenFirebaseAppHostingDomainDeleteTime(res["deleteTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Domain: %s", err)
	}
	if err := d.Set("create_time", flattenFirebaseAppHostingDomainCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Domain: %s", err)
	}

	return nil
}

func resourceFirebaseAppHostingDomainUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Domain: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	serveProp, err := expandFirebaseAppHostingDomainServe(d.Get("serve"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("serve"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, serveProp)) {
		obj["serve"] = serveProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{FirebaseAppHostingBasePath}}projects/{{project}}/locations/{{location}}/backends/{{backend}}/domains/{{domain_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Domain %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("serve") {
		updateMask = append(updateMask, "serve")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Domain %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Domain %q: %#v", d.Id(), res)
		}

		err = transport_tpg.PollingWaitTime(resourceFirebaseAppHostingDomainPollRead(d, meta), transport_tpg.PollCheckForExistence, "Updating Domain", d.Timeout(schema.TimeoutUpdate), 1)
		if err != nil {
			log.Printf("[ERROR] Unable to confirm eventually consistent Domain%q finished updating: %q", d.Id(), err)

		}
	}

	return resourceFirebaseAppHostingDomainRead(d, meta)
}

func resourceFirebaseAppHostingDomainDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Domain: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{FirebaseAppHostingBasePath}}projects/{{project}}/locations/{{location}}/backends/{{backend}}/domains/{{domain_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Domain %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Domain")
	}

	err = transport_tpg.PollingWaitTime(resourceFirebaseAppHostingDomainPollRead(d, meta), transport_tpg.PollCheckForAbsence, "Deleting Domain", d.Timeout(schema.TimeoutCreate), 1)
	if err != nil {
		log.Printf("[ERROR] Unable to confirm eventually consistent Domain %q finished updating: %q", d.Id(), err)
	}

	log.Printf("[DEBUG] Finished deleting Domain %q: %#v", d.Id(), res)
	return nil
}

func resourceFirebaseAppHostingDomainImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/backends/(?P<backend>[^/]+)/domains/(?P<domain_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<backend>[^/]+)/(?P<domain_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<backend>[^/]+)/(?P<domain_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/backends/{{backend}}/domains/{{domain_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenFirebaseAppHostingDomainCustomDomainStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cert_state"] =
		flattenFirebaseAppHostingDomainCustomDomainStatusCertState(original["certState"], d, config)
	transformed["required_dns_updates"] =
		flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdates(original["requiredDnsUpdates"], d, config)
	transformed["issues"] =
		flattenFirebaseAppHostingDomainCustomDomainStatusIssues(original["issues"], d, config)
	transformed["host_state"] =
		flattenFirebaseAppHostingDomainCustomDomainStatusHostState(original["hostState"], d, config)
	transformed["ownership_state"] =
		flattenFirebaseAppHostingDomainCustomDomainStatusOwnershipState(original["ownershipState"], d, config)
	return []interface{}{transformed}
}
func flattenFirebaseAppHostingDomainCustomDomainStatusCertState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdates(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"domain_name": flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDomainName(original["domainName"], d, config),
			"discovered":  flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscovered(original["discovered"], d, config),
			"desired":     flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesired(original["desired"], d, config),
			"check_time":  flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesCheckTime(original["checkTime"], d, config),
		})
	}
	return transformed
}
func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDomainName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscovered(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"domain_name": flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredDomainName(original["domainName"], d, config),
			"check_error": flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredCheckError(original["checkError"], d, config),
			"records":     flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecords(original["records"], d, config),
		})
	}
	return transformed
}
func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredDomainName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredCheckError(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["code"] =
		flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredCheckErrorCode(original["code"], d, config)
	transformed["message"] =
		flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredCheckErrorMessage(original["message"], d, config)
	transformed["details"] =
		flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredCheckErrorDetails(original["details"], d, config)
	return []interface{}{transformed}
}
func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredCheckErrorCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredCheckErrorMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredCheckErrorDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecords(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"domain_name":     flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecordsDomainName(original["domainName"], d, config),
			"type":            flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecordsType(original["type"], d, config),
			"rdata":           flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecordsRdata(original["rdata"], d, config),
			"required_action": flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecordsRequiredAction(original["requiredAction"], d, config),
			"relevant_state":  flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecordsRelevantState(original["relevantState"], d, config),
		})
	}
	return transformed
}
func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecordsDomainName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecordsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecordsRdata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecordsRequiredAction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDiscoveredRecordsRelevantState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesired(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"domain_name": flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredDomainName(original["domainName"], d, config),
			"check_error": flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredCheckError(original["checkError"], d, config),
			"records":     flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecords(original["records"], d, config),
		})
	}
	return transformed
}
func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredDomainName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredCheckError(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["code"] =
		flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredCheckErrorCode(original["code"], d, config)
	transformed["message"] =
		flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredCheckErrorMessage(original["message"], d, config)
	transformed["details"] =
		flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredCheckErrorDetails(original["details"], d, config)
	return []interface{}{transformed}
}
func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredCheckErrorCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredCheckErrorMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredCheckErrorDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecords(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"required_action": flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecordsRequiredAction(original["requiredAction"], d, config),
			"relevant_state":  flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecordsRelevantState(original["relevantState"], d, config),
			"domain_name":     flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecordsDomainName(original["domainName"], d, config),
			"type":            flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecordsType(original["type"], d, config),
			"rdata":           flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecordsRdata(original["rdata"], d, config),
		})
	}
	return transformed
}
func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecordsRequiredAction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecordsRelevantState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecordsDomainName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecordsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesDesiredRecordsRdata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusRequiredDnsUpdatesCheckTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusIssues(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"code":    flattenFirebaseAppHostingDomainCustomDomainStatusIssuesCode(original["code"], d, config),
			"message": flattenFirebaseAppHostingDomainCustomDomainStatusIssuesMessage(original["message"], d, config),
			"details": flattenFirebaseAppHostingDomainCustomDomainStatusIssuesDetails(original["details"], d, config),
		})
	}
	return transformed
}
func flattenFirebaseAppHostingDomainCustomDomainStatusIssuesCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenFirebaseAppHostingDomainCustomDomainStatusIssuesMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusIssuesDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenFirebaseAppHostingDomainCustomDomainStatusHostState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCustomDomainStatusOwnershipState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainServe(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["redirect"] =
		flattenFirebaseAppHostingDomainServeRedirect(original["redirect"], d, config)
	return []interface{}{transformed}
}
func flattenFirebaseAppHostingDomainServeRedirect(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenFirebaseAppHostingDomainServeRedirectUri(original["uri"], d, config)
	transformed["status"] =
		flattenFirebaseAppHostingDomainServeRedirectStatus(original["status"], d, config)
	return []interface{}{transformed}
}
func flattenFirebaseAppHostingDomainServeRedirectUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainServeRedirectStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainPurgeTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainDeleteTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingDomainCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandFirebaseAppHostingDomainServe(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRedirect, err := expandFirebaseAppHostingDomainServeRedirect(original["redirect"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRedirect); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["redirect"] = transformedRedirect
	}

	return transformed, nil
}

func expandFirebaseAppHostingDomainServeRedirect(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandFirebaseAppHostingDomainServeRedirectUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedStatus, err := expandFirebaseAppHostingDomainServeRedirectStatus(original["status"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStatus); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["status"] = transformedStatus
	}

	return transformed, nil
}

func expandFirebaseAppHostingDomainServeRedirectUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingDomainServeRedirectStatus(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
