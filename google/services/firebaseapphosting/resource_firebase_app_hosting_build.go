// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/firebaseapphosting/Build.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package firebaseapphosting

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceFirebaseAppHostingBuild() *schema.Resource {
	return &schema.Resource{
		Create: resourceFirebaseAppHostingBuildCreate,
		Read:   resourceFirebaseAppHostingBuildRead,
		Update: resourceFirebaseAppHostingBuildUpdate,
		Delete: resourceFirebaseAppHostingBuildDelete,

		Importer: &schema.ResourceImporter{
			State: resourceFirebaseAppHostingBuildImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"backend": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description:      `The ID of the Backend that this Build applies to`,
			},
			"build_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The user-specified ID of the build being created.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the Backend that this Build applies to`,
			},
			"source": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `The source for the build.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"codebase": {
							Type:     schema.TypeList,
							Optional: true,
							ForceNew: true,
							Description: `A codebase source, representing the state of the codebase
that the build will be created at.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"branch": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `The branch in the codebase to build from, using the latest commit.`,
									},
									"commit": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `The commit in the codebase to build from.`,
									},
									"author": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Version control metadata for a user associated with a resolved codebase.
Currently assumes a Git user.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"display_name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The 'name' field in a Git user's git.config. Required by Git.`,
												},
												"email": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The 'email' field in a Git user's git.config, if available.`,
												},
												"image_uri": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The URI of an image file associated with the user's account in an
external source control provider, if available.`,
												},
											},
										},
									},
									"commit_message": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The message of a codebase change.`,
									},
									"commit_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The time the change was made.`,
									},
									"display_name": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The human-friendly name to use for this Codebase when displaying a build.
We use the first eight characters of the SHA-1 hash for GitHub.com.`,
									},
									"hash": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The full SHA-1 hash of a Git commit, if available.`,
									},
									"uri": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `A URI linking to the codebase on an hosting provider's website. May
not be valid if the commit has been rebased or force-pushed out of
existence in the linked repository.`,
									},
								},
							},
							ExactlyOneOf: []string{"source.0.container", "source.0.codebase"},
						},
						"container": {
							Type:     schema.TypeList,
							Optional: true,
							ForceNew: true,
							Description: `The URI of an Artifact Registry
[container
image](https://cloud.google.com/artifact-registry/docs/reference/rest/v1/projects.locations.repositories.dockerImages)
to use as the build source.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"image": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `A URI representing a container for the backend to use.`,
									},
								},
							},
							ExactlyOneOf: []string{"source.0.container", "source.0.codebase"},
						},
					},
				},
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				ForceNew: true,
				Description: `Unstructured key value map that may be set by external tools to
store and arbitrary metadata. They are not queryable and should be
preserved when modifying objects.

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"display_name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `Human-readable name. 63 character limit.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Unstructured key value map that can be used to organize and categorize
objects.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"build_logs_uri": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The location of the [Cloud Build
logs](https://cloud.google.com/build/docs/view-build-results) for the build
process.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time at which the build was created.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				ForceNew:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				ForceNew:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"environment": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The environment name of the backend when this build was created.`,
			},
			"error": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `The 'Status' type defines a logical error model that is suitable for
different programming environments, including REST APIs and RPC APIs. It is
used by [gRPC](https://github.com/grpc). Each 'Status' message contains
three pieces of data: error code, error message, and error details.

You can find out more about this error model and how to work with it in the
[API Design Guide](https://cloud.google.com/apis/design/errors).`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"code": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The status code, which should be an enum value of google.rpc.Code.`,
						},
						"details": {
							Type:     schema.TypeList,
							Computed: true,
							Description: `A list of messages that carry the error details. There is a common set of
message types for APIs to use.`,
							Elem: &schema.Schema{
								Type: schema.TypeMap,
							},
						},
						"message": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `A developer-facing error message, which should be in English. Any
user-facing error message should be localized and sent in the
google.rpc.Status.details field, or localized by the client.`,
						},
					},
				},
			},
			"error_source": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The source of the error for the build, if in a 'FAILED' state.
Possible values:
CLOUD_BUILD
CLOUD_RUN`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Server-computed checksum based on other values; may be sent
on update or delete to ensure operation is done on expected resource.`,
			},
			"image": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The Artifact Registry
[container
image](https://cloud.google.com/artifact-registry/docs/reference/rest/v1/projects.locations.repositories.dockerImages)
URI, used by the Cloud Run
['revision'](https://cloud.google.com/run/docs/reference/rest/v2/projects.locations.services.revisions)
for this build.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The resource name of the build.

Format:

'projects/{project}/locations/{locationId}/backends/{backendId}/builds/{buildId}'.`,
			},
			"state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The state of the build.
Possible values:
BUILDING
BUILT
DEPLOYING
READY
FAILED`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `System-assigned, unique identifier.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time at which the build was last updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceFirebaseAppHostingBuildCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandFirebaseAppHostingBuildDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	etagProp, err := expandFirebaseAppHostingBuildEtag(d.Get("etag"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("etag"); !tpgresource.IsEmptyValue(reflect.ValueOf(etagProp)) && (ok || !reflect.DeepEqual(v, etagProp)) {
		obj["etag"] = etagProp
	}
	sourceProp, err := expandFirebaseAppHostingBuildSource(d.Get("source"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("source"); !tpgresource.IsEmptyValue(reflect.ValueOf(sourceProp)) && (ok || !reflect.DeepEqual(v, sourceProp)) {
		obj["source"] = sourceProp
	}
	annotationsProp, err := expandFirebaseAppHostingBuildEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(annotationsProp)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}
	labelsProp, err := expandFirebaseAppHostingBuildEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{FirebaseAppHostingBasePath}}projects/{{project}}/locations/{{location}}/backends/{{backend}}/builds?buildId={{build_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Build: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Build: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Build: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/backends/{{backend}}/builds/{{build_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = FirebaseAppHostingOperationWaitTime(
		config, res, project, "Creating Build", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Build: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Build %q: %#v", d.Id(), res)

	return resourceFirebaseAppHostingBuildRead(d, meta)
}

func resourceFirebaseAppHostingBuildRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{FirebaseAppHostingBasePath}}projects/{{project}}/locations/{{location}}/backends/{{backend}}/builds/{{build_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Build: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("FirebaseAppHostingBuild %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}

	if err := d.Set("display_name", flattenFirebaseAppHostingBuildDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("annotations", flattenFirebaseAppHostingBuildAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("labels", flattenFirebaseAppHostingBuildLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("name", flattenFirebaseAppHostingBuildName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("create_time", flattenFirebaseAppHostingBuildCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("update_time", flattenFirebaseAppHostingBuildUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("etag", flattenFirebaseAppHostingBuildEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("uid", flattenFirebaseAppHostingBuildUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("image", flattenFirebaseAppHostingBuildImage(res["image"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("build_logs_uri", flattenFirebaseAppHostingBuildBuildLogsUri(res["buildLogsUri"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("state", flattenFirebaseAppHostingBuildState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("error_source", flattenFirebaseAppHostingBuildErrorSource(res["errorSource"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("environment", flattenFirebaseAppHostingBuildEnvironment(res["environment"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("source", flattenFirebaseAppHostingBuildSource(res["source"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("error", flattenFirebaseAppHostingBuildError(res["error"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("effective_annotations", flattenFirebaseAppHostingBuildEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("terraform_labels", flattenFirebaseAppHostingBuildTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}
	if err := d.Set("effective_labels", flattenFirebaseAppHostingBuildEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Build: %s", err)
	}

	return nil
}

func resourceFirebaseAppHostingBuildUpdate(d *schema.ResourceData, meta interface{}) error {
	// Only the root field "labels" and "terraform_labels" are mutable
	return resourceFirebaseAppHostingBuildRead(d, meta)
}

func resourceFirebaseAppHostingBuildDelete(d *schema.ResourceData, meta interface{}) error {
	log.Printf("[WARNING] FirebaseAppHosting Build resources"+
		" cannot be deleted from Google Cloud. The resource %s will be removed from Terraform"+
		" state, but will still be present on Google Cloud.", d.Id())
	d.SetId("")

	return nil
}

func resourceFirebaseAppHostingBuildImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/backends/(?P<backend>[^/]+)/builds/(?P<build_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<backend>[^/]+)/(?P<build_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<backend>[^/]+)/(?P<build_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/backends/{{backend}}/builds/{{build_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenFirebaseAppHostingBuildDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenFirebaseAppHostingBuildLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenFirebaseAppHostingBuildName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildBuildLogsUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildErrorSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildEnvironment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["container"] =
		flattenFirebaseAppHostingBuildSourceContainer(original["container"], d, config)
	transformed["codebase"] =
		flattenFirebaseAppHostingBuildSourceCodebase(original["codebase"], d, config)
	return []interface{}{transformed}
}
func flattenFirebaseAppHostingBuildSourceContainer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["image"] =
		flattenFirebaseAppHostingBuildSourceContainerImage(original["image"], d, config)
	return []interface{}{transformed}
}
func flattenFirebaseAppHostingBuildSourceContainerImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildSourceCodebase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["display_name"] =
		flattenFirebaseAppHostingBuildSourceCodebaseDisplayName(original["displayName"], d, config)
	transformed["hash"] =
		flattenFirebaseAppHostingBuildSourceCodebaseHash(original["hash"], d, config)
	transformed["commit_message"] =
		flattenFirebaseAppHostingBuildSourceCodebaseCommitMessage(original["commitMessage"], d, config)
	transformed["uri"] =
		flattenFirebaseAppHostingBuildSourceCodebaseUri(original["uri"], d, config)
	transformed["author"] =
		flattenFirebaseAppHostingBuildSourceCodebaseAuthor(original["author"], d, config)
	transformed["commit_time"] =
		flattenFirebaseAppHostingBuildSourceCodebaseCommitTime(original["commitTime"], d, config)
	transformed["branch"] =
		flattenFirebaseAppHostingBuildSourceCodebaseBranch(original["branch"], d, config)
	transformed["commit"] =
		flattenFirebaseAppHostingBuildSourceCodebaseCommit(original["commit"], d, config)
	return []interface{}{transformed}
}
func flattenFirebaseAppHostingBuildSourceCodebaseDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildSourceCodebaseHash(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildSourceCodebaseCommitMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildSourceCodebaseUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildSourceCodebaseAuthor(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["display_name"] =
		flattenFirebaseAppHostingBuildSourceCodebaseAuthorDisplayName(original["displayName"], d, config)
	transformed["email"] =
		flattenFirebaseAppHostingBuildSourceCodebaseAuthorEmail(original["email"], d, config)
	transformed["image_uri"] =
		flattenFirebaseAppHostingBuildSourceCodebaseAuthorImageUri(original["imageUri"], d, config)
	return []interface{}{transformed}
}
func flattenFirebaseAppHostingBuildSourceCodebaseAuthorDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildSourceCodebaseAuthorEmail(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildSourceCodebaseAuthorImageUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildSourceCodebaseCommitTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildSourceCodebaseBranch(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildSourceCodebaseCommit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildError(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["code"] =
		flattenFirebaseAppHostingBuildErrorCode(original["code"], d, config)
	transformed["message"] =
		flattenFirebaseAppHostingBuildErrorMessage(original["message"], d, config)
	transformed["details"] =
		flattenFirebaseAppHostingBuildErrorDetails(original["details"], d, config)
	return []interface{}{transformed}
}
func flattenFirebaseAppHostingBuildErrorCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenFirebaseAppHostingBuildErrorMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildErrorDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenFirebaseAppHostingBuildTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenFirebaseAppHostingBuildEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandFirebaseAppHostingBuildDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildEtag(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedContainer, err := expandFirebaseAppHostingBuildSourceContainer(original["container"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContainer); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["container"] = transformedContainer
	}

	transformedCodebase, err := expandFirebaseAppHostingBuildSourceCodebase(original["codebase"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCodebase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["codebase"] = transformedCodebase
	}

	return transformed, nil
}

func expandFirebaseAppHostingBuildSourceContainer(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedImage, err := expandFirebaseAppHostingBuildSourceContainerImage(original["image"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedImage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["image"] = transformedImage
	}

	return transformed, nil
}

func expandFirebaseAppHostingBuildSourceContainerImage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildSourceCodebase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDisplayName, err := expandFirebaseAppHostingBuildSourceCodebaseDisplayName(original["display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayName"] = transformedDisplayName
	}

	transformedHash, err := expandFirebaseAppHostingBuildSourceCodebaseHash(original["hash"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHash); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hash"] = transformedHash
	}

	transformedCommitMessage, err := expandFirebaseAppHostingBuildSourceCodebaseCommitMessage(original["commit_message"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommitMessage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["commitMessage"] = transformedCommitMessage
	}

	transformedUri, err := expandFirebaseAppHostingBuildSourceCodebaseUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedAuthor, err := expandFirebaseAppHostingBuildSourceCodebaseAuthor(original["author"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthor); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["author"] = transformedAuthor
	}

	transformedCommitTime, err := expandFirebaseAppHostingBuildSourceCodebaseCommitTime(original["commit_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommitTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["commitTime"] = transformedCommitTime
	}

	transformedBranch, err := expandFirebaseAppHostingBuildSourceCodebaseBranch(original["branch"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBranch); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["branch"] = transformedBranch
	}

	transformedCommit, err := expandFirebaseAppHostingBuildSourceCodebaseCommit(original["commit"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommit); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["commit"] = transformedCommit
	}

	return transformed, nil
}

func expandFirebaseAppHostingBuildSourceCodebaseDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildSourceCodebaseHash(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildSourceCodebaseCommitMessage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildSourceCodebaseUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildSourceCodebaseAuthor(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDisplayName, err := expandFirebaseAppHostingBuildSourceCodebaseAuthorDisplayName(original["display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayName"] = transformedDisplayName
	}

	transformedEmail, err := expandFirebaseAppHostingBuildSourceCodebaseAuthorEmail(original["email"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEmail); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["email"] = transformedEmail
	}

	transformedImageUri, err := expandFirebaseAppHostingBuildSourceCodebaseAuthorImageUri(original["image_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedImageUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["imageUri"] = transformedImageUri
	}

	return transformed, nil
}

func expandFirebaseAppHostingBuildSourceCodebaseAuthorDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildSourceCodebaseAuthorEmail(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildSourceCodebaseAuthorImageUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildSourceCodebaseCommitTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildSourceCodebaseBranch(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildSourceCodebaseCommit(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseAppHostingBuildEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandFirebaseAppHostingBuildEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
