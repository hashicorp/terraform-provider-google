// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/discoveryengine/RecommendationEngine.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package discoveryengine

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceDiscoveryEngineRecommendationEngine() *schema.Resource {
	return &schema.Resource{
		Create: resourceDiscoveryEngineRecommendationEngineCreate,
		Read:   resourceDiscoveryEngineRecommendationEngineRead,
		Update: resourceDiscoveryEngineRecommendationEngineUpdate,
		Delete: resourceDiscoveryEngineRecommendationEngineDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDiscoveryEngineRecommendationEngineImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"engine_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"data_store_ids": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `The data stores associated with this engine. For SOLUTION_TYPE_RECOMMENDATION type of engines, they can only associate with at most one data store.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Required. The display name of the engine. Should be human readable. UTF-8 encoded string with limit of 1024 characters.`,
			},
			"engine_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Unique ID to use for Recommendation Engine.`,
			},
			"location": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The geographic location where the data store should reside. The value can
only be one of "global", "us" and "eu".`,
			},
			"common_config": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Common config spec that specifies the metadata of the engine.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"company_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd`,
						},
					},
				},
			},
			"industry_vertical": {
				Type:         schema.TypeString,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"GENERIC", "MEDIA", ""}),
				Description:  `The industry vertical that the engine registers. The restriction of the Engine industry vertical is based on DataStore: If unspecified, default to GENERIC. Vertical on Engine has to match vertical of the DataStore liniked to the engine. Default value: "GENERIC" Possible values: ["GENERIC", "MEDIA"]`,
				Default:      "GENERIC",
			},
			"media_recommendation_engine_config": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Configurations for a Media Recommendation Engine. Only applicable on the data stores
with SOLUTION_TYPE_RECOMMENDATION solution type and MEDIA industry vertical.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"engine_features_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `More feature configs of the selected engine type.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"most_popular_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Feature configurations that are required for creating a Most Popular engine.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"time_window_days": {
													Type:     schema.TypeInt,
													Optional: true,
													Description: `The time window of which the engine is queried at training and
prediction time. Positive integers only. The value translates to the
last X days of events. Currently required for the 'most-popular-items'
engine.`,
												},
											},
										},
									},
									"recommended_for_you_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Additional feature configurations for creating a 'recommended-for-you' engine.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"context_event_type": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `The type of event with which the engine is queried at prediction time.
If set to 'generic', only 'view-item', 'media-play',and
'media-complete' will be used as 'context-event' in engine training. If
set to 'view-home-page', 'view-home-page' will also be used as
'context-events' in addition to 'view-item', 'media-play', and
'media-complete'. Currently supported for the 'recommended-for-you'
engine. Currently supported values: 'view-home-page', 'generic'.`,
												},
											},
										},
									},
								},
							},
							ExactlyOneOf: []string{},
						},
						"optimization_objective": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The optimization objective. e.g., 'cvr'.
This field together with MediaRecommendationEngineConfig.type describes
engine metadata to use to control engine training and serving.
Currently supported values: 'ctr', 'cvr'.
If not specified, we choose default based on engine type. Default depends on type of recommendation:
'recommended-for-you' => 'ctr'
'others-you-may-like' => 'ctr'`,
						},
						"optimization_objective_config": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Name and value of the custom threshold for cvr optimization_objective.
For target_field 'watch-time', target_field_value must be an integer
value indicating the media progress time in seconds between (0, 86400]
(excludes 0, includes 86400) (e.g., 90).
For target_field 'watch-percentage', the target_field_value must be a
valid float value between (0, 1.0] (excludes 0, includes 1.0) (e.g., 0.5).`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"target_field": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The name of the field to target. Currently supported values: 'watch-percentage', 'watch-time'.`,
									},
									"target_field_value_float": {
										Type:        schema.TypeFloat,
										Optional:    true,
										Description: `The threshold to be applied to the target (e.g., 0.5).`,
									},
								},
							},
						},
						"training_state": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"PAUSED", "TRAINING", ""}),
							Description: `The training state that the engine is in (e.g. 'TRAINING' or 'PAUSED').
Since part of the cost of running the service
is frequency of training - this can be used to determine when to train
engine in order to control cost. If not specified: the default value for
'CreateEngine' method is 'TRAINING'. The default value for
'UpdateEngine' method is to keep the state the same as before. Possible values: ["PAUSED", "TRAINING"]`,
						},
						"type": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The type of engine. e.g., 'recommended-for-you'.
This field together with MediaRecommendationEngineConfig.optimizationObjective describes
engine metadata to use to control engine training and serving.
Currently supported values: 'recommended-for-you', 'others-you-may-like',
'more-like-this', 'most-popular-items'.`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp the Engine was created at.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The unique full resource name of the recommendation engine. Values are of the format
'projects/{project}/locations/{location}/collections/{collection}/engines/{engine_id}'.
This field must be a UTF-8 encoded string with a length limit of 1024 characters.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp the Engine was last updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDiscoveryEngineRecommendationEngineCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandDiscoveryEngineRecommendationEngineDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	dataStoreIdsProp, err := expandDiscoveryEngineRecommendationEngineDataStoreIds(d.Get("data_store_ids"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_store_ids"); !tpgresource.IsEmptyValue(reflect.ValueOf(dataStoreIdsProp)) && (ok || !reflect.DeepEqual(v, dataStoreIdsProp)) {
		obj["dataStoreIds"] = dataStoreIdsProp
	}
	industryVerticalProp, err := expandDiscoveryEngineRecommendationEngineIndustryVertical(d.Get("industry_vertical"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("industry_vertical"); !tpgresource.IsEmptyValue(reflect.ValueOf(industryVerticalProp)) && (ok || !reflect.DeepEqual(v, industryVerticalProp)) {
		obj["industryVertical"] = industryVerticalProp
	}
	mediaRecommendationEngineConfigProp, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfig(d.Get("media_recommendation_engine_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("media_recommendation_engine_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(mediaRecommendationEngineConfigProp)) && (ok || !reflect.DeepEqual(v, mediaRecommendationEngineConfigProp)) {
		obj["mediaRecommendationEngineConfig"] = mediaRecommendationEngineConfigProp
	}
	commonConfigProp, err := expandDiscoveryEngineRecommendationEngineCommonConfig(d.Get("common_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("common_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(commonConfigProp)) && (ok || !reflect.DeepEqual(v, commonConfigProp)) {
		obj["commonConfig"] = commonConfigProp
	}

	obj, err = resourceDiscoveryEngineRecommendationEngineEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DiscoveryEngineBasePath}}projects/{{project}}/locations/{{location}}/collections/default_collection/engines?engineId={{engine_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new RecommendationEngine: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RecommendationEngine: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating RecommendationEngine: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/collections/default_collection/engines/{{engine_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if engineIdValue, ok := d.GetOk("engine_id"); ok && engineIdValue.(string) != "" {
			if err = identity.Set("engine_id", engineIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting engine_id: %s", err)
			}
		}
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = DiscoveryEngineOperationWaitTime(
		config, res, project, "Creating RecommendationEngine", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create RecommendationEngine: %s", err)
	}

	log.Printf("[DEBUG] Finished creating RecommendationEngine %q: %#v", d.Id(), res)

	return resourceDiscoveryEngineRecommendationEngineRead(d, meta)
}

func resourceDiscoveryEngineRecommendationEngineRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DiscoveryEngineBasePath}}projects/{{project}}/locations/{{location}}/collections/default_collection/engines/{{engine_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RecommendationEngine: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DiscoveryEngineRecommendationEngine %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading RecommendationEngine: %s", err)
	}

	if err := d.Set("name", flattenDiscoveryEngineRecommendationEngineName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading RecommendationEngine: %s", err)
	}
	if err := d.Set("display_name", flattenDiscoveryEngineRecommendationEngineDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading RecommendationEngine: %s", err)
	}
	if err := d.Set("create_time", flattenDiscoveryEngineRecommendationEngineCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading RecommendationEngine: %s", err)
	}
	if err := d.Set("update_time", flattenDiscoveryEngineRecommendationEngineUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading RecommendationEngine: %s", err)
	}
	if err := d.Set("data_store_ids", flattenDiscoveryEngineRecommendationEngineDataStoreIds(res["dataStoreIds"], d, config)); err != nil {
		return fmt.Errorf("Error reading RecommendationEngine: %s", err)
	}
	if err := d.Set("media_recommendation_engine_config", flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfig(res["mediaRecommendationEngineConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading RecommendationEngine: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("engine_id"); !ok && v == "" {
			err = identity.Set("engine_id", d.Get("engine_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting engine_id: %s", err)
			}
		}
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceDiscoveryEngineRecommendationEngineUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if engineIdValue, ok := d.GetOk("engine_id"); ok && engineIdValue.(string) != "" {
			if err = identity.Set("engine_id", engineIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting engine_id: %s", err)
			}
		}
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RecommendationEngine: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	displayNameProp, err := expandDiscoveryEngineRecommendationEngineDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	dataStoreIdsProp, err := expandDiscoveryEngineRecommendationEngineDataStoreIds(d.Get("data_store_ids"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_store_ids"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dataStoreIdsProp)) {
		obj["dataStoreIds"] = dataStoreIdsProp
	}
	mediaRecommendationEngineConfigProp, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfig(d.Get("media_recommendation_engine_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("media_recommendation_engine_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, mediaRecommendationEngineConfigProp)) {
		obj["mediaRecommendationEngineConfig"] = mediaRecommendationEngineConfigProp
	}

	obj, err = resourceDiscoveryEngineRecommendationEngineEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DiscoveryEngineBasePath}}projects/{{project}}/locations/{{location}}/collections/default_collection/engines/{{engine_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating RecommendationEngine %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("data_store_ids") {
		updateMask = append(updateMask, "dataStoreIds")
	}

	if d.HasChange("media_recommendation_engine_config") {
		updateMask = append(updateMask, "mediaRecommendationEngineConfig")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating RecommendationEngine %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating RecommendationEngine %q: %#v", d.Id(), res)
		}

	}

	return resourceDiscoveryEngineRecommendationEngineRead(d, meta)
}

func resourceDiscoveryEngineRecommendationEngineDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RecommendationEngine: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{DiscoveryEngineBasePath}}projects/{{project}}/locations/{{location}}/collections/default_collection/engines/{{engine_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting RecommendationEngine %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "RecommendationEngine")
	}

	err = DiscoveryEngineOperationWaitTime(
		config, res, project, "Deleting RecommendationEngine", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting RecommendationEngine %q: %#v", d.Id(), res)
	return nil
}

func resourceDiscoveryEngineRecommendationEngineImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/collections/default_collection/engines/(?P<engine_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<engine_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<engine_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/collections/default_collection/engines/{{engine_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenDiscoveryEngineRecommendationEngineName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDiscoveryEngineRecommendationEngineDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDiscoveryEngineRecommendationEngineCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDiscoveryEngineRecommendationEngineUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDiscoveryEngineRecommendationEngineDataStoreIds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["type"] =
		flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigType(original["type"], d, config)
	transformed["optimization_objective"] =
		flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjective(original["optimizationObjective"], d, config)
	transformed["optimization_objective_config"] =
		flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig(original["optimizationObjectiveConfig"], d, config)
	transformed["training_state"] =
		flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigTrainingState(original["trainingState"], d, config)
	transformed["engine_features_config"] =
		flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfig(original["engineFeaturesConfig"], d, config)
	return []interface{}{transformed}
}
func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjective(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["target_field"] =
		flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigTargetField(original["targetField"], d, config)
	transformed["target_field_value_float"] =
		flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigTargetFieldValueFloat(original["targetFieldValueFloat"], d, config)
	return []interface{}{transformed}
}
func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigTargetField(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigTargetFieldValueFloat(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigTrainingState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["recommended_for_you_config"] =
		flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfig(original["recommendedForYouConfig"], d, config)
	transformed["most_popular_config"] =
		flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfig(original["mostPopularConfig"], d, config)
	return []interface{}{transformed}
}
func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["context_event_type"] =
		flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigContextEventType(original["contextEventType"], d, config)
	return []interface{}{transformed}
}
func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigContextEventType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["time_window_days"] =
		flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigTimeWindowDays(original["timeWindowDays"], d, config)
	return []interface{}{transformed}
}
func flattenDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigTimeWindowDays(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func expandDiscoveryEngineRecommendationEngineDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDiscoveryEngineRecommendationEngineDataStoreIds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDiscoveryEngineRecommendationEngineIndustryVertical(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedType, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedOptimizationObjective, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjective(original["optimization_objective"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOptimizationObjective); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["optimizationObjective"] = transformedOptimizationObjective
	}

	transformedOptimizationObjectiveConfig, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig(original["optimization_objective_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOptimizationObjectiveConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["optimizationObjectiveConfig"] = transformedOptimizationObjectiveConfig
	}

	transformedTrainingState, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigTrainingState(original["training_state"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTrainingState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["trainingState"] = transformedTrainingState
	}

	transformedEngineFeaturesConfig, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfig(original["engine_features_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEngineFeaturesConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["engineFeaturesConfig"] = transformedEngineFeaturesConfig
	}

	return transformed, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjective(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTargetField, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigTargetField(original["target_field"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTargetField); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["targetField"] = transformedTargetField
	}

	transformedTargetFieldValueFloat, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigTargetFieldValueFloat(original["target_field_value_float"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTargetFieldValueFloat); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["targetFieldValueFloat"] = transformedTargetFieldValueFloat
	}

	return transformed, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigTargetField(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigTargetFieldValueFloat(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigTrainingState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRecommendedForYouConfig, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfig(original["recommended_for_you_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRecommendedForYouConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["recommendedForYouConfig"] = transformedRecommendedForYouConfig
	}

	transformedMostPopularConfig, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfig(original["most_popular_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMostPopularConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["mostPopularConfig"] = transformedMostPopularConfig
	}

	return transformed, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedContextEventType, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigContextEventType(original["context_event_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContextEventType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["contextEventType"] = transformedContextEventType
	}

	return transformed, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigContextEventType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTimeWindowDays, err := expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigTimeWindowDays(original["time_window_days"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeWindowDays); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["timeWindowDays"] = transformedTimeWindowDays
	}

	return transformed, nil
}

func expandDiscoveryEngineRecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigTimeWindowDays(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDiscoveryEngineRecommendationEngineCommonConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCompanyName, err := expandDiscoveryEngineRecommendationEngineCommonConfigCompanyName(original["company_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCompanyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["companyName"] = transformedCompanyName
	}

	return transformed, nil
}

func expandDiscoveryEngineRecommendationEngineCommonConfigCompanyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceDiscoveryEngineRecommendationEngineEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	// hard code solutionType to "SOLUTION_TYPE_RECOMMENDATION" for recommendation engine resource
	obj["solutionType"] = "SOLUTION_TYPE_RECOMMENDATION"
	return obj, nil
}
