// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package healthcare

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceHealthcarePipelineJob() *schema.Resource {
	return &schema.Resource{
		Create: resourceHealthcarePipelineJobCreate,
		Read:   resourceHealthcarePipelineJobRead,
		Update: resourceHealthcarePipelineJobUpdate,
		Delete: resourceHealthcarePipelineJobDelete,

		Importer: &schema.ResourceImporter{
			State: resourceHealthcarePipelineJobImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
		),

		Schema: map[string]*schema.Schema{
			"dataset": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Healthcare Dataset under which the Pipeline Job is to run`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Location where the Pipeline Job is to run`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Specifies the name of the pipeline job. This field is user-assigned.`,
			},
			"backfill_pipeline_job": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Specifies the backfill configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"mapping_pipeline_job": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `Specifies the mapping pipeline job to backfill, the name format
should follow: projects/{projectId}/locations/{locationId}/datasets/{datasetId}/pipelineJobs/{pipelineJobId}.`,
						},
					},
				},
				ConflictsWith: []string{"mapping_pipeline_job", "reconciliation_pipeline_job"},
			},
			"disable_lineage": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `If true, disables writing lineage for the pipeline.`,
				Default:     false,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `User-supplied key-value pairs used to organize Pipeline Jobs.
Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of
maximum 128 bytes, and must conform to the following PCRE regular expression:
[\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}
Label values are optional, must be between 1 and 63 characters long, have a
UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE
regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63}
No more than 64 labels can be associated with a given pipeline.
An object containing a list of "key": value pairs.
Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"mapping_pipeline_job": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Specifies mapping configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"mapping_config": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `The location of the mapping configuration.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Describes the mapping configuration.`,
									},
									"whistle_config_source": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Specifies the path to the mapping configuration for harmonization pipeline.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"import_uri_prefix": {
													Type:     schema.TypeString,
													Required: true,
													Description: `Directory path where all the Whistle files are located.
Example: gs://{bucket-id}/{path/to/import-root/dir}`,
												},
												"uri": {
													Type:     schema.TypeString,
													Required: true,
													Description: `Main configuration file which has the entrypoint or the root function.
Example: gs://{bucket-id}/{path/to/import-root/dir}/entrypoint-file-name.wstl.`,
												},
											},
										},
									},
								},
							},
						},
						"fhir_store_destination": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `If set, the mapping pipeline will write snapshots to this
FHIR store without assigning stable IDs. You must
grant your pipeline project's Cloud Healthcare Service
Agent serviceaccount healthcare.fhirResources.executeBundle
and healthcare.fhirResources.create permissions on the
destination store. The destination store must set
[disableReferentialIntegrity][FhirStore.disable_referential_integrity]
to true. The destination store must use FHIR version R4.
Format: project/{projectID}/locations/{locationID}/datasets/{datasetName}/fhirStores/{fhirStoreID}.`,
							ConflictsWith: []string{},
						},
						"fhir_streaming_source": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `A streaming FHIR data source.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"fhir_store": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The path to the FHIR store in the format projects/{projectId}/locations/{locationId}/datasets/{datasetId}/fhirStores/{fhirStoreId}.`,
									},
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Describes the streaming FHIR data source.`,
									},
								},
							},
						},
						"reconciliation_destination": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `If set to true, a mapping pipeline will send output snapshots
to the reconciliation pipeline in its dataset. A reconciliation
pipeline must exist in this dataset before a mapping pipeline
with a reconciliation destination can be created.`,
							ConflictsWith: []string{},
						},
					},
				},
				ConflictsWith: []string{"reconciliation_pipeline_job", "backfill_pipeline_job"},
			},
			"reconciliation_pipeline_job": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Specifies reconciliation configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"matching_uri_prefix": {
							Type:     schema.TypeString,
							Required: true,
							Description: `Specifies the top level directory of the matching configs used
in all mapping pipelines, which extract properties for resources
to be matched on.
Example: gs://{bucket-id}/{path/to/matching/configs}`,
						},
						"merge_config": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Specifies the location of the reconciliation configuration.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"whistle_config_source": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `Specifies the path to the mapping configuration for harmonization pipeline.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"import_uri_prefix": {
													Type:     schema.TypeString,
													Required: true,
													Description: `Directory path where all the Whistle files are located.
Example: gs://{bucket-id}/{path/to/import-root/dir}`,
												},
												"uri": {
													Type:     schema.TypeString,
													Required: true,
													Description: `Main configuration file which has the entrypoint or the root function.
Example: gs://{bucket-id}/{path/to/import-root/dir}/entrypoint-file-name.wstl.`,
												},
											},
										},
									},
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Describes the mapping configuration.`,
									},
								},
							},
						},
						"fhir_store_destination": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The harmonized FHIR store to write harmonized FHIR resources to,
in the format of: project/{projectID}/locations/{locationID}/datasets/{datasetName}/fhirStores/{id}`,
						},
					},
				},
				ConflictsWith: []string{"mapping_pipeline_job", "backfill_pipeline_job"},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"self_link": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The fully qualified name of this dataset`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
		},
		UseJSONNumber: true,
	}
}

func resourceHealthcarePipelineJobCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandHealthcarePipelineJobName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	disableLineageProp, err := expandHealthcarePipelineJobDisableLineage(d.Get("disable_lineage"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("disable_lineage"); !tpgresource.IsEmptyValue(reflect.ValueOf(disableLineageProp)) && (ok || !reflect.DeepEqual(v, disableLineageProp)) {
		obj["disableLineage"] = disableLineageProp
	}
	mappingPipelineJobProp, err := expandHealthcarePipelineJobMappingPipelineJob(d.Get("mapping_pipeline_job"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("mapping_pipeline_job"); !tpgresource.IsEmptyValue(reflect.ValueOf(mappingPipelineJobProp)) && (ok || !reflect.DeepEqual(v, mappingPipelineJobProp)) {
		obj["mappingPipelineJob"] = mappingPipelineJobProp
	}
	reconciliationPipelineJobProp, err := expandHealthcarePipelineJobReconciliationPipelineJob(d.Get("reconciliation_pipeline_job"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("reconciliation_pipeline_job"); !tpgresource.IsEmptyValue(reflect.ValueOf(reconciliationPipelineJobProp)) && (ok || !reflect.DeepEqual(v, reconciliationPipelineJobProp)) {
		obj["reconciliationPipelineJob"] = reconciliationPipelineJobProp
	}
	backfillPipelineJobProp, err := expandHealthcarePipelineJobBackfillPipelineJob(d.Get("backfill_pipeline_job"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backfill_pipeline_job"); !tpgresource.IsEmptyValue(reflect.ValueOf(backfillPipelineJobProp)) && (ok || !reflect.DeepEqual(v, backfillPipelineJobProp)) {
		obj["backfillPipelineJob"] = backfillPipelineJobProp
	}
	labelsProp, err := expandHealthcarePipelineJobEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{HealthcareBasePath}}{{dataset}}/pipelineJobs?pipelineJobId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new PipelineJob: %#v", obj)
	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating PipelineJob: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "{{dataset}}/pipelineJobs/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating PipelineJob %q: %#v", d.Id(), res)

	return resourceHealthcarePipelineJobRead(d, meta)
}

func resourceHealthcarePipelineJobRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{HealthcareBasePath}}{{dataset}}/pipelineJobs/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("HealthcarePipelineJob %q", d.Id()))
	}

	res, err = resourceHealthcarePipelineJobDecoder(d, meta, res)
	if err != nil {
		return err
	}

	if res == nil {
		// Decoding the object has resulted in it being gone. It may be marked deleted
		log.Printf("[DEBUG] Removing HealthcarePipelineJob because it no longer exists.")
		d.SetId("")
		return nil
	}

	if err := d.Set("name", flattenHealthcarePipelineJobName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("disable_lineage", flattenHealthcarePipelineJobDisableLineage(res["disableLineage"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("labels", flattenHealthcarePipelineJobLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("mapping_pipeline_job", flattenHealthcarePipelineJobMappingPipelineJob(res["mappingPipelineJob"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("reconciliation_pipeline_job", flattenHealthcarePipelineJobReconciliationPipelineJob(res["reconciliationPipelineJob"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("backfill_pipeline_job", flattenHealthcarePipelineJobBackfillPipelineJob(res["backfillPipelineJob"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("terraform_labels", flattenHealthcarePipelineJobTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("effective_labels", flattenHealthcarePipelineJobEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}

	return nil
}

func resourceHealthcarePipelineJobUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	obj := make(map[string]interface{})
	nameProp, err := expandHealthcarePipelineJobName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	disableLineageProp, err := expandHealthcarePipelineJobDisableLineage(d.Get("disable_lineage"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("disable_lineage"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, disableLineageProp)) {
		obj["disableLineage"] = disableLineageProp
	}
	mappingPipelineJobProp, err := expandHealthcarePipelineJobMappingPipelineJob(d.Get("mapping_pipeline_job"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("mapping_pipeline_job"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, mappingPipelineJobProp)) {
		obj["mappingPipelineJob"] = mappingPipelineJobProp
	}
	reconciliationPipelineJobProp, err := expandHealthcarePipelineJobReconciliationPipelineJob(d.Get("reconciliation_pipeline_job"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("reconciliation_pipeline_job"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, reconciliationPipelineJobProp)) {
		obj["reconciliationPipelineJob"] = reconciliationPipelineJobProp
	}
	backfillPipelineJobProp, err := expandHealthcarePipelineJobBackfillPipelineJob(d.Get("backfill_pipeline_job"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backfill_pipeline_job"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, backfillPipelineJobProp)) {
		obj["backfillPipelineJob"] = backfillPipelineJobProp
	}
	labelsProp, err := expandHealthcarePipelineJobEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{HealthcareBasePath}}{{dataset}}/pipelineJobs/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating PipelineJob %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("name") {
		updateMask = append(updateMask, "name")
	}

	if d.HasChange("disable_lineage") {
		updateMask = append(updateMask, "disableLineage")
	}

	if d.HasChange("mapping_pipeline_job") {
		updateMask = append(updateMask, "mappingPipelineJob")
	}

	if d.HasChange("reconciliation_pipeline_job") {
		updateMask = append(updateMask, "reconciliationPipelineJob")
	}

	if d.HasChange("backfill_pipeline_job") {
		updateMask = append(updateMask, "backfillPipelineJob")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating PipelineJob %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating PipelineJob %q: %#v", d.Id(), res)
		}

	}

	return resourceHealthcarePipelineJobRead(d, meta)
}

func resourceHealthcarePipelineJobDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	url, err := tpgresource.ReplaceVars(d, config, "{{HealthcareBasePath}}{{dataset}}/pipelineJobs/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting PipelineJob %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "PipelineJob")
	}

	log.Printf("[DEBUG] Finished deleting PipelineJob %q: %#v", d.Id(), res)
	return nil
}

func resourceHealthcarePipelineJobImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^(?P<dataset>.+)/pipelineJobs/(?P<name>[^/]+)$",
		"^(?P<dataset>[^/]+)/pipelineJobs?pipelineJobId=(?P<name>[^/]+)$",
		"^(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "{{dataset}}/pipelineJobs/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenHealthcarePipelineJobName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobDisableLineage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenHealthcarePipelineJobMappingPipelineJob(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["mapping_config"] =
		flattenHealthcarePipelineJobMappingPipelineJobMappingConfig(original["mappingConfig"], d, config)
	transformed["fhir_streaming_source"] =
		flattenHealthcarePipelineJobMappingPipelineJobFhirStreamingSource(original["fhirStreamingSource"], d, config)
	transformed["fhir_store_destination"] =
		flattenHealthcarePipelineJobMappingPipelineJobFhirStoreDestination(original["fhirStoreDestination"], d, config)
	transformed["reconciliation_destination"] =
		flattenHealthcarePipelineJobMappingPipelineJobReconciliationDestination(original["reconciliationDestination"], d, config)
	return []interface{}{transformed}
}
func flattenHealthcarePipelineJobMappingPipelineJobMappingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenHealthcarePipelineJobMappingPipelineJobMappingConfigDescription(original["description"], d, config)
	transformed["whistle_config_source"] =
		flattenHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSource(original["whistleConfigSource"], d, config)
	return []interface{}{transformed}
}
func flattenHealthcarePipelineJobMappingPipelineJobMappingConfigDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSourceUri(original["uri"], d, config)
	transformed["import_uri_prefix"] =
		flattenHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSourceImportUriPrefix(original["importUriPrefix"], d, config)
	return []interface{}{transformed}
}
func flattenHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSourceUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSourceImportUriPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobMappingPipelineJobFhirStreamingSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["fhir_store"] =
		flattenHealthcarePipelineJobMappingPipelineJobFhirStreamingSourceFhirStore(original["fhirStore"], d, config)
	transformed["description"] =
		flattenHealthcarePipelineJobMappingPipelineJobFhirStreamingSourceDescription(original["description"], d, config)
	return []interface{}{transformed}
}
func flattenHealthcarePipelineJobMappingPipelineJobFhirStreamingSourceFhirStore(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobMappingPipelineJobFhirStreamingSourceDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobMappingPipelineJobFhirStoreDestination(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobMappingPipelineJobReconciliationDestination(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobReconciliationPipelineJob(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["merge_config"] =
		flattenHealthcarePipelineJobReconciliationPipelineJobMergeConfig(original["mergeConfig"], d, config)
	transformed["matching_uri_prefix"] =
		flattenHealthcarePipelineJobReconciliationPipelineJobMatchingUriPrefix(original["matchingUriPrefix"], d, config)
	transformed["fhir_store_destination"] =
		flattenHealthcarePipelineJobReconciliationPipelineJobFhirStoreDestination(original["fhirStoreDestination"], d, config)
	return []interface{}{transformed}
}
func flattenHealthcarePipelineJobReconciliationPipelineJobMergeConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenHealthcarePipelineJobReconciliationPipelineJobMergeConfigDescription(original["description"], d, config)
	transformed["whistle_config_source"] =
		flattenHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSource(original["whistleConfigSource"], d, config)
	return []interface{}{transformed}
}
func flattenHealthcarePipelineJobReconciliationPipelineJobMergeConfigDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSourceUri(original["uri"], d, config)
	transformed["import_uri_prefix"] =
		flattenHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSourceImportUriPrefix(original["importUriPrefix"], d, config)
	return []interface{}{transformed}
}
func flattenHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSourceUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSourceImportUriPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobReconciliationPipelineJobMatchingUriPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobReconciliationPipelineJobFhirStoreDestination(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobBackfillPipelineJob(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["mapping_pipeline_job"] =
		flattenHealthcarePipelineJobBackfillPipelineJobMappingPipelineJob(original["mappingPipelineJob"], d, config)
	return []interface{}{transformed}
}
func flattenHealthcarePipelineJobBackfillPipelineJobMappingPipelineJob(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenHealthcarePipelineJobTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenHealthcarePipelineJobEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandHealthcarePipelineJobName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobDisableLineage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobMappingPipelineJob(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMappingConfig, err := expandHealthcarePipelineJobMappingPipelineJobMappingConfig(original["mapping_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMappingConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["mappingConfig"] = transformedMappingConfig
	}

	transformedFhirStreamingSource, err := expandHealthcarePipelineJobMappingPipelineJobFhirStreamingSource(original["fhir_streaming_source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFhirStreamingSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fhirStreamingSource"] = transformedFhirStreamingSource
	}

	transformedFhirStoreDestination, err := expandHealthcarePipelineJobMappingPipelineJobFhirStoreDestination(original["fhir_store_destination"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFhirStoreDestination); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fhirStoreDestination"] = transformedFhirStoreDestination
	}

	transformedReconciliationDestination, err := expandHealthcarePipelineJobMappingPipelineJobReconciliationDestination(original["reconciliation_destination"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReconciliationDestination); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["reconciliationDestination"] = transformedReconciliationDestination
	}

	return transformed, nil
}

func expandHealthcarePipelineJobMappingPipelineJobMappingConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDescription, err := expandHealthcarePipelineJobMappingPipelineJobMappingConfigDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedWhistleConfigSource, err := expandHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSource(original["whistle_config_source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWhistleConfigSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["whistleConfigSource"] = transformedWhistleConfigSource
	}

	return transformed, nil
}

func expandHealthcarePipelineJobMappingPipelineJobMappingConfigDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSourceUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedImportUriPrefix, err := expandHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSourceImportUriPrefix(original["import_uri_prefix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedImportUriPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["importUriPrefix"] = transformedImportUriPrefix
	}

	return transformed, nil
}

func expandHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSourceUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobMappingPipelineJobMappingConfigWhistleConfigSourceImportUriPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobMappingPipelineJobFhirStreamingSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFhirStore, err := expandHealthcarePipelineJobMappingPipelineJobFhirStreamingSourceFhirStore(original["fhir_store"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFhirStore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fhirStore"] = transformedFhirStore
	}

	transformedDescription, err := expandHealthcarePipelineJobMappingPipelineJobFhirStreamingSourceDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	return transformed, nil
}

func expandHealthcarePipelineJobMappingPipelineJobFhirStreamingSourceFhirStore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobMappingPipelineJobFhirStreamingSourceDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobMappingPipelineJobFhirStoreDestination(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobMappingPipelineJobReconciliationDestination(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobReconciliationPipelineJob(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMergeConfig, err := expandHealthcarePipelineJobReconciliationPipelineJobMergeConfig(original["merge_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMergeConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["mergeConfig"] = transformedMergeConfig
	}

	transformedMatchingUriPrefix, err := expandHealthcarePipelineJobReconciliationPipelineJobMatchingUriPrefix(original["matching_uri_prefix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMatchingUriPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["matchingUriPrefix"] = transformedMatchingUriPrefix
	}

	transformedFhirStoreDestination, err := expandHealthcarePipelineJobReconciliationPipelineJobFhirStoreDestination(original["fhir_store_destination"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFhirStoreDestination); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fhirStoreDestination"] = transformedFhirStoreDestination
	}

	return transformed, nil
}

func expandHealthcarePipelineJobReconciliationPipelineJobMergeConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDescription, err := expandHealthcarePipelineJobReconciliationPipelineJobMergeConfigDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedWhistleConfigSource, err := expandHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSource(original["whistle_config_source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWhistleConfigSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["whistleConfigSource"] = transformedWhistleConfigSource
	}

	return transformed, nil
}

func expandHealthcarePipelineJobReconciliationPipelineJobMergeConfigDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSourceUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedImportUriPrefix, err := expandHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSourceImportUriPrefix(original["import_uri_prefix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedImportUriPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["importUriPrefix"] = transformedImportUriPrefix
	}

	return transformed, nil
}

func expandHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSourceUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobReconciliationPipelineJobMergeConfigWhistleConfigSourceImportUriPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobReconciliationPipelineJobMatchingUriPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobReconciliationPipelineJobFhirStoreDestination(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobBackfillPipelineJob(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMappingPipelineJob, err := expandHealthcarePipelineJobBackfillPipelineJobMappingPipelineJob(original["mapping_pipeline_job"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMappingPipelineJob); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["mappingPipelineJob"] = transformedMappingPipelineJob
	}

	return transformed, nil
}

func expandHealthcarePipelineJobBackfillPipelineJobMappingPipelineJob(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHealthcarePipelineJobEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func resourceHealthcarePipelineJobDecoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
	// Take the returned long form of the name and use it as `self_link`.
	// Then modify the name to be the user specified form.
	// We can't just ignore_read on `name` as the linter will
	// complain that the returned `res` is never used afterwards.
	// Some field needs to be actually set, and we chose `name`.
	if err := d.Set("self_link", res["name"].(string)); err != nil {
		return nil, fmt.Errorf("Error setting self_link: %s", err)
	}
	res["name"] = d.Get("name").(string)
	return res, nil
}
