// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package integrationconnectors

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

// waitforConnectionReady waits for an connecion to leave the
// "CREATING" state, to indicate that it's ready.
func waitforConnectionReady(d *schema.ResourceData, config *transport_tpg.Config, timeout time.Duration) error {
	return resource.Retry(timeout, func() *resource.RetryError {
		if err := resourceIntegrationConnectorsConnectionRead(d, config); err != nil {
			return resource.NonRetryableError(err)
		}
		name := d.Get("name").(string)
		status := d.Get("status").([]interface{})
		state := status[0].(map[string]interface{})["state"]
		log.Printf("[DEBUG] Connection %q has state %v.", name, state)
		if state == "CREATING" || state == "UPDATING" {
			return resource.RetryableError(fmt.Errorf("Connection %q has state %q.", name, state))
		}
		log.Printf("[DEBUG] Connection %q has state %q.", name, state)
		return nil
	})
}

func ResourceIntegrationConnectorsConnection() *schema.Resource {
	return &schema.Resource{
		Create: resourceIntegrationConnectorsConnectionCreate,
		Read:   resourceIntegrationConnectorsConnectionRead,
		Update: resourceIntegrationConnectorsConnectionUpdate,
		Delete: resourceIntegrationConnectorsConnectionDelete,

		Importer: &schema.ResourceImporter{
			State: resourceIntegrationConnectorsConnectionImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(30 * time.Minute),
			Update: schema.DefaultTimeout(30 * time.Minute),
			Delete: schema.DefaultTimeout(30 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"connector_version": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `connectorVersion of the Connector.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Location in which Connection needs to be created.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Name of Connection needs to be created.`,
			},
			"auth_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `authConfig for the connection.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_type": {
							Type:         schema.TypeString,
							Required:     true,
							ValidateFunc: verify.ValidateEnum([]string{"USER_PASSWORD", "OAUTH2_JWT_BEARER", "OAUTH2_CLIENT_CREDENTIALS", "SSH_PUBLIC_KEY", "OAUTH2_AUTH_CODE_FLOW"}),
							Description:  `authType of the Connection Possible values: ["USER_PASSWORD", "OAUTH2_JWT_BEARER", "OAUTH2_CLIENT_CREDENTIALS", "SSH_PUBLIC_KEY", "OAUTH2_AUTH_CODE_FLOW"]`,
						},
						"additional_variable": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `List containing additional auth configs.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Key for the configVariable`,
									},
									"boolean_value": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Boolean Value of configVariable.`,
									},
									"encryption_key_value": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Encription key value of configVariable.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"type": {
													Type:         schema.TypeString,
													Required:     true,
													ValidateFunc: verify.ValidateEnum([]string{"GOOGLE_MANAGED", "CUSTOMER_MANAGED"}),
													Description:  `Type of Encription Key Possible values: ["GOOGLE_MANAGED", "CUSTOMER_MANAGED"]`,
												},
												"kms_key_name": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `The [KMS key name] with which the content of the Operation is encrypted. The expected
format: projects/*/locations/*/keyRings/*/cryptoKeys/*.
Will be empty string if google managed.`,
												},
											},
										},
									},
									"integer_value": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Integer Value of configVariable.`,
									},
									"secret_value": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Secret value of configVariable.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `Secret version of Secret Value for Config variable.`,
												},
											},
										},
									},
									"string_value": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `String Value of configVariabley.`,
									},
								},
							},
						},
						"auth_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The type of authentication configured.`,
						},
						"oauth2_auth_code_flow": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Parameters to support Oauth 2.0 Auth Code Grant Authentication.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auth_uri": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Auth URL for Authorization Code Flow.`,
									},
									"client_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Client ID for user-provided OAuth app.`,
									},
									"client_secret": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Client secret for user-provided OAuth app.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The resource name of the secret version in the format,
format as: projects/*/secrets/*/versions/*.`,
												},
											},
										},
									},
									"enable_pkce": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Whether to enable PKCE when the user performs the auth code flow.`,
									},
									"scopes": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Scopes the connection will request when the user performs the auth code flow.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
							ExactlyOneOf: []string{"auth_config.0.user_password", "auth_config.0.oauth2_jwt_bearer", "auth_config.0.oauth2_client_credentials", "auth_config.0.ssh_public_key", "auth_config.0.oauth2_auth_code_flow"},
						},
						"oauth2_client_credentials": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `OAuth3 Client Credentials for Authentication.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"client_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Secret version of Password for Authentication.`,
									},
									"client_secret": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Secret version reference containing the client secret.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The resource name of the secret version in the format,
format as: projects/*/secrets/*/versions/*.`,
												},
											},
										},
									},
								},
							},
							ExactlyOneOf: []string{"auth_config.0.user_password", "auth_config.0.oauth2_jwt_bearer", "auth_config.0.oauth2_client_credentials", "auth_config.0.ssh_public_key", "auth_config.0.oauth2_auth_code_flow"},
						},
						"oauth2_jwt_bearer": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `OAuth2 JWT Bearer for Authentication.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"client_key": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Secret version reference containing a PKCS#8 PEM-encoded private key associated with the Client Certificate.
This private key will be used to sign JWTs used for the jwt-bearer authorization grant.
Specified in the form as: projects/*/secrets/*/versions/*.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The resource name of the secret version in the format,
format as: projects/*/secrets/*/versions/*.`,
												},
											},
										},
									},
									"jwt_claims": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `JwtClaims providers fields to generate the token.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"audience": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Value for the "aud" claim.`,
												},
												"issuer": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Value for the "iss" claim.`,
												},
												"subject": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Value for the "sub" claim.`,
												},
											},
										},
									},
								},
							},
							ExactlyOneOf: []string{"auth_config.0.user_password", "auth_config.0.oauth2_jwt_bearer", "auth_config.0.oauth2_client_credentials", "auth_config.0.ssh_public_key", "auth_config.0.oauth2_auth_code_flow"},
						},
						"ssh_public_key": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `SSH Public Key for Authentication.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"username": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The user account used to authenticate.`,
									},
									"cert_type": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Format of SSH Client cert.`,
									},
									"ssh_client_cert": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `SSH Client Cert. It should contain both public and private key.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The resource name of the secret version in the format,
format as: projects/*/secrets/*/versions/*.`,
												},
											},
										},
									},
									"ssh_client_cert_pass": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Password (passphrase) for ssh client certificate if it has one.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The resource name of the secret version in the format,
format as: projects/*/secrets/*/versions/*.`,
												},
											},
										},
									},
								},
							},
							ExactlyOneOf: []string{"auth_config.0.user_password", "auth_config.0.oauth2_jwt_bearer", "auth_config.0.oauth2_client_credentials", "auth_config.0.ssh_public_key", "auth_config.0.oauth2_auth_code_flow"},
						},
						"user_password": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `User password for Authentication.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"username": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Username for Authentication.`,
									},
									"password": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Password for Authentication.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The resource name of the secret version in the format,
format as: projects/*/secrets/*/versions/*.`,
												},
											},
										},
									},
								},
							},
							ExactlyOneOf: []string{"auth_config.0.user_password", "auth_config.0.oauth2_jwt_bearer", "auth_config.0.oauth2_client_credentials", "auth_config.0.ssh_public_key", "auth_config.0.oauth2_auth_code_flow"},
						},
					},
				},
			},
			"config_variable": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Config Variables for the connection.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"key": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Key for the configVariable`,
						},
						"boolean_value": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Boolean Value of configVariable`,
						},
						"encryption_key_value": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Encription key value of configVariable.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"type": {
										Type:         schema.TypeString,
										Required:     true,
										ValidateFunc: verify.ValidateEnum([]string{"GOOGLE_MANAGED", "CUSTOMER_MANAGED"}),
										Description:  `Type of Encription Key Possible values: ["GOOGLE_MANAGED", "CUSTOMER_MANAGED"]`,
									},
									"kms_key_name": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The [KMS key name] with which the content of the Operation is encrypted. The expected
format: projects/*/locations/*/keyRings/*/cryptoKeys/*.
Will be empty string if google managed.`,
									},
								},
							},
						},
						"integer_value": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `Integer Value of configVariable`,
						},
						"secret_value": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Secret value of configVariable.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"secret_version": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Secret version of Secret Value for Config variable.`,
									},
								},
							},
						},
						"string_value": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `String Value of configVariabley`,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An arbitrary description for the Conection.`,
			},
			"destination_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Define the Connectors target endpoint.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"key": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The key is the destination identifier that is supported by the Connector.`,
						},
						"destination": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The destinations for the key.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"host": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `For publicly routable host.`,
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `The port is the target port number that is accepted by the destination.`,
									},
									"service_attachment": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `PSC service attachments. Format: projects/*/regions/*/serviceAttachments/*`,
									},
								},
							},
						},
					},
				},
			},
			"eventing_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Eventing Configuration of a connection`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"registration_destination_config": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `registrationDestinationConfig`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"destination": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `destinations for the connection`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"host": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Host`,
												},
												"port": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `port number`,
												},
												"service_attachment": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Service Attachment`,
												},
											},
										},
									},
									"key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Key for the connection`,
									},
								},
							},
						},
						"additional_variable": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `List containing additional auth configs.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Key for the configVariable`,
									},
									"boolean_value": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Boolean Value of configVariable.`,
									},
									"encryption_key_value": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Encription key value of configVariable.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"kms_key_name": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `The [KMS key name] with which the content of the Operation is encrypted. The expected
format: projects/*/locations/*/keyRings/*/cryptoKeys/*.
Will be empty string if google managed.`,
												},
												"type": {
													Type:         schema.TypeString,
													Optional:     true,
													ValidateFunc: verify.ValidateEnum([]string{"GOOGLE_MANAGED", "CUSTOMER_MANAGED", ""}),
													Description:  `Type of Encryption Key Possible values: ["GOOGLE_MANAGED", "CUSTOMER_MANAGED"]`,
												},
											},
										},
									},
									"integer_value": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Integer Value of configVariable.`,
									},
									"secret_value": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Secret value of configVariable`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `Secret version of Secret Value for Config variable.`,
												},
											},
										},
									},
									"string_value": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `String Value of configVariabley.`,
									},
								},
							},
						},
						"auth_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `authConfig for Eventing Configuration.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auth_type": {
										Type:         schema.TypeString,
										Required:     true,
										ValidateFunc: verify.ValidateEnum([]string{"USER_PASSWORD"}),
										Description:  `authType of the Connection Possible values: ["USER_PASSWORD"]`,
									},
									"user_password": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `User password for Authentication.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"password": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Password for Authentication.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"secret_version": {
																Type:     schema.TypeString,
																Required: true,
																Description: `The resource name of the secret version in the format,
format as: projects/*/secrets/*/versions/*.`,
															},
														},
													},
												},
												"username": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Username for Authentication.`,
												},
											},
										},
									},
									"additional_variable": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `List containing additional auth configs.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"key": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `Key for the configVariable`,
												},
												"boolean_value": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: `Boolean Value of configVariable.`,
												},
												"encryption_key_value": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Encription key value of configVariable`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"kms_key_name": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The [KMS key name] with which the content of the Operation is encrypted. The expected
format: projects/*/locations/*/keyRings/*/cryptoKeys/*.
Will be empty string if google managed.`,
															},
															"type": {
																Type:         schema.TypeString,
																Optional:     true,
																ValidateFunc: verify.ValidateEnum([]string{"GOOGLE_MANAGED", "CUSTOMER_MANAGED", ""}),
																Description:  `Type of Encription Key Possible values: ["GOOGLE_MANAGED", "CUSTOMER_MANAGED"]`,
															},
														},
													},
												},
												"integer_value": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `Integer Value of configVariable.`,
												},
												"secret_value": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Secret value of configVariable`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"secret_version": {
																Type:        schema.TypeString,
																Required:    true,
																Description: `Secret version of Secret Value for Config variable.`,
															},
														},
													},
												},
												"string_value": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `String Value of configVariabley.`,
												},
											},
										},
									},
									"auth_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The type of authentication configured.`,
									},
								},
							},
						},
						"enrichment_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Enrichment Enabled.`,
						},
					},
				},
			},
			"eventing_enablement_type": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"EVENTING_AND_CONNECTION", "ONLY_EVENTING", ""}),
				Description:  `Eventing enablement type. Will be nil if eventing is not enabled. Possible values: ["EVENTING_AND_CONNECTION", "ONLY_EVENTING"]`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Resource labels to represent user provided metadata.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"lock_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Determines whether or no a connection is locked. If locked, a reason must be specified.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"locked": {
							Type:        schema.TypeBool,
							Required:    true,
							Description: `Indicates whether or not the connection is locked.`,
						},
						"reason": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Describes why a connection is locked.`,
						},
					},
				},
			},
			"log_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Log configuration for the connection.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enabled": {
							Type:        schema.TypeBool,
							Required:    true,
							Description: `Enabled represents whether logging is enabled or not for a connection.`,
						},
					},
				},
			},
			"node_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Node configuration for the connection.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"max_node_count": {
							Type:        schema.TypeInt,
							Computed:    true,
							Optional:    true,
							Description: `Minimum number of nodes in the runtime nodes.`,
						},
						"min_node_count": {
							Type:        schema.TypeInt,
							Computed:    true,
							Optional:    true,
							Description: `Minimum number of nodes in the runtime nodes.`,
						},
					},
				},
			},
			"service_account": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				Description: `Service account needed for runtime plane to access Google Cloud resources.`,
			},
			"ssl_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `SSL Configuration of a connection`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"type": {
							Type:         schema.TypeString,
							Required:     true,
							ValidateFunc: verify.ValidateEnum([]string{"TLS", "MTLS"}),
							Description:  `Enum for controlling the SSL Type (TLS/MTLS) Possible values: ["TLS", "MTLS"]`,
						},
						"additional_variable": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Additional SSL related field values.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Key for the configVariable`,
									},
									"boolean_value": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Boolean Value of configVariable.`,
									},
									"encryption_key_value": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Encription key value of configVariable`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"kms_key_name": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `The [KMS key name] with which the content of the Operation is encrypted. The expected
format: projects/*/locations/*/keyRings/*/cryptoKeys/*.
Will be empty string if google managed.`,
												},
												"type": {
													Type:         schema.TypeString,
													Optional:     true,
													ValidateFunc: verify.ValidateEnum([]string{"GOOGLE_MANAGED", "CUSTOMER_MANAGED", ""}),
													Description:  `Type of Encription Key Possible values: ["GOOGLE_MANAGED", "CUSTOMER_MANAGED"]`,
												},
											},
										},
									},
									"integer_value": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Integer Value of configVariable.`,
									},
									"secret_value": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Secret value of configVariable`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `Secret version of Secret Value for Config variable.`,
												},
											},
										},
									},
									"string_value": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `String Value of configVariabley.`,
									},
								},
							},
						},
						"client_cert_type": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"PEM", ""}),
							Description:  `Type of Client Cert (PEM/JKS/.. etc.) Possible values: ["PEM"]`,
						},
						"client_certificate": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Client Certificate`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"secret_version": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Secret version of Secret Value for Config variable.`,
									},
								},
							},
						},
						"client_private_key": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Client Private Key`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"secret_version": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Secret version of Secret Value for Config variable.`,
									},
								},
							},
						},
						"client_private_key_pass": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Secret containing the passphrase protecting the Client Private Key`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"secret_version": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Secret version of Secret Value for Config variable.`,
									},
								},
							},
						},
						"private_server_certificate": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Private Server Certificate. Needs to be specified if trust model is PRIVATE.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"secret_version": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Secret version of Secret Value for Config variable.`,
									},
								},
							},
						},
						"server_cert_type": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"PEM", ""}),
							Description:  `Type of Server Cert (PEM/JKS/.. etc.) Possible values: ["PEM"]`,
						},
						"trust_model": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"PUBLIC", "PRIVATE", "INSECURE", ""}),
							Description:  `Enum for Trust Model Possible values: ["PUBLIC", "PRIVATE", "INSECURE"]`,
						},
						"use_ssl": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Bool for enabling SSL`,
						},
					},
				},
			},
			"suspended": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Suspended indicates if a user has suspended a connection or not.`,
			},
			"connection_revision": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Connection revision. This field is only updated when the connection is created or updated by User.`,
			},
			"connector_version_infra_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `This configuration provides infra configs like rate limit threshold which need to be configurable for every connector version.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ratelimit_threshold": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Max QPS supported by the connector version before throttling of requests.`,
						},
					},
				},
			},
			"connector_version_launch_stage": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Flag to mark the version indicating the launch stage.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time the Namespace was created in UTC.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"eventing_runtime_data": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Eventing Runtime Data.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"events_listener_endpoint": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Events listener endpoint. The value will populated after provisioning the events listener.`,
						},
						"status": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Current status of eventing.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"description": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Description of error if State is set to "ERROR".`,
									},
									"state": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `State of the Eventing`,
									},
								},
							},
						},
					},
				},
			},
			"service_directory": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The name of the Service Directory service name. Used for Private Harpoon to resolve the ILB address.
e.g. "projects/cloud-connectors-e2e-testing/locations/us-central1/namespaces/istio-system/services/istio-ingressgateway-connectors"`,
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Status of the Integration Connector.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"description": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Description of Status of Connection.`,
						},
						"state": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `State of the Integration Connector`,
						},
						"status": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Status of the Connection.`,
						},
					},
				},
			},
			"subscription_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `This subscription type enum states the subscription type of the project.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Time the Namespace was updated in UTC.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceIntegrationConnectorsConnectionCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandIntegrationConnectorsConnectionDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	connectorVersionProp, err := expandIntegrationConnectorsConnectionConnectorVersion(d.Get("connector_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("connector_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(connectorVersionProp)) && (ok || !reflect.DeepEqual(v, connectorVersionProp)) {
		obj["connectorVersion"] = connectorVersionProp
	}
	configVariablesProp, err := expandIntegrationConnectorsConnectionConfigVariable(d.Get("config_variable"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("config_variable"); !tpgresource.IsEmptyValue(reflect.ValueOf(configVariablesProp)) && (ok || !reflect.DeepEqual(v, configVariablesProp)) {
		obj["configVariables"] = configVariablesProp
	}
	authConfigProp, err := expandIntegrationConnectorsConnectionAuthConfig(d.Get("auth_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auth_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(authConfigProp)) && (ok || !reflect.DeepEqual(v, authConfigProp)) {
		obj["authConfig"] = authConfigProp
	}
	lockConfigProp, err := expandIntegrationConnectorsConnectionLockConfig(d.Get("lock_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("lock_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(lockConfigProp)) && (ok || !reflect.DeepEqual(v, lockConfigProp)) {
		obj["lockConfig"] = lockConfigProp
	}
	destinationConfigsProp, err := expandIntegrationConnectorsConnectionDestinationConfig(d.Get("destination_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("destination_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(destinationConfigsProp)) && (ok || !reflect.DeepEqual(v, destinationConfigsProp)) {
		obj["destinationConfigs"] = destinationConfigsProp
	}
	serviceAccountProp, err := expandIntegrationConnectorsConnectionServiceAccount(d.Get("service_account"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("service_account"); !tpgresource.IsEmptyValue(reflect.ValueOf(serviceAccountProp)) && (ok || !reflect.DeepEqual(v, serviceAccountProp)) {
		obj["serviceAccount"] = serviceAccountProp
	}
	suspendedProp, err := expandIntegrationConnectorsConnectionSuspended(d.Get("suspended"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("suspended"); !tpgresource.IsEmptyValue(reflect.ValueOf(suspendedProp)) && (ok || !reflect.DeepEqual(v, suspendedProp)) {
		obj["suspended"] = suspendedProp
	}
	nodeConfigProp, err := expandIntegrationConnectorsConnectionNodeConfig(d.Get("node_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("node_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(nodeConfigProp)) && (ok || !reflect.DeepEqual(v, nodeConfigProp)) {
		obj["nodeConfig"] = nodeConfigProp
	}
	logConfigProp, err := expandIntegrationConnectorsConnectionLogConfig(d.Get("log_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("log_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(logConfigProp)) && (ok || !reflect.DeepEqual(v, logConfigProp)) {
		obj["logConfig"] = logConfigProp
	}
	sslConfigProp, err := expandIntegrationConnectorsConnectionSslConfig(d.Get("ssl_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ssl_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(sslConfigProp)) && (ok || !reflect.DeepEqual(v, sslConfigProp)) {
		obj["sslConfig"] = sslConfigProp
	}
	eventingEnablementTypeProp, err := expandIntegrationConnectorsConnectionEventingEnablementType(d.Get("eventing_enablement_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("eventing_enablement_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(eventingEnablementTypeProp)) && (ok || !reflect.DeepEqual(v, eventingEnablementTypeProp)) {
		obj["eventingEnablementType"] = eventingEnablementTypeProp
	}
	eventingConfigProp, err := expandIntegrationConnectorsConnectionEventingConfig(d.Get("eventing_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("eventing_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(eventingConfigProp)) && (ok || !reflect.DeepEqual(v, eventingConfigProp)) {
		obj["eventingConfig"] = eventingConfigProp
	}
	labelsProp, err := expandIntegrationConnectorsConnectionEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationConnectorsBasePath}}projects/{{project}}/locations/{{location}}/connections?connectionId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Connection: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating Connection: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = IntegrationConnectorsOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating Connection", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create Connection: %s", err)
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	if err := waitforConnectionReady(d, config, d.Timeout(schema.TimeoutCreate)-time.Minute); err != nil {
		return fmt.Errorf("Error waiting for Connection %q to finish being in CREATING state during creation: %q", d.Get("name").(string), err)
	}

	log.Printf("[DEBUG] Finished creating Connection %q: %#v", d.Id(), res)

	return resourceIntegrationConnectorsConnectionRead(d, meta)
}

func resourceIntegrationConnectorsConnectionRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationConnectorsBasePath}}projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("IntegrationConnectorsConnection %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}

	if err := d.Set("create_time", flattenIntegrationConnectorsConnectionCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("update_time", flattenIntegrationConnectorsConnectionUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("description", flattenIntegrationConnectorsConnectionDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("labels", flattenIntegrationConnectorsConnectionLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("connector_version", flattenIntegrationConnectorsConnectionConnectorVersion(res["connectorVersion"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("status", flattenIntegrationConnectorsConnectionStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("config_variable", flattenIntegrationConnectorsConnectionConfigVariable(res["configVariables"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("auth_config", flattenIntegrationConnectorsConnectionAuthConfig(res["authConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("lock_config", flattenIntegrationConnectorsConnectionLockConfig(res["lockConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("destination_config", flattenIntegrationConnectorsConnectionDestinationConfig(res["destinationConfigs"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("service_account", flattenIntegrationConnectorsConnectionServiceAccount(res["serviceAccount"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("service_directory", flattenIntegrationConnectorsConnectionServiceDirectory(res["serviceDirectory"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("suspended", flattenIntegrationConnectorsConnectionSuspended(res["suspended"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("node_config", flattenIntegrationConnectorsConnectionNodeConfig(res["nodeConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("log_config", flattenIntegrationConnectorsConnectionLogConfig(res["logConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("ssl_config", flattenIntegrationConnectorsConnectionSslConfig(res["sslConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("subscription_type", flattenIntegrationConnectorsConnectionSubscriptionType(res["subscriptionType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("connection_revision", flattenIntegrationConnectorsConnectionConnectionRevision(res["connectionRevision"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("eventing_enablement_type", flattenIntegrationConnectorsConnectionEventingEnablementType(res["eventingEnablementType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("eventing_config", flattenIntegrationConnectorsConnectionEventingConfig(res["eventingConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("connector_version_launch_stage", flattenIntegrationConnectorsConnectionConnectorVersionLaunchStage(res["connectorVersionLaunchStage"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("eventing_runtime_data", flattenIntegrationConnectorsConnectionEventingRuntimeData(res["eventingRuntimeData"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("connector_version_infra_config", flattenIntegrationConnectorsConnectionConnectorVersionInfraConfig(res["connectorVersionInfraConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("terraform_labels", flattenIntegrationConnectorsConnectionTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("effective_labels", flattenIntegrationConnectorsConnectionEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}

	return nil
}

func resourceIntegrationConnectorsConnectionUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandIntegrationConnectorsConnectionDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	connectorVersionProp, err := expandIntegrationConnectorsConnectionConnectorVersion(d.Get("connector_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("connector_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, connectorVersionProp)) {
		obj["connectorVersion"] = connectorVersionProp
	}
	configVariablesProp, err := expandIntegrationConnectorsConnectionConfigVariable(d.Get("config_variable"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("config_variable"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, configVariablesProp)) {
		obj["configVariables"] = configVariablesProp
	}
	authConfigProp, err := expandIntegrationConnectorsConnectionAuthConfig(d.Get("auth_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auth_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, authConfigProp)) {
		obj["authConfig"] = authConfigProp
	}
	lockConfigProp, err := expandIntegrationConnectorsConnectionLockConfig(d.Get("lock_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("lock_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, lockConfigProp)) {
		obj["lockConfig"] = lockConfigProp
	}
	destinationConfigsProp, err := expandIntegrationConnectorsConnectionDestinationConfig(d.Get("destination_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("destination_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, destinationConfigsProp)) {
		obj["destinationConfigs"] = destinationConfigsProp
	}
	serviceAccountProp, err := expandIntegrationConnectorsConnectionServiceAccount(d.Get("service_account"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("service_account"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, serviceAccountProp)) {
		obj["serviceAccount"] = serviceAccountProp
	}
	suspendedProp, err := expandIntegrationConnectorsConnectionSuspended(d.Get("suspended"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("suspended"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, suspendedProp)) {
		obj["suspended"] = suspendedProp
	}
	nodeConfigProp, err := expandIntegrationConnectorsConnectionNodeConfig(d.Get("node_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("node_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nodeConfigProp)) {
		obj["nodeConfig"] = nodeConfigProp
	}
	logConfigProp, err := expandIntegrationConnectorsConnectionLogConfig(d.Get("log_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("log_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, logConfigProp)) {
		obj["logConfig"] = logConfigProp
	}
	sslConfigProp, err := expandIntegrationConnectorsConnectionSslConfig(d.Get("ssl_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ssl_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, sslConfigProp)) {
		obj["sslConfig"] = sslConfigProp
	}
	eventingEnablementTypeProp, err := expandIntegrationConnectorsConnectionEventingEnablementType(d.Get("eventing_enablement_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("eventing_enablement_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, eventingEnablementTypeProp)) {
		obj["eventingEnablementType"] = eventingEnablementTypeProp
	}
	eventingConfigProp, err := expandIntegrationConnectorsConnectionEventingConfig(d.Get("eventing_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("eventing_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, eventingConfigProp)) {
		obj["eventingConfig"] = eventingConfigProp
	}
	labelsProp, err := expandIntegrationConnectorsConnectionEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationConnectorsBasePath}}projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Connection %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("connector_version") {
		updateMask = append(updateMask, "connectorVersion")
	}

	if d.HasChange("config_variable") {
		updateMask = append(updateMask, "configVariables")
	}

	if d.HasChange("auth_config") {
		updateMask = append(updateMask, "authConfig")
	}

	if d.HasChange("lock_config") {
		updateMask = append(updateMask, "lockConfig")
	}

	if d.HasChange("destination_config") {
		updateMask = append(updateMask, "destinationConfigs")
	}

	if d.HasChange("service_account") {
		updateMask = append(updateMask, "serviceAccount")
	}

	if d.HasChange("suspended") {
		updateMask = append(updateMask, "suspended")
	}

	if d.HasChange("node_config") {
		updateMask = append(updateMask, "nodeConfig")
	}

	if d.HasChange("log_config") {
		updateMask = append(updateMask, "logConfig")
	}

	if d.HasChange("ssl_config") {
		updateMask = append(updateMask, "sslConfig")
	}

	if d.HasChange("eventing_enablement_type") {
		updateMask = append(updateMask, "eventingEnablementType")
	}

	if d.HasChange("eventing_config") {
		updateMask = append(updateMask, "eventingConfig")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
		})

		if err != nil {
			return fmt.Errorf("Error updating Connection %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Connection %q: %#v", d.Id(), res)
		}

		err = IntegrationConnectorsOperationWaitTime(
			config, res, project, "Updating Connection", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	if err := waitforConnectionReady(d, config, d.Timeout(schema.TimeoutCreate)-time.Minute); err != nil {
		return fmt.Errorf("Error waiting for Connection %q to finish being in UPDATING state during updation: %q", d.Get("name").(string), err)
	}
	return resourceIntegrationConnectorsConnectionRead(d, meta)
}

func resourceIntegrationConnectorsConnectionDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationConnectorsBasePath}}projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	log.Printf("[DEBUG] Deleting Connection %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Connection")
	}

	err = IntegrationConnectorsOperationWaitTime(
		config, res, project, "Deleting Connection", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Connection %q: %#v", d.Id(), res)
	return nil
}

func resourceIntegrationConnectorsConnectionImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/connections/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	if err := waitforConnectionReady(d, config, d.Timeout(schema.TimeoutCreate)-time.Minute); err != nil {
		return nil, fmt.Errorf("Error waiting for Connection %q to be in a stable state: %q", d.Get("name").(string), err)
	}

	return []*schema.ResourceData{d}, nil
}

func flattenIntegrationConnectorsConnectionCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenIntegrationConnectorsConnectionConnectorVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["state"] =
		flattenIntegrationConnectorsConnectionStatusState(original["state"], d, config)
	transformed["description"] =
		flattenIntegrationConnectorsConnectionStatusDescription(original["description"], d, config)
	transformed["status"] =
		flattenIntegrationConnectorsConnectionStatusStatus(original["status"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionStatusState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionStatusDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionStatusStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionConfigVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":                  flattenIntegrationConnectorsConnectionConfigVariableKey(original["key"], d, config),
			"integer_value":        flattenIntegrationConnectorsConnectionConfigVariableIntegerValue(original["intValue"], d, config),
			"string_value":         flattenIntegrationConnectorsConnectionConfigVariableStringValue(original["stringValue"], d, config),
			"boolean_value":        flattenIntegrationConnectorsConnectionConfigVariableBooleanValue(original["boolValue"], d, config),
			"secret_value":         flattenIntegrationConnectorsConnectionConfigVariableSecretValue(original["secretValue"], d, config),
			"encryption_key_value": flattenIntegrationConnectorsConnectionConfigVariableEncryptionKeyValue(original["encryptionKeyValue"], d, config),
		})
	}
	return transformed
}
func flattenIntegrationConnectorsConnectionConfigVariableKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionConfigVariableIntegerValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionConfigVariableStringValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionConfigVariableBooleanValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionConfigVariableSecretValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionConfigVariableSecretValueSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionConfigVariableSecretValueSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionConfigVariableEncryptionKeyValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["type"] =
		flattenIntegrationConnectorsConnectionConfigVariableEncryptionKeyValueType(original["type"], d, config)
	transformed["kms_key_name"] =
		flattenIntegrationConnectorsConnectionConfigVariableEncryptionKeyValueKmsKeyName(original["kmsKeyName"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionConfigVariableEncryptionKeyValueType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionConfigVariableEncryptionKeyValueKmsKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["auth_type"] =
		flattenIntegrationConnectorsConnectionAuthConfigAuthType(original["authType"], d, config)
	transformed["additional_variable"] =
		flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariable(original["additionalVariables"], d, config)
	transformed["auth_key"] =
		flattenIntegrationConnectorsConnectionAuthConfigAuthKey(original["authKey"], d, config)
	transformed["user_password"] =
		flattenIntegrationConnectorsConnectionAuthConfigUserPassword(original["userPassword"], d, config)
	transformed["oauth2_jwt_bearer"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearer(original["oauth2JwtBearer"], d, config)
	transformed["oauth2_client_credentials"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentials(original["oauth2ClientCredentials"], d, config)
	transformed["ssh_public_key"] =
		flattenIntegrationConnectorsConnectionAuthConfigSshPublicKey(original["sshPublicKey"], d, config)
	transformed["oauth2_auth_code_flow"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlow(original["oauth2AuthCodeFlow"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigAuthType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":                  flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableKey(original["key"], d, config),
			"integer_value":        flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableIntegerValue(original["intValue"], d, config),
			"string_value":         flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableStringValue(original["stringValue"], d, config),
			"boolean_value":        flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableBooleanValue(original["boolValue"], d, config),
			"secret_value":         flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableSecretValue(original["secretValue"], d, config),
			"encryption_key_value": flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValue(original["encryptionKeyValue"], d, config),
		})
	}
	return transformed
}
func flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableIntegerValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableStringValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableBooleanValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableSecretValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableSecretValueSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableSecretValueSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["type"] =
		flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValueType(original["type"], d, config)
	transformed["kms_key_name"] =
		flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValueKmsKeyName(original["kmsKeyName"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValueType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValueKmsKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigAuthKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigUserPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["username"] =
		flattenIntegrationConnectorsConnectionAuthConfigUserPasswordUsername(original["username"], d, config)
	transformed["password"] =
		flattenIntegrationConnectorsConnectionAuthConfigUserPasswordPassword(original["password"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigUserPasswordUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigUserPasswordPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionAuthConfigUserPasswordPasswordSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigUserPasswordPasswordSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["client_key"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerClientKey(original["clientKey"], d, config)
	transformed["jwt_claims"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaims(original["jwtClaims"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerClientKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerClientKeySecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerClientKeySecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaims(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["issuer"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsIssuer(original["issuer"], d, config)
	transformed["subject"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsSubject(original["subject"], d, config)
	transformed["audience"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsAudience(original["audience"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsIssuer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsSubject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsAudience(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentials(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["client_id"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientId(original["clientId"], d, config)
	transformed["client_secret"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientSecret(original["clientSecret"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientSecretSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientSecretSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigSshPublicKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["username"] =
		flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeyUsername(original["username"], d, config)
	transformed["ssh_client_cert"] =
		flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCert(original["sshClientCert"], d, config)
	transformed["cert_type"] =
		flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeyCertType(original["certType"], d, config)
	transformed["ssh_client_cert_pass"] =
		flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertPass(original["sshClientCertPass"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeyUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCert(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeyCertType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertPass(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertPassSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertPassSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlow(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["client_id"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientId(original["clientId"], d, config)
	transformed["client_secret"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientSecret(original["clientSecret"], d, config)
	transformed["scopes"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowScopes(original["scopes"], d, config)
	transformed["enable_pkce"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowEnablePkce(original["enablePkce"], d, config)
	transformed["auth_uri"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowAuthUri(original["authUri"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientSecretSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientSecretSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowScopes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowEnablePkce(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowAuthUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionLockConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["locked"] =
		flattenIntegrationConnectorsConnectionLockConfigLocked(original["locked"], d, config)
	transformed["reason"] =
		flattenIntegrationConnectorsConnectionLockConfigReason(original["reason"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionLockConfigLocked(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionLockConfigReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionDestinationConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":         flattenIntegrationConnectorsConnectionDestinationConfigKey(original["key"], d, config),
			"destination": flattenIntegrationConnectorsConnectionDestinationConfigDestination(original["destinations"], d, config),
		})
	}
	return transformed
}
func flattenIntegrationConnectorsConnectionDestinationConfigKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionDestinationConfigDestination(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"port":               flattenIntegrationConnectorsConnectionDestinationConfigDestinationPort(original["port"], d, config),
			"service_attachment": flattenIntegrationConnectorsConnectionDestinationConfigDestinationServiceAttachment(original["serviceAttachment"], d, config),
			"host":               flattenIntegrationConnectorsConnectionDestinationConfigDestinationHost(original["host"], d, config),
		})
	}
	return transformed
}
func flattenIntegrationConnectorsConnectionDestinationConfigDestinationPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionDestinationConfigDestinationServiceAttachment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionDestinationConfigDestinationHost(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionServiceDirectory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSuspended(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionNodeConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["min_node_count"] =
		flattenIntegrationConnectorsConnectionNodeConfigMinNodeCount(original["minNodeCount"], d, config)
	transformed["max_node_count"] =
		flattenIntegrationConnectorsConnectionNodeConfigMaxNodeCount(original["maxNodeCount"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionNodeConfigMinNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionNodeConfigMaxNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionLogConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenIntegrationConnectorsConnectionLogConfigEnabled(original["enabled"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionLogConfigEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["type"] =
		flattenIntegrationConnectorsConnectionSslConfigType(original["type"], d, config)
	transformed["trust_model"] =
		flattenIntegrationConnectorsConnectionSslConfigTrustModel(original["trustModel"], d, config)
	transformed["private_server_certificate"] =
		flattenIntegrationConnectorsConnectionSslConfigPrivateServerCertificate(original["privateServerCertificate"], d, config)
	transformed["client_certificate"] =
		flattenIntegrationConnectorsConnectionSslConfigClientCertificate(original["clientCertificate"], d, config)
	transformed["client_private_key"] =
		flattenIntegrationConnectorsConnectionSslConfigClientPrivateKey(original["clientPrivateKey"], d, config)
	transformed["client_private_key_pass"] =
		flattenIntegrationConnectorsConnectionSslConfigClientPrivateKeyPass(original["clientPrivateKeyPass"], d, config)
	transformed["server_cert_type"] =
		flattenIntegrationConnectorsConnectionSslConfigServerCertType(original["serverCertType"], d, config)
	transformed["client_cert_type"] =
		flattenIntegrationConnectorsConnectionSslConfigClientCertType(original["clientCertType"], d, config)
	transformed["use_ssl"] =
		flattenIntegrationConnectorsConnectionSslConfigUseSsl(original["useSsl"], d, config)
	transformed["additional_variable"] =
		flattenIntegrationConnectorsConnectionSslConfigAdditionalVariable(original["additionalVariables"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionSslConfigType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigTrustModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigPrivateServerCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionSslConfigPrivateServerCertificateSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionSslConfigPrivateServerCertificateSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigClientCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionSslConfigClientCertificateSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionSslConfigClientCertificateSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigClientPrivateKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionSslConfigClientPrivateKeySecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionSslConfigClientPrivateKeySecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigClientPrivateKeyPass(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionSslConfigClientPrivateKeyPassSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionSslConfigClientPrivateKeyPassSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigServerCertType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigClientCertType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigUseSsl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigAdditionalVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":                  flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableKey(original["key"], d, config),
			"integer_value":        flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableIntegerValue(original["intValue"], d, config),
			"string_value":         flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableStringValue(original["stringValue"], d, config),
			"boolean_value":        flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableBooleanValue(original["boolValue"], d, config),
			"secret_value":         flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableSecretValue(original["secretValue"], d, config),
			"encryption_key_value": flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValue(original["encryptionKeyValue"], d, config),
		})
	}
	return transformed
}
func flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableIntegerValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableStringValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableBooleanValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableSecretValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableSecretValueSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableSecretValueSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["type"] =
		flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValueType(original["type"], d, config)
	transformed["kms_key_name"] =
		flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValueKmsKeyName(original["kmsKeyName"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValueType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValueKmsKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionSubscriptionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionConnectionRevision(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingEnablementType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["registration_destination_config"] =
		flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfig(original["registrationDestinationConfig"], d, config)
	transformed["auth_config"] =
		flattenIntegrationConnectorsConnectionEventingConfigAuthConfig(original["authConfig"], d, config)
	transformed["additional_variable"] =
		flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariable(original["additionalVariables"], d, config)
	transformed["enrichment_enabled"] =
		flattenIntegrationConnectorsConnectionEventingConfigEnrichmentEnabled(original["enrichmentEnabled"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["key"] =
		flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigKey(original["key"], d, config)
	transformed["destination"] =
		flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestination(original["destinations"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestination(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"port":               flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationPort(original["port"], d, config),
			"service_attachment": flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationServiceAttachment(original["serviceAttachment"], d, config),
			"host":               flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationHost(original["host"], d, config),
		})
	}
	return transformed
}
func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationServiceAttachment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationHost(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["auth_type"] =
		flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAuthType(original["authType"], d, config)
	transformed["additional_variable"] =
		flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariable(original["additionalVariables"], d, config)
	transformed["auth_key"] =
		flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAuthKey(original["authKey"], d, config)
	transformed["user_password"] =
		flattenIntegrationConnectorsConnectionEventingConfigAuthConfigUserPassword(original["userPassword"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAuthType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":                  flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableKey(original["key"], d, config),
			"integer_value":        flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableIntegerValue(original["intValue"], d, config),
			"string_value":         flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableStringValue(original["stringValue"], d, config),
			"boolean_value":        flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableBooleanValue(original["boolValue"], d, config),
			"secret_value":         flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableSecretValue(original["secretValue"], d, config),
			"encryption_key_value": flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValue(original["encryptionKeyValue"], d, config),
		})
	}
	return transformed
}
func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableIntegerValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableStringValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableBooleanValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableSecretValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableSecretValueSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableSecretValueSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["type"] =
		flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValueType(original["type"], d, config)
	transformed["kms_key_name"] =
		flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValueKmsKeyName(original["kmsKeyName"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValueType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValueKmsKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigAuthKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigUserPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["username"] =
		flattenIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordUsername(original["username"], d, config)
	transformed["password"] =
		flattenIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordPassword(original["password"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordPasswordSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordPasswordSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":                  flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableKey(original["key"], d, config),
			"integer_value":        flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableIntegerValue(original["intValue"], d, config),
			"string_value":         flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableStringValue(original["stringValue"], d, config),
			"boolean_value":        flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableBooleanValue(original["boolValue"], d, config),
			"secret_value":         flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableSecretValue(original["secretValue"], d, config),
			"encryption_key_value": flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValue(original["encryptionKeyValue"], d, config),
		})
	}
	return transformed
}
func flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableIntegerValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableStringValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableBooleanValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableSecretValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableSecretValueSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableSecretValueSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["type"] =
		flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValueType(original["type"], d, config)
	transformed["kms_key_name"] =
		flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValueKmsKeyName(original["kmsKeyName"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValueType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValueKmsKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigEnrichmentEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionConnectorVersionLaunchStage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingRuntimeData(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["status"] =
		flattenIntegrationConnectorsConnectionEventingRuntimeDataStatus(original["status"], d, config)
	transformed["events_listener_endpoint"] =
		flattenIntegrationConnectorsConnectionEventingRuntimeDataEventsListenerEndpoint(original["eventsListenerEndpoint"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingRuntimeDataStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["state"] =
		flattenIntegrationConnectorsConnectionEventingRuntimeDataStatusState(original["state"], d, config)
	transformed["description"] =
		flattenIntegrationConnectorsConnectionEventingRuntimeDataStatusDescription(original["description"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingRuntimeDataStatusState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingRuntimeDataStatusDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingRuntimeDataEventsListenerEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionConnectorVersionInfraConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ratelimit_threshold"] =
		flattenIntegrationConnectorsConnectionConnectorVersionInfraConfigRatelimitThreshold(original["ratelimitThreshold"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionConnectorVersionInfraConfigRatelimitThreshold(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenIntegrationConnectorsConnectionEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandIntegrationConnectorsConnectionDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionConnectorVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionConfigVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandIntegrationConnectorsConnectionConfigVariableKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedIntegerValue, err := expandIntegrationConnectorsConnectionConfigVariableIntegerValue(original["integer_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIntegerValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["intValue"] = transformedIntegerValue
		}

		transformedStringValue, err := expandIntegrationConnectorsConnectionConfigVariableStringValue(original["string_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStringValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["stringValue"] = transformedStringValue
		}

		transformedBooleanValue, err := expandIntegrationConnectorsConnectionConfigVariableBooleanValue(original["boolean_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedBooleanValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["boolValue"] = transformedBooleanValue
		}

		transformedSecretValue, err := expandIntegrationConnectorsConnectionConfigVariableSecretValue(original["secret_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSecretValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["secretValue"] = transformedSecretValue
		}

		transformedEncryptionKeyValue, err := expandIntegrationConnectorsConnectionConfigVariableEncryptionKeyValue(original["encryption_key_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEncryptionKeyValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["encryptionKeyValue"] = transformedEncryptionKeyValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandIntegrationConnectorsConnectionConfigVariableKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionConfigVariableIntegerValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionConfigVariableStringValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionConfigVariableBooleanValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionConfigVariableSecretValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionConfigVariableSecretValueSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionConfigVariableSecretValueSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionConfigVariableEncryptionKeyValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedType, err := expandIntegrationConnectorsConnectionConfigVariableEncryptionKeyValueType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedKmsKeyName, err := expandIntegrationConnectorsConnectionConfigVariableEncryptionKeyValueKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionConfigVariableEncryptionKeyValueType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionConfigVariableEncryptionKeyValueKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAuthType, err := expandIntegrationConnectorsConnectionAuthConfigAuthType(original["auth_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authType"] = transformedAuthType
	}

	transformedAdditionalVariable, err := expandIntegrationConnectorsConnectionAuthConfigAdditionalVariable(original["additional_variable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdditionalVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["additionalVariables"] = transformedAdditionalVariable
	}

	transformedAuthKey, err := expandIntegrationConnectorsConnectionAuthConfigAuthKey(original["auth_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authKey"] = transformedAuthKey
	}

	transformedUserPassword, err := expandIntegrationConnectorsConnectionAuthConfigUserPassword(original["user_password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUserPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["userPassword"] = transformedUserPassword
	}

	transformedOauth2JwtBearer, err := expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearer(original["oauth2_jwt_bearer"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauth2JwtBearer); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauth2JwtBearer"] = transformedOauth2JwtBearer
	}

	transformedOauth2ClientCredentials, err := expandIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentials(original["oauth2_client_credentials"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauth2ClientCredentials); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauth2ClientCredentials"] = transformedOauth2ClientCredentials
	}

	transformedSshPublicKey, err := expandIntegrationConnectorsConnectionAuthConfigSshPublicKey(original["ssh_public_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSshPublicKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sshPublicKey"] = transformedSshPublicKey
	}

	transformedOauth2AuthCodeFlow, err := expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlow(original["oauth2_auth_code_flow"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauth2AuthCodeFlow); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauth2AuthCodeFlow"] = transformedOauth2AuthCodeFlow
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAuthType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAdditionalVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedIntegerValue, err := expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableIntegerValue(original["integer_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIntegerValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["intValue"] = transformedIntegerValue
		}

		transformedStringValue, err := expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableStringValue(original["string_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStringValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["stringValue"] = transformedStringValue
		}

		transformedBooleanValue, err := expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableBooleanValue(original["boolean_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedBooleanValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["boolValue"] = transformedBooleanValue
		}

		transformedSecretValue, err := expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableSecretValue(original["secret_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSecretValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["secretValue"] = transformedSecretValue
		}

		transformedEncryptionKeyValue, err := expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValue(original["encryption_key_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEncryptionKeyValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["encryptionKeyValue"] = transformedEncryptionKeyValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableIntegerValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableStringValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableBooleanValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableSecretValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableSecretValueSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableSecretValueSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedType, err := expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValueType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedKmsKeyName, err := expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValueKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValueType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAdditionalVariableEncryptionKeyValueKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAuthKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigUserPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUsername, err := expandIntegrationConnectorsConnectionAuthConfigUserPasswordUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	transformedPassword, err := expandIntegrationConnectorsConnectionAuthConfigUserPasswordPassword(original["password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["password"] = transformedPassword
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigUserPasswordUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigUserPasswordPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionAuthConfigUserPasswordPasswordSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigUserPasswordPasswordSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearer(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedClientKey, err := expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerClientKey(original["client_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientKey"] = transformedClientKey
	}

	transformedJwtClaims, err := expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaims(original["jwt_claims"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedJwtClaims); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["jwtClaims"] = transformedJwtClaims
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerClientKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerClientKeySecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerClientKeySecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaims(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIssuer, err := expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsIssuer(original["issuer"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIssuer); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["issuer"] = transformedIssuer
	}

	transformedSubject, err := expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsSubject(original["subject"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSubject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["subject"] = transformedSubject
	}

	transformedAudience, err := expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsAudience(original["audience"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAudience); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["audience"] = transformedAudience
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsIssuer(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsSubject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2JwtBearerJwtClaimsAudience(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentials(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedClientId, err := expandIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientId(original["client_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientId"] = transformedClientId
	}

	transformedClientSecret, err := expandIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientSecret(original["client_secret"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientSecret"] = transformedClientSecret
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientSecretSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2ClientCredentialsClientSecretSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigSshPublicKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUsername, err := expandIntegrationConnectorsConnectionAuthConfigSshPublicKeyUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	transformedSshClientCert, err := expandIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCert(original["ssh_client_cert"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSshClientCert); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sshClientCert"] = transformedSshClientCert
	}

	transformedCertType, err := expandIntegrationConnectorsConnectionAuthConfigSshPublicKeyCertType(original["cert_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCertType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["certType"] = transformedCertType
	}

	transformedSshClientCertPass, err := expandIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertPass(original["ssh_client_cert_pass"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSshClientCertPass); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sshClientCertPass"] = transformedSshClientCertPass
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigSshPublicKeyUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCert(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigSshPublicKeyCertType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertPass(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertPassSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigSshPublicKeySshClientCertPassSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlow(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedClientId, err := expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientId(original["client_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientId"] = transformedClientId
	}

	transformedClientSecret, err := expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientSecret(original["client_secret"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientSecret"] = transformedClientSecret
	}

	transformedScopes, err := expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowScopes(original["scopes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScopes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scopes"] = transformedScopes
	}

	transformedEnablePkce, err := expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowEnablePkce(original["enable_pkce"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnablePkce); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enablePkce"] = transformedEnablePkce
	}

	transformedAuthUri, err := expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowAuthUri(original["auth_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authUri"] = transformedAuthUri
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientSecretSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowClientSecretSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowScopes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowEnablePkce(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigOauth2AuthCodeFlowAuthUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionLockConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLocked, err := expandIntegrationConnectorsConnectionLockConfigLocked(original["locked"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocked); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["locked"] = transformedLocked
	}

	transformedReason, err := expandIntegrationConnectorsConnectionLockConfigReason(original["reason"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReason); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["reason"] = transformedReason
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionLockConfigLocked(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionLockConfigReason(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionDestinationConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandIntegrationConnectorsConnectionDestinationConfigKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedDestination, err := expandIntegrationConnectorsConnectionDestinationConfigDestination(original["destination"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDestination); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["destinations"] = transformedDestination
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandIntegrationConnectorsConnectionDestinationConfigKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionDestinationConfigDestination(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedPort, err := expandIntegrationConnectorsConnectionDestinationConfigDestinationPort(original["port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["port"] = transformedPort
		}

		transformedServiceAttachment, err := expandIntegrationConnectorsConnectionDestinationConfigDestinationServiceAttachment(original["service_attachment"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedServiceAttachment); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["serviceAttachment"] = transformedServiceAttachment
		}

		transformedHost, err := expandIntegrationConnectorsConnectionDestinationConfigDestinationHost(original["host"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHost); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["host"] = transformedHost
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandIntegrationConnectorsConnectionDestinationConfigDestinationPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionDestinationConfigDestinationServiceAttachment(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionDestinationConfigDestinationHost(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSuspended(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionNodeConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMinNodeCount, err := expandIntegrationConnectorsConnectionNodeConfigMinNodeCount(original["min_node_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minNodeCount"] = transformedMinNodeCount
	}

	transformedMaxNodeCount, err := expandIntegrationConnectorsConnectionNodeConfigMaxNodeCount(original["max_node_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxNodeCount"] = transformedMaxNodeCount
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionNodeConfigMinNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionNodeConfigMaxNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionLogConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandIntegrationConnectorsConnectionLogConfigEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionLogConfigEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedType, err := expandIntegrationConnectorsConnectionSslConfigType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedTrustModel, err := expandIntegrationConnectorsConnectionSslConfigTrustModel(original["trust_model"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTrustModel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["trustModel"] = transformedTrustModel
	}

	transformedPrivateServerCertificate, err := expandIntegrationConnectorsConnectionSslConfigPrivateServerCertificate(original["private_server_certificate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrivateServerCertificate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["privateServerCertificate"] = transformedPrivateServerCertificate
	}

	transformedClientCertificate, err := expandIntegrationConnectorsConnectionSslConfigClientCertificate(original["client_certificate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientCertificate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientCertificate"] = transformedClientCertificate
	}

	transformedClientPrivateKey, err := expandIntegrationConnectorsConnectionSslConfigClientPrivateKey(original["client_private_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientPrivateKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientPrivateKey"] = transformedClientPrivateKey
	}

	transformedClientPrivateKeyPass, err := expandIntegrationConnectorsConnectionSslConfigClientPrivateKeyPass(original["client_private_key_pass"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientPrivateKeyPass); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientPrivateKeyPass"] = transformedClientPrivateKeyPass
	}

	transformedServerCertType, err := expandIntegrationConnectorsConnectionSslConfigServerCertType(original["server_cert_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServerCertType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serverCertType"] = transformedServerCertType
	}

	transformedClientCertType, err := expandIntegrationConnectorsConnectionSslConfigClientCertType(original["client_cert_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientCertType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientCertType"] = transformedClientCertType
	}

	transformedUseSsl, err := expandIntegrationConnectorsConnectionSslConfigUseSsl(original["use_ssl"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUseSsl); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["useSsl"] = transformedUseSsl
	}

	transformedAdditionalVariable, err := expandIntegrationConnectorsConnectionSslConfigAdditionalVariable(original["additional_variable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdditionalVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["additionalVariables"] = transformedAdditionalVariable
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionSslConfigType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigTrustModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigPrivateServerCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionSslConfigPrivateServerCertificateSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionSslConfigPrivateServerCertificateSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigClientCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionSslConfigClientCertificateSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionSslConfigClientCertificateSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigClientPrivateKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionSslConfigClientPrivateKeySecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionSslConfigClientPrivateKeySecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigClientPrivateKeyPass(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionSslConfigClientPrivateKeyPassSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionSslConfigClientPrivateKeyPassSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigServerCertType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigClientCertType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigUseSsl(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigAdditionalVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandIntegrationConnectorsConnectionSslConfigAdditionalVariableKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedIntegerValue, err := expandIntegrationConnectorsConnectionSslConfigAdditionalVariableIntegerValue(original["integer_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIntegerValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["intValue"] = transformedIntegerValue
		}

		transformedStringValue, err := expandIntegrationConnectorsConnectionSslConfigAdditionalVariableStringValue(original["string_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStringValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["stringValue"] = transformedStringValue
		}

		transformedBooleanValue, err := expandIntegrationConnectorsConnectionSslConfigAdditionalVariableBooleanValue(original["boolean_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedBooleanValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["boolValue"] = transformedBooleanValue
		}

		transformedSecretValue, err := expandIntegrationConnectorsConnectionSslConfigAdditionalVariableSecretValue(original["secret_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSecretValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["secretValue"] = transformedSecretValue
		}

		transformedEncryptionKeyValue, err := expandIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValue(original["encryption_key_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEncryptionKeyValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["encryptionKeyValue"] = transformedEncryptionKeyValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandIntegrationConnectorsConnectionSslConfigAdditionalVariableKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigAdditionalVariableIntegerValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigAdditionalVariableStringValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigAdditionalVariableBooleanValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigAdditionalVariableSecretValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionSslConfigAdditionalVariableSecretValueSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionSslConfigAdditionalVariableSecretValueSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedType, err := expandIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValueType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedKmsKeyName, err := expandIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValueKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValueType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionSslConfigAdditionalVariableEncryptionKeyValueKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingEnablementType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRegistrationDestinationConfig, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfig(original["registration_destination_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRegistrationDestinationConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["registrationDestinationConfig"] = transformedRegistrationDestinationConfig
	}

	transformedAuthConfig, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfig(original["auth_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authConfig"] = transformedAuthConfig
	}

	transformedAdditionalVariable, err := expandIntegrationConnectorsConnectionEventingConfigAdditionalVariable(original["additional_variable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdditionalVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["additionalVariables"] = transformedAdditionalVariable
	}

	transformedEnrichmentEnabled, err := expandIntegrationConnectorsConnectionEventingConfigEnrichmentEnabled(original["enrichment_enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnrichmentEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enrichmentEnabled"] = transformedEnrichmentEnabled
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKey, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigKey(original["key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["key"] = transformedKey
	}

	transformedDestination, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestination(original["destination"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestination); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["destinations"] = transformedDestination
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestination(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedPort, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationPort(original["port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["port"] = transformedPort
		}

		transformedServiceAttachment, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationServiceAttachment(original["service_attachment"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedServiceAttachment); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["serviceAttachment"] = transformedServiceAttachment
		}

		transformedHost, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationHost(original["host"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHost); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["host"] = transformedHost
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationServiceAttachment(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationHost(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAuthType, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAuthType(original["auth_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authType"] = transformedAuthType
	}

	transformedAdditionalVariable, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariable(original["additional_variable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdditionalVariable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["additionalVariables"] = transformedAdditionalVariable
	}

	transformedAuthKey, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAuthKey(original["auth_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authKey"] = transformedAuthKey
	}

	transformedUserPassword, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigUserPassword(original["user_password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUserPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["userPassword"] = transformedUserPassword
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAuthType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedIntegerValue, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableIntegerValue(original["integer_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIntegerValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["intValue"] = transformedIntegerValue
		}

		transformedStringValue, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableStringValue(original["string_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStringValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["stringValue"] = transformedStringValue
		}

		transformedBooleanValue, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableBooleanValue(original["boolean_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedBooleanValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["boolValue"] = transformedBooleanValue
		}

		transformedSecretValue, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableSecretValue(original["secret_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSecretValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["secretValue"] = transformedSecretValue
		}

		transformedEncryptionKeyValue, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValue(original["encryption_key_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEncryptionKeyValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["encryptionKeyValue"] = transformedEncryptionKeyValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableIntegerValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableStringValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableBooleanValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableSecretValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableSecretValueSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableSecretValueSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedType, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValueType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedKmsKeyName, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValueKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValueType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAdditionalVariableEncryptionKeyValueKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigAuthKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigUserPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUsername, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	transformedPassword, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordPassword(original["password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["password"] = transformedPassword
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordPasswordSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAuthConfigUserPasswordPasswordSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAdditionalVariable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedIntegerValue, err := expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableIntegerValue(original["integer_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIntegerValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["intValue"] = transformedIntegerValue
		}

		transformedStringValue, err := expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableStringValue(original["string_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStringValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["stringValue"] = transformedStringValue
		}

		transformedBooleanValue, err := expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableBooleanValue(original["boolean_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedBooleanValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["boolValue"] = transformedBooleanValue
		}

		transformedSecretValue, err := expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableSecretValue(original["secret_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSecretValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["secretValue"] = transformedSecretValue
		}

		transformedEncryptionKeyValue, err := expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValue(original["encryption_key_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEncryptionKeyValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["encryptionKeyValue"] = transformedEncryptionKeyValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableIntegerValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableStringValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableBooleanValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableSecretValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableSecretValueSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableSecretValueSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedType, err := expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValueType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedKmsKeyName, err := expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValueKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValueType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigAdditionalVariableEncryptionKeyValueKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigEnrichmentEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
