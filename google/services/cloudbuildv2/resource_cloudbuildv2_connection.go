// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package cloudbuildv2

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceCloudbuildv2Connection() *schema.Resource {
	return &schema.Resource{
		Create: resourceCloudbuildv2ConnectionCreate,
		Read:   resourceCloudbuildv2ConnectionRead,
		Update: resourceCloudbuildv2ConnectionUpdate,
		Delete: resourceCloudbuildv2ConnectionDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCloudbuildv2ConnectionImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location for the resource`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Immutable. The resource name of the connection.`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Allows clients to store small amounts of arbitrary data.

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"bitbucket_cloud_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configuration for connections to Bitbucket Cloud.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"authorizer_credential": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Required. An access token with the 'webhook', 'repository', 'repository:admin' and 'pullrequest' scope access. It can be either a workspace, project or repository access token. It's recommended to use a system account to generate these credentials.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"user_token_secret_version": {
										Type:             schema.TypeString,
										Required:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
										Description:      `Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: 'projects/*/secrets/*/versions/*'.`,
									},
									"username": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. The username associated to this token.`,
									},
								},
							},
						},
						"read_authorizer_credential": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Required. An access token with the 'repository' access. It can be either a workspace, project or repository access token. It's recommended to use a system account to generate the credentials.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"user_token_secret_version": {
										Type:             schema.TypeString,
										Required:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
										Description:      `Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: 'projects/*/secrets/*/versions/*'.`,
									},
									"username": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. The username associated to this token.`,
									},
								},
							},
						},
						"webhook_secret_secret_version": {
							Type:             schema.TypeString,
							Required:         true,
							ForceNew:         true,
							DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
							Description:      `Required. Immutable. SecretManager resource containing the webhook secret used to verify webhook events, formatted as 'projects/*/secrets/*/versions/*'.`,
						},
						"workspace": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The Bitbucket Cloud Workspace ID to be connected to Google Cloud Platform.`,
						},
					},
				},
				ConflictsWith: []string{"github_config", "github_enterprise_config", "gitlab_config", "bitbucket_data_center_config"},
			},
			"bitbucket_data_center_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configuration for connections to Bitbucket Data Center.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"authorizer_credential": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Required. A http access token with the 'REPO_ADMIN' scope access.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"user_token_secret_version": {
										Type:             schema.TypeString,
										Required:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
										Description:      `Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: 'projects/*/secrets/*/versions/*'.`,
									},
									"username": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. The username associated to this token.`,
									},
								},
							},
						},
						"host_uri": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The URI of the Bitbucket Data Center host this connection is for.`,
						},
						"read_authorizer_credential": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Required. A http access token with the 'REPO_READ' access.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"user_token_secret_version": {
										Type:             schema.TypeString,
										Required:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
										Description:      `Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: 'projects/*/secrets/*/versions/*'.`,
									},
									"username": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. The username associated to this token.`,
									},
								},
							},
						},
						"webhook_secret_secret_version": {
							Type:             schema.TypeString,
							Required:         true,
							ForceNew:         true,
							DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
							Description:      `Required. Immutable. SecretManager resource containing the webhook secret used to verify webhook events, formatted as 'projects/*/secrets/*/versions/*'.`,
						},
						"service_directory_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for using Service Directory to privately connect to a Bitbucket Data Center. This should only be set if the Bitbucket Data Center is hosted on-premises and not reachable by public internet. If this field is left empty, calls to the Bitbucket Data Center will be made over the public internet.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"service": {
										Type:             schema.TypeString,
										Required:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
										Description:      `Required. The Service Directory service name. Format: projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.`,
									},
								},
							},
						},
						"ssl_ca": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `SSL certificate to use for requests to the Bitbucket Data Center.`,
						},
						"server_version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. Version of the Bitbucket Data Center running on the 'host_uri'.`,
						},
					},
				},
				ConflictsWith: []string{"github_config", "github_enterprise_config", "bitbucket_cloud_config", "gitlab_config"},
			},
			"disabled": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `If disabled is set to true, functionality is disabled for this connection. Repository based API methods and webhooks processing for repositories in this connection will be disabled.`,
			},
			"github_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configuration for connections to github.com.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"app_installation_id": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `GitHub App installation id.`,
						},
						"authorizer_credential": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `OAuth credential of the account that authorized the Cloud Build GitHub App. It is recommended to use a robot account instead of a human user account. The OAuth token must be tied to the Cloud Build GitHub App.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"oauth_token_secret_version": {
										Type:             schema.TypeString,
										Optional:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
										Description:      `A SecretManager resource containing the OAuth token that authorizes the Cloud Build connection. Format: 'projects/*/secrets/*/versions/*'.`,
									},
									"username": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. The username associated to this token.`,
									},
								},
							},
						},
					},
				},
				ConflictsWith: []string{"github_enterprise_config", "gitlab_config", "bitbucket_cloud_config", "bitbucket_data_center_config"},
			},
			"github_enterprise_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configuration for connections to an instance of GitHub Enterprise.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"host_uri": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Required. The URI of the GitHub Enterprise host this connection is for.`,
						},
						"app_id": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `Id of the GitHub App created from the manifest.`,
						},
						"app_installation_id": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `ID of the installation of the GitHub App.`,
						},
						"app_slug": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The URL-friendly name of the GitHub App.`,
						},
						"private_key_secret_version": {
							Type:             schema.TypeString,
							Optional:         true,
							DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
							Description:      `SecretManager resource containing the private key of the GitHub App, formatted as 'projects/*/secrets/*/versions/*'.`,
						},
						"service_directory_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for using Service Directory to privately connect to a GitHub Enterprise server. This should only be set if the GitHub Enterprise server is hosted on-premises and not reachable by public internet. If this field is left empty, calls to the GitHub Enterprise server will be made over the public internet.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"service": {
										Type:             schema.TypeString,
										Required:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
										Description:      `Required. The Service Directory service name. Format: projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.`,
									},
								},
							},
						},
						"ssl_ca": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `SSL certificate to use for requests to GitHub Enterprise.`,
						},
						"webhook_secret_secret_version": {
							Type:             schema.TypeString,
							Optional:         true,
							DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
							Description:      `SecretManager resource containing the webhook secret of the GitHub App, formatted as 'projects/*/secrets/*/versions/*'.`,
						},
					},
				},
				ConflictsWith: []string{"github_config", "gitlab_config", "bitbucket_cloud_config", "bitbucket_data_center_config"},
			},
			"gitlab_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configuration for connections to gitlab.com or an instance of GitLab Enterprise.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"authorizer_credential": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Required. A GitLab personal access token with the 'api' scope access.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"user_token_secret_version": {
										Type:             schema.TypeString,
										Required:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
										Description:      `Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: 'projects/*/secrets/*/versions/*'.`,
									},
									"username": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. The username associated to this token.`,
									},
								},
							},
						},
						"read_authorizer_credential": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Required. A GitLab personal access token with the minimum 'read_api' scope access.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"user_token_secret_version": {
										Type:             schema.TypeString,
										Required:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
										Description:      `Required. A SecretManager resource containing the user token that authorizes the Cloud Build connection. Format: 'projects/*/secrets/*/versions/*'.`,
									},
									"username": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. The username associated to this token.`,
									},
								},
							},
						},
						"webhook_secret_secret_version": {
							Type:             schema.TypeString,
							Required:         true,
							ForceNew:         true,
							DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
							Description:      `Required. Immutable. SecretManager resource containing the webhook secret of a GitLab Enterprise project, formatted as 'projects/*/secrets/*/versions/*'.`,
						},
						"host_uri": {
							Type:        schema.TypeString,
							Computed:    true,
							Optional:    true,
							Description: `The URI of the GitLab Enterprise host this connection is for. If not specified, the default value is https://gitlab.com.`,
						},
						"service_directory_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for using Service Directory to privately connect to a GitLab Enterprise server. This should only be set if the GitLab Enterprise server is hosted on-premises and not reachable by public internet. If this field is left empty, calls to the GitLab Enterprise server will be made over the public internet.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"service": {
										Type:             schema.TypeString,
										Required:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
										Description:      `Required. The Service Directory service name. Format: projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.`,
									},
								},
							},
						},
						"ssl_ca": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `SSL certificate to use for requests to GitLab Enterprise.`,
						},
						"server_version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. Version of the GitLab Enterprise server running on the 'host_uri'.`,
						},
					},
				},
				ConflictsWith: []string{"github_config", "github_enterprise_config", "bitbucket_cloud_config", "bitbucket_data_center_config"},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Server assigned timestamp for when the connection was created.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"etag": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `This checksum is computed by the server based on the value of other fields, and may be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.`,
			},
			"installation_state": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. Installation state of the Connection.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"action_uri": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. Link to follow for next action. Empty string if the installation is already complete.`,
						},
						"message": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. Message of what the user should do next to continue the installation. Empty string if the installation is already complete.`,
						},
						"stage": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. Current step of the installation process.`,
						},
					},
				},
			},
			"reconciling": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `Output only. Set to true when the connection is being set up or updated in the background.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Server assigned timestamp for when the connection was updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCloudbuildv2ConnectionCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	githubConfigProp, err := expandCloudbuildv2ConnectionGithubConfig(d.Get("github_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("github_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(githubConfigProp)) && (ok || !reflect.DeepEqual(v, githubConfigProp)) {
		obj["githubConfig"] = githubConfigProp
	}
	githubEnterpriseConfigProp, err := expandCloudbuildv2ConnectionGithubEnterpriseConfig(d.Get("github_enterprise_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("github_enterprise_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(githubEnterpriseConfigProp)) && (ok || !reflect.DeepEqual(v, githubEnterpriseConfigProp)) {
		obj["githubEnterpriseConfig"] = githubEnterpriseConfigProp
	}
	gitlabConfigProp, err := expandCloudbuildv2ConnectionGitlabConfig(d.Get("gitlab_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("gitlab_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(gitlabConfigProp)) && (ok || !reflect.DeepEqual(v, gitlabConfigProp)) {
		obj["gitlabConfig"] = gitlabConfigProp
	}
	bitbucketDataCenterConfigProp, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfig(d.Get("bitbucket_data_center_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("bitbucket_data_center_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(bitbucketDataCenterConfigProp)) && (ok || !reflect.DeepEqual(v, bitbucketDataCenterConfigProp)) {
		obj["bitbucketDataCenterConfig"] = bitbucketDataCenterConfigProp
	}
	bitbucketCloudConfigProp, err := expandCloudbuildv2ConnectionBitbucketCloudConfig(d.Get("bitbucket_cloud_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("bitbucket_cloud_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(bitbucketCloudConfigProp)) && (ok || !reflect.DeepEqual(v, bitbucketCloudConfigProp)) {
		obj["bitbucketCloudConfig"] = bitbucketCloudConfigProp
	}
	disabledProp, err := expandCloudbuildv2ConnectionDisabled(d.Get("disabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("disabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(disabledProp)) && (ok || !reflect.DeepEqual(v, disabledProp)) {
		obj["disabled"] = disabledProp
	}
	etagProp, err := expandCloudbuildv2ConnectionEtag(d.Get("etag"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("etag"); !tpgresource.IsEmptyValue(reflect.ValueOf(etagProp)) && (ok || !reflect.DeepEqual(v, etagProp)) {
		obj["etag"] = etagProp
	}
	annotationsProp, err := expandCloudbuildv2ConnectionEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(annotationsProp)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}

	url, err := tpgresource.ReplaceVarsForId(d, config, "{{Cloudbuildv2BasePath}}projects/{{project}}/locations/{{location}}/connections?connectionId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Connection: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = strings.TrimPrefix(project, "projects/")

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Connection: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVarsForId(d, config, "projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = Cloudbuildv2OperationWaitTime(
		config, res, tpgresource.GetResourceNameFromSelfLink(project), "Creating Connection", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Connection: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Connection %q: %#v", d.Id(), res)

	return resourceCloudbuildv2ConnectionRead(d, meta)
}

func resourceCloudbuildv2ConnectionRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVarsForId(d, config, "{{Cloudbuildv2BasePath}}projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = strings.TrimPrefix(project, "projects/")

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("Cloudbuildv2Connection %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}

	if err := d.Set("create_time", flattenCloudbuildv2ConnectionCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("update_time", flattenCloudbuildv2ConnectionUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("github_config", flattenCloudbuildv2ConnectionGithubConfig(res["githubConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("github_enterprise_config", flattenCloudbuildv2ConnectionGithubEnterpriseConfig(res["githubEnterpriseConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("gitlab_config", flattenCloudbuildv2ConnectionGitlabConfig(res["gitlabConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("bitbucket_data_center_config", flattenCloudbuildv2ConnectionBitbucketDataCenterConfig(res["bitbucketDataCenterConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("bitbucket_cloud_config", flattenCloudbuildv2ConnectionBitbucketCloudConfig(res["bitbucketCloudConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("installation_state", flattenCloudbuildv2ConnectionInstallationState(res["installationState"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("disabled", flattenCloudbuildv2ConnectionDisabled(res["disabled"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("reconciling", flattenCloudbuildv2ConnectionReconciling(res["reconciling"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("annotations", flattenCloudbuildv2ConnectionAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("etag", flattenCloudbuildv2ConnectionEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("effective_annotations", flattenCloudbuildv2ConnectionEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}

	return nil
}

func resourceCloudbuildv2ConnectionUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = strings.TrimPrefix(project, "projects/")

	obj := make(map[string]interface{})
	githubConfigProp, err := expandCloudbuildv2ConnectionGithubConfig(d.Get("github_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("github_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, githubConfigProp)) {
		obj["githubConfig"] = githubConfigProp
	}
	githubEnterpriseConfigProp, err := expandCloudbuildv2ConnectionGithubEnterpriseConfig(d.Get("github_enterprise_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("github_enterprise_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, githubEnterpriseConfigProp)) {
		obj["githubEnterpriseConfig"] = githubEnterpriseConfigProp
	}
	gitlabConfigProp, err := expandCloudbuildv2ConnectionGitlabConfig(d.Get("gitlab_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("gitlab_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, gitlabConfigProp)) {
		obj["gitlabConfig"] = gitlabConfigProp
	}
	bitbucketDataCenterConfigProp, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfig(d.Get("bitbucket_data_center_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("bitbucket_data_center_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, bitbucketDataCenterConfigProp)) {
		obj["bitbucketDataCenterConfig"] = bitbucketDataCenterConfigProp
	}
	bitbucketCloudConfigProp, err := expandCloudbuildv2ConnectionBitbucketCloudConfig(d.Get("bitbucket_cloud_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("bitbucket_cloud_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, bitbucketCloudConfigProp)) {
		obj["bitbucketCloudConfig"] = bitbucketCloudConfigProp
	}
	disabledProp, err := expandCloudbuildv2ConnectionDisabled(d.Get("disabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("disabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, disabledProp)) {
		obj["disabled"] = disabledProp
	}
	etagProp, err := expandCloudbuildv2ConnectionEtag(d.Get("etag"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("etag"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, etagProp)) {
		obj["etag"] = etagProp
	}
	annotationsProp, err := expandCloudbuildv2ConnectionEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}

	url, err := tpgresource.ReplaceVarsForId(d, config, "{{Cloudbuildv2BasePath}}projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Connection %q: %#v", d.Id(), obj)
	headers := make(http.Header)

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "PATCH",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutUpdate),
		Headers:   headers,
	})

	if err != nil {
		return fmt.Errorf("Error updating Connection %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating Connection %q: %#v", d.Id(), res)
	}

	err = Cloudbuildv2OperationWaitTime(
		config, res, tpgresource.GetResourceNameFromSelfLink(project), "Updating Connection", userAgent,
		d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return err
	}

	return resourceCloudbuildv2ConnectionRead(d, meta)
}

func resourceCloudbuildv2ConnectionDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = strings.TrimPrefix(project, "projects/")

	url, err := tpgresource.ReplaceVarsForId(d, config, "{{Cloudbuildv2BasePath}}projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Connection %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Connection")
	}

	err = Cloudbuildv2OperationWaitTime(
		config, res, tpgresource.GetResourceNameFromSelfLink(project), "Deleting Connection", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Connection %q: %#v", d.Id(), res)
	return nil
}

func resourceCloudbuildv2ConnectionImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/connections/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVarsForId(d, config, "projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCloudbuildv2ConnectionCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGithubConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["authorizer_credential"] =
		flattenCloudbuildv2ConnectionGithubConfigAuthorizerCredential(original["authorizerCredential"], d, config)
	transformed["app_installation_id"] =
		flattenCloudbuildv2ConnectionGithubConfigAppInstallationId(original["appInstallationId"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionGithubConfigAuthorizerCredential(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["oauth_token_secret_version"] =
		flattenCloudbuildv2ConnectionGithubConfigAuthorizerCredentialOauthTokenSecretVersion(original["oauthTokenSecretVersion"], d, config)
	transformed["username"] =
		flattenCloudbuildv2ConnectionGithubConfigAuthorizerCredentialUsername(original["username"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionGithubConfigAuthorizerCredentialOauthTokenSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGithubConfigAuthorizerCredentialUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGithubConfigAppInstallationId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudbuildv2ConnectionGithubEnterpriseConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["host_uri"] =
		flattenCloudbuildv2ConnectionGithubEnterpriseConfigHostUri(original["hostUri"], d, config)
	transformed["app_id"] =
		flattenCloudbuildv2ConnectionGithubEnterpriseConfigAppId(original["appId"], d, config)
	transformed["app_slug"] =
		flattenCloudbuildv2ConnectionGithubEnterpriseConfigAppSlug(original["appSlug"], d, config)
	transformed["private_key_secret_version"] =
		flattenCloudbuildv2ConnectionGithubEnterpriseConfigPrivateKeySecretVersion(original["privateKeySecretVersion"], d, config)
	transformed["webhook_secret_secret_version"] =
		flattenCloudbuildv2ConnectionGithubEnterpriseConfigWebhookSecretSecretVersion(original["webhookSecretSecretVersion"], d, config)
	transformed["app_installation_id"] =
		flattenCloudbuildv2ConnectionGithubEnterpriseConfigAppInstallationId(original["appInstallationId"], d, config)
	transformed["service_directory_config"] =
		flattenCloudbuildv2ConnectionGithubEnterpriseConfigServiceDirectoryConfig(original["serviceDirectoryConfig"], d, config)
	transformed["ssl_ca"] =
		flattenCloudbuildv2ConnectionGithubEnterpriseConfigSslCa(original["sslCa"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionGithubEnterpriseConfigHostUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGithubEnterpriseConfigAppId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudbuildv2ConnectionGithubEnterpriseConfigAppSlug(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGithubEnterpriseConfigPrivateKeySecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGithubEnterpriseConfigWebhookSecretSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGithubEnterpriseConfigAppInstallationId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudbuildv2ConnectionGithubEnterpriseConfigServiceDirectoryConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service"] =
		flattenCloudbuildv2ConnectionGithubEnterpriseConfigServiceDirectoryConfigService(original["service"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionGithubEnterpriseConfigServiceDirectoryConfigService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGithubEnterpriseConfigSslCa(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGitlabConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["host_uri"] =
		flattenCloudbuildv2ConnectionGitlabConfigHostUri(original["hostUri"], d, config)
	transformed["webhook_secret_secret_version"] =
		flattenCloudbuildv2ConnectionGitlabConfigWebhookSecretSecretVersion(original["webhookSecretSecretVersion"], d, config)
	transformed["read_authorizer_credential"] =
		flattenCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredential(original["readAuthorizerCredential"], d, config)
	transformed["authorizer_credential"] =
		flattenCloudbuildv2ConnectionGitlabConfigAuthorizerCredential(original["authorizerCredential"], d, config)
	transformed["service_directory_config"] =
		flattenCloudbuildv2ConnectionGitlabConfigServiceDirectoryConfig(original["serviceDirectoryConfig"], d, config)
	transformed["ssl_ca"] =
		flattenCloudbuildv2ConnectionGitlabConfigSslCa(original["sslCa"], d, config)
	transformed["server_version"] =
		flattenCloudbuildv2ConnectionGitlabConfigServerVersion(original["serverVersion"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionGitlabConfigHostUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGitlabConfigWebhookSecretSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredential(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["user_token_secret_version"] =
		flattenCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredentialUserTokenSecretVersion(original["userTokenSecretVersion"], d, config)
	transformed["username"] =
		flattenCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredentialUsername(original["username"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredentialUserTokenSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredentialUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGitlabConfigAuthorizerCredential(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["user_token_secret_version"] =
		flattenCloudbuildv2ConnectionGitlabConfigAuthorizerCredentialUserTokenSecretVersion(original["userTokenSecretVersion"], d, config)
	transformed["username"] =
		flattenCloudbuildv2ConnectionGitlabConfigAuthorizerCredentialUsername(original["username"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionGitlabConfigAuthorizerCredentialUserTokenSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGitlabConfigAuthorizerCredentialUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGitlabConfigServiceDirectoryConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service"] =
		flattenCloudbuildv2ConnectionGitlabConfigServiceDirectoryConfigService(original["service"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionGitlabConfigServiceDirectoryConfigService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGitlabConfigSslCa(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionGitlabConfigServerVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketDataCenterConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["host_uri"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigHostUri(original["hostUri"], d, config)
	transformed["webhook_secret_secret_version"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigWebhookSecretSecretVersion(original["webhookSecretSecretVersion"], d, config)
	transformed["read_authorizer_credential"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredential(original["readAuthorizerCredential"], d, config)
	transformed["authorizer_credential"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredential(original["authorizerCredential"], d, config)
	transformed["service_directory_config"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigServiceDirectoryConfig(original["serviceDirectoryConfig"], d, config)
	transformed["ssl_ca"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigSslCa(original["sslCa"], d, config)
	transformed["server_version"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigServerVersion(original["serverVersion"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigHostUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigWebhookSecretSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredential(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["user_token_secret_version"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredentialUserTokenSecretVersion(original["userTokenSecretVersion"], d, config)
	transformed["username"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredentialUsername(original["username"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredentialUserTokenSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredentialUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredential(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["user_token_secret_version"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredentialUserTokenSecretVersion(original["userTokenSecretVersion"], d, config)
	transformed["username"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredentialUsername(original["username"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredentialUserTokenSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredentialUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigServiceDirectoryConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service"] =
		flattenCloudbuildv2ConnectionBitbucketDataCenterConfigServiceDirectoryConfigService(original["service"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigServiceDirectoryConfigService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigSslCa(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketDataCenterConfigServerVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketCloudConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["workspace"] =
		flattenCloudbuildv2ConnectionBitbucketCloudConfigWorkspace(original["workspace"], d, config)
	transformed["webhook_secret_secret_version"] =
		flattenCloudbuildv2ConnectionBitbucketCloudConfigWebhookSecretSecretVersion(original["webhookSecretSecretVersion"], d, config)
	transformed["read_authorizer_credential"] =
		flattenCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredential(original["readAuthorizerCredential"], d, config)
	transformed["authorizer_credential"] =
		flattenCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredential(original["authorizerCredential"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionBitbucketCloudConfigWorkspace(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketCloudConfigWebhookSecretSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredential(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["user_token_secret_version"] =
		flattenCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredentialUserTokenSecretVersion(original["userTokenSecretVersion"], d, config)
	transformed["username"] =
		flattenCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredentialUsername(original["username"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredentialUserTokenSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredentialUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredential(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["user_token_secret_version"] =
		flattenCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredentialUserTokenSecretVersion(original["userTokenSecretVersion"], d, config)
	transformed["username"] =
		flattenCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredentialUsername(original["username"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredentialUserTokenSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredentialUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionInstallationState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["stage"] =
		flattenCloudbuildv2ConnectionInstallationStateStage(original["stage"], d, config)
	transformed["message"] =
		flattenCloudbuildv2ConnectionInstallationStateMessage(original["message"], d, config)
	transformed["action_uri"] =
		flattenCloudbuildv2ConnectionInstallationStateActionUri(original["actionUri"], d, config)
	return []interface{}{transformed}
}
func flattenCloudbuildv2ConnectionInstallationStateStage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionInstallationStateMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionInstallationStateActionUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionReconciling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenCloudbuildv2ConnectionEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudbuildv2ConnectionEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandCloudbuildv2ConnectionGithubConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAuthorizerCredential, err := expandCloudbuildv2ConnectionGithubConfigAuthorizerCredential(original["authorizer_credential"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthorizerCredential); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authorizerCredential"] = transformedAuthorizerCredential
	}

	transformedAppInstallationId, err := expandCloudbuildv2ConnectionGithubConfigAppInstallationId(original["app_installation_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAppInstallationId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["appInstallationId"] = transformedAppInstallationId
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionGithubConfigAuthorizerCredential(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOauthTokenSecretVersion, err := expandCloudbuildv2ConnectionGithubConfigAuthorizerCredentialOauthTokenSecretVersion(original["oauth_token_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauthTokenSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauthTokenSecretVersion"] = transformedOauthTokenSecretVersion
	}

	transformedUsername, err := expandCloudbuildv2ConnectionGithubConfigAuthorizerCredentialUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionGithubConfigAuthorizerCredentialOauthTokenSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGithubConfigAuthorizerCredentialUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGithubConfigAppInstallationId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGithubEnterpriseConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHostUri, err := expandCloudbuildv2ConnectionGithubEnterpriseConfigHostUri(original["host_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostUri"] = transformedHostUri
	}

	transformedAppId, err := expandCloudbuildv2ConnectionGithubEnterpriseConfigAppId(original["app_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAppId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["appId"] = transformedAppId
	}

	transformedAppSlug, err := expandCloudbuildv2ConnectionGithubEnterpriseConfigAppSlug(original["app_slug"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAppSlug); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["appSlug"] = transformedAppSlug
	}

	transformedPrivateKeySecretVersion, err := expandCloudbuildv2ConnectionGithubEnterpriseConfigPrivateKeySecretVersion(original["private_key_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrivateKeySecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["privateKeySecretVersion"] = transformedPrivateKeySecretVersion
	}

	transformedWebhookSecretSecretVersion, err := expandCloudbuildv2ConnectionGithubEnterpriseConfigWebhookSecretSecretVersion(original["webhook_secret_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWebhookSecretSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["webhookSecretSecretVersion"] = transformedWebhookSecretSecretVersion
	}

	transformedAppInstallationId, err := expandCloudbuildv2ConnectionGithubEnterpriseConfigAppInstallationId(original["app_installation_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAppInstallationId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["appInstallationId"] = transformedAppInstallationId
	}

	transformedServiceDirectoryConfig, err := expandCloudbuildv2ConnectionGithubEnterpriseConfigServiceDirectoryConfig(original["service_directory_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceDirectoryConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceDirectoryConfig"] = transformedServiceDirectoryConfig
	}

	transformedSslCa, err := expandCloudbuildv2ConnectionGithubEnterpriseConfigSslCa(original["ssl_ca"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSslCa); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sslCa"] = transformedSslCa
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionGithubEnterpriseConfigHostUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGithubEnterpriseConfigAppId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGithubEnterpriseConfigAppSlug(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGithubEnterpriseConfigPrivateKeySecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGithubEnterpriseConfigWebhookSecretSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGithubEnterpriseConfigAppInstallationId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGithubEnterpriseConfigServiceDirectoryConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedService, err := expandCloudbuildv2ConnectionGithubEnterpriseConfigServiceDirectoryConfigService(original["service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["service"] = transformedService
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionGithubEnterpriseConfigServiceDirectoryConfigService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGithubEnterpriseConfigSslCa(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGitlabConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHostUri, err := expandCloudbuildv2ConnectionGitlabConfigHostUri(original["host_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostUri"] = transformedHostUri
	}

	transformedWebhookSecretSecretVersion, err := expandCloudbuildv2ConnectionGitlabConfigWebhookSecretSecretVersion(original["webhook_secret_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWebhookSecretSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["webhookSecretSecretVersion"] = transformedWebhookSecretSecretVersion
	}

	transformedReadAuthorizerCredential, err := expandCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredential(original["read_authorizer_credential"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReadAuthorizerCredential); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["readAuthorizerCredential"] = transformedReadAuthorizerCredential
	}

	transformedAuthorizerCredential, err := expandCloudbuildv2ConnectionGitlabConfigAuthorizerCredential(original["authorizer_credential"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthorizerCredential); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authorizerCredential"] = transformedAuthorizerCredential
	}

	transformedServiceDirectoryConfig, err := expandCloudbuildv2ConnectionGitlabConfigServiceDirectoryConfig(original["service_directory_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceDirectoryConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceDirectoryConfig"] = transformedServiceDirectoryConfig
	}

	transformedSslCa, err := expandCloudbuildv2ConnectionGitlabConfigSslCa(original["ssl_ca"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSslCa); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sslCa"] = transformedSslCa
	}

	transformedServerVersion, err := expandCloudbuildv2ConnectionGitlabConfigServerVersion(original["server_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServerVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serverVersion"] = transformedServerVersion
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionGitlabConfigHostUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGitlabConfigWebhookSecretSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredential(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUserTokenSecretVersion, err := expandCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredentialUserTokenSecretVersion(original["user_token_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUserTokenSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["userTokenSecretVersion"] = transformedUserTokenSecretVersion
	}

	transformedUsername, err := expandCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredentialUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredentialUserTokenSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGitlabConfigReadAuthorizerCredentialUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGitlabConfigAuthorizerCredential(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUserTokenSecretVersion, err := expandCloudbuildv2ConnectionGitlabConfigAuthorizerCredentialUserTokenSecretVersion(original["user_token_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUserTokenSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["userTokenSecretVersion"] = transformedUserTokenSecretVersion
	}

	transformedUsername, err := expandCloudbuildv2ConnectionGitlabConfigAuthorizerCredentialUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionGitlabConfigAuthorizerCredentialUserTokenSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGitlabConfigAuthorizerCredentialUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGitlabConfigServiceDirectoryConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedService, err := expandCloudbuildv2ConnectionGitlabConfigServiceDirectoryConfigService(original["service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["service"] = transformedService
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionGitlabConfigServiceDirectoryConfigService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGitlabConfigSslCa(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionGitlabConfigServerVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHostUri, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigHostUri(original["host_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostUri"] = transformedHostUri
	}

	transformedWebhookSecretSecretVersion, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigWebhookSecretSecretVersion(original["webhook_secret_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWebhookSecretSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["webhookSecretSecretVersion"] = transformedWebhookSecretSecretVersion
	}

	transformedReadAuthorizerCredential, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredential(original["read_authorizer_credential"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReadAuthorizerCredential); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["readAuthorizerCredential"] = transformedReadAuthorizerCredential
	}

	transformedAuthorizerCredential, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredential(original["authorizer_credential"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthorizerCredential); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authorizerCredential"] = transformedAuthorizerCredential
	}

	transformedServiceDirectoryConfig, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigServiceDirectoryConfig(original["service_directory_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceDirectoryConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceDirectoryConfig"] = transformedServiceDirectoryConfig
	}

	transformedSslCa, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigSslCa(original["ssl_ca"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSslCa); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sslCa"] = transformedSslCa
	}

	transformedServerVersion, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigServerVersion(original["server_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServerVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serverVersion"] = transformedServerVersion
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigHostUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigWebhookSecretSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredential(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUserTokenSecretVersion, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredentialUserTokenSecretVersion(original["user_token_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUserTokenSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["userTokenSecretVersion"] = transformedUserTokenSecretVersion
	}

	transformedUsername, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredentialUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredentialUserTokenSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigReadAuthorizerCredentialUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredential(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUserTokenSecretVersion, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredentialUserTokenSecretVersion(original["user_token_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUserTokenSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["userTokenSecretVersion"] = transformedUserTokenSecretVersion
	}

	transformedUsername, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredentialUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredentialUserTokenSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigAuthorizerCredentialUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigServiceDirectoryConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedService, err := expandCloudbuildv2ConnectionBitbucketDataCenterConfigServiceDirectoryConfigService(original["service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["service"] = transformedService
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigServiceDirectoryConfigService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigSslCa(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketDataCenterConfigServerVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketCloudConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedWorkspace, err := expandCloudbuildv2ConnectionBitbucketCloudConfigWorkspace(original["workspace"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWorkspace); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["workspace"] = transformedWorkspace
	}

	transformedWebhookSecretSecretVersion, err := expandCloudbuildv2ConnectionBitbucketCloudConfigWebhookSecretSecretVersion(original["webhook_secret_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWebhookSecretSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["webhookSecretSecretVersion"] = transformedWebhookSecretSecretVersion
	}

	transformedReadAuthorizerCredential, err := expandCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredential(original["read_authorizer_credential"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReadAuthorizerCredential); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["readAuthorizerCredential"] = transformedReadAuthorizerCredential
	}

	transformedAuthorizerCredential, err := expandCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredential(original["authorizer_credential"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthorizerCredential); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authorizerCredential"] = transformedAuthorizerCredential
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionBitbucketCloudConfigWorkspace(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketCloudConfigWebhookSecretSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredential(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUserTokenSecretVersion, err := expandCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredentialUserTokenSecretVersion(original["user_token_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUserTokenSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["userTokenSecretVersion"] = transformedUserTokenSecretVersion
	}

	transformedUsername, err := expandCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredentialUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredentialUserTokenSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketCloudConfigReadAuthorizerCredentialUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredential(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUserTokenSecretVersion, err := expandCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredentialUserTokenSecretVersion(original["user_token_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUserTokenSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["userTokenSecretVersion"] = transformedUserTokenSecretVersion
	}

	transformedUsername, err := expandCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredentialUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	return transformed, nil
}

func expandCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredentialUserTokenSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionBitbucketCloudConfigAuthorizerCredentialUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionEtag(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudbuildv2ConnectionEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
