// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/vmwareengine/resource_vmwareengine_cluster_test.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package vmwareengine_test

import (
	"fmt"
	"os"
	"reflect"
	"strings"
	"testing"

	"github.com/hashicorp/terraform-provider-google/google/acctest"
	"github.com/hashicorp/terraform-provider-google/google/envvar"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-plugin-testing/terraform"
	"github.com/hashicorp/terraform-provider-google/google/services/vmwareengine"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func TestAccVmwareengineCluster_vmwareEngineClusterUpdate(t *testing.T) {
	acctest.SkipIfVcr(t)
	t.Parallel()

	acctest.BootstrapIamMembers(t, []acctest.IamMember{
		{
			Member: "serviceAccount:service-{project_number}@gcp-sa-vmwareengine.iam.gserviceaccount.com",
			Role:   "roles/file.viewer",
		},
	})
	random_suffix := acctest.RandString(t, 10)
	region_id := "me-west1" // region with allocated quota
	context := map[string]interface{}{
		"region":               region_id,
		"random_suffix":        random_suffix,
		"org_id":               envvar.GetTestOrgFromEnv(t),
		"billing_account":      envvar.GetTestBillingAccountFromEnv(t),
		"vmwareengine_project": os.Getenv("GOOGLE_VMWAREENGINE_PROJECT"),
		"fs_network_name":      acctest.BootstrapSharedServiceNetworkingConnection(t, "tf-test-cluster"),
		"svc_ip_cidr":          "10.0.0.0/24",
		"zone":                 region_id + "-b",
		"pc_name":              "tf-test-cluster-pc" + random_suffix,
		"service_subnet_name":  "service-1",
		"pc_type":              "STANDARD",
		"mgmt_cluster_node":    3,
		"node_type":            "standard-72",
	}

	acctest.VcrTest(t, resource.TestCase{
		PreCheck:                 func() { acctest.AccTestPreCheck(t) },
		ProtoV5ProviderFactories: acctest.ProtoV5ProviderFactories(t),
		ExternalProviders: map[string]resource.ExternalProvider{
			"time": {},
		},
		CheckDestroy: testAccCheckVmwareengineClusterDestroyProducer(t),
		Steps: []resource.TestStep{
			{
				// Verifies Cluster is created and Datastore is mounted with create cluster operation.
				Config: testVmwareEngineClusterConfig_DatastoreMount(t, context, 3, true),
				Check: resource.ComposeTestCheckFunc(
					acctest.CheckDataSourceStateMatchesResourceState("data.google_vmwareengine_cluster.ds_vmw_engine_ext_cluster", "google_vmwareengine_cluster.vmw-engine-ext-cluster"),
				),
			},
			{
				ResourceName:      "google_vmwareengine_cluster.vmw-engine-ext-cluster",
				ImportState:       true,
				ImportStateVerify: true,
				// ignore_colocation field can only be sent in request hence not received in response.
				ImportStateVerifyIgnore: []string{"parent", "name", "ignore_colocation"},
			},
			{
				// Update cluster to do two operations a) expand cluster and b) unmount datastore
				Config: testVmwareEngineClusterConfig_DatastoreUnmount(t, context, 4, true),
			},
			{
				ResourceName:      "google_vmwareengine_cluster.vmw-engine-ext-cluster",
				ImportState:       true,
				ImportStateVerify: true,
				// ignore_colocation field can only be sent in request hence not received in response.
				ImportStateVerifyIgnore: []string{"parent", "name", "ignore_colocation"},
			},
			{
				// Update cluster to do two operations a) shrink clusster and b) mount datastore
				Config: testVmwareEngineClusterConfig_DatastoreMount(t, context, 3, true),
			},
			{
				ResourceName:      "google_vmwareengine_cluster.vmw-engine-ext-cluster",
				ImportState:       true,
				ImportStateVerify: true,
				// ignore_colocation field can only be sent in request hence not received in response.
				ImportStateVerifyIgnore: []string{"parent", "name", "ignore_colocation"},
			},
			{
				// Update cluster to unmount datastore and remove delete protection from the filestore
				// Removal of delete protection is required for filstore instance deletion in next step
				// This test case verifies datastore operation is performed independent of cluster shrink and expand operation
				Config: testVmwareEngineClusterConfig_DatastoreUnmount(t, context, 3, false),
			},
			{
				ResourceName:      "google_vmwareengine_cluster.vmw-engine-ext-cluster",
				ImportState:       true,
				ImportStateVerify: true,
				// ignore_colocation field can only be sent in request hence not received in response.
				ImportStateVerifyIgnore: []string{"parent", "name", "ignore_colocation"},
			},
		},
	})
}

// Verifies in create operation Cluster is created and also Datastore is mounted along with it.
// In mount and unmount tests, GCNV volume can't be used because its deletion requires 52 hours cooling period after unmount
func testVmwareEngineClusterConfig_DatastoreMount(t *testing.T, context map[string]interface{}, nodeCount int, delete_protection bool) string {
	context["node_count"] = nodeCount
	context["delete_protection"] = delete_protection

	return acctest.Nprintf(`

data "google_compute_network" "fs_network" {
  name = "%{fs_network_name}"
}

# Create a filestore instance with delete protection enabled
resource "google_filestore_instance" "test_instance" {
  name                        = "tf-test-cluster-fs-instance%{random_suffix}"
  location                    = "%{zone}"
  tier                        = "ZONAL"
  deletion_protection_enabled = "%{delete_protection}"

  file_shares {
    capacity_gb = 1024
    name        = "share101"
	nfs_export_options {
      ip_ranges = ["%{svc_ip_cidr}"]
    }
  }
  networks {
    network       = data.google_compute_network.fs_network.id
    modes         = ["MODE_IPV4"]
    connect_mode  = "PRIVATE_SERVICE_ACCESS"
  }
}

resource "google_vmwareengine_network" "cluster-nw" {
  project     = "%{vmwareengine_project}"
  name        = "tf-test-cluster-nw%{random_suffix}"
  location    = "global"
  type        = "STANDARD"
  description = "PC network description."
}

resource "google_vmwareengine_private_cloud" "cluster-pc" {
  project     = "%{vmwareengine_project}"
  location    = "%{zone}"
  name        = "%{pc_name}"
  type        = "%{pc_type}"
  description = "Sample test PC."
  deletion_delay_hours = 0
  send_deletion_delay_hours_if_zero = true
  network_config {
    management_cidr       = "192.168.10.0/24"
    vmware_engine_network = google_vmwareengine_network.cluster-nw.id
  }
  management_cluster {
    cluster_id = "tf-test-mgmt-cluster%{random_suffix}"
    node_type_configs {
      node_type_id = "%{node_type}"
      node_count   = "%{mgmt_cluster_node}"
    }
  }
}

resource "google_vmwareengine_subnet" "cluster-pc-subnet" {
  name = "service-1"
  parent =  google_vmwareengine_private_cloud.cluster-pc.id
  ip_cidr_range = "%{svc_ip_cidr}"
}


data "google_compute_network_peering" "sn_peering" {
  name       = "servicenetworking-googleapis-com"
  network    = data.google_compute_network.fs_network.id
}

resource "google_vmwareengine_network_peering" "psa_network_peering" {
  project = "%{vmwareengine_project}"
  name = "tf-test-psa-network-peering%{random_suffix}"
  description = "test description"
  vmware_engine_network = google_vmwareengine_network.cluster-nw.id
  peer_network = trimprefix(trimprefix(trimprefix(data.google_compute_network_peering.sn_peering.peer_network, "https://www.googleapis.com/compute/"), "v1/"), "beta/")
  peer_network_type = "PRIVATE_SERVICES_ACCESS"
}

# Create a VmwareEngine Datastore, referencing the filestore instance
resource "google_vmwareengine_datastore" "test_fs_datastore" {
  name        = "tf-test-cluster-fs-datastore%{random_suffix}"
  location    = "%{zone}"
  description = "test description"

  nfs_datastore {
    google_file_service {
      filestore_instance = google_filestore_instance.test_instance.id
    }
  }
}

resource "google_vmwareengine_cluster" "vmw-engine-ext-cluster" {
  name = "tf-test-ext-cluster%{random_suffix}"
  parent =  google_vmwareengine_private_cloud.cluster-pc.id
  node_type_configs {
    node_type_id = "%{node_type}"
    node_count   = %{node_count}
    custom_core_count = 32
  }
  autoscaling_settings {
    autoscaling_policies {
      autoscale_policy_id = "autoscaling-policy"
      node_type_id = "%{node_type}"
      scale_out_size = 1
      consumed_memory_thresholds {
        scale_out = 75
        scale_in  = 20
      }
      storage_thresholds {
        scale_out = 80
        scale_in  = 20
      }
    }
    min_cluster_node_count = 3
    max_cluster_node_count = 8
    cool_down_period = "1800s"
  }
  datastore_mount_config {
    datastore = google_vmwareengine_datastore.test_fs_datastore.id
    datastore_network {
      subnet = google_vmwareengine_subnet.cluster-pc-subnet.id
      connection_count = 1
      mtu = 1460
    }
    nfs_version = "NFS_V3"
    access_mode = "READ_WRITE"
    ignore_colocation = false
  }

  depends_on = [google_vmwareengine_network_peering.psa_network_peering]
}

data "google_vmwareengine_cluster" "ds_vmw_engine_ext_cluster" {
  name = google_vmwareengine_cluster.vmw-engine-ext-cluster.name
  parent = google_vmwareengine_private_cloud.cluster-pc.id
}
`, context)
}

func testVmwareEngineClusterConfig_DatastoreUnmount(t *testing.T, context map[string]interface{}, nodeCount int, delete_protection bool) string {
	context["node_count"] = nodeCount
	context["delete_protection"] = delete_protection

	return acctest.Nprintf(`

data "google_compute_network" "fs_network" {
  name = "%{fs_network_name}"
}

# Create a filestore instance with delete protection enabled
resource "google_filestore_instance" "test_instance" {
  name                        = "tf-test-cluster-fs-instance%{random_suffix}"
  location                    = "%{zone}"
  tier                        = "ZONAL"
  deletion_protection_enabled = "%{delete_protection}"

  file_shares {
    capacity_gb = 1024
    name        = "share101"
	nfs_export_options {
      ip_ranges = ["%{svc_ip_cidr}"]
    }
  }
  networks {
    network       = data.google_compute_network.fs_network.id
    modes         = ["MODE_IPV4"]
    connect_mode  = "PRIVATE_SERVICE_ACCESS"
  }
}

resource "google_vmwareengine_network" "cluster-nw" {
  project     = "%{vmwareengine_project}"
  name        = "tf-test-cluster-nw%{random_suffix}"
  location    = "global"
  type        = "STANDARD"
  description = "PC network description."
}


resource "google_vmwareengine_private_cloud" "cluster-pc" {
  project     = "%{vmwareengine_project}"
  location    = "%{zone}"
  name        = "%{pc_name}"
  type        = "%{pc_type}"
  description = "Sample test PC."
  deletion_delay_hours = 0
  send_deletion_delay_hours_if_zero = true
  network_config {
    management_cidr       = "192.168.10.0/24"
    vmware_engine_network = google_vmwareengine_network.cluster-nw.id
  }
  management_cluster {
    cluster_id = "tf-test-mgmt-cluster%{random_suffix}"
    node_type_configs {
      node_type_id = "%{node_type}"
      node_count   = "%{mgmt_cluster_node}"
    }
  }
}

resource "google_vmwareengine_subnet" "cluster-pc-subnet" {
  name = "service-1"
  parent =  google_vmwareengine_private_cloud.cluster-pc.id
  ip_cidr_range = "%{svc_ip_cidr}"
}


data "google_compute_network_peering" "sn_peering" {
  name       = "servicenetworking-googleapis-com"
  network    = data.google_compute_network.fs_network.id
}

resource "google_vmwareengine_network_peering" "psa_network_peering" {
  project = "%{vmwareengine_project}"
  name = "tf-test-psa-network-peering%{random_suffix}"
  description = "test description"
  vmware_engine_network = google_vmwareengine_network.cluster-nw.id
  peer_network = trimprefix(data.google_compute_network_peering.sn_peering.peer_network, "https://www.googleapis.com/compute/")
  peer_network_type = "PRIVATE_SERVICES_ACCESS"
}

# Create a VmwareEngine Datastore, referencing the filestore instance
resource "google_vmwareengine_datastore" "test_fs_datastore" {
  name        = "tf-test-cluster-fs-datastore%{random_suffix}"
  location    = "%{zone}"
  description = "test description"

  nfs_datastore {
    google_file_service {
      filestore_instance = google_filestore_instance.test_instance.id
    }
  }
}

resource "google_vmwareengine_cluster" "vmw-engine-ext-cluster" {
  name = "tf-test-ext-cluster%{random_suffix}"
  parent =  google_vmwareengine_private_cloud.cluster-pc.id
  node_type_configs {
    node_type_id = "%{node_type}"
    node_count   = %{node_count}
    custom_core_count = 32
  }
  autoscaling_settings {
    autoscaling_policies {
      autoscale_policy_id = "autoscaling-policy"
      node_type_id = "%{node_type}"
      scale_out_size = 2
      cpu_thresholds {
        scale_out = 80
        scale_in  = 15
      }
      storage_thresholds {
        scale_out = 79
        scale_in = 15
      }
    }
    min_cluster_node_count = 3
    max_cluster_node_count = 10
    cool_down_period = "3600s"
  }
  depends_on = [google_vmwareengine_network_peering.psa_network_peering]
}

data "google_vmwareengine_cluster" "ds_vmw_engine_ext_cluster" {
  name = google_vmwareengine_cluster.vmw-engine-ext-cluster.name
  parent = google_vmwareengine_private_cloud.cluster-pc.id
}
`, context)
}

func testAccCheckVmwareengineClusterDestroyProducer(t *testing.T) func(s *terraform.State) error {
	return func(s *terraform.State) error {
		for name, rs := range s.RootModule().Resources {
			if rs.Type != "google_vmwareengine_cluster" {
				continue
			}
			if strings.HasPrefix(name, "data.") {
				continue
			}

			config := acctest.GoogleProviderConfig(t)

			url, err := tpgresource.ReplaceVarsForTest(config, rs, "{{VmwareengineBasePath}}{{parent}}/clusters/{{name}}")
			if err != nil {
				return err
			}

			billingProject := ""

			if config.BillingProject != "" {
				billingProject = config.BillingProject
			}

			_, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
				Config:    config,
				Method:    "GET",
				Project:   billingProject,
				RawURL:    url,
				UserAgent: config.UserAgent,
			})
			if err == nil {
				return fmt.Errorf("VmwareengineCluster still exists at %s", url)
			}
		}

		return nil
	}
}

// Unit test for fucntion CalculateDatastoreMountsDiff() defined in constants
func TestCalculateDatastoreMountsDiff(t *testing.T) {
	tests := []struct {
		name      string
		existing  []interface{}
		requested []interface{}
		want      []interface{}
	}{
		{
			name: "No changes - both identical",
			existing: []interface{}{
				map[string]interface{}{"datastore": "ds1", "mode": "readWrite"},
			},
			requested: []interface{}{
				map[string]interface{}{"datastore": "ds1", "mode": "readWrite"},
			},
			want: nil, // diff starts as nil slice
		},
		{
			name:     "Add new datastore",
			existing: []interface{}{},
			requested: []interface{}{
				map[string]interface{}{"datastore": "ds1", "mode": "readWrite"},
			},
			want: []interface{}{
				map[string]interface{}{"datastore": "ds1", "mode": "readWrite"},
			},
		},
		{
			name: "Existing has one, requested has two",
			existing: []interface{}{
				map[string]interface{}{"datastore": "ds1"},
			},
			requested: []interface{}{
				map[string]interface{}{"datastore": "ds1"},
				map[string]interface{}{"datastore": "ds2"},
			},
			want: []interface{}{
				map[string]interface{}{"datastore": "ds2"},
			},
		},
		{
			name:      "Both empty",
			existing:  []interface{}{},
			requested: []interface{}{},
			want:      nil,
		},
		{
			name: "Requested contains existing plus multiple new ones",
			existing: []interface{}{
				map[string]interface{}{"datastore": "shared-1"},
			},
			requested: []interface{}{
				map[string]interface{}{"datastore": "shared-1"},
				map[string]interface{}{"datastore": "new-1"},
				map[string]interface{}{"datastore": "new-2"},
			},
			want: []interface{}{
				map[string]interface{}{"datastore": "new-1"},
				map[string]interface{}{"datastore": "new-2"},
			},
		},
		{
			name: "Deletion scenario (function only returns additions)",
			existing: []interface{}{
				map[string]interface{}{"datastore": "ds1"},
				map[string]interface{}{"datastore": "ds2"},
			},
			requested: []interface{}{
				map[string]interface{}{"datastore": "ds1"},
			},
			want: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := vmwareengine.CalculateDatastoreMountsDiff(tt.existing, tt.requested)
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("CalculateDatastoreMountsDiff() = %v, want %v", got, tt.want)
			}
		})
	}
}

// Unit test for function RemoveDatastoreMountConfigFieldFromUpdateMask()

func TestRemoveDatastoreMountConfigFieldFromUpdateMask(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "Field at the end (preceded by comma)",
			input: "update_mask=foo%2CdatastoreMountConfig",
			want:  "update_mask=foo",
		},
		{
			name:  "Field at the start (followed by comma)",
			input: "update_mask=datastoreMountConfig%2Cbar",
			want:  "update_mask=bar",
		},
		{
			name:  "Field in the middle",
			input: "update_mask=foo%2CdatastoreMountConfig%2Cbar",
			want:  "update_mask=foo%2Cbar",
		},
		{
			name:  "Field is the only content",
			input: "update_mask=datastoreMountConfig",
			want:  "update_mask=",
		},
		{
			name:  "Field with encoded space (%20)",
			input: "update_mask=datastoreMountConfig%20",
			want:  "update_mask=",
		},
		{
			name:  "Field with encoded plus (+)",
			input: "update_mask=datastoreMountConfig+",
			want:  "update_mask=",
		},
		{
			name:  "Field not present",
			input: "update_mask=foo%2Cbar",
			want:  "update_mask=foo%2Cbar",
		},
		{
			name:  "Empty string",
			input: "",
			want:  "",
		},
		{
			name:  "Multiple instances",
			input: "foo%2CdatastoreMountConfig%2Cbar%2CdatastoreMountConfig",
			want:  "foo%2Cbar",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := vmwareengine.RemoveDatastoreMountConfigFieldFromUpdateMask(tt.input)
			if got != tt.want {
				t.Errorf("RemoveDatastoreMountConfigFieldFromUpdateMask(%q) = %q, want %q", tt.input, got, tt.want)
			}
		})
	}
}
