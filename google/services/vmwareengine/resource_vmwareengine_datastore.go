// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/vmwareengine/Datastore.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package vmwareengine

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceVmwareengineDatastore() *schema.Resource {
	return &schema.Resource{
		Create: resourceVmwareengineDatastoreCreate,
		Read:   resourceVmwareengineDatastoreRead,
		Update: resourceVmwareengineDatastoreUpdate,
		Delete: resourceVmwareengineDatastoreDelete,

		Importer: &schema.ResourceImporter{
			State: resourceVmwareengineDatastoreImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The user-provided identifier of the datastore to be created.
This identifier must be unique among each 'Datastore' within the parent
and becomes the final token in the name URI.
The identifier must meet the following requirements:

* Only contains 1-63 alphanumeric characters and hyphens
* Begins with an alphabetical character
* Ends with a non-hyphen character
* Not formatted as a UUID
* Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
(section 3.5)`,
			},
			"nfs_datastore": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `The NFS datastore configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"google_file_service": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Google service file service configuration`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"filestore_instance": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Google filestore instance resource name
e.g. projects/my-project/locations/me-west1-b/instances/my-instance`,
									},
									"netapp_volume": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Google netapp volume resource name
e.g. projects/my-project/locations/me-west1-b/volumes/my-volume`,
									},
								},
							},
						},
						"third_party_file_service": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Third party file service configuration`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"file_share": {
										Type:     schema.TypeString,
										Required: true,
										Description: `Required
Mount Folder name`,
									},
									"network": {
										Type:     schema.TypeString,
										Required: true,
										Description: `Required to identify vpc peering used for NFS access
network name of NFS's vpc
e.g. projects/project-id/global/networks/my-network_id`,
									},
									"servers": {
										Type:     schema.TypeList,
										Required: true,
										Description: `Server IP addresses of the NFS file service.
NFS v3, provide a single IP address or DNS name.
Multiple servers can be supported in future when NFS 4.1 protocol support
is enabled.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `User-provided description for this datastore`,
			},
			"clusters": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Clusters to which the datastore is attached.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Creation time of this resource.`,
			},
			"state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The state of the Datastore.
Possible values:
CREATING
ACTIVE
UPDATING
DELETING
SOFT_DELETING
SOFT_DELETED`,
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `System-generated unique identifier for the resource.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Last update time of this resource.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceVmwareengineDatastoreCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandVmwareengineDatastoreDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	nfsDatastoreProp, err := expandVmwareengineDatastoreNfsDatastore(d.Get("nfs_datastore"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("nfs_datastore"); !tpgresource.IsEmptyValue(reflect.ValueOf(nfsDatastoreProp)) && (ok || !reflect.DeepEqual(v, nfsDatastoreProp)) {
		obj["nfsDatastore"] = nfsDatastoreProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/datastores?datastoreId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Datastore: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Datastore: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Datastore: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/datastores/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = VmwareengineOperationWaitTime(
		config, res, project, "Creating Datastore", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Datastore: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Datastore %q: %#v", d.Id(), res)

	return resourceVmwareengineDatastoreRead(d, meta)
}

func resourceVmwareengineDatastoreRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/datastores/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Datastore: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("VmwareengineDatastore %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Datastore: %s", err)
	}

	if err := d.Set("clusters", flattenVmwareengineDatastoreClusters(res["clusters"], d, config)); err != nil {
		return fmt.Errorf("Error reading Datastore: %s", err)
	}
	if err := d.Set("create_time", flattenVmwareengineDatastoreCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Datastore: %s", err)
	}
	if err := d.Set("description", flattenVmwareengineDatastoreDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Datastore: %s", err)
	}
	if err := d.Set("nfs_datastore", flattenVmwareengineDatastoreNfsDatastore(res["nfsDatastore"], d, config)); err != nil {
		return fmt.Errorf("Error reading Datastore: %s", err)
	}
	if err := d.Set("state", flattenVmwareengineDatastoreState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Datastore: %s", err)
	}
	if err := d.Set("uid", flattenVmwareengineDatastoreUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading Datastore: %s", err)
	}
	if err := d.Set("update_time", flattenVmwareengineDatastoreUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Datastore: %s", err)
	}

	return nil
}

func resourceVmwareengineDatastoreUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Datastore: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandVmwareengineDatastoreDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	nfsDatastoreProp, err := expandVmwareengineDatastoreNfsDatastore(d.Get("nfs_datastore"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("nfs_datastore"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nfsDatastoreProp)) {
		obj["nfsDatastore"] = nfsDatastoreProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/datastores/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Datastore %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("nfs_datastore") {
		updateMask = append(updateMask, "nfsDatastore")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Datastore %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Datastore %q: %#v", d.Id(), res)
		}

		err = VmwareengineOperationWaitTime(
			config, res, project, "Updating Datastore", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceVmwareengineDatastoreRead(d, meta)
}

func resourceVmwareengineDatastoreDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Datastore: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/datastores/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Datastore %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Datastore")
	}

	err = VmwareengineOperationWaitTime(
		config, res, project, "Deleting Datastore", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Datastore %q: %#v", d.Id(), res)
	return nil
}

func resourceVmwareengineDatastoreImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/datastores/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/datastores/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenVmwareengineDatastoreClusters(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareengineDatastoreCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareengineDatastoreDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareengineDatastoreNfsDatastore(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["google_file_service"] =
		flattenVmwareengineDatastoreNfsDatastoreGoogleFileService(original["googleFileService"], d, config)
	transformed["third_party_file_service"] =
		flattenVmwareengineDatastoreNfsDatastoreThirdPartyFileService(original["thirdPartyFileService"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareengineDatastoreNfsDatastoreGoogleFileService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["filestore_instance"] =
		flattenVmwareengineDatastoreNfsDatastoreGoogleFileServiceFilestoreInstance(original["filestoreInstance"], d, config)
	transformed["netapp_volume"] =
		flattenVmwareengineDatastoreNfsDatastoreGoogleFileServiceNetappVolume(original["netappVolume"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareengineDatastoreNfsDatastoreGoogleFileServiceFilestoreInstance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareengineDatastoreNfsDatastoreGoogleFileServiceNetappVolume(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareengineDatastoreNfsDatastoreThirdPartyFileService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["file_share"] =
		flattenVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceFileShare(original["fileShare"], d, config)
	transformed["network"] =
		flattenVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceNetwork(original["network"], d, config)
	transformed["servers"] =
		flattenVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceServers(original["servers"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceFileShare(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceServers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareengineDatastoreState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareengineDatastoreUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareengineDatastoreUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandVmwareengineDatastoreDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareengineDatastoreNfsDatastore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGoogleFileService, err := expandVmwareengineDatastoreNfsDatastoreGoogleFileService(original["google_file_service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGoogleFileService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["googleFileService"] = transformedGoogleFileService
	}

	transformedThirdPartyFileService, err := expandVmwareengineDatastoreNfsDatastoreThirdPartyFileService(original["third_party_file_service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedThirdPartyFileService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["thirdPartyFileService"] = transformedThirdPartyFileService
	}

	return transformed, nil
}

func expandVmwareengineDatastoreNfsDatastoreGoogleFileService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFilestoreInstance, err := expandVmwareengineDatastoreNfsDatastoreGoogleFileServiceFilestoreInstance(original["filestore_instance"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFilestoreInstance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["filestoreInstance"] = transformedFilestoreInstance
	}

	transformedNetappVolume, err := expandVmwareengineDatastoreNfsDatastoreGoogleFileServiceNetappVolume(original["netapp_volume"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetappVolume); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["netappVolume"] = transformedNetappVolume
	}

	return transformed, nil
}

func expandVmwareengineDatastoreNfsDatastoreGoogleFileServiceFilestoreInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareengineDatastoreNfsDatastoreGoogleFileServiceNetappVolume(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareengineDatastoreNfsDatastoreThirdPartyFileService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFileShare, err := expandVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceFileShare(original["file_share"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFileShare); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fileShare"] = transformedFileShare
	}

	transformedNetwork, err := expandVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceNetwork(original["network"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["network"] = transformedNetwork
	}

	transformedServers, err := expandVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceServers(original["servers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServers); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["servers"] = transformedServers
	}

	return transformed, nil
}

func expandVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceFileShare(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareengineDatastoreNfsDatastoreThirdPartyFileServiceServers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
