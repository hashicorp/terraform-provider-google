// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/vmwareengine/data_source_google_vmwareengine_annoucements.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package vmwareengine

import (
	"fmt"
	"net/url"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func DataSourceVmwareengineAnnouncements() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceVmwareengineAnnouncementsRead,
		Schema: map[string]*schema.Schema{
			"parent": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Required. The resource name of the location to be queried for announcements. Resource names are schemeless URIs that follow the conventions in https://cloud.google.com/apis/design/resource_names. For example: projects/my-project/locations/us-west1-a`,
			},
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The resource name of the specific Announcements to retrieve. If provided, the 'announcements' list will contain only this announcement.`,
			},
			"announcements": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: ` A list of announcements`,
				Elem:        dataSourceVmwareengineAnnouncement(),
			},
		},
	}
}

func dataSourceVmwareengineAnnouncementsRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	_, fetchSingleAnnouncement := d.GetOk("name")

	var resourceURL string
	if fetchSingleAnnouncement {
		resourceURL, err = tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}{{parent}}/announcements/{{name}}")
	} else {
		resourceURL, err = tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}{{parent}}/announcements")
	}

	if err != nil {
		return err
	}

	// we allow to list only active maintenance announcements
	if !fetchSingleAnnouncement {
		u, err := url.Parse(resourceURL)
		if err != nil {
			return err
		}
		query := u.Query()
		maintenanceAnnouncementsFilter := `activityType="MAINTENANCE" AND state="ACTIVE"`
		query.Set("filter", maintenanceAnnouncementsFilter)
		u.RawQuery = query.Encode()

		resourceURL = u.String()
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:               config,
		Method:               "GET",
		Project:              billingProject,
		RawURL:               resourceURL,
		UserAgent:            userAgent,
		ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{transport_tpg.Is429QuotaError},
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("VmwareengineAnnouncements %q", d.Id()))
	}

	if fetchSingleAnnouncement {
		err = d.Set("announcements", flattenVmwareengineAnnouncement(res, d, config))
		d.SetId(res["name"].(string))
	} else {
		err = d.Set("announcements", flattenVmwareengineAnnouncements(res["announcements"], d, config))
		d.SetId(d.Get("parent").(string))
	}

	if err != nil {
		return fmt.Errorf("Error reading Announcements: %s", err)
	}

	return nil
}

func dataSourceVmwareengineAnnouncement() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The resource name of the announcement. Resource names are schemeless URIs that follow the conventions in https://cloud.google.com/apis/design/resource_names. For example: projects/my-project/locations/us-west1-a/announcements/my-announcement-id`,
			},

			"code": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Code of the announcement, could be one of MAINTENANCE_SCHEDULE_NOT_AVAILABLE, MAINTENANCE_SCHEDULE_READY, MAINTENANCE_SCHEDULE_LOCKED, MAINTENANCE_SCHEDULE_CANCELED, MAINTENANCE_INPROGRESS, MAINTENANCE_SUCCESSFUL, MAINTENANCE_CANCELED, MAINTENANCE_PAUSED, MAINTENANCE_FAILED, IMMUTABLE_MAINTENANCE_SCHEDULE_READY, MAINTENANCE_STARTING_SOON`,
			},
			"target_resource_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Target Resource Type defines the type of the target for the announcement`,
			},
			"metadata": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `Additional structured details about this announcement`,
			},
		},
	}
}

func flattenVmwareengineAnnouncement(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	return flattenVmwareengineAnnouncements([]interface{}{v}, d, config)
}

func flattenVmwareengineAnnouncements(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	l := v.([]interface{})
	transformed := make([]map[string]interface{}, 0, len(l))
	for _, raw := range l {
		rawMap := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"name":                 rawMap["name"],
			"code":                 rawMap["code"],
			"target_resource_type": rawMap["targetResourceType"],
			"metadata":             rawMap["metadata"],
		})
	}

	return transformed
}
