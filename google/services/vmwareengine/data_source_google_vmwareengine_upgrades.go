// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/vmwareengine/data_source_google_vmwareengine_upgrades.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package vmwareengine

import (
	"fmt"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func DataSourceVmwareengineUpgrades() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceVmwareengineUpgradesRead,
		Schema: map[string]*schema.Schema{
			"parent": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The resource name of the private cloud for which upgrades will be listed.
Resource names are schemeless URIs that follow the conventions in https://cloud.google.com/apis/design/resource_names.
For example: projects/my-project/locations/us-west1-a/privateClouds/my-cloud`,
			},
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The resource name of the specific Upgrade to retrieve. If provided, the 'upgrades' list will contain only this upgrade.`,
			},
			"upgrades": {
				Type:        schema.TypeList,
				Description: "A list of VMware Engine upgrades. Contains one element if 'name' is specified in the arguments, otherwise all upgrades for the private cloud.",
				Computed:    true,
				Elem:        dataSourceVmwareengineUpgrade(),
			},
		},
	}
}

func dataSourceVmwareengineUpgradesRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	_, fetchSingleUpgrade := d.GetOk("name")

	var url string
	if fetchSingleUpgrade {
		url, err = tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}{{parent}}/upgrades/{{name}}")
	} else {
		url, err = tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}{{parent}}/upgrades")
	}

	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:               config,
		Method:               "GET",
		Project:              billingProject,
		RawURL:               url,
		UserAgent:            userAgent,
		ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{transport_tpg.Is429QuotaError},
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("VmwareengineUpgrades %q", d.Id()))
	}

	if fetchSingleUpgrade {
		err = d.Set("upgrades", flattenVmwareengineUpgrade(res, d, config))
		d.SetId(res["name"].(string))
	} else {
		err = d.Set("upgrades", flattenVmwareengineUpgrades(res["upgrades"], d, config))
		d.SetId(d.Get("parent").(string))
	}

	if err != nil {
		return fmt.Errorf("Error reading Upgrades: %s", err)
	}

	return nil
}

func dataSourceVmwareengineUpgrade() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The resource name of the private cloud Upgrade.",
			},
			"end_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "End time of the upgrade in RFC3339 format. Only set when upgrade reaches a succeeded/failed/cancelled state.",
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The current state of the upgrade. Possible values include: `SCHEDULED`, `ONGOING`, `SUCCEEDED`, `PAUSED`, `FAILED`, `CANCELLING`, `CANCELLED`, `RESCHEDULING`.",
			},
			"type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The type of upgrade. Possible values include: `VSPHERE_UPGRADE`, `VSPHERE_PATCH`, `WORKAROUND`, `FIRMWARE_UPGRADE`, `SWITCH_UPGRADE`, `OTHER`, `INFRASTRUCTURE_UPGRADE`.",
			},
			"description": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Additional information about the private cloud upgrade.",
			},
			"estimated_duration": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The estimated total duration of the upgrade in seconds.",
			},
			"schedule": {
				Type:        schema.TypeList,
				Description: "Schedule details for the upgrade.",
				Computed:    true,
				Elem:        dataSourceVmwareengineUpgradeSchedule(),
			},
			"component_upgrades": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "The list of component upgrades.",
				Elem:        dataSourceVmwareengineUpgradeComponentUpgrades(),
			},
			"start_version": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The start version of the private cloud for this upgrade.",
			},
			"target_version": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The targeted version of the private cloud at the end of the upgrade.",
			},
		},
	}
}

func dataSourceVmwareengineUpgradeSchedule() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"start_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The scheduled start time for the upgrade in RFC3339 format.",
			},
			"weekly_windows": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Weekly time windows for upgrade activities.",
				Elem:        dataSourceVmwareengineUpgradeScheduleWeeklyWindow(),
			},
			"constraints": {
				Type:        schema.TypeList,
				Computed:    true,
				MaxItems:    1,
				Optional:    true,
				Description: "Constraints applied to the schedule.",
				Elem:        dataSourceVmwareengineUpgradeScheduleConstraint(),
			},
			"edit_window": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "The schedule is open for edits during this time interval.",
				Elem:        dataSourceVmwareengineUpgradeScheduleEditWindow(),
			},
			"last_editor": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Indicates who most recently edited the upgrade schedule. Possible values: `SYSTEM`, `USER`.",
			},
		},
	}
}

func dataSourceVmwareengineUpgradeScheduleWeeklyWindow() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"day_of_week": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Day of the week for this window.",
			},
			"start_time": {
				Type:     schema.TypeList,
				Computed: true,
				Elem:     dataSourceVmwareengineUpgradeTimeOfDay(),
			},
			"duration": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The duration of the window in seconds.",
			},
		},
	}
}

func dataSourceVmwareengineUpgradeScheduleConstraint() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"min_hours_day": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "Minimum number of hours must be allotted for the upgrade activities for each selected day.",
			},
			"min_hours_week": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "The minimum number of weekly hours must be allotted for the upgrade activities.",
			},
			"reschedule_date_range": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				MaxItems:    1,
				Description: "The user can only reschedule an upgrade that starts within this range.",
				Elem:        dataSourceVmwareengineUpgradeScheduleConstraintRescheduleDateRange(),
			},
			"disallowed_intervals": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				MaxItems:    1,
				Description: "A list of intervals in which maintenance windows are not allowed.",
				Elem:        dataSourceVmwareengineUpgradeScheduleConstraintDisallowedInterval(),
			},
		},
	}
}

func dataSourceVmwareengineUpgradeScheduleConstraintRescheduleDateRange() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"start_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Start of the reschedule interval (RFC3339).",
			},
			"end_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "End of the reschedule interval (RFC3339).",
			},
		},
	}
}

func dataSourceVmwareengineUpgradeScheduleConstraintDisallowedInterval() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"start_day": {Type: schema.TypeString, Computed: true},
			"start_time": {
				Type:     schema.TypeList,
				Computed: true,
				MaxItems: 1,
				Optional: true,
				Elem:     dataSourceVmwareengineUpgradeTimeOfDay(),
			},
			"end_day": {Type: schema.TypeString, Computed: true},
			"end_time": {
				Type:     schema.TypeList,
				Computed: true,
				MaxItems: 1,
				Optional: true,
				Elem:     dataSourceVmwareengineUpgradeTimeOfDay(),
			},
		},
	}
}

func dataSourceVmwareengineUpgradeScheduleEditWindow() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"start_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Start of the edit window (RFC3339).",
			},
			"end_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "End of the edit window (RFC3339).",
			},
		},
	}
}

func dataSourceVmwareengineUpgradeComponentUpgrades() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"component_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The type of vmware component being upgraded.",
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Component's upgrade state.",
			},
		},
	}
}

func dataSourceVmwareengineUpgradeTimeOfDay() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"hours":   {Type: schema.TypeInt, Computed: true},
			"minutes": {Type: schema.TypeInt, Computed: true},
		},
	}
}

func flattenVmwareengineUpgrade(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	return flattenVmwareengineUpgrades([]interface{}{v}, d, config)
}

func flattenVmwareengineUpgrades(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	l := v.([]interface{})
	transformed := make([]map[string]interface{}, 0, len(l))
	for _, raw := range l {
		rawMap := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"name":               rawMap["name"],
			"end_time":           rawMap["endTime"],
			"state":              rawMap["state"],
			"type":               rawMap["type"],
			"description":        rawMap["description"],
			"estimated_duration": rawMap["estimatedDuration"],
			"schedule":           flattenVmwareengineUpgradesSchedule(rawMap["schedule"], d, config),
			"component_upgrades": flattenVmwareengineUpgradesComponentUpgrades(rawMap["componentUpgrades"], d, config),
			"start_version":      rawMap["startVersion"],
			"target_version":     rawMap["targetVersion"],
		})
	}

	return transformed
}

func flattenVmwareengineUpgradesSchedule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	raw := v.(map[string]interface{})

	transformed := map[string]interface{}{
		"start_time":     raw["startTime"],
		"weekly_windows": flattenVmwareengineUpgradesScheduleWeeklyWindows(raw["weeklyWindows"], d, config),
		"constraints":    flattenVmwareengineUpgradesScheduleConstraints(raw["constraints"], d, config),
		"edit_window":    flattenVmwareengineUpgradesInterval(raw["editWindow"], d, config),
		"last_editor":    raw["lastEditor"],
	}

	return []map[string]interface{}{transformed}
}

func flattenVmwareengineUpgradesScheduleWeeklyWindows(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	l := v.([]interface{})
	transformed := make([]map[string]interface{}, 0, len(l))

	for _, raw := range l {
		rawMap := raw.(map[string]interface{})

		transformed = append(transformed, map[string]interface{}{
			"day_of_week": rawMap["dayOfWeek"],
			"start_time":  flattenVmwareengineUpgradesTimeOfDay(rawMap["startTime"], d, config),
			"duration":    rawMap["duration"],
		})

	}

	return transformed
}

func flattenVmwareengineUpgradesScheduleConstraints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	raw := v.(map[string]interface{})

	return []map[string]interface{}{
		{
			"min_hours_day":         raw["minHoursDay"],
			"min_hours_week":        raw["minHoursWeek"],
			"reschedule_date_range": flattenVmwareengineUpgradesInterval(raw["rescheduleDateRange"], d, config),
			"disallowed_intervals":  flattenVmwareengineUpgradesScheduleConstraintsDisallowedIntervals(raw["disallowedIntervals"], d, config),
		},
	}
}

func flattenVmwareengineUpgradesScheduleConstraintsDisallowedIntervals(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	l := v.([]interface{})
	transformed := make([]map[string]interface{}, 0, len(l))

	for _, raw := range l {
		rawMap := raw.(map[string]interface{})

		transformed = append(transformed, map[string]interface{}{
			"start_day":  rawMap["startDay"],
			"start_time": flattenVmwareengineUpgradesTimeOfDay(rawMap["startTime"], d, config),
			"end_day":    rawMap["endDay"],
			"end_time":   flattenVmwareengineUpgradesTimeOfDay(rawMap["endTime"], d, config),
		})
	}

	return transformed
}

func flattenVmwareengineUpgradesComponentUpgrades(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	l := v.([]interface{})
	transformed := make([]map[string]interface{}, 0, len(l))

	for _, raw := range l {
		rawMap := raw.(map[string]interface{})

		transformed = append(transformed, map[string]interface{}{
			"component_type": rawMap["componentType"],
			"state":          rawMap["state"],
		})

	}

	return transformed
}

func flattenVmwareengineUpgradesInterval(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	raw := v.(map[string]interface{})

	return []map[string]interface{}{
		{
			"start_time": raw["startTime"],
			"end_time":   raw["endTime"],
		},
	}
}

func flattenVmwareengineUpgradesTimeOfDay(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}

	return []interface{}{v}
}
