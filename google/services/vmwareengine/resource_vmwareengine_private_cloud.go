// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/vmwareengine/PrivateCloud.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package vmwareengine

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"google.golang.org/api/googleapi"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func vmwareenginePrivateCloudStandardTypeDiffSuppressFunc(_, old, new string, d *schema.ResourceData) bool {
	if (old == "STANDARD" && new == "") || (old == "" && new == "STANDARD") {
		return true
	}
	if isMultiNodePrivateCloud(d) && old == "TIME_LIMITED" && new == "STANDARD" {
		log.Printf("[DEBUG] Multinode Private Cloud found, facilitating TYPE change to STANDARD")
		return true
	}
	return false
}

func isMultiNodePrivateCloud(d *schema.ResourceData) bool {
	nodeConfigMap := d.Get("management_cluster.0.node_type_configs").(*schema.Set).List()
	totalNodeCount := 0
	for _, nodeConfig := range nodeConfigMap {
		configMap, ok := nodeConfig.(map[string]interface{})
		if !ok {
			log.Printf("[DEBUG] Invalid node configuration format for private cloud.")
			continue
		}
		nodeCount, ok := configMap["node_count"].(int)
		if !ok {
			log.Printf("[DEBUG] Invalid node_count format for private cloud.")
			continue
		}
		totalNodeCount += nodeCount
	}
	log.Printf("[DEBUG] The node count of the private cloud is found to be %v nodes.", totalNodeCount)
	if totalNodeCount > 2 {
		return true
	}
	return false
}

func isPrivateCloudInDeletedState(config *transport_tpg.Config, d *schema.ResourceData, billingProject string, userAgent string) (bool, error) {
	baseurl, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return false, err
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    baseurl,
		UserAgent: userAgent,
	})
	if err != nil {
		if gerr, ok := err.(*googleapi.Error); ok && gerr.Code == 404 {
			log.Printf("[DEBUG] No existing private cloud found")
			return false, nil
		}
		return false, err
	}
	// if resource exists but is marked for deletion
	v, ok := res["state"]
	if ok && v.(string) == "DELETED" {
		log.Printf("[DEBUG] The Private cloud exists and is marked for deletion.")
		return true, nil
	}
	return false, nil
}

// Check if private cloud is absent or if it exists in a deleted state.
func pollCheckForPrivateCloudAbsence(resp map[string]interface{}, respErr error) transport_tpg.PollResult {
	if respErr != nil {
		if transport_tpg.IsGoogleApiErrorWithCode(respErr, 404) {
			return transport_tpg.SuccessPollResult()
		}
		return transport_tpg.ErrorPollResult(respErr)
	}
	// if resource exists but is marked for deletion
	log.Printf("[DEBUG] Fetching state of the private cloud.")
	v, ok := resp["state"]
	if ok && v.(string) == "DELETED" {
		log.Printf("[DEBUG] The Private cloud has been successfully marked for delayed deletion.")
		return transport_tpg.SuccessPollResult()
	}
	return transport_tpg.PendingStatusPollResult("found")
}

func ResourceVmwareenginePrivateCloud() *schema.Resource {
	return &schema.Resource{
		Create: resourceVmwareenginePrivateCloudCreate,
		Read:   resourceVmwareenginePrivateCloudRead,
		Update: resourceVmwareenginePrivateCloudUpdate,
		Delete: resourceVmwareenginePrivateCloudDelete,

		Importer: &schema.ResourceImporter{
			State: resourceVmwareenginePrivateCloudImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(360 * time.Minute),
			Update: schema.DefaultTimeout(190 * time.Minute),
			Delete: schema.DefaultTimeout(150 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location where the PrivateCloud should reside.`,
			},
			"management_cluster": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `The management cluster for this private cloud. This used for creating and managing the default cluster.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cluster_id": {
							Type:     schema.TypeString,
							Required: true,
							Description: `The user-provided identifier of the new Cluster. The identifier must meet the following requirements:
  * Only contains 1-63 alphanumeric characters and hyphens
  * Begins with an alphabetical character
  * Ends with a non-hyphen character
  * Not formatted as a UUID
  * Complies with RFC 1034 (https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)`,
						},
						"autoscaling_settings": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Configuration of the autoscaling applied to this cluster
Private cloud must have a minimum of 3 nodes to add autoscale settings`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"autoscaling_policies": {
										Type:     schema.TypeSet,
										Required: true,
										Description: `The map with autoscaling policies applied to the cluster.
The key is the identifier of the policy.
It must meet the following requirements:
 * Only contains 1-63 alphanumeric characters and hyphens
 * Begins with an alphabetical character
 * Ends with a non-hyphen character
 * Not formatted as a UUID
 * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)

Currently the map must contain only one element
that describes the autoscaling policy for compute nodes.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"autoscale_policy_id": {
													Type:     schema.TypeString,
													Required: true,
												},
												"node_type_id": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The canonical identifier of the node type to add or remove.`,
												},
												"scale_out_size": {
													Type:     schema.TypeInt,
													Required: true,
													Description: `Number of nodes to add to a cluster during a scale-out operation.
Must be divisible by 2 for stretched clusters.`,
												},
												"consumed_memory_thresholds": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Utilization thresholds pertaining to amount of consumed memory.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"scale_in": {
																Type:        schema.TypeInt,
																Required:    true,
																Description: `The utilization triggering the scale-in operation in percent.`,
															},
															"scale_out": {
																Type:        schema.TypeInt,
																Required:    true,
																Description: `The utilization triggering the scale-out operation in percent.`,
															},
														},
													},
												},
												"cpu_thresholds": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Utilization thresholds pertaining to CPU utilization.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"scale_in": {
																Type:        schema.TypeInt,
																Required:    true,
																Description: `The utilization triggering the scale-in operation in percent.`,
															},
															"scale_out": {
																Type:        schema.TypeInt,
																Required:    true,
																Description: `The utilization triggering the scale-out operation in percent.`,
															},
														},
													},
												},
												"storage_thresholds": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Utilization thresholds pertaining to amount of consumed storage.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"scale_in": {
																Type:        schema.TypeInt,
																Required:    true,
																Description: `The utilization triggering the scale-in operation in percent.`,
															},
															"scale_out": {
																Type:        schema.TypeInt,
																Required:    true,
																Description: `The utilization triggering the scale-out operation in percent.`,
															},
														},
													},
												},
											},
										},
									},
									"cool_down_period": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The minimum duration between consecutive autoscale operations.
It starts once addition or removal of nodes is fully completed.
Minimum cool down period is 30m.
Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
Mandatory for successful addition of autoscaling settings in cluster.`,
									},
									"max_cluster_node_count": {
										Type:     schema.TypeInt,
										Optional: true,
										Description: `Maximum number of nodes of any type in a cluster.
Mandatory for successful addition of autoscaling settings in cluster.`,
									},
									"min_cluster_node_count": {
										Type:     schema.TypeInt,
										Optional: true,
										Description: `Minimum number of nodes of any type in a cluster.
Mandatory for successful addition of autoscaling settings in cluster.`,
									},
								},
							},
						},
						"node_type_configs": {
							Type:     schema.TypeSet,
							Optional: true,
							Description: `The map of cluster node types in this cluster,
where the key is canonical identifier of the node type (corresponds to the NodeType).`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"node_type_id": {
										Type:     schema.TypeString,
										Required: true,
									},
									"node_count": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: `The number of nodes of this type in the cluster.`,
									},
									"custom_core_count": {
										Type:     schema.TypeInt,
										Optional: true,
										Description: `Customized number of cores available to each node of the type.
This number must always be one of 'nodeType.availableCustomCoreCounts'.
If zero is provided max value from 'nodeType.availableCustomCoreCounts' will be used.
This cannot be changed once the PrivateCloud is created.`,
										Default: 0,
									},
								},
							},
						},
						"stretched_cluster_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The stretched cluster configuration for the private cloud.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"preferred_location": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Zone that will remain operational when connection between the two zones is lost.
Specify the zone in the following format: projects/{project}/locations/{location}.`,
									},
									"secondary_location": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Additional zone for a higher level of availability and load balancing.
Specify the zone in the following format: projects/{project}/locations/{location}.`,
									},
								},
							},
						},
					},
				},
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The ID of the PrivateCloud.`,
			},
			"network_config": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `Network configuration in the consumer project with which the peering has to be done.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"management_cidr": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Management CIDR used by VMware management appliances.`,
						},
						"vmware_engine_network": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The relative resource name of the VMware Engine network attached to the private cloud.
Specify the name in the following form: projects/{project}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
where {project} can either be a project number or a project ID.`,
						},
						"dns_server_ip": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `DNS Server IP of the Private Cloud.`,
						},
						"management_ip_address_layout_version": {
							Type:     schema.TypeInt,
							Computed: true,
							Description: `The IP address layout version of the management IP address range.
Possible versions include:
* managementIpAddressLayoutVersion=1: Indicates the legacy IP address layout used by some existing private clouds. This is no longer supported for new private clouds
as it does not support all features.
* managementIpAddressLayoutVersion=2: Indicates the latest IP address layout
used by all newly created private clouds. This version supports all current features.`,
						},
						"vmware_engine_network_canonical": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The canonical name of the VMware Engine network in
the form: projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}`,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `User-provided description for this private cloud.`,
			},
			"type": {
				Type:             schema.TypeString,
				Optional:         true,
				ForceNew:         true,
				ValidateFunc:     verify.ValidateEnum([]string{"STANDARD", "TIME_LIMITED", "STRETCHED", ""}),
				DiffSuppressFunc: vmwareenginePrivateCloudStandardTypeDiffSuppressFunc,
				Description:      `Initial type of the private cloud. Possible values: ["STANDARD", "TIME_LIMITED", "STRETCHED"]`,
			},
			"hcx": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Details about a HCX Cloud Manager appliance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"fqdn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Fully qualified domain name of the appliance.`,
						},
						"internal_ip": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Internal IP address of the appliance.`,
						},
						"state": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"ACTIVE", "CREATING", ""}),
							Description:  `State of the appliance. Possible values: ["ACTIVE", "CREATING"]`,
						},
						"version": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Version of the appliance.`,
						},
					},
				},
			},
			"nsx": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Details about a NSX Manager appliance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"fqdn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Fully qualified domain name of the appliance.`,
						},
						"internal_ip": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Internal IP address of the appliance.`,
						},
						"state": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"ACTIVE", "CREATING", ""}),
							Description:  `State of the appliance. Possible values: ["ACTIVE", "CREATING"]`,
						},
						"version": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Version of the appliance.`,
						},
					},
				},
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `State of the resource. New values may be added to this enum when appropriate.`,
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `System-generated unique identifier for the resource.`,
			},
			"vcenter": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Details about a vCenter Server management appliance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"fqdn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Fully qualified domain name of the appliance.`,
						},
						"internal_ip": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Internal IP address of the appliance.`,
						},
						"state": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"ACTIVE", "CREATING", ""}),
							Description:  `State of the appliance. Possible values: ["ACTIVE", "CREATING"]`,
						},
						"version": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Version of the appliance.`,
						},
					},
				},
			},
			"deletion_delay_hours": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: `The number of hours to delay this request. You can set this value to an hour between 0 to 8, where setting it to 0 starts the deletion request immediately. If no value is set, a default value is set at the API Level.`,
			},
			"send_deletion_delay_hours_if_zero": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `While set true, deletion_delay_hours value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the deletion_delay_hours field. It can be used both alone and together with deletion_delay_hours.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceVmwareenginePrivateCloudCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandVmwareenginePrivateCloudDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	networkConfigProp, err := expandVmwareenginePrivateCloudNetworkConfig(d.Get("network_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(networkConfigProp)) && (ok || !reflect.DeepEqual(v, networkConfigProp)) {
		obj["networkConfig"] = networkConfigProp
	}
	managementClusterProp, err := expandVmwareenginePrivateCloudManagementCluster(d.Get("management_cluster"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("management_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(managementClusterProp)) && (ok || !reflect.DeepEqual(v, managementClusterProp)) {
		obj["managementCluster"] = managementClusterProp
	}
	typeProp, err := expandVmwareenginePrivateCloudType(d.Get("type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("type"); !tpgresource.IsEmptyValue(reflect.ValueOf(typeProp)) && (ok || !reflect.DeepEqual(v, typeProp)) {
		obj["type"] = typeProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds?privateCloudId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new PrivateCloud: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PrivateCloud: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// Check if the project exists in a deleted state
	pcMarkedForDeletion, err := isPrivateCloudInDeletedState(config, d, billingProject, userAgent)
	if err != nil {
		return fmt.Errorf("Error checking if Private Cloud exists and is marked for deletion: %s", err)
	}
	if pcMarkedForDeletion {
		log.Printf("[DEBUG] Private Cloud exists and is marked for deletion. Triggering UNDELETE of the Private Cloud.\n")
		url, err = tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}:undelete")
		if err != nil {
			return err
		}
		obj = make(map[string]interface{})
	} else {
		log.Printf("[DEBUG] Private Cloud is not found to be marked for deletion. Triggering CREATE of the Private Cloud.\n")
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:               config,
		Method:               "POST",
		Project:              billingProject,
		RawURL:               url,
		UserAgent:            userAgent,
		Body:                 obj,
		Timeout:              d.Timeout(schema.TimeoutCreate),
		Headers:              headers,
		ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{transport_tpg.Is429QuotaError},
	})
	if err != nil {
		return fmt.Errorf("Error creating PrivateCloud: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = VmwareengineOperationWaitTime(
		config, res, project, "Creating PrivateCloud", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create PrivateCloud: %s", err)
	}

	mgmtClusterProp, err := expandVmwareenginePrivateCloudManagementCluster(d.Get("management_cluster"), d, config)
	if v, ok := d.GetOkExists("management_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, mgmtClusterProp)) {
		obj["managementCluster"] = mgmtClusterProp
	}

	mgmtMap := mgmtClusterProp.(map[string]interface{})
	parentUrl, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return err
	}

	clusterUrl := fmt.Sprintf("%s/clusters/%s", parentUrl, mgmtMap["clusterId"])
	clusterUpdateMask := []string{}
	clusterObj := make(map[string]interface{})

	if v, ok := d.GetOkExists("management_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(mgmtClusterProp)) && (ok || !reflect.DeepEqual(v, mgmtClusterProp)) {
		clusterObj["autoscalingSettings"] = mgmtMap["autoscalingSettings"]
	}

	if d.HasChange("management_cluster") {
		clusterUpdateMask = append(clusterUpdateMask, "autoscalingSettings")
	}

	clusterPatchUrl, err := transport_tpg.AddQueryParams(clusterUrl, map[string]string{"updateMask": strings.Join(clusterUpdateMask, ",")})
	if err != nil {
		return err
	}

	// check if there is anything to update to avoid API call if not required.
	if len(clusterUpdateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    clusterPatchUrl,
			UserAgent: userAgent,
			Body:      clusterObj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
		})

		if err != nil {
			return fmt.Errorf("Error updating magament cluster %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating magament cluster %q: %#v", d.Id(), res)
		}

		err = VmwareengineOperationWaitTime(
			config, res, project, "Updating Management Cluster", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	log.Printf("[DEBUG] Finished creating PrivateCloud %q: %#v", d.Id(), res)

	return resourceVmwareenginePrivateCloudRead(d, meta)
}

func resourceVmwareenginePrivateCloudRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PrivateCloud: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:               config,
		Method:               "GET",
		Project:              billingProject,
		RawURL:               url,
		UserAgent:            userAgent,
		Headers:              headers,
		ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{transport_tpg.Is429QuotaError},
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("VmwareenginePrivateCloud %q", d.Id()))
	}

	res, err = resourceVmwareenginePrivateCloudDecoder(d, meta, res)
	if err != nil {
		return err
	}

	if res == nil {
		// Decoding the object has resulted in it being gone. It may be marked deleted
		log.Printf("[DEBUG] Removing VmwareenginePrivateCloud because it no longer exists.")
		d.SetId("")
		return nil
	}

	// Explicitly set virtual fields to default values if unset
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}

	if err := d.Set("description", flattenVmwareenginePrivateCloudDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("uid", flattenVmwareenginePrivateCloudUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("state", flattenVmwareenginePrivateCloudState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("network_config", flattenVmwareenginePrivateCloudNetworkConfig(res["networkConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("management_cluster", flattenVmwareenginePrivateCloudManagementCluster(res["managementCluster"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("hcx", flattenVmwareenginePrivateCloudHcx(res["hcx"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("nsx", flattenVmwareenginePrivateCloudNsx(res["nsx"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("vcenter", flattenVmwareenginePrivateCloudVcenter(res["vcenter"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("type", flattenVmwareenginePrivateCloudType(res["type"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}

	return nil
}

func resourceVmwareenginePrivateCloudUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PrivateCloud: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandVmwareenginePrivateCloudDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	managementClusterProp, err := expandVmwareenginePrivateCloudManagementCluster(d.Get("management_cluster"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("management_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, managementClusterProp)) {
		obj["managementCluster"] = managementClusterProp
	}

	obj, err = resourceVmwareenginePrivateCloudUpdateEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating PrivateCloud %q: %#v", d.Id(), obj)
	headers := make(http.Header)

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:               config,
		Method:               "PATCH",
		Project:              billingProject,
		RawURL:               url,
		UserAgent:            userAgent,
		Body:                 obj,
		Timeout:              d.Timeout(schema.TimeoutUpdate),
		Headers:              headers,
		ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{transport_tpg.Is429QuotaError},
	})

	if err != nil {
		return fmt.Errorf("Error updating PrivateCloud %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating PrivateCloud %q: %#v", d.Id(), res)
	}

	err = VmwareengineOperationWaitTime(
		config, res, project, "Updating PrivateCloud", userAgent,
		d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return err
	}

	mgmtClusterProp, err := expandVmwareenginePrivateCloudManagementCluster(d.Get("management_cluster"), d, config)
	if v, ok := d.GetOkExists("management_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, mgmtClusterProp)) {
		obj["managementCluster"] = mgmtClusterProp
	}

	mgmtMap := mgmtClusterProp.(map[string]interface{})
	parentUrl, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return err
	}

	clusterUrl := fmt.Sprintf("%s/clusters/%s", parentUrl, mgmtMap["clusterId"])
	clusterUpdateMask := []string{}
	clusterObj := make(map[string]interface{})

	if v, ok := d.GetOkExists("management_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(mgmtClusterProp)) && (ok || !reflect.DeepEqual(v, mgmtClusterProp)) {
		clusterObj["nodeTypeConfigs"] = mgmtMap["nodeTypeConfigs"]
		clusterObj["autoscalingSettings"] = mgmtMap["autoscalingSettings"]
	}

	if d.HasChange("management_cluster") {
		clusterUpdateMask = append(clusterUpdateMask, "nodeTypeConfigs.*.nodeCount")
		clusterUpdateMask = append(clusterUpdateMask, "autoscalingSettings")
	}

	clusterPatchUrl, err := transport_tpg.AddQueryParams(clusterUrl, map[string]string{"updateMask": strings.Join(clusterUpdateMask, ",")})
	if err != nil {
		return err
	}

	// check if there is anything to update to avoid API call if not required.
	if len(clusterUpdateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    clusterPatchUrl,
			UserAgent: userAgent,
			Body:      clusterObj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
		})

		if err != nil {
			return fmt.Errorf("Error updating magament cluster %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating magament cluster %q: %#v", d.Id(), res)
		}

		err = VmwareengineOperationWaitTime(
			config, res, project, "Updating Management Cluster", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}
	return resourceVmwareenginePrivateCloudRead(d, meta)
}

func resourceVmwareenginePrivateCloudDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PrivateCloud: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// Delay deletion of the Private Cloud if delationDelayHours value is set
	delationDelayHours := d.Get("deletion_delay_hours").(int)
	if delationDelayHours > 0 || (delationDelayHours == 0 && d.Get("send_deletion_delay_hours_if_zero").(bool) == true) {
		log.Printf("[DEBUG] Triggering delete of the Private Cloud with a delay of %v hours.\n", delationDelayHours)
		url = url + "?delay_hours=" + fmt.Sprintf("%v", delationDelayHours)
	} else {
		log.Printf("[DEBUG] No deletion delay provided, triggering DELETE API without setting delay hours.\n")
	}

	log.Printf("[DEBUG] Deleting PrivateCloud %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:               config,
		Method:               "DELETE",
		Project:              billingProject,
		RawURL:               url,
		UserAgent:            userAgent,
		Body:                 obj,
		Timeout:              d.Timeout(schema.TimeoutDelete),
		Headers:              headers,
		ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{transport_tpg.Is429QuotaError},
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "PrivateCloud")
	}

	err = VmwareengineOperationWaitTime(
		config, res, project, "Deleting PrivateCloud", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting PrivateCloud %q: %#v", d.Id(), res)
	return nil
}

func resourceVmwareenginePrivateCloudImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/privateClouds/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Explicitly set virtual fields to default values on import

	return []*schema.ResourceData{d}, nil
}

func flattenVmwareenginePrivateCloudDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNetworkConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["management_cidr"] =
		flattenVmwareenginePrivateCloudNetworkConfigManagementCidr(original["managementCidr"], d, config)
	transformed["vmware_engine_network"] =
		flattenVmwareenginePrivateCloudNetworkConfigVmwareEngineNetwork(original["vmwareEngineNetwork"], d, config)
	transformed["vmware_engine_network_canonical"] =
		flattenVmwareenginePrivateCloudNetworkConfigVmwareEngineNetworkCanonical(original["vmwareEngineNetworkCanonical"], d, config)
	transformed["management_ip_address_layout_version"] =
		flattenVmwareenginePrivateCloudNetworkConfigManagementIpAddressLayoutVersion(original["managementIpAddressLayoutVersion"], d, config)
	transformed["dns_server_ip"] =
		flattenVmwareenginePrivateCloudNetworkConfigDnsServerIp(original["dnsServerIp"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudNetworkConfigManagementCidr(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNetworkConfigVmwareEngineNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNetworkConfigVmwareEngineNetworkCanonical(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNetworkConfigManagementIpAddressLayoutVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudNetworkConfigDnsServerIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudManagementCluster(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cluster_id"] =
		flattenVmwareenginePrivateCloudManagementClusterClusterId(original["clusterId"], d, config)
	transformed["node_type_configs"] =
		flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigs(original["nodeTypeConfigs"], d, config)
	transformed["stretched_cluster_config"] =
		flattenVmwareenginePrivateCloudManagementClusterStretchedClusterConfig(original["stretchedClusterConfig"], d, config)
	transformed["autoscaling_settings"] =
		flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettings(original["autoscalingSettings"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudManagementClusterClusterId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"node_type_id":      k,
			"node_count":        flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigsNodeCount(original["nodeCount"], d, config),
			"custom_core_count": flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigsCustomCoreCount(original["customCoreCount"], d, config),
		})
	}
	return transformed
}
func flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigsNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigsCustomCoreCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterStretchedClusterConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["preferred_location"] =
		flattenVmwareenginePrivateCloudManagementClusterStretchedClusterConfigPreferredLocation(original["preferredLocation"], d, config)
	transformed["secondary_location"] =
		flattenVmwareenginePrivateCloudManagementClusterStretchedClusterConfigSecondaryLocation(original["secondaryLocation"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudManagementClusterStretchedClusterConfigPreferredLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudManagementClusterStretchedClusterConfigSecondaryLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["autoscaling_policies"] =
		flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicies(original["autoscalingPolicies"], d, config)
	transformed["min_cluster_node_count"] =
		flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsMinClusterNodeCount(original["minClusterNodeCount"], d, config)
	transformed["max_cluster_node_count"] =
		flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsMaxClusterNodeCount(original["maxClusterNodeCount"], d, config)
	transformed["cool_down_period"] =
		flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsCoolDownPeriod(original["coolDownPeriod"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicies(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"autoscale_policy_id":        k,
			"node_type_id":               flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesNodeTypeId(original["nodeTypeId"], d, config),
			"scale_out_size":             flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesScaleOutSize(original["scaleOutSize"], d, config),
			"cpu_thresholds":             flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholds(original["cpuThresholds"], d, config),
			"consumed_memory_thresholds": flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholds(original["consumedMemoryThresholds"], d, config),
			"storage_thresholds":         flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholds(original["storageThresholds"], d, config),
		})
	}
	return transformed
}
func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesNodeTypeId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesScaleOutSize(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["scale_out"] =
		flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholdsScaleOut(original["scaleOut"], d, config)
	transformed["scale_in"] =
		flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholdsScaleIn(original["scaleIn"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholdsScaleOut(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholdsScaleIn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["scale_out"] =
		flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholdsScaleOut(original["scaleOut"], d, config)
	transformed["scale_in"] =
		flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholdsScaleIn(original["scaleIn"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholdsScaleOut(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholdsScaleIn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["scale_out"] =
		flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholdsScaleOut(original["scaleOut"], d, config)
	transformed["scale_in"] =
		flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholdsScaleIn(original["scaleIn"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholdsScaleOut(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholdsScaleIn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsMinClusterNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsMaxClusterNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterAutoscalingSettingsCoolDownPeriod(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudHcx(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["internal_ip"] =
		flattenVmwareenginePrivateCloudHcxInternalIp(original["internalIp"], d, config)
	transformed["version"] =
		flattenVmwareenginePrivateCloudHcxVersion(original["version"], d, config)
	transformed["state"] =
		flattenVmwareenginePrivateCloudHcxState(original["state"], d, config)
	transformed["fqdn"] =
		flattenVmwareenginePrivateCloudHcxFqdn(original["fqdn"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudHcxInternalIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudHcxVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudHcxState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudHcxFqdn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNsx(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["internal_ip"] =
		flattenVmwareenginePrivateCloudNsxInternalIp(original["internalIp"], d, config)
	transformed["version"] =
		flattenVmwareenginePrivateCloudNsxVersion(original["version"], d, config)
	transformed["state"] =
		flattenVmwareenginePrivateCloudNsxState(original["state"], d, config)
	transformed["fqdn"] =
		flattenVmwareenginePrivateCloudNsxFqdn(original["fqdn"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudNsxInternalIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNsxVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNsxState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNsxFqdn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudVcenter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["internal_ip"] =
		flattenVmwareenginePrivateCloudVcenterInternalIp(original["internalIp"], d, config)
	transformed["version"] =
		flattenVmwareenginePrivateCloudVcenterVersion(original["version"], d, config)
	transformed["state"] =
		flattenVmwareenginePrivateCloudVcenterState(original["state"], d, config)
	transformed["fqdn"] =
		flattenVmwareenginePrivateCloudVcenterFqdn(original["fqdn"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudVcenterInternalIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudVcenterVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudVcenterState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudVcenterFqdn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandVmwareenginePrivateCloudDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudNetworkConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedManagementCidr, err := expandVmwareenginePrivateCloudNetworkConfigManagementCidr(original["management_cidr"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedManagementCidr); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["managementCidr"] = transformedManagementCidr
	}

	transformedVmwareEngineNetwork, err := expandVmwareenginePrivateCloudNetworkConfigVmwareEngineNetwork(original["vmware_engine_network"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVmwareEngineNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vmwareEngineNetwork"] = transformedVmwareEngineNetwork
	}

	transformedVmwareEngineNetworkCanonical, err := expandVmwareenginePrivateCloudNetworkConfigVmwareEngineNetworkCanonical(original["vmware_engine_network_canonical"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVmwareEngineNetworkCanonical); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vmwareEngineNetworkCanonical"] = transformedVmwareEngineNetworkCanonical
	}

	transformedManagementIpAddressLayoutVersion, err := expandVmwareenginePrivateCloudNetworkConfigManagementIpAddressLayoutVersion(original["management_ip_address_layout_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedManagementIpAddressLayoutVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["managementIpAddressLayoutVersion"] = transformedManagementIpAddressLayoutVersion
	}

	transformedDnsServerIp, err := expandVmwareenginePrivateCloudNetworkConfigDnsServerIp(original["dns_server_ip"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDnsServerIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dnsServerIp"] = transformedDnsServerIp
	}

	return transformed, nil
}

func expandVmwareenginePrivateCloudNetworkConfigManagementCidr(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudNetworkConfigVmwareEngineNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudNetworkConfigVmwareEngineNetworkCanonical(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudNetworkConfigManagementIpAddressLayoutVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudNetworkConfigDnsServerIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementCluster(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedClusterId, err := expandVmwareenginePrivateCloudManagementClusterClusterId(original["cluster_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClusterId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clusterId"] = transformedClusterId
	}

	transformedNodeTypeConfigs, err := expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigs(original["node_type_configs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNodeTypeConfigs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nodeTypeConfigs"] = transformedNodeTypeConfigs
	}

	transformedStretchedClusterConfig, err := expandVmwareenginePrivateCloudManagementClusterStretchedClusterConfig(original["stretched_cluster_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStretchedClusterConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["stretchedClusterConfig"] = transformedStretchedClusterConfig
	}

	transformedAutoscalingSettings, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettings(original["autoscaling_settings"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAutoscalingSettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["autoscalingSettings"] = transformedAutoscalingSettings
	}

	return transformed, nil
}

func expandVmwareenginePrivateCloudManagementClusterClusterId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedNodeCount, err := expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigsNodeCount(original["node_count"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["nodeCount"] = transformedNodeCount
		}

		transformedCustomCoreCount, err := expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigsCustomCoreCount(original["custom_core_count"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCustomCoreCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["customCoreCount"] = transformedCustomCoreCount
		}

		transformedNodeTypeId, err := tpgresource.ExpandString(original["node_type_id"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedNodeTypeId] = transformed
	}
	return m, nil
}

func expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigsNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigsCustomCoreCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterStretchedClusterConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPreferredLocation, err := expandVmwareenginePrivateCloudManagementClusterStretchedClusterConfigPreferredLocation(original["preferred_location"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPreferredLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["preferredLocation"] = transformedPreferredLocation
	}

	transformedSecondaryLocation, err := expandVmwareenginePrivateCloudManagementClusterStretchedClusterConfigSecondaryLocation(original["secondary_location"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecondaryLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secondaryLocation"] = transformedSecondaryLocation
	}

	return transformed, nil
}

func expandVmwareenginePrivateCloudManagementClusterStretchedClusterConfigPreferredLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterStretchedClusterConfigSecondaryLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAutoscalingPolicies, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicies(original["autoscaling_policies"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAutoscalingPolicies); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["autoscalingPolicies"] = transformedAutoscalingPolicies
	}

	transformedMinClusterNodeCount, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsMinClusterNodeCount(original["min_cluster_node_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinClusterNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minClusterNodeCount"] = transformedMinClusterNodeCount
	}

	transformedMaxClusterNodeCount, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsMaxClusterNodeCount(original["max_cluster_node_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxClusterNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxClusterNodeCount"] = transformedMaxClusterNodeCount
	}

	transformedCoolDownPeriod, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsCoolDownPeriod(original["cool_down_period"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCoolDownPeriod); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["coolDownPeriod"] = transformedCoolDownPeriod
	}

	return transformed, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicies(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedNodeTypeId, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesNodeTypeId(original["node_type_id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNodeTypeId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["nodeTypeId"] = transformedNodeTypeId
		}

		transformedScaleOutSize, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesScaleOutSize(original["scale_out_size"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedScaleOutSize); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["scaleOutSize"] = transformedScaleOutSize
		}

		transformedCpuThresholds, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholds(original["cpu_thresholds"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCpuThresholds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["cpuThresholds"] = transformedCpuThresholds
		}

		transformedConsumedMemoryThresholds, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholds(original["consumed_memory_thresholds"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedConsumedMemoryThresholds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["consumedMemoryThresholds"] = transformedConsumedMemoryThresholds
		}

		transformedStorageThresholds, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholds(original["storage_thresholds"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStorageThresholds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["storageThresholds"] = transformedStorageThresholds
		}

		transformedAutoscalePolicyId, err := tpgresource.ExpandString(original["autoscale_policy_id"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedAutoscalePolicyId] = transformed
	}
	return m, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesNodeTypeId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesScaleOutSize(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedScaleOut, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholdsScaleOut(original["scale_out"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScaleOut); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scaleOut"] = transformedScaleOut
	}

	transformedScaleIn, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholdsScaleIn(original["scale_in"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScaleIn); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scaleIn"] = transformedScaleIn
	}

	return transformed, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholdsScaleOut(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesCpuThresholdsScaleIn(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedScaleOut, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholdsScaleOut(original["scale_out"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScaleOut); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scaleOut"] = transformedScaleOut
	}

	transformedScaleIn, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholdsScaleIn(original["scale_in"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScaleIn); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scaleIn"] = transformedScaleIn
	}

	return transformed, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholdsScaleOut(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesConsumedMemoryThresholdsScaleIn(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedScaleOut, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholdsScaleOut(original["scale_out"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScaleOut); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scaleOut"] = transformedScaleOut
	}

	transformedScaleIn, err := expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholdsScaleIn(original["scale_in"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScaleIn); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scaleIn"] = transformedScaleIn
	}

	return transformed, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholdsScaleOut(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsAutoscalingPoliciesStorageThresholdsScaleIn(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsMinClusterNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsMaxClusterNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterAutoscalingSettingsCoolDownPeriod(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceVmwareenginePrivateCloudUpdateEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	delete(obj, "managementCluster")
	return obj, nil
}

func resourceVmwareenginePrivateCloudDecoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
	config := meta.(*transport_tpg.Config)

	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return nil, err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}/clusters")
	if err != nil {
		return nil, err
	}

	url, err = transport_tpg.AddQueryParams(url, map[string]string{"filter": "management=true"})
	if err != nil {
		return nil, err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return nil, fmt.Errorf("Error fetching project for Instance: %s", err)
	}

	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	clusterResponse, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})

	if err != nil {
		return nil, fmt.Errorf("Error reading management cluster of PrivateCloud: %s", err)
	}

	// There can only be 1 management cluster and if the PC read is successfully and
	// we got response from cluster API then it should be present.
	mgmtClusterObj := clusterResponse["clusters"].([]interface{})[0].(map[string]interface{})
	clusterName := mgmtClusterObj["name"].(string)
	// get clusterId from the full name, clusterName is "projects/project/locations/location/privateClouds/pc/clusters/cls"
	// then clusterId will be "cls"
	mgmtClusterObj["clusterId"] = clusterName[strings.LastIndex(clusterName, "/")+1:]

	res["managementCluster"] = mgmtClusterObj

	return res, nil
}
