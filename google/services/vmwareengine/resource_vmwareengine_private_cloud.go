// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package vmwareengine

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceVmwareenginePrivateCloud() *schema.Resource {
	return &schema.Resource{
		Create: resourceVmwareenginePrivateCloudCreate,
		Read:   resourceVmwareenginePrivateCloudRead,
		Update: resourceVmwareenginePrivateCloudUpdate,
		Delete: resourceVmwareenginePrivateCloudDelete,

		Importer: &schema.ResourceImporter{
			State: resourceVmwareenginePrivateCloudImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(240 * time.Minute),
			Update: schema.DefaultTimeout(190 * time.Minute),
			Delete: schema.DefaultTimeout(150 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location where the PrivateCloud should reside.`,
			},
			"management_cluster": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `The management cluster for this private cloud. This used for creating and managing the default cluster.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cluster_id": {
							Type:     schema.TypeString,
							Required: true,
							Description: `The user-provided identifier of the new Cluster. The identifier must meet the following requirements:
  * Only contains 1-63 alphanumeric characters and hyphens
  * Begins with an alphabetical character
  * Ends with a non-hyphen character
  * Not formatted as a UUID
  * Complies with RFC 1034 (https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)`,
						},
						"node_type_configs": {
							Type:     schema.TypeSet,
							Optional: true,
							Description: `The map of cluster node types in this cluster,
where the key is canonical identifier of the node type (corresponds to the NodeType).`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"node_type_id": {
										Type:     schema.TypeString,
										Required: true,
									},
									"node_count": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: `The number of nodes of this type in the cluster.`,
									},
									"custom_core_count": {
										Type:     schema.TypeInt,
										Optional: true,
										Description: `Customized number of cores available to each node of the type.
This number must always be one of 'nodeType.availableCustomCoreCounts'.
If zero is provided max value from 'nodeType.availableCustomCoreCounts' will be used.
This cannot be changed once the PrivateCloud is created.`,
										Default: 0,
									},
								},
							},
						},
					},
				},
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The ID of the PrivateCloud.`,
			},
			"network_config": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `Network configuration in the consumer project with which the peering has to be done.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"management_cidr": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Management CIDR used by VMware management appliances.`,
						},
						"vmware_engine_network": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The relative resource name of the VMware Engine network attached to the private cloud.
Specify the name in the following form: projects/{project}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
where {project} can either be a project number or a project ID.`,
						},
						"dns_server_ip": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `DNS Server IP of the Private Cloud.`,
						},
						"management_ip_address_layout_version": {
							Type:     schema.TypeInt,
							Computed: true,
							Description: `The IP address layout version of the management IP address range.
Possible versions include:
* managementIpAddressLayoutVersion=1: Indicates the legacy IP address layout used by some existing private clouds. This is no longer supported for new private clouds
as it does not support all features.
* managementIpAddressLayoutVersion=2: Indicates the latest IP address layout
used by all newly created private clouds. This version supports all current features.`,
						},
						"vmware_engine_network_canonical": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The canonical name of the VMware Engine network in
the form: projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}`,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `User-provided description for this private cloud.`,
			},
			"hcx": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Details about a HCX Cloud Manager appliance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"fqdn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Fully qualified domain name of the appliance.`,
						},
						"internal_ip": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Internal IP address of the appliance.`,
						},
						"state": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"ACTIVE", "CREATING", ""}),
							Description:  `State of the appliance. Possible values: ["ACTIVE", "CREATING"]`,
						},
						"version": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Version of the appliance.`,
						},
					},
				},
			},
			"nsx": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Details about a NSX Manager appliance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"fqdn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Fully qualified domain name of the appliance.`,
						},
						"internal_ip": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Internal IP address of the appliance.`,
						},
						"state": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"ACTIVE", "CREATING", ""}),
							Description:  `State of the appliance. Possible values: ["ACTIVE", "CREATING"]`,
						},
						"version": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Version of the appliance.`,
						},
					},
				},
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `State of the resource. New values may be added to this enum when appropriate.`,
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `System-generated unique identifier for the resource.`,
			},
			"vcenter": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Details about a vCenter Server management appliance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"fqdn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Fully qualified domain name of the appliance.`,
						},
						"internal_ip": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Internal IP address of the appliance.`,
						},
						"state": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"ACTIVE", "CREATING", ""}),
							Description:  `State of the appliance. Possible values: ["ACTIVE", "CREATING"]`,
						},
						"version": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Version of the appliance.`,
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceVmwareenginePrivateCloudCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandVmwareenginePrivateCloudDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	networkConfigProp, err := expandVmwareenginePrivateCloudNetworkConfig(d.Get("network_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(networkConfigProp)) && (ok || !reflect.DeepEqual(v, networkConfigProp)) {
		obj["networkConfig"] = networkConfigProp
	}
	managementClusterProp, err := expandVmwareenginePrivateCloudManagementCluster(d.Get("management_cluster"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("management_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(managementClusterProp)) && (ok || !reflect.DeepEqual(v, managementClusterProp)) {
		obj["managementCluster"] = managementClusterProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds?privateCloudId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new PrivateCloud: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PrivateCloud: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:               config,
		Method:               "POST",
		Project:              billingProject,
		RawURL:               url,
		UserAgent:            userAgent,
		Body:                 obj,
		Timeout:              d.Timeout(schema.TimeoutCreate),
		ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{transport_tpg.Is429QuotaError},
	})
	if err != nil {
		return fmt.Errorf("Error creating PrivateCloud: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = VmwareengineOperationWaitTime(
		config, res, project, "Creating PrivateCloud", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create PrivateCloud: %s", err)
	}

	log.Printf("[DEBUG] Finished creating PrivateCloud %q: %#v", d.Id(), res)

	return resourceVmwareenginePrivateCloudRead(d, meta)
}

func resourceVmwareenginePrivateCloudRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PrivateCloud: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:               config,
		Method:               "GET",
		Project:              billingProject,
		RawURL:               url,
		UserAgent:            userAgent,
		ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{transport_tpg.Is429QuotaError},
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("VmwareenginePrivateCloud %q", d.Id()))
	}

	res, err = resourceVmwareenginePrivateCloudDecoder(d, meta, res)
	if err != nil {
		return err
	}

	if res == nil {
		// Decoding the object has resulted in it being gone. It may be marked deleted
		log.Printf("[DEBUG] Removing VmwareenginePrivateCloud because it no longer exists.")
		d.SetId("")
		return nil
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}

	if err := d.Set("description", flattenVmwareenginePrivateCloudDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("uid", flattenVmwareenginePrivateCloudUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("state", flattenVmwareenginePrivateCloudState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("network_config", flattenVmwareenginePrivateCloudNetworkConfig(res["networkConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("management_cluster", flattenVmwareenginePrivateCloudManagementCluster(res["managementCluster"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("hcx", flattenVmwareenginePrivateCloudHcx(res["hcx"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("nsx", flattenVmwareenginePrivateCloudNsx(res["nsx"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}
	if err := d.Set("vcenter", flattenVmwareenginePrivateCloudVcenter(res["vcenter"], d, config)); err != nil {
		return fmt.Errorf("Error reading PrivateCloud: %s", err)
	}

	return nil
}

func resourceVmwareenginePrivateCloudUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PrivateCloud: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandVmwareenginePrivateCloudDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	managementClusterProp, err := expandVmwareenginePrivateCloudManagementCluster(d.Get("management_cluster"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("management_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, managementClusterProp)) {
		obj["managementCluster"] = managementClusterProp
	}

	obj, err = resourceVmwareenginePrivateCloudUpdateEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating PrivateCloud %q: %#v", d.Id(), obj)

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:               config,
		Method:               "PATCH",
		Project:              billingProject,
		RawURL:               url,
		UserAgent:            userAgent,
		Body:                 obj,
		Timeout:              d.Timeout(schema.TimeoutUpdate),
		ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{transport_tpg.Is429QuotaError},
	})

	if err != nil {
		return fmt.Errorf("Error updating PrivateCloud %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating PrivateCloud %q: %#v", d.Id(), res)
	}

	err = VmwareengineOperationWaitTime(
		config, res, project, "Updating PrivateCloud", userAgent,
		d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return err
	}

	mgmtClusterProp, err := expandVmwareenginePrivateCloudManagementCluster(d.Get("management_cluster"), d, config)
	if v, ok := d.GetOkExists("management_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, mgmtClusterProp)) {
		obj["managementCluster"] = mgmtClusterProp
	}

	mgmtMap := mgmtClusterProp.(map[string]interface{})
	parentUrl, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return err
	}

	clusterUrl := fmt.Sprintf("%s/clusters/%s", parentUrl, mgmtMap["clusterId"])
	clusterUpdateMask := []string{}
	clusterObj := make(map[string]interface{})

	if v, ok := d.GetOkExists("management_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(mgmtClusterProp)) && (ok || !reflect.DeepEqual(v, mgmtClusterProp)) {
		clusterObj["nodeTypeConfigs"] = mgmtMap["nodeTypeConfigs"]
	}

	if d.HasChange("management_cluster") {
		clusterUpdateMask = append(clusterUpdateMask, "nodeTypeConfigs.*.nodeCount")
	}

	clusterPatchUrl, err := transport_tpg.AddQueryParams(clusterUrl, map[string]string{"updateMask": strings.Join(clusterUpdateMask, ",")})
	if err != nil {
		return err
	}

	// check if there is anything to update to avoid API call if not required.
	if len(clusterUpdateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    clusterPatchUrl,
			UserAgent: userAgent,
			Body:      clusterObj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
		})

		if err != nil {
			return fmt.Errorf("Error updating magament cluster %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating magament cluster %q: %#v", d.Id(), res)
		}

		err = VmwareengineOperationWaitTime(
			config, res, project, "Updating Managment Cluster", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}
	return resourceVmwareenginePrivateCloudRead(d, meta)
}

func resourceVmwareenginePrivateCloudDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PrivateCloud: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}?delay_hours=0")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting PrivateCloud %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:               config,
		Method:               "DELETE",
		Project:              billingProject,
		RawURL:               url,
		UserAgent:            userAgent,
		Body:                 obj,
		Timeout:              d.Timeout(schema.TimeoutDelete),
		ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{transport_tpg.Is429QuotaError},
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "PrivateCloud")
	}

	err = VmwareengineOperationWaitTime(
		config, res, project, "Deleting PrivateCloud", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}
	privateCloudPollRead := func(d *schema.ResourceData, meta interface{}) transport_tpg.PollReadFunc {
		return func() (map[string]interface{}, error) {
			config := meta.(*transport_tpg.Config)
			url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
			if err != nil {
				return nil, err
			}
			billingProject := ""
			project, err := tpgresource.GetProject(d, config)
			if err != nil {
				return nil, fmt.Errorf("Error fetching project for PrivateCloud: %s", err)
			}
			billingProject = project
			// err == nil indicates that the billing_project value was found
			if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
				billingProject = bp
			}
			userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
			if err != nil {
				return nil, err
			}
			res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
				Config:    config,
				Method:    "GET",
				Project:   billingProject,
				RawURL:    url,
				UserAgent: userAgent,
			})
			if err != nil {
				return res, err
			}
			return res, nil
		}
	}

	err = transport_tpg.PollingWaitTime(privateCloudPollRead(d, meta), transport_tpg.PollCheckForAbsence, "Deleting PrivateCloud", d.Timeout(schema.TimeoutDelete), 10)
	if err != nil {
		return fmt.Errorf("Error waiting to delete PrivateCloud: %s", err)
	}

	log.Printf("[DEBUG] Finished deleting PrivateCloud %q: %#v", d.Id(), res)
	return nil
}

func resourceVmwareenginePrivateCloudImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/privateClouds/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/privateClouds/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenVmwareenginePrivateCloudDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNetworkConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["management_cidr"] =
		flattenVmwareenginePrivateCloudNetworkConfigManagementCidr(original["managementCidr"], d, config)
	transformed["vmware_engine_network"] =
		flattenVmwareenginePrivateCloudNetworkConfigVmwareEngineNetwork(original["vmwareEngineNetwork"], d, config)
	transformed["vmware_engine_network_canonical"] =
		flattenVmwareenginePrivateCloudNetworkConfigVmwareEngineNetworkCanonical(original["vmwareEngineNetworkCanonical"], d, config)
	transformed["management_ip_address_layout_version"] =
		flattenVmwareenginePrivateCloudNetworkConfigManagementIpAddressLayoutVersion(original["managementIpAddressLayoutVersion"], d, config)
	transformed["dns_server_ip"] =
		flattenVmwareenginePrivateCloudNetworkConfigDnsServerIp(original["dnsServerIp"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudNetworkConfigManagementCidr(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNetworkConfigVmwareEngineNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNetworkConfigVmwareEngineNetworkCanonical(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNetworkConfigManagementIpAddressLayoutVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudNetworkConfigDnsServerIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudManagementCluster(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cluster_id"] =
		flattenVmwareenginePrivateCloudManagementClusterClusterId(original["clusterId"], d, config)
	transformed["node_type_configs"] =
		flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigs(original["nodeTypeConfigs"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudManagementClusterClusterId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"node_type_id":      k,
			"node_count":        flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigsNodeCount(original["nodeCount"], d, config),
			"custom_core_count": flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigsCustomCoreCount(original["customCoreCount"], d, config),
		})
	}
	return transformed
}
func flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigsNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudManagementClusterNodeTypeConfigsCustomCoreCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenVmwareenginePrivateCloudHcx(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["internal_ip"] =
		flattenVmwareenginePrivateCloudHcxInternalIp(original["internalIp"], d, config)
	transformed["version"] =
		flattenVmwareenginePrivateCloudHcxVersion(original["version"], d, config)
	transformed["state"] =
		flattenVmwareenginePrivateCloudHcxState(original["state"], d, config)
	transformed["fqdn"] =
		flattenVmwareenginePrivateCloudHcxFqdn(original["fqdn"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudHcxInternalIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudHcxVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudHcxState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudHcxFqdn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNsx(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["internal_ip"] =
		flattenVmwareenginePrivateCloudNsxInternalIp(original["internalIp"], d, config)
	transformed["version"] =
		flattenVmwareenginePrivateCloudNsxVersion(original["version"], d, config)
	transformed["state"] =
		flattenVmwareenginePrivateCloudNsxState(original["state"], d, config)
	transformed["fqdn"] =
		flattenVmwareenginePrivateCloudNsxFqdn(original["fqdn"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudNsxInternalIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNsxVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNsxState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudNsxFqdn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudVcenter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["internal_ip"] =
		flattenVmwareenginePrivateCloudVcenterInternalIp(original["internalIp"], d, config)
	transformed["version"] =
		flattenVmwareenginePrivateCloudVcenterVersion(original["version"], d, config)
	transformed["state"] =
		flattenVmwareenginePrivateCloudVcenterState(original["state"], d, config)
	transformed["fqdn"] =
		flattenVmwareenginePrivateCloudVcenterFqdn(original["fqdn"], d, config)
	return []interface{}{transformed}
}
func flattenVmwareenginePrivateCloudVcenterInternalIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudVcenterVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudVcenterState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVmwareenginePrivateCloudVcenterFqdn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandVmwareenginePrivateCloudDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudNetworkConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedManagementCidr, err := expandVmwareenginePrivateCloudNetworkConfigManagementCidr(original["management_cidr"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedManagementCidr); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["managementCidr"] = transformedManagementCidr
	}

	transformedVmwareEngineNetwork, err := expandVmwareenginePrivateCloudNetworkConfigVmwareEngineNetwork(original["vmware_engine_network"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVmwareEngineNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vmwareEngineNetwork"] = transformedVmwareEngineNetwork
	}

	transformedVmwareEngineNetworkCanonical, err := expandVmwareenginePrivateCloudNetworkConfigVmwareEngineNetworkCanonical(original["vmware_engine_network_canonical"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVmwareEngineNetworkCanonical); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vmwareEngineNetworkCanonical"] = transformedVmwareEngineNetworkCanonical
	}

	transformedManagementIpAddressLayoutVersion, err := expandVmwareenginePrivateCloudNetworkConfigManagementIpAddressLayoutVersion(original["management_ip_address_layout_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedManagementIpAddressLayoutVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["managementIpAddressLayoutVersion"] = transformedManagementIpAddressLayoutVersion
	}

	transformedDnsServerIp, err := expandVmwareenginePrivateCloudNetworkConfigDnsServerIp(original["dns_server_ip"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDnsServerIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dnsServerIp"] = transformedDnsServerIp
	}

	return transformed, nil
}

func expandVmwareenginePrivateCloudNetworkConfigManagementCidr(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudNetworkConfigVmwareEngineNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudNetworkConfigVmwareEngineNetworkCanonical(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudNetworkConfigManagementIpAddressLayoutVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudNetworkConfigDnsServerIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementCluster(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedClusterId, err := expandVmwareenginePrivateCloudManagementClusterClusterId(original["cluster_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClusterId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clusterId"] = transformedClusterId
	}

	transformedNodeTypeConfigs, err := expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigs(original["node_type_configs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNodeTypeConfigs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nodeTypeConfigs"] = transformedNodeTypeConfigs
	}

	return transformed, nil
}

func expandVmwareenginePrivateCloudManagementClusterClusterId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedNodeCount, err := expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigsNodeCount(original["node_count"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["nodeCount"] = transformedNodeCount
		}

		transformedCustomCoreCount, err := expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigsCustomCoreCount(original["custom_core_count"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCustomCoreCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["customCoreCount"] = transformedCustomCoreCount
		}

		transformedNodeTypeId, err := tpgresource.ExpandString(original["node_type_id"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedNodeTypeId] = transformed
	}
	return m, nil
}

func expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigsNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVmwareenginePrivateCloudManagementClusterNodeTypeConfigsCustomCoreCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceVmwareenginePrivateCloudUpdateEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	delete(obj, "managementCluster")
	return obj, nil
}

func resourceVmwareenginePrivateCloudDecoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
	config := meta.(*transport_tpg.Config)

	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return nil, err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VmwareengineBasePath}}projects/{{project}}/locations/{{location}}/privateClouds/{{name}}/clusters")
	if err != nil {
		return nil, err
	}

	url, err = transport_tpg.AddQueryParams(url, map[string]string{"filter": "management=true"})
	if err != nil {
		return nil, err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return nil, fmt.Errorf("Error fetching project for Instance: %s", err)
	}

	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	clusterResponse, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})

	if err != nil {
		return nil, fmt.Errorf("Error reading management cluster of PrivateCloud: %s", err)
	}

	// There can only be 1 management cluster and if the PC read is successfuly and
	// we got response from cluster API then it should be present.
	mgmtClusterObj := clusterResponse["clusters"].([]interface{})[0].(map[string]interface{})
	clusterName := mgmtClusterObj["name"].(string)
	// get clusterId from the full name, clusterName is "projects/project/locations/location/privateClouds/pc/clusters/cls"
	// then clusterId will be "cls"
	mgmtClusterObj["clusterId"] = clusterName[strings.LastIndex(clusterName, "/")+1:]

	res["managementCluster"] = mgmtClusterObj

	return res, nil
}
