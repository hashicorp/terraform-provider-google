// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/accesscontextmanager/data_source_access_context_manager_supported_services.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package accesscontextmanager

import (
	"fmt"
	"net/http"
	"net/url"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func DataSourceAccessContextManagerSupportedServices() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceAccessContextManagerSupportedServicesRead,
		Schema: map[string]*schema.Schema{
			"supported_services": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "The list of VPC-SC supported services.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The service name or address of the supported service, such as `storage.googleapis.com`.",
						},
						"title": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The name of the supported product, such as 'Cloud Storage'.",
						},
						"support_stage": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The support stage of the service.",
						},
						"available_on_restricted_vip": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: "True if the service is available on the restricted VIP. Services on the restricted VIP typically either support VPC Service Controls or are core infrastructure services required for the functioning of Google Cloud.",
						},
						"known_limitations": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: "True if the service is supported with some limitations. Check documentation for details.",
						},
						"service_support_stage": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The support stage of the service. Values are `GA`, `PREVIEW`, and `DEPRECATED`.",
						},
					},
				},
			},
		},
	}
}

func dataSourceAccessContextManagerSupportedServicesRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	urlRequest := config.AccessContextManagerBasePath + "services"

	headers := make(http.Header)
	supportedServices := make([]map[string]interface{}, 0)
	pageToken := ""

	for {
		u, err := url.Parse(urlRequest)
		if err != nil {
			return fmt.Errorf("error parsing URL: %s", err)
		}

		q := u.Query()
		if pageToken != "" {
			q.Set("pageToken", pageToken)
		}
		u.RawQuery = q.Encode()

		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "GET",
			RawURL:    u.String(),
			UserAgent: userAgent,
			Headers:   headers,
		})
		if err != nil {
			return fmt.Errorf("error listing Access Context Manager supported services: %s", err)
		}

		if items, ok := res["supportedServices"].([]interface{}); ok {
			for _, item := range items {
				service, ok := item.(map[string]interface{})
				if !ok {
					continue
				}

				getString := func(m map[string]interface{}, key string) string {
					if v, ok := m[key].(string); ok {
						return v
					}
					return ""
				}

				getBool := func(m map[string]interface{}, key string) bool {
					if v, ok := m[key].(bool); ok {
						return v
					}
					return false
				}

				supportedServices = append(supportedServices, map[string]interface{}{
					"name":                        getString(service, "name"),
					"title":                       getString(service, "title"),
					"support_stage":               getString(service, "supportStage"),
					"available_on_restricted_vip": getBool(service, "availableOnRestrictedVip"),
					"known_limitations":           getBool(service, "knownLimitations"),
					"service_support_stage":       getString(service, "serviceSupportStage"),
				})
			}
		}

		if nextToken, ok := res["nextPageToken"].(string); ok && nextToken != "" {
			pageToken = nextToken
		} else {
			break
		}
	}

	if err := d.Set("supported_services", supportedServices); err != nil {
		return fmt.Errorf("error setting supported services: %s", err)
	}

	d.SetId("accessContextManager/supportedServices")

	return nil
}
