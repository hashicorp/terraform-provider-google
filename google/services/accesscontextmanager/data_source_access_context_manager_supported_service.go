// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/accesscontextmanager/data_source_access_context_manager_supported_service.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package accesscontextmanager

import (
	"fmt"
	"net/http"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func DataSourceAccessContextManagerSupportedService() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceAccessContextManagerSupportedServiceRead,
		Schema: map[string]*schema.Schema{
			"service_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The name of the service to get information about. The names must be in the same format as used in defining a service perimeter, for example, `storage.googleapis.com`.",
			},
			"title": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The name of the supported product, such as 'Cloud Storage'.",
			},
			"support_stage": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The support stage of the service.",
			},
			"available_on_restricted_vip": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "True if the service is available on the restricted VIP. Services on the restricted VIP typically either support VPC Service Controls or are core infrastructure services required for the functioning of Google Cloud.",
			},
			"known_limitations": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "True if the service is supported with some limitations. Check documentation for details.",
			},
			"service_support_stage": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The support stage of the service. Values are `GA`, `PREVIEW`, and `DEPRECATED`.",
			},
			"supported_methods": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "The list of supported methods for this service.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"method": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "A valid method name for the respective request mode. Must be a fully qualified name, for example, `storage.googleapis.com/BucketService.GetBucket`.",
						},
						"permission": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "A valid Cloud IAM permission for the respective request mode, for example, `storage.buckets.get`.",
						},
					},
				},
			},
		},
	}
}

func dataSourceAccessContextManagerSupportedServiceRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	serviceName := d.Get("service_name").(string)
	urlRequest := fmt.Sprintf("%sservices/%s", config.AccessContextManagerBasePath, serviceName)

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		RawURL:    urlRequest,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("error reading Access Context Manager supported service %q: %s", serviceName, err)
	}

	getString := func(m map[string]interface{}, key string) string {
		if v, ok := m[key].(string); ok {
			return v
		}
		return ""
	}

	getBool := func(m map[string]interface{}, key string) bool {
		if v, ok := m[key].(bool); ok {
			return v
		}
		return false
	}

	if err := d.Set("title", getString(res, "title")); err != nil {
		return fmt.Errorf("error setting title: %s", err)
	}
	if err := d.Set("support_stage", getString(res, "supportStage")); err != nil {
		return fmt.Errorf("error setting support_stage: %s", err)
	}
	if err := d.Set("available_on_restricted_vip", getBool(res, "availableOnRestrictedVip")); err != nil {
		return fmt.Errorf("error setting available_on_restricted_vip: %s", err)
	}
	if err := d.Set("known_limitations", getBool(res, "knownLimitations")); err != nil {
		return fmt.Errorf("error setting known_limitations: %s", err)
	}
	if err := d.Set("service_support_stage", getString(res, "serviceSupportStage")); err != nil {
		return fmt.Errorf("error setting service_support_stage: %s", err)
	}

	supportedMethods := make([]map[string]interface{}, 0)
	if rawMethods, ok := res["supportedMethods"].([]interface{}); ok {
		for _, item := range rawMethods {
			method, ok := item.(map[string]interface{})
			if !ok {
				continue
			}
			supportedMethods = append(supportedMethods, map[string]interface{}{
				"method":     getString(method, "method"),
				"permission": getString(method, "permission"),
			})
		}
	}

	if err := d.Set("supported_methods", supportedMethods); err != nil {
		return fmt.Errorf("error setting supported_methods: %s", err)
	}

	d.SetId(fmt.Sprintf("accessContextManager/services/%s", serviceName))

	return nil
}
