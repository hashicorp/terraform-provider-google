// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/gkeonprem/VmwareAdminCluster.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package gkeonprem

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceGkeonpremVmwareAdminCluster() *schema.Resource {
	return &schema.Resource{
		Create: resourceGkeonpremVmwareAdminClusterCreate,
		Read:   resourceGkeonpremVmwareAdminClusterRead,
		Update: resourceGkeonpremVmwareAdminClusterUpdate,
		Delete: resourceGkeonpremVmwareAdminClusterDelete,

		Importer: &schema.ResourceImporter{
			State: resourceGkeonpremVmwareAdminClusterImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(60 * time.Minute),
			Update: schema.DefaultTimeout(60 * time.Minute),
			Delete: schema.DefaultTimeout(60 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the resource.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The VMware admin cluster resource name.`,
			},
			"network_config": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `The VMware admin cluster network configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"pod_address_cidr_blocks": {
							Type:     schema.TypeList,
							Required: true,
							Description: `All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
Only a single range is supported. This field cannot be changed after creation.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"service_address_cidr_blocks": {
							Type:     schema.TypeList,
							Required: true,
							Description: `All services in the cluster are assigned an RFC1918 IPv4 address
from these ranges. Only a single range is supported.. This field
cannot be changed after creation.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"dhcp_ip_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Configuration settings for a DHCP IP configuration.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enabled": {
										Type:     schema.TypeBool,
										Required: true,
										Description: `enabled is a flag to mark if DHCP IP allocation is
used for VMware admin clusters.`,
									},
								},
							},
							ExactlyOneOf: []string{"network_config.0.dhcp_ip_config", "network_config.0.static_ip_config"},
						},
						"ha_control_plane_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for HA admin cluster control plane.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"control_plane_ip_block": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Static IP addresses for the control plane nodes.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"gateway": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The network gateway used by the VMware Admin Cluster.`,
												},
												"ips": {
													Type:        schema.TypeList,
													Required:    true,
													Description: `The node's network configurations used by the VMware Admin Cluster.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"ip": {
																Type:        schema.TypeString,
																Required:    true,
																Description: `IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).`,
															},
															"hostname": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																Description: `Hostname of the machine. VM's name will be used if this field is empty.`,
															},
														},
													},
												},
												"netmask": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The netmask used by the VMware Admin Cluster.`,
												},
											},
										},
									},
								},
							},
						},
						"host_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Represents common network settings irrespective of the host's IP address.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"dns_search_domains": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `DNS search domains.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"dns_servers": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `DNS servers.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"ntp_servers": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `NTP servers.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"static_ip_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration settings for a static IP configuration.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ip_blocks": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Represents the configuration values for static IP allocation to nodes.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"gateway": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The network gateway used by the VMware Admin Cluster.`,
												},
												"ips": {
													Type:        schema.TypeList,
													Required:    true,
													Description: `The node's network configurations used by the VMware Admin Cluster.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"ip": {
																Type:        schema.TypeString,
																Required:    true,
																Description: `IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).`,
															},
															"hostname": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																Description: `Hostname of the machine. VM's name will be used if this field is empty.`,
															},
														},
													},
												},
												"netmask": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The netmask used by the VMware Admin Cluster.`,
												},
											},
										},
									},
								},
							},
							ExactlyOneOf: []string{"network_config.0.dhcp_ip_config", "network_config.0.static_ip_config"},
						},
						"vcenter_network": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `vcenter_network specifies vCenter network name.`,
						},
					},
				},
			},
			"addon_node": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `The VMware admin cluster addon node configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auto_resize_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Specifies auto resize config.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enabled": {
										Type:        schema.TypeBool,
										Required:    true,
										Description: `Whether to enable controle plane node auto resizing.`,
									},
								},
							},
						},
					},
				},
			},
			"annotations": {
				Type:     schema.TypeMap,
				Computed: true,
				Optional: true,
				Description: `Annotations on the VMware Admin Cluster.
This field has the same restrictions as Kubernetes annotations.
The total size of all keys and values combined is limited to 256k.
Key can have 2 segments: prefix (optional) and name (required),
separated by a slash (/).
Prefix must be a DNS subdomain.
Name must be 63 characters or less, begin and end with alphanumerics,
with dashes (-), underscores (_), dots (.), and alphanumerics between.


**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"anti_affinity_groups": {
				Type:     schema.TypeList,
				Computed: true,
				Optional: true,
				Description: `AAGConfig specifies whether to spread VMware Admin Cluster nodes across at
least three physical hosts in the datacenter.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"aag_config_disabled": {
							Type:     schema.TypeBool,
							Required: true,
							Description: `Spread nodes across at least three physical hosts (requires at least three
hosts).
Enabled by default.`,
						},
					},
				},
			},
			"authorization": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The VMware admin cluster authorization configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"viewer_users": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Users that will be granted the cluster-admin role on the cluster, providing
full access to the cluster.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"username": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The name of the user, e.g. 'my-gcp-id@gmail.com'.`,
									},
								},
							},
						},
					},
				},
			},
			"auto_repair_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Configuration for auto repairing.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enabled": {
							Type:        schema.TypeBool,
							Required:    true,
							Description: `Whether auto repair is enabled.`,
						},
					},
				},
			},
			"bootstrap_cluster_membership": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				Description: `The bootstrap cluster this VMware admin cluster belongs to.`,
			},
			"control_plane_node": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The VMware admin cluster control plane node configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cpus": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `The number of vCPUs for the control-plane node of the admin cluster.`,
							Default:     4,
						},
						"memory": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `The number of mebibytes of memory for the control-plane node of the admin cluster.`,
							Default:     8192,
						},
						"replicas": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `The number of control plane nodes for this VMware admin cluster.`,
							Default:     1,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				Description: `A human readable description of this VMware admin cluster.`,
			},
			"enable_advanced_cluster": {
				Type:        schema.TypeBool,
				Computed:    true,
				Optional:    true,
				Description: `If set, the advanced cluster feature is enabled.`,
			},
			"image_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				Description: `The OS image type for the VMware admin cluster.`,
			},
			"load_balancer": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Specifies the load balancer configuration for VMware admin cluster.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"vip_config": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Specified the VMware Load Balancer Config`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"control_plane_vip": {
										Type:     schema.TypeString,
										Required: true,
										Description: `The VIP which you previously set aside for the Kubernetes
API of this VMware Admin Cluster.`,
									},
									"addons_vip": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The VIP to configure the load balancer for add-ons.`,
									},
								},
							},
						},
						"f5_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for F5 Big IP typed load balancers.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The load balancer's IP address.`,
									},
									"partition": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `he preexisting partition to be used by the load balancer. T
his partition is usually created for the admin cluster for example:
'my-f5-admin-partition'.`,
									},
									"snat_pool": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The pool name. Only necessary, if using SNAT.`,
									},
								},
							},
							ExactlyOneOf: []string{"load_balancer.0.f5_config", "load_balancer.0.manual_lb_config", "load_balancer.0.metal_lb_config"},
						},
						"manual_lb_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Manually configured load balancers.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"addons_node_port": {
										Type:        schema.TypeInt,
										Computed:    true,
										Optional:    true,
										Description: `NodePort for add-ons server in the admin cluster.`,
									},
									"control_plane_node_port": {
										Type:     schema.TypeInt,
										Computed: true,
										Optional: true,
										Description: `NodePort for control plane service. The Kubernetes API server in the admin
cluster is implemented as a Service of type NodePort (ex. 30968).`,
									},
									"ingress_http_node_port": {
										Type:     schema.TypeInt,
										Computed: true,
										Optional: true,
										Description: `NodePort for ingress service's http. The ingress service in the admin
cluster is implemented as a Service of type NodePort (ex. 32527).`,
									},
									"ingress_https_node_port": {
										Type:     schema.TypeInt,
										Computed: true,
										Optional: true,
										Description: `NodePort for ingress service's https. The ingress service in the admin
cluster is implemented as a Service of type NodePort (ex. 30139).`,
									},
									"konnectivity_server_node_port": {
										Type:     schema.TypeInt,
										Computed: true,
										Optional: true,
										Description: `NodePort for konnectivity server service running as a sidecar in each
kube-apiserver pod (ex. 30564).`,
									},
								},
							},
							ExactlyOneOf: []string{"load_balancer.0.f5_config", "load_balancer.0.manual_lb_config", "load_balancer.0.metal_lb_config"},
						},
						"metal_lb_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Metal LB load balancers.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enabled": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Metal LB is enabled.`,
									},
								},
							},
							ExactlyOneOf: []string{"load_balancer.0.f5_config", "load_balancer.0.manual_lb_config", "load_balancer.0.metal_lb_config"},
						},
					},
				},
			},
			"on_prem_version": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The Anthos clusters on the VMware version for the admin cluster.`,
			},
			"platform_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The VMware platform configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"required_platform_version": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The required platform version e.g. 1.13.1.
If the current platform version is lower than the target version,
the platform version will be updated to the target version.
If the target version is not installed in the platform
(bundle versions), download the target version bundle.`,
						},
						"bundles": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The list of bundles installed in the admin cluster.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"status": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `ResourceStatus representing detailed cluster state.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"conditions": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"last_transition_time": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Last time the condition transit from one status to another.`,
															},
															"message": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Human-readable message indicating details about last transition.`,
															},
															"reason": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Machine-readable message indicating details about last transition.`,
															},
															"state": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The lifecycle state of the condition.`,
															},
															"type": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Type of the condition.
(e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)`,
															},
														},
													},
												},
												"error_message": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `Human-friendly representation of the error message from the admin cluster
controller. The error message can be temporary as the admin cluster
controller creates a cluster or node pool. If the error message persists
for a longer period of time, it can be used to surface error message to
indicate real problems requiring user intervention.`,
												},
											},
										},
									},
									"version": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The version of the bundle.`,
									},
								},
							},
						},
						"platform_version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The platform version e.g. 1.13.2.`,
						},
						"status": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `ResourceStatus representing detailed cluster state.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"conditions": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"last_transition_time": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Last time the condition transit from one status to another.`,
												},
												"message": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Human-readable message indicating details about last transition.`,
												},
												"reason": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Machine-readable message indicating details about last transition.`,
												},
												"state": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The lifecycle state of the condition.`,
												},
												"type": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `Type of the condition.
(e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)`,
												},
											},
										},
									},
									"error_message": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Human-friendly representation of the error message from the admin cluster
controller. The error message can be temporary as the admin cluster
controller creates a cluster or node pool. If the error message persists
for a longer period of time, it can be used to surface error message to
indicate real problems requiring user intervention.`,
									},
								},
							},
						},
					},
				},
			},
			"private_registry_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configuration for private registry.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"address": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The registry address.`,
						},
						"ca_cert": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The CA certificate public key for private registry.`,
						},
					},
				},
			},
			"proxy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configuration for proxy.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"url": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The proxy url.`,
						},
						"no_proxy": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `A comma-separated list of IP addresses, IP address ranges,
host names, and domain names that should not go through the proxy server.`,
						},
					},
				},
			},
			"vcenter": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Specifies vCenter config for the admin cluster.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"address": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The vCenter IP address.`,
						},
						"ca_cert_data": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Contains the vCenter CA certificate public key for SSL verification.`,
						},
						"cluster": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter cluster for the admin cluster.`,
						},
						"data_disk": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the virtual machine disk (VMDK) for the admin cluster.`,
						},
						"datacenter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter datacenter for the admin cluster.`,
						},
						"datastore": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter datastore for the admin cluster.`,
						},
						"folder": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter folder for the admin cluster.`,
						},
						"resource_pool": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter resource pool for the admin cluster.`,
						},
						"storage_policy_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter storage policy for the user cluster.`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time the cluster was created, in RFC3339 text format.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"endpoint": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The DNS name of VMware admin cluster's API server.`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `This checksum is computed by the server based on the value of other
fields, and may be sent on update and delete requests to ensure the
client has an up-to-date value before proceeding.
Allows clients to perform consistent read-modify-writes
through optimistic concurrency control.`,
			},
			"fleet": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Fleet configuration for the cluster.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"membership": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The name of the managed Fleet Membership resource associated to this cluster.
Membership names are formatted as
'projects/<project-number>/locations/<location>/memberships/<cluster-id>'.`,
						},
					},
				},
			},
			"local_name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The object name of the VMwareAdminCluster custom resource on the
associated admin cluster. This field is used to support conflicting
names when enrolling existing clusters to the API. When used as a part of
cluster enrollment, this field will differ from the ID in the resource
name. For new clusters, this field will match the user provided cluster ID
and be visible in the last component of the resource name. It is not
modifiable.
All users should use this name to access their cluster using gkectl or
kubectl and should expect to see the local name when viewing admin
cluster controller logs.`,
			},
			"reconciling": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `If set, there are currently changes in flight to the VMware admin cluster.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The lifecycle state of the VMware admin cluster.`,
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `ResourceStatus representing detailed cluster state.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"conditions": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"last_transition_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Last time the condition transit from one status to another.`,
									},
									"message": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Human-readable message indicating details about last transition.`,
									},
									"reason": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Machine-readable message indicating details about last transition.`,
									},
									"state": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The lifecycle state of the condition.`,
									},
									"type": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Type of the condition.
(e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)`,
									},
								},
							},
						},
						"error_message": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Human-friendly representation of the error message from the admin cluster
controller. The error message can be temporary as the admin cluster
controller creates a cluster or node pool. If the error message persists
for a longer period of time, it can be used to surface error message to
indicate real problems requiring user intervention.`,
						},
					},
				},
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The unique identifier of the VMware Admin Cluster.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time the cluster was last updated, in RFC3339 text format.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceGkeonpremVmwareAdminClusterCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandGkeonpremVmwareAdminClusterDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	onPremVersionProp, err := expandGkeonpremVmwareAdminClusterOnPremVersion(d.Get("on_prem_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("on_prem_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(onPremVersionProp)) && (ok || !reflect.DeepEqual(v, onPremVersionProp)) {
		obj["onPremVersion"] = onPremVersionProp
	}
	imageTypeProp, err := expandGkeonpremVmwareAdminClusterImageType(d.Get("image_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("image_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(imageTypeProp)) && (ok || !reflect.DeepEqual(v, imageTypeProp)) {
		obj["imageType"] = imageTypeProp
	}
	bootstrapClusterMembershipProp, err := expandGkeonpremVmwareAdminClusterBootstrapClusterMembership(d.Get("bootstrap_cluster_membership"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("bootstrap_cluster_membership"); !tpgresource.IsEmptyValue(reflect.ValueOf(bootstrapClusterMembershipProp)) && (ok || !reflect.DeepEqual(v, bootstrapClusterMembershipProp)) {
		obj["bootstrapClusterMembership"] = bootstrapClusterMembershipProp
	}
	networkConfigProp, err := expandGkeonpremVmwareAdminClusterNetworkConfig(d.Get("network_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(networkConfigProp)) && (ok || !reflect.DeepEqual(v, networkConfigProp)) {
		obj["networkConfig"] = networkConfigProp
	}
	controlPlaneNodeProp, err := expandGkeonpremVmwareAdminClusterControlPlaneNode(d.Get("control_plane_node"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("control_plane_node"); !tpgresource.IsEmptyValue(reflect.ValueOf(controlPlaneNodeProp)) && (ok || !reflect.DeepEqual(v, controlPlaneNodeProp)) {
		obj["controlPlaneNode"] = controlPlaneNodeProp
	}
	addonNodeProp, err := expandGkeonpremVmwareAdminClusterAddonNode(d.Get("addon_node"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("addon_node"); !tpgresource.IsEmptyValue(reflect.ValueOf(addonNodeProp)) && (ok || !reflect.DeepEqual(v, addonNodeProp)) {
		obj["addonNode"] = addonNodeProp
	}
	loadBalancerProp, err := expandGkeonpremVmwareAdminClusterLoadBalancer(d.Get("load_balancer"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("load_balancer"); !tpgresource.IsEmptyValue(reflect.ValueOf(loadBalancerProp)) && (ok || !reflect.DeepEqual(v, loadBalancerProp)) {
		obj["loadBalancer"] = loadBalancerProp
	}
	vcenterProp, err := expandGkeonpremVmwareAdminClusterVcenter(d.Get("vcenter"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vcenter"); !tpgresource.IsEmptyValue(reflect.ValueOf(vcenterProp)) && (ok || !reflect.DeepEqual(v, vcenterProp)) {
		obj["vcenter"] = vcenterProp
	}
	antiAffinityGroupsProp, err := expandGkeonpremVmwareAdminClusterAntiAffinityGroups(d.Get("anti_affinity_groups"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("anti_affinity_groups"); !tpgresource.IsEmptyValue(reflect.ValueOf(antiAffinityGroupsProp)) && (ok || !reflect.DeepEqual(v, antiAffinityGroupsProp)) {
		obj["antiAffinityGroups"] = antiAffinityGroupsProp
	}
	autoRepairConfigProp, err := expandGkeonpremVmwareAdminClusterAutoRepairConfig(d.Get("auto_repair_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_repair_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(autoRepairConfigProp)) && (ok || !reflect.DeepEqual(v, autoRepairConfigProp)) {
		obj["autoRepairConfig"] = autoRepairConfigProp
	}
	authorizationProp, err := expandGkeonpremVmwareAdminClusterAuthorization(d.Get("authorization"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("authorization"); !tpgresource.IsEmptyValue(reflect.ValueOf(authorizationProp)) && (ok || !reflect.DeepEqual(v, authorizationProp)) {
		obj["authorization"] = authorizationProp
	}
	platformConfigProp, err := expandGkeonpremVmwareAdminClusterPlatformConfig(d.Get("platform_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("platform_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(platformConfigProp)) && (ok || !reflect.DeepEqual(v, platformConfigProp)) {
		obj["platformConfig"] = platformConfigProp
	}
	enableAdvancedClusterProp, err := expandGkeonpremVmwareAdminClusterEnableAdvancedCluster(d.Get("enable_advanced_cluster"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("enable_advanced_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(enableAdvancedClusterProp)) && (ok || !reflect.DeepEqual(v, enableAdvancedClusterProp)) {
		obj["enableAdvancedCluster"] = enableAdvancedClusterProp
	}
	privateRegistryConfigProp, err := expandGkeonpremVmwareAdminClusterPrivateRegistryConfig(d.Get("private_registry_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("private_registry_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(privateRegistryConfigProp)) && (ok || !reflect.DeepEqual(v, privateRegistryConfigProp)) {
		obj["privateRegistryConfig"] = privateRegistryConfigProp
	}
	proxyProp, err := expandGkeonpremVmwareAdminClusterProxy(d.Get("proxy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("proxy"); !tpgresource.IsEmptyValue(reflect.ValueOf(proxyProp)) && (ok || !reflect.DeepEqual(v, proxyProp)) {
		obj["proxy"] = proxyProp
	}
	effectiveAnnotationsProp, err := expandGkeonpremVmwareAdminClusterEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveAnnotationsProp)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GkeonpremBasePath}}projects/{{project}}/locations/{{location}}/vmwareAdminClusters?vmware_admin_cluster_id={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new VmwareAdminCluster: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for VmwareAdminCluster: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating VmwareAdminCluster: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/vmwareAdminClusters/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = GkeonpremOperationWaitTime(
		config, res, project, "Creating VmwareAdminCluster", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {

		return fmt.Errorf("Error waiting to create VmwareAdminCluster: %s", err)
	}

	log.Printf("[DEBUG] Finished creating VmwareAdminCluster %q: %#v", d.Id(), res)

	return resourceGkeonpremVmwareAdminClusterRead(d, meta)
}

func resourceGkeonpremVmwareAdminClusterRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GkeonpremBasePath}}projects/{{project}}/locations/{{location}}/vmwareAdminClusters/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for VmwareAdminCluster: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("GkeonpremVmwareAdminCluster %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}

	if err := d.Set("description", flattenGkeonpremVmwareAdminClusterDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("on_prem_version", flattenGkeonpremVmwareAdminClusterOnPremVersion(res["onPremVersion"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("image_type", flattenGkeonpremVmwareAdminClusterImageType(res["imageType"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("bootstrap_cluster_membership", flattenGkeonpremVmwareAdminClusterBootstrapClusterMembership(res["bootstrapClusterMembership"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("annotations", flattenGkeonpremVmwareAdminClusterAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("network_config", flattenGkeonpremVmwareAdminClusterNetworkConfig(res["networkConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("control_plane_node", flattenGkeonpremVmwareAdminClusterControlPlaneNode(res["controlPlaneNode"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("addon_node", flattenGkeonpremVmwareAdminClusterAddonNode(res["addonNode"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("load_balancer", flattenGkeonpremVmwareAdminClusterLoadBalancer(res["loadBalancer"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("vcenter", flattenGkeonpremVmwareAdminClusterVcenter(res["vcenter"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("anti_affinity_groups", flattenGkeonpremVmwareAdminClusterAntiAffinityGroups(res["antiAffinityGroups"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("auto_repair_config", flattenGkeonpremVmwareAdminClusterAutoRepairConfig(res["autoRepairConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("authorization", flattenGkeonpremVmwareAdminClusterAuthorization(res["authorization"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("platform_config", flattenGkeonpremVmwareAdminClusterPlatformConfig(res["platformConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("uid", flattenGkeonpremVmwareAdminClusterUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("state", flattenGkeonpremVmwareAdminClusterState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("endpoint", flattenGkeonpremVmwareAdminClusterEndpoint(res["endpoint"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("reconciling", flattenGkeonpremVmwareAdminClusterReconciling(res["reconciling"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("create_time", flattenGkeonpremVmwareAdminClusterCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("update_time", flattenGkeonpremVmwareAdminClusterUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("local_name", flattenGkeonpremVmwareAdminClusterLocalName(res["localName"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("etag", flattenGkeonpremVmwareAdminClusterEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("fleet", flattenGkeonpremVmwareAdminClusterFleet(res["fleet"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("status", flattenGkeonpremVmwareAdminClusterStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("enable_advanced_cluster", flattenGkeonpremVmwareAdminClusterEnableAdvancedCluster(res["enableAdvancedCluster"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("private_registry_config", flattenGkeonpremVmwareAdminClusterPrivateRegistryConfig(res["privateRegistryConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("proxy", flattenGkeonpremVmwareAdminClusterProxy(res["proxy"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}
	if err := d.Set("effective_annotations", flattenGkeonpremVmwareAdminClusterEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareAdminCluster: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("name"); !ok && v == "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceGkeonpremVmwareAdminClusterUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for VmwareAdminCluster: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandGkeonpremVmwareAdminClusterDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	onPremVersionProp, err := expandGkeonpremVmwareAdminClusterOnPremVersion(d.Get("on_prem_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("on_prem_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, onPremVersionProp)) {
		obj["onPremVersion"] = onPremVersionProp
	}
	imageTypeProp, err := expandGkeonpremVmwareAdminClusterImageType(d.Get("image_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("image_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, imageTypeProp)) {
		obj["imageType"] = imageTypeProp
	}
	bootstrapClusterMembershipProp, err := expandGkeonpremVmwareAdminClusterBootstrapClusterMembership(d.Get("bootstrap_cluster_membership"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("bootstrap_cluster_membership"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, bootstrapClusterMembershipProp)) {
		obj["bootstrapClusterMembership"] = bootstrapClusterMembershipProp
	}
	networkConfigProp, err := expandGkeonpremVmwareAdminClusterNetworkConfig(d.Get("network_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, networkConfigProp)) {
		obj["networkConfig"] = networkConfigProp
	}
	controlPlaneNodeProp, err := expandGkeonpremVmwareAdminClusterControlPlaneNode(d.Get("control_plane_node"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("control_plane_node"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, controlPlaneNodeProp)) {
		obj["controlPlaneNode"] = controlPlaneNodeProp
	}
	addonNodeProp, err := expandGkeonpremVmwareAdminClusterAddonNode(d.Get("addon_node"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("addon_node"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, addonNodeProp)) {
		obj["addonNode"] = addonNodeProp
	}
	loadBalancerProp, err := expandGkeonpremVmwareAdminClusterLoadBalancer(d.Get("load_balancer"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("load_balancer"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, loadBalancerProp)) {
		obj["loadBalancer"] = loadBalancerProp
	}
	vcenterProp, err := expandGkeonpremVmwareAdminClusterVcenter(d.Get("vcenter"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vcenter"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, vcenterProp)) {
		obj["vcenter"] = vcenterProp
	}
	antiAffinityGroupsProp, err := expandGkeonpremVmwareAdminClusterAntiAffinityGroups(d.Get("anti_affinity_groups"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("anti_affinity_groups"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, antiAffinityGroupsProp)) {
		obj["antiAffinityGroups"] = antiAffinityGroupsProp
	}
	autoRepairConfigProp, err := expandGkeonpremVmwareAdminClusterAutoRepairConfig(d.Get("auto_repair_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_repair_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, autoRepairConfigProp)) {
		obj["autoRepairConfig"] = autoRepairConfigProp
	}
	authorizationProp, err := expandGkeonpremVmwareAdminClusterAuthorization(d.Get("authorization"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("authorization"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, authorizationProp)) {
		obj["authorization"] = authorizationProp
	}
	platformConfigProp, err := expandGkeonpremVmwareAdminClusterPlatformConfig(d.Get("platform_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("platform_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, platformConfigProp)) {
		obj["platformConfig"] = platformConfigProp
	}
	enableAdvancedClusterProp, err := expandGkeonpremVmwareAdminClusterEnableAdvancedCluster(d.Get("enable_advanced_cluster"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("enable_advanced_cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, enableAdvancedClusterProp)) {
		obj["enableAdvancedCluster"] = enableAdvancedClusterProp
	}
	privateRegistryConfigProp, err := expandGkeonpremVmwareAdminClusterPrivateRegistryConfig(d.Get("private_registry_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("private_registry_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, privateRegistryConfigProp)) {
		obj["privateRegistryConfig"] = privateRegistryConfigProp
	}
	proxyProp, err := expandGkeonpremVmwareAdminClusterProxy(d.Get("proxy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("proxy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, proxyProp)) {
		obj["proxy"] = proxyProp
	}
	effectiveAnnotationsProp, err := expandGkeonpremVmwareAdminClusterEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GkeonpremBasePath}}projects/{{project}}/locations/{{location}}/vmwareAdminClusters/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating VmwareAdminCluster %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("on_prem_version") {
		updateMask = append(updateMask, "onPremVersion")
	}

	if d.HasChange("image_type") {
		updateMask = append(updateMask, "imageType")
	}

	if d.HasChange("bootstrap_cluster_membership") {
		updateMask = append(updateMask, "bootstrapClusterMembership")
	}

	if d.HasChange("network_config") {
		updateMask = append(updateMask, "networkConfig")
	}

	if d.HasChange("control_plane_node") {
		updateMask = append(updateMask, "controlPlaneNode")
	}

	if d.HasChange("addon_node") {
		updateMask = append(updateMask, "addonNode")
	}

	if d.HasChange("load_balancer") {
		updateMask = append(updateMask, "loadBalancer")
	}

	if d.HasChange("vcenter") {
		updateMask = append(updateMask, "vcenter")
	}

	if d.HasChange("anti_affinity_groups") {
		updateMask = append(updateMask, "antiAffinityGroups")
	}

	if d.HasChange("auto_repair_config") {
		updateMask = append(updateMask, "autoRepairConfig")
	}

	if d.HasChange("authorization") {
		updateMask = append(updateMask, "authorization")
	}

	if d.HasChange("platform_config") {
		updateMask = append(updateMask, "platformConfig")
	}

	if d.HasChange("enable_advanced_cluster") {
		updateMask = append(updateMask, "enableAdvancedCluster")
	}

	if d.HasChange("private_registry_config") {
		updateMask = append(updateMask, "privateRegistryConfig")
	}

	if d.HasChange("proxy") {
		updateMask = append(updateMask, "proxy")
	}

	if d.HasChange("effective_annotations") {
		updateMask = append(updateMask, "annotations")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating VmwareAdminCluster %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating VmwareAdminCluster %q: %#v", d.Id(), res)
		}

		err = GkeonpremOperationWaitTime(
			config, res, project, "Updating VmwareAdminCluster", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceGkeonpremVmwareAdminClusterRead(d, meta)
}

func resourceGkeonpremVmwareAdminClusterDelete(d *schema.ResourceData, meta interface{}) error {
	log.Printf("[WARNING] Gkeonprem VmwareAdminCluster resources"+
		" cannot be deleted from Google Cloud. The resource %s will be removed from Terraform"+
		" state, but will still be present on Google Cloud.", d.Id())
	d.SetId("")

	return nil
}

func resourceGkeonpremVmwareAdminClusterImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/vmwareAdminClusters/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/vmwareAdminClusters/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenGkeonpremVmwareAdminClusterDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterOnPremVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterImageType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterBootstrapClusterMembership(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenGkeonpremVmwareAdminClusterNetworkConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_address_cidr_blocks"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigServiceAddressCidrBlocks(original["serviceAddressCidrBlocks"], d, config)
	transformed["pod_address_cidr_blocks"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigPodAddressCidrBlocks(original["podAddressCidrBlocks"], d, config)
	transformed["static_ip_config"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfig(original["staticIpConfig"], d, config)
	transformed["dhcp_ip_config"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigDhcpIpConfig(original["dhcpIpConfig"], d, config)
	transformed["vcenter_network"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigVcenterNetwork(original["vcenterNetwork"], d, config)
	transformed["host_config"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigHostConfig(original["hostConfig"], d, config)
	transformed["ha_control_plane_config"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfig(original["haControlPlaneConfig"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterNetworkConfigServiceAddressCidrBlocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigPodAddressCidrBlocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ip_blocks"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocks(original["ipBlocks"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"netmask": flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksNetmask(original["netmask"], d, config),
			"gateway": flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksGateway(original["gateway"], d, config),
			"ips":     flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIps(original["ips"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksNetmask(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksGateway(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ip":       flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIpsIp(original["ip"], d, config),
			"hostname": flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIpsHostname(original["hostname"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIpsIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIpsHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigDhcpIpConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigDhcpIpConfigEnabled(original["enabled"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterNetworkConfigDhcpIpConfigEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigVcenterNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigHostConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dns_servers"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigHostConfigDnsServers(original["dnsServers"], d, config)
	transformed["ntp_servers"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigHostConfigNtpServers(original["ntpServers"], d, config)
	transformed["dns_search_domains"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigHostConfigDnsSearchDomains(original["dnsSearchDomains"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterNetworkConfigHostConfigDnsServers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigHostConfigNtpServers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigHostConfigDnsSearchDomains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["control_plane_ip_block"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlock(original["controlPlaneIpBlock"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlock(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["netmask"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockNetmask(original["netmask"], d, config)
	transformed["gateway"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockGateway(original["gateway"], d, config)
	transformed["ips"] =
		flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIps(original["ips"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockNetmask(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockGateway(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ip":       flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIpsIp(original["ip"], d, config),
			"hostname": flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIpsHostname(original["hostname"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIpsIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIpsHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterControlPlaneNode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cpus"] =
		flattenGkeonpremVmwareAdminClusterControlPlaneNodeCpus(original["cpus"], d, config)
	transformed["memory"] =
		flattenGkeonpremVmwareAdminClusterControlPlaneNodeMemory(original["memory"], d, config)
	transformed["replicas"] =
		flattenGkeonpremVmwareAdminClusterControlPlaneNodeReplicas(original["replicas"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterControlPlaneNodeCpus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareAdminClusterControlPlaneNodeMemory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareAdminClusterControlPlaneNodeReplicas(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareAdminClusterAddonNode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["auto_resize_config"] =
		flattenGkeonpremVmwareAdminClusterAddonNodeAutoResizeConfig(original["autoResizeConfig"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterAddonNodeAutoResizeConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenGkeonpremVmwareAdminClusterAddonNodeAutoResizeConfigEnabled(original["enabled"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterAddonNodeAutoResizeConfigEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterLoadBalancer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["vip_config"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerVipConfig(original["vipConfig"], d, config)
	transformed["f5_config"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerF5Config(original["f5Config"], d, config)
	transformed["manual_lb_config"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfig(original["manualLbConfig"], d, config)
	transformed["metal_lb_config"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerMetalLbConfig(original["metalLbConfig"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterLoadBalancerVipConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["control_plane_vip"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerVipConfigControlPlaneVip(original["controlPlaneVip"], d, config)
	transformed["addons_vip"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerVipConfigAddonsVip(original["addonsVip"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterLoadBalancerVipConfigControlPlaneVip(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterLoadBalancerVipConfigAddonsVip(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterLoadBalancerF5Config(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["address"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerF5ConfigAddress(original["address"], d, config)
	transformed["partition"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerF5ConfigPartition(original["partition"], d, config)
	transformed["snat_pool"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerF5ConfigSnatPool(original["snatPool"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterLoadBalancerF5ConfigAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterLoadBalancerF5ConfigPartition(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterLoadBalancerF5ConfigSnatPool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ingress_http_node_port"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigIngressHttpNodePort(original["ingressHttpNodePort"], d, config)
	transformed["ingress_https_node_port"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigIngressHttpsNodePort(original["ingressHttpsNodePort"], d, config)
	transformed["control_plane_node_port"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigControlPlaneNodePort(original["controlPlaneNodePort"], d, config)
	transformed["konnectivity_server_node_port"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigKonnectivityServerNodePort(original["konnectivityServerNodePort"], d, config)
	transformed["addons_node_port"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigAddonsNodePort(original["addonsNodePort"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigIngressHttpNodePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigIngressHttpsNodePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigControlPlaneNodePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigKonnectivityServerNodePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigAddonsNodePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareAdminClusterLoadBalancerMetalLbConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenGkeonpremVmwareAdminClusterLoadBalancerMetalLbConfigEnabled(original["enabled"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterLoadBalancerMetalLbConfigEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterVcenter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["resource_pool"] =
		flattenGkeonpremVmwareAdminClusterVcenterResourcePool(original["resourcePool"], d, config)
	transformed["datastore"] =
		flattenGkeonpremVmwareAdminClusterVcenterDatastore(original["datastore"], d, config)
	transformed["datacenter"] =
		flattenGkeonpremVmwareAdminClusterVcenterDatacenter(original["datacenter"], d, config)
	transformed["cluster"] =
		flattenGkeonpremVmwareAdminClusterVcenterCluster(original["cluster"], d, config)
	transformed["folder"] =
		flattenGkeonpremVmwareAdminClusterVcenterFolder(original["folder"], d, config)
	transformed["ca_cert_data"] =
		flattenGkeonpremVmwareAdminClusterVcenterCaCertData(original["caCertData"], d, config)
	transformed["address"] =
		flattenGkeonpremVmwareAdminClusterVcenterAddress(original["address"], d, config)
	transformed["data_disk"] =
		flattenGkeonpremVmwareAdminClusterVcenterDataDisk(original["dataDisk"], d, config)
	transformed["storage_policy_name"] =
		flattenGkeonpremVmwareAdminClusterVcenterStoragePolicyName(original["storagePolicyName"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterVcenterResourcePool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterVcenterDatastore(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterVcenterDatacenter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterVcenterCluster(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterVcenterFolder(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterVcenterCaCertData(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterVcenterAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterVcenterDataDisk(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterVcenterStoragePolicyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterAntiAffinityGroups(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["aag_config_disabled"] =
		flattenGkeonpremVmwareAdminClusterAntiAffinityGroupsAagConfigDisabled(original["aagConfigDisabled"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterAntiAffinityGroupsAagConfigDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterAutoRepairConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenGkeonpremVmwareAdminClusterAutoRepairConfigEnabled(original["enabled"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterAutoRepairConfigEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterAuthorization(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["viewer_users"] =
		flattenGkeonpremVmwareAdminClusterAuthorizationViewerUsers(original["viewerUsers"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterAuthorizationViewerUsers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"username": flattenGkeonpremVmwareAdminClusterAuthorizationViewerUsersUsername(original["username"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareAdminClusterAuthorizationViewerUsersUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["required_platform_version"] =
		flattenGkeonpremVmwareAdminClusterPlatformConfigRequiredPlatformVersion(original["requiredPlatformVersion"], d, config)
	transformed["platform_version"] =
		flattenGkeonpremVmwareAdminClusterPlatformConfigPlatformVersion(original["platformVersion"], d, config)
	transformed["bundles"] =
		flattenGkeonpremVmwareAdminClusterPlatformConfigBundles(original["bundles"], d, config)
	transformed["status"] =
		flattenGkeonpremVmwareAdminClusterPlatformConfigStatus(original["status"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterPlatformConfigRequiredPlatformVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("platform_config.0.required_platform_version")
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigPlatformVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigBundles(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"version": flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesVersion(original["version"], d, config),
			"status":  flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatus(original["status"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error_message"] =
		flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusErrorMessage(original["errorMessage"], d, config)
	transformed["conditions"] =
		flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditions(original["conditions"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusErrorMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":                 flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsType(original["type"], d, config),
			"reason":               flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsReason(original["reason"], d, config),
			"message":              flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsMessage(original["message"], d, config),
			"last_transition_time": flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsLastTransitionTime(original["lastTransitionTime"], d, config),
			"state":                flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsState(original["state"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsLastTransitionTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error_message"] =
		flattenGkeonpremVmwareAdminClusterPlatformConfigStatusErrorMessage(original["errorMessage"], d, config)
	transformed["conditions"] =
		flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditions(original["conditions"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterPlatformConfigStatusErrorMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":                 flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsType(original["type"], d, config),
			"reason":               flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsReason(original["reason"], d, config),
			"message":              flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsMessage(original["message"], d, config),
			"last_transition_time": flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsLastTransitionTime(original["lastTransitionTime"], d, config),
			"state":                flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsState(original["state"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsLastTransitionTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterReconciling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterLocalName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterFleet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["membership"] =
		flattenGkeonpremVmwareAdminClusterFleetMembership(original["membership"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterFleetMembership(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error_message"] =
		flattenGkeonpremVmwareAdminClusterStatusErrorMessage(original["errorMessage"], d, config)
	transformed["conditions"] =
		flattenGkeonpremVmwareAdminClusterStatusConditions(original["conditions"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterStatusErrorMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterStatusConditions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":                 flattenGkeonpremVmwareAdminClusterStatusConditionsType(original["type"], d, config),
			"reason":               flattenGkeonpremVmwareAdminClusterStatusConditionsReason(original["reason"], d, config),
			"message":              flattenGkeonpremVmwareAdminClusterStatusConditionsMessage(original["message"], d, config),
			"last_transition_time": flattenGkeonpremVmwareAdminClusterStatusConditionsLastTransitionTime(original["lastTransitionTime"], d, config),
			"state":                flattenGkeonpremVmwareAdminClusterStatusConditionsState(original["state"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareAdminClusterStatusConditionsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterStatusConditionsReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterStatusConditionsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterStatusConditionsLastTransitionTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterStatusConditionsState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterEnableAdvancedCluster(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPrivateRegistryConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["address"] =
		flattenGkeonpremVmwareAdminClusterPrivateRegistryConfigAddress(original["address"], d, config)
	transformed["ca_cert"] =
		flattenGkeonpremVmwareAdminClusterPrivateRegistryConfigCaCert(original["caCert"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterPrivateRegistryConfigAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterPrivateRegistryConfigCaCert(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterProxy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["url"] =
		flattenGkeonpremVmwareAdminClusterProxyUrl(original["url"], d, config)
	transformed["no_proxy"] =
		flattenGkeonpremVmwareAdminClusterProxyNoProxy(original["noProxy"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareAdminClusterProxyUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterProxyNoProxy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareAdminClusterEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandGkeonpremVmwareAdminClusterDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterOnPremVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterImageType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterBootstrapClusterMembership(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServiceAddressCidrBlocks, err := expandGkeonpremVmwareAdminClusterNetworkConfigServiceAddressCidrBlocks(original["service_address_cidr_blocks"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAddressCidrBlocks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAddressCidrBlocks"] = transformedServiceAddressCidrBlocks
	}

	transformedPodAddressCidrBlocks, err := expandGkeonpremVmwareAdminClusterNetworkConfigPodAddressCidrBlocks(original["pod_address_cidr_blocks"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPodAddressCidrBlocks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["podAddressCidrBlocks"] = transformedPodAddressCidrBlocks
	}

	transformedStaticIpConfig, err := expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfig(original["static_ip_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStaticIpConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["staticIpConfig"] = transformedStaticIpConfig
	}

	transformedDhcpIpConfig, err := expandGkeonpremVmwareAdminClusterNetworkConfigDhcpIpConfig(original["dhcp_ip_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDhcpIpConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dhcpIpConfig"] = transformedDhcpIpConfig
	}

	transformedVcenterNetwork, err := expandGkeonpremVmwareAdminClusterNetworkConfigVcenterNetwork(original["vcenter_network"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVcenterNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vcenterNetwork"] = transformedVcenterNetwork
	}

	transformedHostConfig, err := expandGkeonpremVmwareAdminClusterNetworkConfigHostConfig(original["host_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostConfig"] = transformedHostConfig
	}

	transformedHaControlPlaneConfig, err := expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfig(original["ha_control_plane_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHaControlPlaneConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["haControlPlaneConfig"] = transformedHaControlPlaneConfig
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigServiceAddressCidrBlocks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigPodAddressCidrBlocks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIpBlocks, err := expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocks(original["ip_blocks"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIpBlocks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ipBlocks"] = transformedIpBlocks
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedNetmask, err := expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksNetmask(original["netmask"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetmask); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["netmask"] = transformedNetmask
		}

		transformedGateway, err := expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksGateway(original["gateway"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedGateway); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["gateway"] = transformedGateway
		}

		transformedIps, err := expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIps(original["ips"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ips"] = transformedIps
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksNetmask(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksGateway(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedIp, err := expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIpsIp(original["ip"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ip"] = transformedIp
		}

		transformedHostname, err := expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIpsHostname(original["hostname"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hostname"] = transformedHostname
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIpsIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigStaticIpConfigIpBlocksIpsHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigDhcpIpConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandGkeonpremVmwareAdminClusterNetworkConfigDhcpIpConfigEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigDhcpIpConfigEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigVcenterNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigHostConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDnsServers, err := expandGkeonpremVmwareAdminClusterNetworkConfigHostConfigDnsServers(original["dns_servers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDnsServers); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dnsServers"] = transformedDnsServers
	}

	transformedNtpServers, err := expandGkeonpremVmwareAdminClusterNetworkConfigHostConfigNtpServers(original["ntp_servers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNtpServers); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ntpServers"] = transformedNtpServers
	}

	transformedDnsSearchDomains, err := expandGkeonpremVmwareAdminClusterNetworkConfigHostConfigDnsSearchDomains(original["dns_search_domains"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDnsSearchDomains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dnsSearchDomains"] = transformedDnsSearchDomains
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigHostConfigDnsServers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigHostConfigNtpServers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigHostConfigDnsSearchDomains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedControlPlaneIpBlock, err := expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlock(original["control_plane_ip_block"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedControlPlaneIpBlock); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["controlPlaneIpBlock"] = transformedControlPlaneIpBlock
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlock(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNetmask, err := expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockNetmask(original["netmask"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetmask); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["netmask"] = transformedNetmask
	}

	transformedGateway, err := expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockGateway(original["gateway"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGateway); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gateway"] = transformedGateway
	}

	transformedIps, err := expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIps(original["ips"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ips"] = transformedIps
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockNetmask(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockGateway(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedIp, err := expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIpsIp(original["ip"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ip"] = transformedIp
		}

		transformedHostname, err := expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIpsHostname(original["hostname"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hostname"] = transformedHostname
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIpsIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIpsHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterControlPlaneNode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCpus, err := expandGkeonpremVmwareAdminClusterControlPlaneNodeCpus(original["cpus"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCpus); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cpus"] = transformedCpus
	}

	transformedMemory, err := expandGkeonpremVmwareAdminClusterControlPlaneNodeMemory(original["memory"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMemory); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["memory"] = transformedMemory
	}

	transformedReplicas, err := expandGkeonpremVmwareAdminClusterControlPlaneNodeReplicas(original["replicas"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReplicas); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["replicas"] = transformedReplicas
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterControlPlaneNodeCpus(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterControlPlaneNodeMemory(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterControlPlaneNodeReplicas(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterAddonNode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAutoResizeConfig, err := expandGkeonpremVmwareAdminClusterAddonNodeAutoResizeConfig(original["auto_resize_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAutoResizeConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["autoResizeConfig"] = transformedAutoResizeConfig
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterAddonNodeAutoResizeConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandGkeonpremVmwareAdminClusterAddonNodeAutoResizeConfigEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterAddonNodeAutoResizeConfigEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancer(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedVipConfig, err := expandGkeonpremVmwareAdminClusterLoadBalancerVipConfig(original["vip_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVipConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vipConfig"] = transformedVipConfig
	}

	transformedF5Config, err := expandGkeonpremVmwareAdminClusterLoadBalancerF5Config(original["f5_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedF5Config); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["f5Config"] = transformedF5Config
	}

	transformedManualLbConfig, err := expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfig(original["manual_lb_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedManualLbConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["manualLbConfig"] = transformedManualLbConfig
	}

	transformedMetalLbConfig, err := expandGkeonpremVmwareAdminClusterLoadBalancerMetalLbConfig(original["metal_lb_config"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["metalLbConfig"] = transformedMetalLbConfig
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerVipConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedControlPlaneVip, err := expandGkeonpremVmwareAdminClusterLoadBalancerVipConfigControlPlaneVip(original["control_plane_vip"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedControlPlaneVip); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["controlPlaneVip"] = transformedControlPlaneVip
	}

	transformedAddonsVip, err := expandGkeonpremVmwareAdminClusterLoadBalancerVipConfigAddonsVip(original["addons_vip"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAddonsVip); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["addonsVip"] = transformedAddonsVip
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerVipConfigControlPlaneVip(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerVipConfigAddonsVip(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerF5Config(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAddress, err := expandGkeonpremVmwareAdminClusterLoadBalancerF5ConfigAddress(original["address"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAddress); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["address"] = transformedAddress
	}

	transformedPartition, err := expandGkeonpremVmwareAdminClusterLoadBalancerF5ConfigPartition(original["partition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPartition); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["partition"] = transformedPartition
	}

	transformedSnatPool, err := expandGkeonpremVmwareAdminClusterLoadBalancerF5ConfigSnatPool(original["snat_pool"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSnatPool); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["snatPool"] = transformedSnatPool
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerF5ConfigAddress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerF5ConfigPartition(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerF5ConfigSnatPool(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIngressHttpNodePort, err := expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigIngressHttpNodePort(original["ingress_http_node_port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIngressHttpNodePort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ingressHttpNodePort"] = transformedIngressHttpNodePort
	}

	transformedIngressHttpsNodePort, err := expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigIngressHttpsNodePort(original["ingress_https_node_port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIngressHttpsNodePort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ingressHttpsNodePort"] = transformedIngressHttpsNodePort
	}

	transformedControlPlaneNodePort, err := expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigControlPlaneNodePort(original["control_plane_node_port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedControlPlaneNodePort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["controlPlaneNodePort"] = transformedControlPlaneNodePort
	}

	transformedKonnectivityServerNodePort, err := expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigKonnectivityServerNodePort(original["konnectivity_server_node_port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKonnectivityServerNodePort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["konnectivityServerNodePort"] = transformedKonnectivityServerNodePort
	}

	transformedAddonsNodePort, err := expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigAddonsNodePort(original["addons_node_port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAddonsNodePort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["addonsNodePort"] = transformedAddonsNodePort
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigIngressHttpNodePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigIngressHttpsNodePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigControlPlaneNodePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigKonnectivityServerNodePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerManualLbConfigAddonsNodePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerMetalLbConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandGkeonpremVmwareAdminClusterLoadBalancerMetalLbConfigEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterLoadBalancerMetalLbConfigEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterVcenter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedResourcePool, err := expandGkeonpremVmwareAdminClusterVcenterResourcePool(original["resource_pool"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResourcePool); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["resourcePool"] = transformedResourcePool
	}

	transformedDatastore, err := expandGkeonpremVmwareAdminClusterVcenterDatastore(original["datastore"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatastore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["datastore"] = transformedDatastore
	}

	transformedDatacenter, err := expandGkeonpremVmwareAdminClusterVcenterDatacenter(original["datacenter"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatacenter); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["datacenter"] = transformedDatacenter
	}

	transformedCluster, err := expandGkeonpremVmwareAdminClusterVcenterCluster(original["cluster"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCluster); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cluster"] = transformedCluster
	}

	transformedFolder, err := expandGkeonpremVmwareAdminClusterVcenterFolder(original["folder"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFolder); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["folder"] = transformedFolder
	}

	transformedCaCertData, err := expandGkeonpremVmwareAdminClusterVcenterCaCertData(original["ca_cert_data"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCertData); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCertData"] = transformedCaCertData
	}

	transformedAddress, err := expandGkeonpremVmwareAdminClusterVcenterAddress(original["address"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAddress); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["address"] = transformedAddress
	}

	transformedDataDisk, err := expandGkeonpremVmwareAdminClusterVcenterDataDisk(original["data_disk"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataDisk); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataDisk"] = transformedDataDisk
	}

	transformedStoragePolicyName, err := expandGkeonpremVmwareAdminClusterVcenterStoragePolicyName(original["storage_policy_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStoragePolicyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["storagePolicyName"] = transformedStoragePolicyName
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterVcenterResourcePool(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterVcenterDatastore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterVcenterDatacenter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterVcenterCluster(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterVcenterFolder(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterVcenterCaCertData(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterVcenterAddress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterVcenterDataDisk(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterVcenterStoragePolicyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterAntiAffinityGroups(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAagConfigDisabled, err := expandGkeonpremVmwareAdminClusterAntiAffinityGroupsAagConfigDisabled(original["aag_config_disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAagConfigDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["aagConfigDisabled"] = transformedAagConfigDisabled
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterAntiAffinityGroupsAagConfigDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterAutoRepairConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandGkeonpremVmwareAdminClusterAutoRepairConfigEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterAutoRepairConfigEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterAuthorization(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedViewerUsers, err := expandGkeonpremVmwareAdminClusterAuthorizationViewerUsers(original["viewer_users"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedViewerUsers); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["viewerUsers"] = transformedViewerUsers
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterAuthorizationViewerUsers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedUsername, err := expandGkeonpremVmwareAdminClusterAuthorizationViewerUsersUsername(original["username"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["username"] = transformedUsername
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareAdminClusterAuthorizationViewerUsersUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRequiredPlatformVersion, err := expandGkeonpremVmwareAdminClusterPlatformConfigRequiredPlatformVersion(original["required_platform_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRequiredPlatformVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["requiredPlatformVersion"] = transformedRequiredPlatformVersion
	}

	transformedPlatformVersion, err := expandGkeonpremVmwareAdminClusterPlatformConfigPlatformVersion(original["platform_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPlatformVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["platformVersion"] = transformedPlatformVersion
	}

	transformedBundles, err := expandGkeonpremVmwareAdminClusterPlatformConfigBundles(original["bundles"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBundles); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bundles"] = transformedBundles
	}

	transformedStatus, err := expandGkeonpremVmwareAdminClusterPlatformConfigStatus(original["status"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStatus); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["status"] = transformedStatus
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigRequiredPlatformVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigPlatformVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigBundles(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedVersion, err := expandGkeonpremVmwareAdminClusterPlatformConfigBundlesVersion(original["version"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["version"] = transformedVersion
		}

		transformedStatus, err := expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatus(original["status"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStatus); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["status"] = transformedStatus
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigBundlesVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatus(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedErrorMessage, err := expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusErrorMessage(original["error_message"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedErrorMessage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["errorMessage"] = transformedErrorMessage
	}

	transformedConditions, err := expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditions(original["conditions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConditions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["conditions"] = transformedConditions
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusErrorMessage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedReason, err := expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsReason(original["reason"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedReason); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["reason"] = transformedReason
		}

		transformedMessage, err := expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsMessage(original["message"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMessage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["message"] = transformedMessage
		}

		transformedLastTransitionTime, err := expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsLastTransitionTime(original["last_transition_time"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLastTransitionTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["lastTransitionTime"] = transformedLastTransitionTime
		}

		transformedState, err := expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsState(original["state"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["state"] = transformedState
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsReason(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsMessage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsLastTransitionTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigBundlesStatusConditionsState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigStatus(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedErrorMessage, err := expandGkeonpremVmwareAdminClusterPlatformConfigStatusErrorMessage(original["error_message"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedErrorMessage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["errorMessage"] = transformedErrorMessage
	}

	transformedConditions, err := expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditions(original["conditions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConditions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["conditions"] = transformedConditions
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigStatusErrorMessage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedReason, err := expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsReason(original["reason"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedReason); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["reason"] = transformedReason
		}

		transformedMessage, err := expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsMessage(original["message"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMessage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["message"] = transformedMessage
		}

		transformedLastTransitionTime, err := expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsLastTransitionTime(original["last_transition_time"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLastTransitionTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["lastTransitionTime"] = transformedLastTransitionTime
		}

		transformedState, err := expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsState(original["state"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["state"] = transformedState
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsReason(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsMessage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsLastTransitionTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPlatformConfigStatusConditionsState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterEnableAdvancedCluster(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPrivateRegistryConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAddress, err := expandGkeonpremVmwareAdminClusterPrivateRegistryConfigAddress(original["address"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAddress); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["address"] = transformedAddress
	}

	transformedCaCert, err := expandGkeonpremVmwareAdminClusterPrivateRegistryConfigCaCert(original["ca_cert"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCert); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCert"] = transformedCaCert
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterPrivateRegistryConfigAddress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterPrivateRegistryConfigCaCert(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterProxy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUrl, err := expandGkeonpremVmwareAdminClusterProxyUrl(original["url"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUrl); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["url"] = transformedUrl
	}

	transformedNoProxy, err := expandGkeonpremVmwareAdminClusterProxyNoProxy(original["no_proxy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNoProxy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["noProxy"] = transformedNoProxy
	}

	return transformed, nil
}

func expandGkeonpremVmwareAdminClusterProxyUrl(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterProxyNoProxy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareAdminClusterEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
