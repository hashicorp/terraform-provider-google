// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package gkeonprem

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceGkeonpremVmwareCluster() *schema.Resource {
	return &schema.Resource{
		Create: resourceGkeonpremVmwareClusterCreate,
		Read:   resourceGkeonpremVmwareClusterRead,
		Update: resourceGkeonpremVmwareClusterUpdate,
		Delete: resourceGkeonpremVmwareClusterDelete,

		Importer: &schema.ResourceImporter{
			State: resourceGkeonpremVmwareClusterImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(60 * time.Minute),
			Update: schema.DefaultTimeout(60 * time.Minute),
			Delete: schema.DefaultTimeout(60 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"admin_cluster_membership": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.ProjectNumberDiffSuppress,
				Description: `The admin cluster this VMware User Cluster belongs to.
This is the full resource name of the admin cluster's hub membership.
In the future, references to other resource types might be allowed if
admin clusters are modeled as their own resources.`,
			},
			"control_plane_node": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `VMware User Cluster control plane nodes must have either 1 or 3 replicas.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auto_resize_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `AutoResizeConfig provides auto resizing configurations.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enabled": {
										Type:        schema.TypeBool,
										Required:    true,
										Description: `Whether to enable control plane node auto resizing.`,
									},
								},
							},
						},
						"cpus": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `The number of CPUs for each admin cluster node that serve as control planes
for this VMware User Cluster. (default: 4 CPUs)`,
							Default: 4,
						},
						"memory": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `The megabytes of memory for each admin cluster node that serves as a
control plane for this VMware User Cluster (default: 8192 MB memory).`,
							Default: 8192,
						},
						"replicas": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `The number of control plane nodes for this VMware User Cluster.
(default: 1 replica).`,
							Default: 1,
						},
						"vsphere_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Vsphere-specific config.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"datastore": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The Vsphere datastore used by the Control Plane Node.`,
									},
									"storage_policy_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The Vsphere storage policy used by the control plane Node.`,
									},
								},
							},
						},
					},
				},
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the resource.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The VMware cluster name.`,
			},
			"on_prem_version": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The Anthos clusters on the VMware version for your user cluster.`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Annotations on the VMware User Cluster.
This field has the same restrictions as Kubernetes annotations.
The total size of all keys and values combined is limited to 256k.
Key can have 2 segments: prefix (optional) and name (required),
separated by a slash (/).
Prefix must be a DNS subdomain.
Name must be 63 characters or less, begin and end with alphanumerics,
with dashes (-), underscores (_), dots (.), and alphanumerics between.


**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"anti_affinity_groups": {
				Type:     schema.TypeList,
				Computed: true,
				Optional: true,
				Description: `AAGConfig specifies whether to spread VMware User Cluster nodes across at
least three physical hosts in the datacenter.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"aag_config_disabled": {
							Type:     schema.TypeBool,
							Required: true,
							Description: `Spread nodes across at least three physical hosts (requires at least three
hosts).
Enabled by default.`,
						},
					},
				},
			},
			"authorization": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `RBAC policy that will be applied and managed by GKE On-Prem.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"admin_users": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Users that will be granted the cluster-admin role on the cluster, providing
full access to the cluster.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"username": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The name of the user, e.g. 'my-gcp-id@gmail.com'.`,
									},
								},
							},
						},
					},
				},
			},
			"auto_repair_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Configuration for auto repairing.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enabled": {
							Type:        schema.TypeBool,
							Required:    true,
							Description: `Whether auto repair is enabled.`,
						},
					},
				},
			},
			"dataplane_v2": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `VmwareDataplaneV2Config specifies configuration for Dataplane V2.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"advanced_networking": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Enable advanced networking which requires dataplane_v2_enabled to be set true.`,
						},
						"dataplane_v2_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Enables Dataplane V2.`,
						},
						"windows_dataplane_v2_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Enable Dataplane V2 for clusters with Windows nodes.`,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `A human readable description of this VMware User Cluster.`,
			},
			"enable_control_plane_v2": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Enable control plane V2. Default to false.`,
			},
			"load_balancer": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Load Balancer configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"f5_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for F5 Big IP typed load balancers.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The load balancer's IP address.`,
									},
									"partition": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `he preexisting partition to be used by the load balancer. T
his partition is usually created for the admin cluster for example:
'my-f5-admin-partition'.`,
									},
									"snat_pool": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										Description: `The pool name. Only necessary, if using SNAT.`,
									},
								},
							},
							ExactlyOneOf: []string{"load_balancer.0.f5_config", "load_balancer.0.manual_lb_config", "load_balancer.0.metal_lb_config"},
						},
						"manual_lb_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Manually configured load balancers.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"control_plane_node_port": {
										Type:     schema.TypeInt,
										Computed: true,
										Optional: true,
										Description: `NodePort for control plane service. The Kubernetes API server in the admin
cluster is implemented as a Service of type NodePort (ex. 30968).`,
									},
									"ingress_http_node_port": {
										Type:     schema.TypeInt,
										Computed: true,
										Optional: true,
										Description: `NodePort for ingress service's http. The ingress service in the admin
cluster is implemented as a Service of type NodePort (ex. 32527).`,
									},
									"ingress_https_node_port": {
										Type:     schema.TypeInt,
										Computed: true,
										Optional: true,
										Description: `NodePort for ingress service's https. The ingress service in the admin
cluster is implemented as a Service of type NodePort (ex. 30139).`,
									},
									"konnectivity_server_node_port": {
										Type:     schema.TypeInt,
										Computed: true,
										Optional: true,
										Description: `NodePort for konnectivity server service running as a sidecar in each
kube-apiserver pod (ex. 30564).`,
									},
								},
							},
							ExactlyOneOf: []string{"load_balancer.0.f5_config", "load_balancer.0.manual_lb_config", "load_balancer.0.metal_lb_config"},
						},
						"metal_lb_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for MetalLB typed load balancers.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"address_pools": {
										Type:     schema.TypeList,
										Required: true,
										Description: `AddressPools is a list of non-overlapping IP pools used by load balancer
typed services. All addresses must be routable to load balancer nodes.
IngressVIP must be included in the pools.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"addresses": {
													Type:     schema.TypeList,
													Required: true,
													Description: `The addresses that are part of this pool. Each address
must be either in the CIDR form (1.2.3.0/24) or range
form (1.2.3.1-1.2.3.5).`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"pool": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The name of the address pool.`,
												},
												"avoid_buggy_ips": {
													Type:     schema.TypeBool,
													Computed: true,
													Optional: true,
													Description: `If true, avoid using IPs ending in .0 or .255.
This avoids buggy consumer devices mistakenly dropping IPv4 traffic for
those special IP addresses.`,
												},
												"manual_assign": {
													Type:        schema.TypeBool,
													Computed:    true,
													Optional:    true,
													Description: `If true, prevent IP addresses from being automatically assigned.`,
												},
											},
										},
									},
								},
							},
							ExactlyOneOf: []string{"load_balancer.0.f5_config", "load_balancer.0.manual_lb_config", "load_balancer.0.metal_lb_config"},
						},
						"vip_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The VIPs used by the load balancer.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"control_plane_vip": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The VIP which you previously set aside for the Kubernetes API of this cluster.`,
									},
									"ingress_vip": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The VIP which you previously set aside for ingress traffic into this cluster.`,
									},
								},
							},
						},
					},
				},
			},
			"network_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The VMware User Cluster network configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"pod_address_cidr_blocks": {
							Type:     schema.TypeList,
							Required: true,
							Description: `All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
Only a single range is supported. This field cannot be changed after creation.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"service_address_cidr_blocks": {
							Type:     schema.TypeList,
							Required: true,
							Description: `All services in the cluster are assigned an RFC1918 IPv4 address
from these ranges. Only a single range is supported.. This field
cannot be changed after creation.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"control_plane_v2_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for control plane V2 mode.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"control_plane_ip_block": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Static IP addresses for the control plane nodes.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"gateway": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The network gateway used by the VMware User Cluster.`,
												},
												"ips": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `The node's network configurations used by the VMware User Cluster.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"hostname": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																Description: `Hostname of the machine. VM's name will be used if this field is empty.`,
															},
															"ip": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).`,
															},
														},
													},
												},
												"netmask": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The netmask used by the VMware User Cluster.`,
												},
											},
										},
									},
								},
							},
						},
						"dhcp_ip_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Configuration settings for a DHCP IP configuration.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enabled": {
										Type:     schema.TypeBool,
										Required: true,
										Description: `enabled is a flag to mark if DHCP IP allocation is
used for VMware user clusters.`,
									},
								},
							},
							ExactlyOneOf: []string{"network_config.0.static_ip_config", "network_config.0.dhcp_ip_config"},
						},
						"host_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Represents common network settings irrespective of the host's IP address.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"dns_search_domains": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `DNS search domains.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"dns_servers": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `DNS servers.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"ntp_servers": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `NTP servers.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"static_ip_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration settings for a static IP configuration.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ip_blocks": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `Represents the configuration values for static IP allocation to nodes.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"gateway": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The network gateway used by the VMware User Cluster.`,
												},
												"ips": {
													Type:        schema.TypeList,
													Required:    true,
													Description: `The node's network configurations used by the VMware User Cluster.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"ip": {
																Type:        schema.TypeString,
																Required:    true,
																Description: `IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).`,
															},
															"hostname": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																Description: `Hostname of the machine. VM's name will be used if this field is empty.`,
															},
														},
													},
												},
												"netmask": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The netmask used by the VMware User Cluster.`,
												},
											},
										},
									},
								},
							},
							ExactlyOneOf: []string{"network_config.0.static_ip_config", "network_config.0.dhcp_ip_config"},
						},
						"vcenter_network": {
							Type:        schema.TypeString,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `vcenter_network specifies vCenter network name. Inherited from the admin cluster.`,
						},
					},
				},
			},
			"storage": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Storage configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"vsphere_csi_disabled": {
							Type:     schema.TypeBool,
							Required: true,
							Description: `Whether or not to deploy vSphere CSI components in the VMware User Cluster.
Enabled by default.`,
						},
					},
				},
			},
			"upgrade_policy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Specifies upgrade policy for the cluster.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"control_plane_only": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Controls whether the upgrade applies to the control plane only.`,
						},
					},
				},
			},
			"vcenter": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `VmwareVCenterConfig specifies vCenter config for the user cluster.
Inherited from the admin cluster.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ca_cert_data": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Contains the vCenter CA certificate public key for SSL verification.`,
						},
						"cluster": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter cluster for the user cluster.`,
						},
						"datacenter": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter datacenter for the user cluster.`,
						},
						"datastore": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter datastore for the user cluster.`,
						},
						"folder": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter folder for the user cluster.`,
						},
						"resource_pool": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter resource pool for the user cluster.`,
						},
						"storage_policy_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The name of the vCenter storage policy for the user cluster.`,
						},
						"address": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The vCenter IP address.`,
						},
					},
				},
			},
			"vm_tracking_enabled": {
				Type:        schema.TypeBool,
				Computed:    true,
				Optional:    true,
				Description: `Enable VM tracking.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time at which VMware User Cluster was created.`,
			},
			"delete_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time at which VMware User Cluster was deleted.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"endpoint": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The DNS name of VMware User Cluster's API server.`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `This checksum is computed by the server based on the value of other
fields, and may be sent on update and delete requests to ensure the
client has an up-to-date value before proceeding.
Allows clients to perform consistent read-modify-writes
through optimistic concurrency control.`,
			},
			"fleet": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Fleet configuration for the cluster.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"membership": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The name of the managed Hub Membership resource associated to this cluster.
Membership names are formatted as
'projects/<project-number>/locations/<location>/memberships/<cluster-id>'.`,
						},
					},
				},
			},
			"local_name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The object name of the VMware OnPremUserCluster custom resource on the
associated admin cluster. This field is used to support conflicting
names when enrolling existing clusters to the API. When used as a part of
cluster enrollment, this field will differ from the ID in the resource
name. For new clusters, this field will match the user provided cluster ID
and be visible in the last component of the resource name. It is not
modifiable.

All users should use this name to access their cluster using gkectl or
kubectl and should expect to see the local name when viewing admin
cluster controller logs.`,
			},
			"reconciling": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `If set, there are currently changes in flight to the VMware User Cluster.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The current state of this cluster.`,
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `ResourceStatus representing detailed cluster state.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"conditions": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"last_transition_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Last time the condition transit from one status to another.`,
									},
									"message": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Human-readable message indicating details about last transition.`,
									},
									"reason": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Machine-readable message indicating details about last transition.`,
									},
									"state": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The lifecycle state of the condition.`,
									},
									"type": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Type of the condition.
(e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)`,
									},
								},
							},
						},
						"error_message": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Human-friendly representation of the error message from the user cluster
controller. The error message can be temporary as the user cluster
controller creates a cluster or node pool. If the error message persists
for a longer period of time, it can be used to surface error message to
indicate real problems requiring user intervention.`,
						},
					},
				},
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The unique identifier of the VMware User Cluster.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time at which VMware User Cluster was last updated.`,
			},
			"validation_check": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `ValidationCheck represents the result of the preflight check job.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"options": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Options used for the validation check.`,
						},
						"scenario": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The scenario when the preflight checks were run..`,
						},
						"status": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Specifies the detailed validation check status`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"result": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Individual checks which failed as part of the Preflight check execution.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"category": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The category of the validation.`,
												},
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The description of the validation check.`,
												},
												"details": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Detailed failure information, which might be unformatted.`,
												},
												"options": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Options used for the validation check.`,
												},
												"reason": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `A human-readable message of the check failure.`,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceGkeonpremVmwareClusterCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	adminClusterMembershipProp, err := expandGkeonpremVmwareClusterAdminClusterMembership(d.Get("admin_cluster_membership"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("admin_cluster_membership"); !tpgresource.IsEmptyValue(reflect.ValueOf(adminClusterMembershipProp)) && (ok || !reflect.DeepEqual(v, adminClusterMembershipProp)) {
		obj["adminClusterMembership"] = adminClusterMembershipProp
	}
	descriptionProp, err := expandGkeonpremVmwareClusterDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	onPremVersionProp, err := expandGkeonpremVmwareClusterOnPremVersion(d.Get("on_prem_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("on_prem_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(onPremVersionProp)) && (ok || !reflect.DeepEqual(v, onPremVersionProp)) {
		obj["onPremVersion"] = onPremVersionProp
	}
	controlPlaneNodeProp, err := expandGkeonpremVmwareClusterControlPlaneNode(d.Get("control_plane_node"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("control_plane_node"); !tpgresource.IsEmptyValue(reflect.ValueOf(controlPlaneNodeProp)) && (ok || !reflect.DeepEqual(v, controlPlaneNodeProp)) {
		obj["controlPlaneNode"] = controlPlaneNodeProp
	}
	antiAffinityGroupsProp, err := expandGkeonpremVmwareClusterAntiAffinityGroups(d.Get("anti_affinity_groups"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("anti_affinity_groups"); !tpgresource.IsEmptyValue(reflect.ValueOf(antiAffinityGroupsProp)) && (ok || !reflect.DeepEqual(v, antiAffinityGroupsProp)) {
		obj["antiAffinityGroups"] = antiAffinityGroupsProp
	}
	storageProp, err := expandGkeonpremVmwareClusterStorage(d.Get("storage"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("storage"); !tpgresource.IsEmptyValue(reflect.ValueOf(storageProp)) && (ok || !reflect.DeepEqual(v, storageProp)) {
		obj["storage"] = storageProp
	}
	networkConfigProp, err := expandGkeonpremVmwareClusterNetworkConfig(d.Get("network_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(networkConfigProp)) && (ok || !reflect.DeepEqual(v, networkConfigProp)) {
		obj["networkConfig"] = networkConfigProp
	}
	loadBalancerProp, err := expandGkeonpremVmwareClusterLoadBalancer(d.Get("load_balancer"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("load_balancer"); !tpgresource.IsEmptyValue(reflect.ValueOf(loadBalancerProp)) && (ok || !reflect.DeepEqual(v, loadBalancerProp)) {
		obj["loadBalancer"] = loadBalancerProp
	}
	dataplaneV2Prop, err := expandGkeonpremVmwareClusterDataplaneV2(d.Get("dataplane_v2"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dataplane_v2"); !tpgresource.IsEmptyValue(reflect.ValueOf(dataplaneV2Prop)) && (ok || !reflect.DeepEqual(v, dataplaneV2Prop)) {
		obj["dataplaneV2"] = dataplaneV2Prop
	}
	vmTrackingEnabledProp, err := expandGkeonpremVmwareClusterVmTrackingEnabled(d.Get("vm_tracking_enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vm_tracking_enabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(vmTrackingEnabledProp)) && (ok || !reflect.DeepEqual(v, vmTrackingEnabledProp)) {
		obj["vmTrackingEnabled"] = vmTrackingEnabledProp
	}
	autoRepairConfigProp, err := expandGkeonpremVmwareClusterAutoRepairConfig(d.Get("auto_repair_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_repair_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(autoRepairConfigProp)) && (ok || !reflect.DeepEqual(v, autoRepairConfigProp)) {
		obj["autoRepairConfig"] = autoRepairConfigProp
	}
	authorizationProp, err := expandGkeonpremVmwareClusterAuthorization(d.Get("authorization"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("authorization"); !tpgresource.IsEmptyValue(reflect.ValueOf(authorizationProp)) && (ok || !reflect.DeepEqual(v, authorizationProp)) {
		obj["authorization"] = authorizationProp
	}
	enableControlPlaneV2Prop, err := expandGkeonpremVmwareClusterEnableControlPlaneV2(d.Get("enable_control_plane_v2"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("enable_control_plane_v2"); !tpgresource.IsEmptyValue(reflect.ValueOf(enableControlPlaneV2Prop)) && (ok || !reflect.DeepEqual(v, enableControlPlaneV2Prop)) {
		obj["enableControlPlaneV2"] = enableControlPlaneV2Prop
	}
	upgradePolicyProp, err := expandGkeonpremVmwareClusterUpgradePolicy(d.Get("upgrade_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("upgrade_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(upgradePolicyProp)) && (ok || !reflect.DeepEqual(v, upgradePolicyProp)) {
		obj["upgradePolicy"] = upgradePolicyProp
	}
	vcenterProp, err := expandGkeonpremVmwareClusterVcenter(d.Get("vcenter"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vcenter"); !tpgresource.IsEmptyValue(reflect.ValueOf(vcenterProp)) && (ok || !reflect.DeepEqual(v, vcenterProp)) {
		obj["vcenter"] = vcenterProp
	}
	annotationsProp, err := expandGkeonpremVmwareClusterEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(annotationsProp)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GkeonpremBasePath}}projects/{{project}}/locations/{{location}}/vmwareClusters?vmware_cluster_id={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new VmwareCluster: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for VmwareCluster: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating VmwareCluster: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/vmwareClusters/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = GkeonpremOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating VmwareCluster", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error waiting to create VmwareCluster: %s", err)
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/vmwareClusters/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating VmwareCluster %q: %#v", d.Id(), res)

	return resourceGkeonpremVmwareClusterRead(d, meta)
}

func resourceGkeonpremVmwareClusterRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GkeonpremBasePath}}projects/{{project}}/locations/{{location}}/vmwareClusters/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for VmwareCluster: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("GkeonpremVmwareCluster %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}

	if err := d.Set("admin_cluster_membership", flattenGkeonpremVmwareClusterAdminClusterMembership(res["adminClusterMembership"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("description", flattenGkeonpremVmwareClusterDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("on_prem_version", flattenGkeonpremVmwareClusterOnPremVersion(res["onPremVersion"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("annotations", flattenGkeonpremVmwareClusterAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("control_plane_node", flattenGkeonpremVmwareClusterControlPlaneNode(res["controlPlaneNode"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("anti_affinity_groups", flattenGkeonpremVmwareClusterAntiAffinityGroups(res["antiAffinityGroups"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("storage", flattenGkeonpremVmwareClusterStorage(res["storage"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("network_config", flattenGkeonpremVmwareClusterNetworkConfig(res["networkConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("load_balancer", flattenGkeonpremVmwareClusterLoadBalancer(res["loadBalancer"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("dataplane_v2", flattenGkeonpremVmwareClusterDataplaneV2(res["dataplaneV2"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("vm_tracking_enabled", flattenGkeonpremVmwareClusterVmTrackingEnabled(res["vmTrackingEnabled"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("auto_repair_config", flattenGkeonpremVmwareClusterAutoRepairConfig(res["autoRepairConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("authorization", flattenGkeonpremVmwareClusterAuthorization(res["authorization"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("validation_check", flattenGkeonpremVmwareClusterValidationCheck(res["validationCheck"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("enable_control_plane_v2", flattenGkeonpremVmwareClusterEnableControlPlaneV2(res["enableControlPlaneV2"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("upgrade_policy", flattenGkeonpremVmwareClusterUpgradePolicy(res["upgradePolicy"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("uid", flattenGkeonpremVmwareClusterUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("state", flattenGkeonpremVmwareClusterState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("endpoint", flattenGkeonpremVmwareClusterEndpoint(res["endpoint"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("reconciling", flattenGkeonpremVmwareClusterReconciling(res["reconciling"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("create_time", flattenGkeonpremVmwareClusterCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("update_time", flattenGkeonpremVmwareClusterUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("delete_time", flattenGkeonpremVmwareClusterDeleteTime(res["deleteTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("local_name", flattenGkeonpremVmwareClusterLocalName(res["localName"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("etag", flattenGkeonpremVmwareClusterEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("fleet", flattenGkeonpremVmwareClusterFleet(res["fleet"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("vcenter", flattenGkeonpremVmwareClusterVcenter(res["vcenter"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("status", flattenGkeonpremVmwareClusterStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}
	if err := d.Set("effective_annotations", flattenGkeonpremVmwareClusterEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareCluster: %s", err)
	}

	return nil
}

func resourceGkeonpremVmwareClusterUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for VmwareCluster: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandGkeonpremVmwareClusterDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	onPremVersionProp, err := expandGkeonpremVmwareClusterOnPremVersion(d.Get("on_prem_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("on_prem_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, onPremVersionProp)) {
		obj["onPremVersion"] = onPremVersionProp
	}
	controlPlaneNodeProp, err := expandGkeonpremVmwareClusterControlPlaneNode(d.Get("control_plane_node"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("control_plane_node"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, controlPlaneNodeProp)) {
		obj["controlPlaneNode"] = controlPlaneNodeProp
	}
	antiAffinityGroupsProp, err := expandGkeonpremVmwareClusterAntiAffinityGroups(d.Get("anti_affinity_groups"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("anti_affinity_groups"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, antiAffinityGroupsProp)) {
		obj["antiAffinityGroups"] = antiAffinityGroupsProp
	}
	storageProp, err := expandGkeonpremVmwareClusterStorage(d.Get("storage"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("storage"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, storageProp)) {
		obj["storage"] = storageProp
	}
	networkConfigProp, err := expandGkeonpremVmwareClusterNetworkConfig(d.Get("network_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, networkConfigProp)) {
		obj["networkConfig"] = networkConfigProp
	}
	loadBalancerProp, err := expandGkeonpremVmwareClusterLoadBalancer(d.Get("load_balancer"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("load_balancer"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, loadBalancerProp)) {
		obj["loadBalancer"] = loadBalancerProp
	}
	dataplaneV2Prop, err := expandGkeonpremVmwareClusterDataplaneV2(d.Get("dataplane_v2"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dataplane_v2"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dataplaneV2Prop)) {
		obj["dataplaneV2"] = dataplaneV2Prop
	}
	vmTrackingEnabledProp, err := expandGkeonpremVmwareClusterVmTrackingEnabled(d.Get("vm_tracking_enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vm_tracking_enabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, vmTrackingEnabledProp)) {
		obj["vmTrackingEnabled"] = vmTrackingEnabledProp
	}
	autoRepairConfigProp, err := expandGkeonpremVmwareClusterAutoRepairConfig(d.Get("auto_repair_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_repair_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, autoRepairConfigProp)) {
		obj["autoRepairConfig"] = autoRepairConfigProp
	}
	authorizationProp, err := expandGkeonpremVmwareClusterAuthorization(d.Get("authorization"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("authorization"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, authorizationProp)) {
		obj["authorization"] = authorizationProp
	}
	enableControlPlaneV2Prop, err := expandGkeonpremVmwareClusterEnableControlPlaneV2(d.Get("enable_control_plane_v2"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("enable_control_plane_v2"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, enableControlPlaneV2Prop)) {
		obj["enableControlPlaneV2"] = enableControlPlaneV2Prop
	}
	upgradePolicyProp, err := expandGkeonpremVmwareClusterUpgradePolicy(d.Get("upgrade_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("upgrade_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, upgradePolicyProp)) {
		obj["upgradePolicy"] = upgradePolicyProp
	}
	vcenterProp, err := expandGkeonpremVmwareClusterVcenter(d.Get("vcenter"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("vcenter"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, vcenterProp)) {
		obj["vcenter"] = vcenterProp
	}
	annotationsProp, err := expandGkeonpremVmwareClusterEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GkeonpremBasePath}}projects/{{project}}/locations/{{location}}/vmwareClusters/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating VmwareCluster %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("on_prem_version") {
		updateMask = append(updateMask, "onPremVersion")
	}

	if d.HasChange("control_plane_node") {
		updateMask = append(updateMask, "controlPlaneNode")
	}

	if d.HasChange("anti_affinity_groups") {
		updateMask = append(updateMask, "antiAffinityGroups")
	}

	if d.HasChange("storage") {
		updateMask = append(updateMask, "storage")
	}

	if d.HasChange("network_config") {
		updateMask = append(updateMask, "networkConfig")
	}

	if d.HasChange("load_balancer") {
		updateMask = append(updateMask, "loadBalancer")
	}

	if d.HasChange("dataplane_v2") {
		updateMask = append(updateMask, "dataplaneV2")
	}

	if d.HasChange("vm_tracking_enabled") {
		updateMask = append(updateMask, "vmTrackingEnabled")
	}

	if d.HasChange("auto_repair_config") {
		updateMask = append(updateMask, "autoRepairConfig")
	}

	if d.HasChange("authorization") {
		updateMask = append(updateMask, "authorization")
	}

	if d.HasChange("enable_control_plane_v2") {
		updateMask = append(updateMask, "enableControlPlaneV2")
	}

	if d.HasChange("upgrade_policy") {
		updateMask = append(updateMask, "upgradePolicy")
	}

	if d.HasChange("vcenter") {
		updateMask = append(updateMask, "vcenter")
	}

	if d.HasChange("effective_annotations") {
		updateMask = append(updateMask, "annotations")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
		})

		if err != nil {
			return fmt.Errorf("Error updating VmwareCluster %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating VmwareCluster %q: %#v", d.Id(), res)
		}

		err = GkeonpremOperationWaitTime(
			config, res, project, "Updating VmwareCluster", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceGkeonpremVmwareClusterRead(d, meta)
}

func resourceGkeonpremVmwareClusterDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for VmwareCluster: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{GkeonpremBasePath}}projects/{{project}}/locations/{{location}}/vmwareClusters/{{name}}?force=true")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	log.Printf("[DEBUG] Deleting VmwareCluster %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "VmwareCluster")
	}

	err = GkeonpremOperationWaitTime(
		config, res, project, "Deleting VmwareCluster", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting VmwareCluster %q: %#v", d.Id(), res)
	return nil
}

func resourceGkeonpremVmwareClusterImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/vmwareClusters/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/vmwareClusters/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenGkeonpremVmwareClusterAdminClusterMembership(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterOnPremVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenGkeonpremVmwareClusterControlPlaneNode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cpus"] =
		flattenGkeonpremVmwareClusterControlPlaneNodeCpus(original["cpus"], d, config)
	transformed["memory"] =
		flattenGkeonpremVmwareClusterControlPlaneNodeMemory(original["memory"], d, config)
	transformed["replicas"] =
		flattenGkeonpremVmwareClusterControlPlaneNodeReplicas(original["replicas"], d, config)
	transformed["auto_resize_config"] =
		flattenGkeonpremVmwareClusterControlPlaneNodeAutoResizeConfig(original["autoResizeConfig"], d, config)
	transformed["vsphere_config"] =
		flattenGkeonpremVmwareClusterControlPlaneNodeVsphereConfig(original["vsphereConfig"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterControlPlaneNodeCpus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareClusterControlPlaneNodeMemory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareClusterControlPlaneNodeReplicas(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareClusterControlPlaneNodeAutoResizeConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenGkeonpremVmwareClusterControlPlaneNodeAutoResizeConfigEnabled(original["enabled"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterControlPlaneNodeAutoResizeConfigEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterControlPlaneNodeVsphereConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["datastore"] =
		flattenGkeonpremVmwareClusterControlPlaneNodeVsphereConfigDatastore(original["datastore"], d, config)
	transformed["storage_policy_name"] =
		flattenGkeonpremVmwareClusterControlPlaneNodeVsphereConfigStoragePolicyName(original["storagePolicyName"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterControlPlaneNodeVsphereConfigDatastore(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterControlPlaneNodeVsphereConfigStoragePolicyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterAntiAffinityGroups(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["aag_config_disabled"] =
		flattenGkeonpremVmwareClusterAntiAffinityGroupsAagConfigDisabled(original["aagConfigDisabled"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterAntiAffinityGroupsAagConfigDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterStorage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["vsphere_csi_disabled"] =
		flattenGkeonpremVmwareClusterStorageVsphereCsiDisabled(original["vsphereCsiDisabled"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterStorageVsphereCsiDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_address_cidr_blocks"] =
		flattenGkeonpremVmwareClusterNetworkConfigServiceAddressCidrBlocks(original["serviceAddressCidrBlocks"], d, config)
	transformed["pod_address_cidr_blocks"] =
		flattenGkeonpremVmwareClusterNetworkConfigPodAddressCidrBlocks(original["podAddressCidrBlocks"], d, config)
	transformed["static_ip_config"] =
		flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfig(original["staticIpConfig"], d, config)
	transformed["dhcp_ip_config"] =
		flattenGkeonpremVmwareClusterNetworkConfigDhcpIpConfig(original["dhcpIpConfig"], d, config)
	transformed["vcenter_network"] =
		flattenGkeonpremVmwareClusterNetworkConfigVcenterNetwork(original["vcenterNetwork"], d, config)
	transformed["host_config"] =
		flattenGkeonpremVmwareClusterNetworkConfigHostConfig(original["hostConfig"], d, config)
	transformed["control_plane_v2_config"] =
		flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2Config(original["controlPlaneV2Config"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterNetworkConfigServiceAddressCidrBlocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigPodAddressCidrBlocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ip_blocks"] =
		flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocks(original["ipBlocks"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"netmask": flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksNetmask(original["netmask"], d, config),
			"gateway": flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksGateway(original["gateway"], d, config),
			"ips":     flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIps(original["ips"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksNetmask(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksGateway(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ip":       flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIpsIp(original["ip"], d, config),
			"hostname": flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIpsHostname(original["hostname"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIpsIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIpsHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigDhcpIpConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenGkeonpremVmwareClusterNetworkConfigDhcpIpConfigEnabled(original["enabled"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterNetworkConfigDhcpIpConfigEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigVcenterNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigHostConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dns_servers"] =
		flattenGkeonpremVmwareClusterNetworkConfigHostConfigDnsServers(original["dnsServers"], d, config)
	transformed["ntp_servers"] =
		flattenGkeonpremVmwareClusterNetworkConfigHostConfigNtpServers(original["ntpServers"], d, config)
	transformed["dns_search_domains"] =
		flattenGkeonpremVmwareClusterNetworkConfigHostConfigDnsSearchDomains(original["dnsSearchDomains"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterNetworkConfigHostConfigDnsServers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigHostConfigNtpServers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigHostConfigDnsSearchDomains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2Config(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["control_plane_ip_block"] =
		flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock(original["controlPlaneIpBlock"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["netmask"] =
		flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockNetmask(original["netmask"], d, config)
	transformed["gateway"] =
		flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockGateway(original["gateway"], d, config)
	transformed["ips"] =
		flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIps(original["ips"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockNetmask(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockGateway(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ip":       flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpsIp(original["ip"], d, config),
			"hostname": flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpsHostname(original["hostname"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpsIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpsHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterLoadBalancer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["vip_config"] =
		flattenGkeonpremVmwareClusterLoadBalancerVipConfig(original["vipConfig"], d, config)
	transformed["f5_config"] =
		flattenGkeonpremVmwareClusterLoadBalancerF5Config(original["f5Config"], d, config)
	transformed["manual_lb_config"] =
		flattenGkeonpremVmwareClusterLoadBalancerManualLbConfig(original["manualLbConfig"], d, config)
	transformed["metal_lb_config"] =
		flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfig(original["metalLbConfig"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterLoadBalancerVipConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["control_plane_vip"] =
		flattenGkeonpremVmwareClusterLoadBalancerVipConfigControlPlaneVip(original["controlPlaneVip"], d, config)
	transformed["ingress_vip"] =
		flattenGkeonpremVmwareClusterLoadBalancerVipConfigIngressVip(original["ingressVip"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterLoadBalancerVipConfigControlPlaneVip(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterLoadBalancerVipConfigIngressVip(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterLoadBalancerF5Config(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["address"] =
		flattenGkeonpremVmwareClusterLoadBalancerF5ConfigAddress(original["address"], d, config)
	transformed["partition"] =
		flattenGkeonpremVmwareClusterLoadBalancerF5ConfigPartition(original["partition"], d, config)
	transformed["snat_pool"] =
		flattenGkeonpremVmwareClusterLoadBalancerF5ConfigSnatPool(original["snatPool"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterLoadBalancerF5ConfigAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterLoadBalancerF5ConfigPartition(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterLoadBalancerF5ConfigSnatPool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterLoadBalancerManualLbConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ingress_http_node_port"] =
		flattenGkeonpremVmwareClusterLoadBalancerManualLbConfigIngressHttpNodePort(original["ingressHttpNodePort"], d, config)
	transformed["ingress_https_node_port"] =
		flattenGkeonpremVmwareClusterLoadBalancerManualLbConfigIngressHttpsNodePort(original["ingressHttpsNodePort"], d, config)
	transformed["control_plane_node_port"] =
		flattenGkeonpremVmwareClusterLoadBalancerManualLbConfigControlPlaneNodePort(original["controlPlaneNodePort"], d, config)
	transformed["konnectivity_server_node_port"] =
		flattenGkeonpremVmwareClusterLoadBalancerManualLbConfigKonnectivityServerNodePort(original["konnectivityServerNodePort"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterLoadBalancerManualLbConfigIngressHttpNodePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareClusterLoadBalancerManualLbConfigIngressHttpsNodePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareClusterLoadBalancerManualLbConfigControlPlaneNodePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareClusterLoadBalancerManualLbConfigKonnectivityServerNodePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["address_pools"] =
		flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPools(original["addressPools"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPools(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"pool":            flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsPool(original["pool"], d, config),
			"addresses":       flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsAddresses(original["addresses"], d, config),
			"avoid_buggy_ips": flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsAvoidBuggyIps(original["avoidBuggyIps"], d, config),
			"manual_assign":   flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsManualAssign(original["manualAssign"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsPool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsAddresses(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsAvoidBuggyIps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsManualAssign(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterDataplaneV2(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dataplane_v2_enabled"] =
		flattenGkeonpremVmwareClusterDataplaneV2DataplaneV2Enabled(original["dataplaneV2Enabled"], d, config)
	transformed["windows_dataplane_v2_enabled"] =
		flattenGkeonpremVmwareClusterDataplaneV2WindowsDataplaneV2Enabled(original["windowsDataplaneV2Enabled"], d, config)
	transformed["advanced_networking"] =
		flattenGkeonpremVmwareClusterDataplaneV2AdvancedNetworking(original["advancedNetworking"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterDataplaneV2DataplaneV2Enabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterDataplaneV2WindowsDataplaneV2Enabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterDataplaneV2AdvancedNetworking(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterVmTrackingEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterAutoRepairConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenGkeonpremVmwareClusterAutoRepairConfigEnabled(original["enabled"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterAutoRepairConfigEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterAuthorization(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["admin_users"] =
		flattenGkeonpremVmwareClusterAuthorizationAdminUsers(original["adminUsers"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterAuthorizationAdminUsers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"username": flattenGkeonpremVmwareClusterAuthorizationAdminUsersUsername(original["username"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareClusterAuthorizationAdminUsersUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterValidationCheck(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["options"] =
		flattenGkeonpremVmwareClusterValidationCheckOptions(original["options"], d, config)
	transformed["status"] =
		flattenGkeonpremVmwareClusterValidationCheckStatus(original["status"], d, config)
	transformed["scenario"] =
		flattenGkeonpremVmwareClusterValidationCheckScenario(original["scenario"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterValidationCheckOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterValidationCheckStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["result"] =
		flattenGkeonpremVmwareClusterValidationCheckStatusResult(original["result"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterValidationCheckStatusResult(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"options":     flattenGkeonpremVmwareClusterValidationCheckStatusResultOptions(original["options"], d, config),
			"description": flattenGkeonpremVmwareClusterValidationCheckStatusResultDescription(original["description"], d, config),
			"category":    flattenGkeonpremVmwareClusterValidationCheckStatusResultCategory(original["category"], d, config),
			"reason":      flattenGkeonpremVmwareClusterValidationCheckStatusResultReason(original["reason"], d, config),
			"details":     flattenGkeonpremVmwareClusterValidationCheckStatusResultDetails(original["details"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareClusterValidationCheckStatusResultOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterValidationCheckStatusResultDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterValidationCheckStatusResultCategory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterValidationCheckStatusResultReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterValidationCheckStatusResultDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterValidationCheckScenario(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterEnableControlPlaneV2(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterUpgradePolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["control_plane_only"] =
		flattenGkeonpremVmwareClusterUpgradePolicyControlPlaneOnly(original["controlPlaneOnly"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterUpgradePolicyControlPlaneOnly(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterReconciling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterDeleteTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterLocalName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterFleet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["membership"] =
		flattenGkeonpremVmwareClusterFleetMembership(original["membership"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterFleetMembership(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterVcenter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["resource_pool"] =
		flattenGkeonpremVmwareClusterVcenterResourcePool(original["resourcePool"], d, config)
	transformed["datastore"] =
		flattenGkeonpremVmwareClusterVcenterDatastore(original["datastore"], d, config)
	transformed["datacenter"] =
		flattenGkeonpremVmwareClusterVcenterDatacenter(original["datacenter"], d, config)
	transformed["cluster"] =
		flattenGkeonpremVmwareClusterVcenterCluster(original["cluster"], d, config)
	transformed["folder"] =
		flattenGkeonpremVmwareClusterVcenterFolder(original["folder"], d, config)
	transformed["ca_cert_data"] =
		flattenGkeonpremVmwareClusterVcenterCaCertData(original["caCertData"], d, config)
	transformed["address"] =
		flattenGkeonpremVmwareClusterVcenterAddress(original["address"], d, config)
	transformed["storage_policy_name"] =
		flattenGkeonpremVmwareClusterVcenterStoragePolicyName(original["storagePolicyName"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterVcenterResourcePool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterVcenterDatastore(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterVcenterDatacenter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterVcenterCluster(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterVcenterFolder(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterVcenterCaCertData(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterVcenterAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterVcenterStoragePolicyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error_message"] =
		flattenGkeonpremVmwareClusterStatusErrorMessage(original["errorMessage"], d, config)
	transformed["conditions"] =
		flattenGkeonpremVmwareClusterStatusConditions(original["conditions"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareClusterStatusErrorMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterStatusConditions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":                 flattenGkeonpremVmwareClusterStatusConditionsType(original["type"], d, config),
			"reason":               flattenGkeonpremVmwareClusterStatusConditionsReason(original["reason"], d, config),
			"message":              flattenGkeonpremVmwareClusterStatusConditionsMessage(original["message"], d, config),
			"last_transition_time": flattenGkeonpremVmwareClusterStatusConditionsLastTransitionTime(original["lastTransitionTime"], d, config),
			"state":                flattenGkeonpremVmwareClusterStatusConditionsState(original["state"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareClusterStatusConditionsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterStatusConditionsReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterStatusConditionsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterStatusConditionsLastTransitionTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterStatusConditionsState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareClusterEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandGkeonpremVmwareClusterAdminClusterMembership(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterOnPremVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterControlPlaneNode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCpus, err := expandGkeonpremVmwareClusterControlPlaneNodeCpus(original["cpus"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCpus); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cpus"] = transformedCpus
	}

	transformedMemory, err := expandGkeonpremVmwareClusterControlPlaneNodeMemory(original["memory"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMemory); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["memory"] = transformedMemory
	}

	transformedReplicas, err := expandGkeonpremVmwareClusterControlPlaneNodeReplicas(original["replicas"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReplicas); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["replicas"] = transformedReplicas
	}

	transformedAutoResizeConfig, err := expandGkeonpremVmwareClusterControlPlaneNodeAutoResizeConfig(original["auto_resize_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAutoResizeConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["autoResizeConfig"] = transformedAutoResizeConfig
	}

	transformedVsphereConfig, err := expandGkeonpremVmwareClusterControlPlaneNodeVsphereConfig(original["vsphere_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVsphereConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vsphereConfig"] = transformedVsphereConfig
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterControlPlaneNodeCpus(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterControlPlaneNodeMemory(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterControlPlaneNodeReplicas(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterControlPlaneNodeAutoResizeConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandGkeonpremVmwareClusterControlPlaneNodeAutoResizeConfigEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterControlPlaneNodeAutoResizeConfigEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterControlPlaneNodeVsphereConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDatastore, err := expandGkeonpremVmwareClusterControlPlaneNodeVsphereConfigDatastore(original["datastore"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatastore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["datastore"] = transformedDatastore
	}

	transformedStoragePolicyName, err := expandGkeonpremVmwareClusterControlPlaneNodeVsphereConfigStoragePolicyName(original["storage_policy_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStoragePolicyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["storagePolicyName"] = transformedStoragePolicyName
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterControlPlaneNodeVsphereConfigDatastore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterControlPlaneNodeVsphereConfigStoragePolicyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterAntiAffinityGroups(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAagConfigDisabled, err := expandGkeonpremVmwareClusterAntiAffinityGroupsAagConfigDisabled(original["aag_config_disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAagConfigDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["aagConfigDisabled"] = transformedAagConfigDisabled
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterAntiAffinityGroupsAagConfigDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterStorage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedVsphereCsiDisabled, err := expandGkeonpremVmwareClusterStorageVsphereCsiDisabled(original["vsphere_csi_disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVsphereCsiDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vsphereCsiDisabled"] = transformedVsphereCsiDisabled
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterStorageVsphereCsiDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServiceAddressCidrBlocks, err := expandGkeonpremVmwareClusterNetworkConfigServiceAddressCidrBlocks(original["service_address_cidr_blocks"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAddressCidrBlocks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAddressCidrBlocks"] = transformedServiceAddressCidrBlocks
	}

	transformedPodAddressCidrBlocks, err := expandGkeonpremVmwareClusterNetworkConfigPodAddressCidrBlocks(original["pod_address_cidr_blocks"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPodAddressCidrBlocks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["podAddressCidrBlocks"] = transformedPodAddressCidrBlocks
	}

	transformedStaticIpConfig, err := expandGkeonpremVmwareClusterNetworkConfigStaticIpConfig(original["static_ip_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStaticIpConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["staticIpConfig"] = transformedStaticIpConfig
	}

	transformedDhcpIpConfig, err := expandGkeonpremVmwareClusterNetworkConfigDhcpIpConfig(original["dhcp_ip_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDhcpIpConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dhcpIpConfig"] = transformedDhcpIpConfig
	}

	transformedVcenterNetwork, err := expandGkeonpremVmwareClusterNetworkConfigVcenterNetwork(original["vcenter_network"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVcenterNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vcenterNetwork"] = transformedVcenterNetwork
	}

	transformedHostConfig, err := expandGkeonpremVmwareClusterNetworkConfigHostConfig(original["host_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostConfig"] = transformedHostConfig
	}

	transformedControlPlaneV2Config, err := expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2Config(original["control_plane_v2_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedControlPlaneV2Config); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["controlPlaneV2Config"] = transformedControlPlaneV2Config
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterNetworkConfigServiceAddressCidrBlocks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigPodAddressCidrBlocks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigStaticIpConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIpBlocks, err := expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocks(original["ip_blocks"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIpBlocks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ipBlocks"] = transformedIpBlocks
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedNetmask, err := expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksNetmask(original["netmask"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetmask); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["netmask"] = transformedNetmask
		}

		transformedGateway, err := expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksGateway(original["gateway"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedGateway); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["gateway"] = transformedGateway
		}

		transformedIps, err := expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIps(original["ips"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ips"] = transformedIps
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksNetmask(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksGateway(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedIp, err := expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIpsIp(original["ip"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ip"] = transformedIp
		}

		transformedHostname, err := expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIpsHostname(original["hostname"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hostname"] = transformedHostname
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIpsIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigStaticIpConfigIpBlocksIpsHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigDhcpIpConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandGkeonpremVmwareClusterNetworkConfigDhcpIpConfigEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterNetworkConfigDhcpIpConfigEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigVcenterNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigHostConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDnsServers, err := expandGkeonpremVmwareClusterNetworkConfigHostConfigDnsServers(original["dns_servers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDnsServers); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dnsServers"] = transformedDnsServers
	}

	transformedNtpServers, err := expandGkeonpremVmwareClusterNetworkConfigHostConfigNtpServers(original["ntp_servers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNtpServers); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ntpServers"] = transformedNtpServers
	}

	transformedDnsSearchDomains, err := expandGkeonpremVmwareClusterNetworkConfigHostConfigDnsSearchDomains(original["dns_search_domains"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDnsSearchDomains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dnsSearchDomains"] = transformedDnsSearchDomains
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterNetworkConfigHostConfigDnsServers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigHostConfigNtpServers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigHostConfigDnsSearchDomains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2Config(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedControlPlaneIpBlock, err := expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock(original["control_plane_ip_block"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedControlPlaneIpBlock); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["controlPlaneIpBlock"] = transformedControlPlaneIpBlock
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNetmask, err := expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockNetmask(original["netmask"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetmask); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["netmask"] = transformedNetmask
	}

	transformedGateway, err := expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockGateway(original["gateway"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGateway); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gateway"] = transformedGateway
	}

	transformedIps, err := expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIps(original["ips"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ips"] = transformedIps
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockNetmask(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockGateway(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedIp, err := expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpsIp(original["ip"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ip"] = transformedIp
		}

		transformedHostname, err := expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpsHostname(original["hostname"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hostname"] = transformedHostname
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpsIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpsHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancer(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedVipConfig, err := expandGkeonpremVmwareClusterLoadBalancerVipConfig(original["vip_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVipConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vipConfig"] = transformedVipConfig
	}

	transformedF5Config, err := expandGkeonpremVmwareClusterLoadBalancerF5Config(original["f5_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedF5Config); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["f5Config"] = transformedF5Config
	}

	transformedManualLbConfig, err := expandGkeonpremVmwareClusterLoadBalancerManualLbConfig(original["manual_lb_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedManualLbConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["manualLbConfig"] = transformedManualLbConfig
	}

	transformedMetalLbConfig, err := expandGkeonpremVmwareClusterLoadBalancerMetalLbConfig(original["metal_lb_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMetalLbConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["metalLbConfig"] = transformedMetalLbConfig
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterLoadBalancerVipConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedControlPlaneVip, err := expandGkeonpremVmwareClusterLoadBalancerVipConfigControlPlaneVip(original["control_plane_vip"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedControlPlaneVip); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["controlPlaneVip"] = transformedControlPlaneVip
	}

	transformedIngressVip, err := expandGkeonpremVmwareClusterLoadBalancerVipConfigIngressVip(original["ingress_vip"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIngressVip); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ingressVip"] = transformedIngressVip
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterLoadBalancerVipConfigControlPlaneVip(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerVipConfigIngressVip(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerF5Config(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAddress, err := expandGkeonpremVmwareClusterLoadBalancerF5ConfigAddress(original["address"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAddress); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["address"] = transformedAddress
	}

	transformedPartition, err := expandGkeonpremVmwareClusterLoadBalancerF5ConfigPartition(original["partition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPartition); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["partition"] = transformedPartition
	}

	transformedSnatPool, err := expandGkeonpremVmwareClusterLoadBalancerF5ConfigSnatPool(original["snat_pool"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSnatPool); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["snatPool"] = transformedSnatPool
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterLoadBalancerF5ConfigAddress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerF5ConfigPartition(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerF5ConfigSnatPool(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerManualLbConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIngressHttpNodePort, err := expandGkeonpremVmwareClusterLoadBalancerManualLbConfigIngressHttpNodePort(original["ingress_http_node_port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIngressHttpNodePort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ingressHttpNodePort"] = transformedIngressHttpNodePort
	}

	transformedIngressHttpsNodePort, err := expandGkeonpremVmwareClusterLoadBalancerManualLbConfigIngressHttpsNodePort(original["ingress_https_node_port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIngressHttpsNodePort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ingressHttpsNodePort"] = transformedIngressHttpsNodePort
	}

	transformedControlPlaneNodePort, err := expandGkeonpremVmwareClusterLoadBalancerManualLbConfigControlPlaneNodePort(original["control_plane_node_port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedControlPlaneNodePort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["controlPlaneNodePort"] = transformedControlPlaneNodePort
	}

	transformedKonnectivityServerNodePort, err := expandGkeonpremVmwareClusterLoadBalancerManualLbConfigKonnectivityServerNodePort(original["konnectivity_server_node_port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKonnectivityServerNodePort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["konnectivityServerNodePort"] = transformedKonnectivityServerNodePort
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterLoadBalancerManualLbConfigIngressHttpNodePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerManualLbConfigIngressHttpsNodePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerManualLbConfigControlPlaneNodePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerManualLbConfigKonnectivityServerNodePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerMetalLbConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAddressPools, err := expandGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPools(original["address_pools"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAddressPools); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["addressPools"] = transformedAddressPools
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPools(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedPool, err := expandGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsPool(original["pool"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPool); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["pool"] = transformedPool
		}

		transformedAddresses, err := expandGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsAddresses(original["addresses"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAddresses); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["addresses"] = transformedAddresses
		}

		transformedAvoidBuggyIps, err := expandGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsAvoidBuggyIps(original["avoid_buggy_ips"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAvoidBuggyIps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["avoidBuggyIps"] = transformedAvoidBuggyIps
		}

		transformedManualAssign, err := expandGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsManualAssign(original["manual_assign"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedManualAssign); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["manualAssign"] = transformedManualAssign
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsPool(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsAddresses(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsAvoidBuggyIps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterLoadBalancerMetalLbConfigAddressPoolsManualAssign(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterDataplaneV2(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDataplaneV2Enabled, err := expandGkeonpremVmwareClusterDataplaneV2DataplaneV2Enabled(original["dataplane_v2_enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataplaneV2Enabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataplaneV2Enabled"] = transformedDataplaneV2Enabled
	}

	transformedWindowsDataplaneV2Enabled, err := expandGkeonpremVmwareClusterDataplaneV2WindowsDataplaneV2Enabled(original["windows_dataplane_v2_enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWindowsDataplaneV2Enabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["windowsDataplaneV2Enabled"] = transformedWindowsDataplaneV2Enabled
	}

	transformedAdvancedNetworking, err := expandGkeonpremVmwareClusterDataplaneV2AdvancedNetworking(original["advanced_networking"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdvancedNetworking); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["advancedNetworking"] = transformedAdvancedNetworking
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterDataplaneV2DataplaneV2Enabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterDataplaneV2WindowsDataplaneV2Enabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterDataplaneV2AdvancedNetworking(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterVmTrackingEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterAutoRepairConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandGkeonpremVmwareClusterAutoRepairConfigEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterAutoRepairConfigEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterAuthorization(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAdminUsers, err := expandGkeonpremVmwareClusterAuthorizationAdminUsers(original["admin_users"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdminUsers); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["adminUsers"] = transformedAdminUsers
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterAuthorizationAdminUsers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedUsername, err := expandGkeonpremVmwareClusterAuthorizationAdminUsersUsername(original["username"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["username"] = transformedUsername
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareClusterAuthorizationAdminUsersUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterEnableControlPlaneV2(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterUpgradePolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedControlPlaneOnly, err := expandGkeonpremVmwareClusterUpgradePolicyControlPlaneOnly(original["control_plane_only"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedControlPlaneOnly); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["controlPlaneOnly"] = transformedControlPlaneOnly
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterUpgradePolicyControlPlaneOnly(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterVcenter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedResourcePool, err := expandGkeonpremVmwareClusterVcenterResourcePool(original["resource_pool"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResourcePool); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["resourcePool"] = transformedResourcePool
	}

	transformedDatastore, err := expandGkeonpremVmwareClusterVcenterDatastore(original["datastore"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatastore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["datastore"] = transformedDatastore
	}

	transformedDatacenter, err := expandGkeonpremVmwareClusterVcenterDatacenter(original["datacenter"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatacenter); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["datacenter"] = transformedDatacenter
	}

	transformedCluster, err := expandGkeonpremVmwareClusterVcenterCluster(original["cluster"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCluster); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cluster"] = transformedCluster
	}

	transformedFolder, err := expandGkeonpremVmwareClusterVcenterFolder(original["folder"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFolder); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["folder"] = transformedFolder
	}

	transformedCaCertData, err := expandGkeonpremVmwareClusterVcenterCaCertData(original["ca_cert_data"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCertData); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCertData"] = transformedCaCertData
	}

	transformedAddress, err := expandGkeonpremVmwareClusterVcenterAddress(original["address"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAddress); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["address"] = transformedAddress
	}

	transformedStoragePolicyName, err := expandGkeonpremVmwareClusterVcenterStoragePolicyName(original["storage_policy_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStoragePolicyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["storagePolicyName"] = transformedStoragePolicyName
	}

	return transformed, nil
}

func expandGkeonpremVmwareClusterVcenterResourcePool(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterVcenterDatastore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterVcenterDatacenter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterVcenterCluster(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterVcenterFolder(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterVcenterCaCertData(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterVcenterAddress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterVcenterStoragePolicyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareClusterEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
