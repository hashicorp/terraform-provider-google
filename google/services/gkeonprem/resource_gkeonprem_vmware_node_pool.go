// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package gkeonprem

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceGkeonpremVmwareNodePool() *schema.Resource {
	return &schema.Resource{
		Create: resourceGkeonpremVmwareNodePoolCreate,
		Read:   resourceGkeonpremVmwareNodePoolRead,
		Update: resourceGkeonpremVmwareNodePoolUpdate,
		Delete: resourceGkeonpremVmwareNodePoolDelete,

		Importer: &schema.ResourceImporter{
			State: resourceGkeonpremVmwareNodePoolImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(60 * time.Minute),
			Update: schema.DefaultTimeout(60 * time.Minute),
			Delete: schema.DefaultTimeout(60 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"config": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `The node configuration of the node pool.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"image_type": {
							Type:     schema.TypeString,
							Required: true,
							Description: `The OS image to be used for each node in a node pool.
Currently 'cos', 'ubuntu', 'ubuntu_containerd' and 'windows' are supported.`,
						},
						"boot_disk_size_gb": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `VMware disk size to be used during creation.`,
						},
						"cpus": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `The number of CPUs for each node in the node pool.`,
							Default:     4,
						},
						"enable_load_balancer": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Allow node pool traffic to be load balanced. Only works for clusters with
MetalLB load balancers.`,
						},
						"image": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The OS image name in vCenter, only valid when using Windows.`,
						},
						"labels": {
							Type:     schema.TypeMap,
							Computed: true,
							Optional: true,
							Description: `The map of Kubernetes labels (key/value pairs) to be applied to each node.
These will added in addition to any default label(s) that
Kubernetes may apply to the node.
In case of conflict in label keys, the applied set may differ depending on
the Kubernetes version -- it's best to assume the behavior is undefined
and conflicts should be avoided.`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"memory_mb": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `The megabytes of memory for each node in the node pool.`,
							Default:     8192,
						},
						"replicas": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `The number of nodes in the node pool.`,
							Default:     1,
						},
						"taints": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The initial taints assigned to nodes of this node pool.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Key associated with the effect.`,
									},
									"value": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Value associated with the effect.`,
									},
									"effect": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"EFFECT_UNSPECIFIED", "NO_SCHEDULE", "PREFER_NO_SCHEDULE", "NO_EXECUTE", ""}),
										Description:  `Available taint effects. Possible values: ["EFFECT_UNSPECIFIED", "NO_SCHEDULE", "PREFER_NO_SCHEDULE", "NO_EXECUTE"]`,
									},
								},
							},
						},
						"vsphere_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Specifies the vSphere config for node pool.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"datastore": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The name of the vCenter datastore. Inherited from the user cluster.`,
									},
									"host_groups": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Vsphere host groups to apply to all VMs in the node pool`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"tags": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Tags to apply to VMs.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"category": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The Vsphere tag category.`,
												},
												"tag": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The Vsphere tag name.`,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the resource.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The vmware node pool name.`,
			},
			"vmware_cluster": {
				Type:             schema.TypeString,
				Required:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description:      `The cluster this node pool belongs to.`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Annotations on the node Pool.
This field has the same restrictions as Kubernetes annotations.
The total size of all keys and values combined is limited to 256k.
Key can have 2 segments: prefix (optional) and name (required),
separated by a slash (/).
Prefix must be a DNS subdomain.
Name must be 63 characters or less, begin and end with alphanumerics,
with dashes (-), underscores (_), dots (.), and alphanumerics between.


**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"display_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The display name for the node pool.`,
			},
			"node_pool_autoscaling": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Node Pool autoscaling config for the node pool.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"max_replicas": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: `Maximum number of replicas in the NodePool.`,
						},
						"min_replicas": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: `Minimum number of replicas in the NodePool.`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time the cluster was created, in RFC3339 text format.`,
			},
			"delete_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time the cluster was deleted, in RFC3339 text format.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `This checksum is computed by the server based on the value of other
fields, and may be sent on update and delete requests to ensure the
client has an up-to-date value before proceeding.
Allows clients to perform consistent read-modify-writes
through optimistic concurrency control.`,
			},
			"on_prem_version": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Anthos version for the node pool. Defaults to the user cluster version.`,
			},
			"reconciling": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `If set, there are currently changes in flight to the node pool.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The current state of this cluster.`,
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `ResourceStatus representing detailed cluster state.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"conditions": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"last_transition_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Last time the condition transit from one status to another.`,
									},
									"message": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Human-readable message indicating details about last transition.`,
									},
									"reason": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Machine-readable message indicating details about last transition.`,
									},
									"state": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The lifecycle state of the condition.`,
									},
									"type": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Type of the condition.
(e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)`,
									},
								},
							},
						},
						"error_message": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Human-friendly representation of the error message from the user cluster
controller. The error message can be temporary as the user cluster
controller creates a cluster or node pool. If the error message persists
for a longer period of time, it can be used to surface error message to
indicate real problems requiring user intervention.`,
						},
					},
				},
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The unique identifier of the node pool.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time the cluster was last updated, in RFC3339 text format.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceGkeonpremVmwareNodePoolCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandGkeonpremVmwareNodePoolDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	nodePoolAutoscalingProp, err := expandGkeonpremVmwareNodePoolNodePoolAutoscaling(d.Get("node_pool_autoscaling"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("node_pool_autoscaling"); !tpgresource.IsEmptyValue(reflect.ValueOf(nodePoolAutoscalingProp)) && (ok || !reflect.DeepEqual(v, nodePoolAutoscalingProp)) {
		obj["nodePoolAutoscaling"] = nodePoolAutoscalingProp
	}
	configProp, err := expandGkeonpremVmwareNodePoolConfig(d.Get("config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("config"); !tpgresource.IsEmptyValue(reflect.ValueOf(configProp)) && (ok || !reflect.DeepEqual(v, configProp)) {
		obj["config"] = configProp
	}
	annotationsProp, err := expandGkeonpremVmwareNodePoolEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(annotationsProp)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GkeonpremBasePath}}projects/{{project}}/locations/{{location}}/vmwareClusters/{{vmware_cluster}}/vmwareNodePools?vmware_node_pool_id={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new VmwareNodePool: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for VmwareNodePool: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating VmwareNodePool: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/vmwareClusters/{{vmware_cluster}}/vmwareNodePools/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = GkeonpremOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating VmwareNodePool", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error waiting to create VmwareNodePool: %s", err)
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/vmwareClusters/{{vmware_cluster}}/vmwareNodePools/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating VmwareNodePool %q: %#v", d.Id(), res)

	return resourceGkeonpremVmwareNodePoolRead(d, meta)
}

func resourceGkeonpremVmwareNodePoolRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GkeonpremBasePath}}projects/{{project}}/locations/{{location}}/vmwareClusters/{{vmware_cluster}}/vmwareNodePools/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for VmwareNodePool: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("GkeonpremVmwareNodePool %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}

	if err := d.Set("display_name", flattenGkeonpremVmwareNodePoolDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("annotations", flattenGkeonpremVmwareNodePoolAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("node_pool_autoscaling", flattenGkeonpremVmwareNodePoolNodePoolAutoscaling(res["nodePoolAutoscaling"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("config", flattenGkeonpremVmwareNodePoolConfig(res["config"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("status", flattenGkeonpremVmwareNodePoolStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("uid", flattenGkeonpremVmwareNodePoolUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("state", flattenGkeonpremVmwareNodePoolState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("reconciling", flattenGkeonpremVmwareNodePoolReconciling(res["reconciling"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("create_time", flattenGkeonpremVmwareNodePoolCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("update_time", flattenGkeonpremVmwareNodePoolUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("delete_time", flattenGkeonpremVmwareNodePoolDeleteTime(res["deleteTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("etag", flattenGkeonpremVmwareNodePoolEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("on_prem_version", flattenGkeonpremVmwareNodePoolOnPremVersion(res["onPremVersion"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}
	if err := d.Set("effective_annotations", flattenGkeonpremVmwareNodePoolEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading VmwareNodePool: %s", err)
	}

	return nil
}

func resourceGkeonpremVmwareNodePoolUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for VmwareNodePool: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	displayNameProp, err := expandGkeonpremVmwareNodePoolDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	nodePoolAutoscalingProp, err := expandGkeonpremVmwareNodePoolNodePoolAutoscaling(d.Get("node_pool_autoscaling"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("node_pool_autoscaling"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nodePoolAutoscalingProp)) {
		obj["nodePoolAutoscaling"] = nodePoolAutoscalingProp
	}
	configProp, err := expandGkeonpremVmwareNodePoolConfig(d.Get("config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, configProp)) {
		obj["config"] = configProp
	}
	annotationsProp, err := expandGkeonpremVmwareNodePoolEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{GkeonpremBasePath}}projects/{{project}}/locations/{{location}}/vmwareClusters/{{vmware_cluster}}/vmwareNodePools/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating VmwareNodePool %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("node_pool_autoscaling") {
		updateMask = append(updateMask, "nodePoolAutoscaling")
	}

	if d.HasChange("config") {
		updateMask = append(updateMask, "config")
	}

	if d.HasChange("effective_annotations") {
		updateMask = append(updateMask, "annotations")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
		})

		if err != nil {
			return fmt.Errorf("Error updating VmwareNodePool %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating VmwareNodePool %q: %#v", d.Id(), res)
		}

		err = GkeonpremOperationWaitTime(
			config, res, project, "Updating VmwareNodePool", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceGkeonpremVmwareNodePoolRead(d, meta)
}

func resourceGkeonpremVmwareNodePoolDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for VmwareNodePool: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{GkeonpremBasePath}}projects/{{project}}/locations/{{location}}/vmwareClusters/{{vmware_cluster}}/vmwareNodePools/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	log.Printf("[DEBUG] Deleting VmwareNodePool %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "VmwareNodePool")
	}

	err = GkeonpremOperationWaitTime(
		config, res, project, "Deleting VmwareNodePool", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting VmwareNodePool %q: %#v", d.Id(), res)
	return nil
}

func resourceGkeonpremVmwareNodePoolImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/vmwareClusters/(?P<vmware_cluster>[^/]+)/vmwareNodePools/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<vmware_cluster>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<vmware_cluster>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/vmwareClusters/{{vmware_cluster}}/vmwareNodePools/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenGkeonpremVmwareNodePoolDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenGkeonpremVmwareNodePoolNodePoolAutoscaling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["min_replicas"] =
		flattenGkeonpremVmwareNodePoolNodePoolAutoscalingMinReplicas(original["minReplicas"], d, config)
	transformed["max_replicas"] =
		flattenGkeonpremVmwareNodePoolNodePoolAutoscalingMaxReplicas(original["maxReplicas"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareNodePoolNodePoolAutoscalingMinReplicas(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareNodePoolNodePoolAutoscalingMaxReplicas(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareNodePoolConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cpus"] =
		flattenGkeonpremVmwareNodePoolConfigCpus(original["cpus"], d, config)
	transformed["memory_mb"] =
		flattenGkeonpremVmwareNodePoolConfigMemoryMb(original["memoryMb"], d, config)
	transformed["replicas"] =
		flattenGkeonpremVmwareNodePoolConfigReplicas(original["replicas"], d, config)
	transformed["image_type"] =
		flattenGkeonpremVmwareNodePoolConfigImageType(original["imageType"], d, config)
	transformed["image"] =
		flattenGkeonpremVmwareNodePoolConfigImage(original["image"], d, config)
	transformed["boot_disk_size_gb"] =
		flattenGkeonpremVmwareNodePoolConfigBootDiskSizeGb(original["bootDiskSizeGb"], d, config)
	transformed["taints"] =
		flattenGkeonpremVmwareNodePoolConfigTaints(original["taints"], d, config)
	transformed["labels"] =
		flattenGkeonpremVmwareNodePoolConfigLabels(original["labels"], d, config)
	transformed["vsphere_config"] =
		flattenGkeonpremVmwareNodePoolConfigVsphereConfig(original["vsphereConfig"], d, config)
	transformed["enable_load_balancer"] =
		flattenGkeonpremVmwareNodePoolConfigEnableLoadBalancer(original["enableLoadBalancer"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareNodePoolConfigCpus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareNodePoolConfigMemoryMb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareNodePoolConfigReplicas(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareNodePoolConfigImageType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolConfigImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolConfigBootDiskSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenGkeonpremVmwareNodePoolConfigTaints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":    flattenGkeonpremVmwareNodePoolConfigTaintsKey(original["key"], d, config),
			"value":  flattenGkeonpremVmwareNodePoolConfigTaintsValue(original["value"], d, config),
			"effect": flattenGkeonpremVmwareNodePoolConfigTaintsEffect(original["effect"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareNodePoolConfigTaintsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolConfigTaintsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolConfigTaintsEffect(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolConfigLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolConfigVsphereConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["datastore"] =
		flattenGkeonpremVmwareNodePoolConfigVsphereConfigDatastore(original["datastore"], d, config)
	transformed["tags"] =
		flattenGkeonpremVmwareNodePoolConfigVsphereConfigTags(original["tags"], d, config)
	transformed["host_groups"] =
		flattenGkeonpremVmwareNodePoolConfigVsphereConfigHostGroups(original["hostGroups"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareNodePoolConfigVsphereConfigDatastore(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolConfigVsphereConfigTags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"category": flattenGkeonpremVmwareNodePoolConfigVsphereConfigTagsCategory(original["category"], d, config),
			"tag":      flattenGkeonpremVmwareNodePoolConfigVsphereConfigTagsTag(original["tag"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareNodePoolConfigVsphereConfigTagsCategory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolConfigVsphereConfigTagsTag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolConfigVsphereConfigHostGroups(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolConfigEnableLoadBalancer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error_message"] =
		flattenGkeonpremVmwareNodePoolStatusErrorMessage(original["errorMessage"], d, config)
	transformed["conditions"] =
		flattenGkeonpremVmwareNodePoolStatusConditions(original["conditions"], d, config)
	return []interface{}{transformed}
}
func flattenGkeonpremVmwareNodePoolStatusErrorMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolStatusConditions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":                 flattenGkeonpremVmwareNodePoolStatusConditionsType(original["type"], d, config),
			"reason":               flattenGkeonpremVmwareNodePoolStatusConditionsReason(original["reason"], d, config),
			"message":              flattenGkeonpremVmwareNodePoolStatusConditionsMessage(original["message"], d, config),
			"last_transition_time": flattenGkeonpremVmwareNodePoolStatusConditionsLastTransitionTime(original["lastTransitionTime"], d, config),
			"state":                flattenGkeonpremVmwareNodePoolStatusConditionsState(original["state"], d, config),
		})
	}
	return transformed
}
func flattenGkeonpremVmwareNodePoolStatusConditionsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolStatusConditionsReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolStatusConditionsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolStatusConditionsLastTransitionTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolStatusConditionsState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolReconciling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolDeleteTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolOnPremVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenGkeonpremVmwareNodePoolEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandGkeonpremVmwareNodePoolDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolNodePoolAutoscaling(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMinReplicas, err := expandGkeonpremVmwareNodePoolNodePoolAutoscalingMinReplicas(original["min_replicas"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinReplicas); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minReplicas"] = transformedMinReplicas
	}

	transformedMaxReplicas, err := expandGkeonpremVmwareNodePoolNodePoolAutoscalingMaxReplicas(original["max_replicas"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxReplicas); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxReplicas"] = transformedMaxReplicas
	}

	return transformed, nil
}

func expandGkeonpremVmwareNodePoolNodePoolAutoscalingMinReplicas(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolNodePoolAutoscalingMaxReplicas(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCpus, err := expandGkeonpremVmwareNodePoolConfigCpus(original["cpus"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCpus); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cpus"] = transformedCpus
	}

	transformedMemoryMb, err := expandGkeonpremVmwareNodePoolConfigMemoryMb(original["memory_mb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMemoryMb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["memoryMb"] = transformedMemoryMb
	}

	transformedReplicas, err := expandGkeonpremVmwareNodePoolConfigReplicas(original["replicas"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReplicas); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["replicas"] = transformedReplicas
	}

	transformedImageType, err := expandGkeonpremVmwareNodePoolConfigImageType(original["image_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedImageType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["imageType"] = transformedImageType
	}

	transformedImage, err := expandGkeonpremVmwareNodePoolConfigImage(original["image"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedImage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["image"] = transformedImage
	}

	transformedBootDiskSizeGb, err := expandGkeonpremVmwareNodePoolConfigBootDiskSizeGb(original["boot_disk_size_gb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBootDiskSizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bootDiskSizeGb"] = transformedBootDiskSizeGb
	}

	transformedTaints, err := expandGkeonpremVmwareNodePoolConfigTaints(original["taints"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTaints); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["taints"] = transformedTaints
	}

	transformedLabels, err := expandGkeonpremVmwareNodePoolConfigLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedVsphereConfig, err := expandGkeonpremVmwareNodePoolConfigVsphereConfig(original["vsphere_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVsphereConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vsphereConfig"] = transformedVsphereConfig
	}

	transformedEnableLoadBalancer, err := expandGkeonpremVmwareNodePoolConfigEnableLoadBalancer(original["enable_load_balancer"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableLoadBalancer); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableLoadBalancer"] = transformedEnableLoadBalancer
	}

	return transformed, nil
}

func expandGkeonpremVmwareNodePoolConfigCpus(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigMemoryMb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigReplicas(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigImageType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigImage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigBootDiskSizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigTaints(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandGkeonpremVmwareNodePoolConfigTaintsKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedValue, err := expandGkeonpremVmwareNodePoolConfigTaintsValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedEffect, err := expandGkeonpremVmwareNodePoolConfigTaintsEffect(original["effect"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEffect); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["effect"] = transformedEffect
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareNodePoolConfigTaintsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigTaintsValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigTaintsEffect(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandGkeonpremVmwareNodePoolConfigVsphereConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDatastore, err := expandGkeonpremVmwareNodePoolConfigVsphereConfigDatastore(original["datastore"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatastore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["datastore"] = transformedDatastore
	}

	transformedTags, err := expandGkeonpremVmwareNodePoolConfigVsphereConfigTags(original["tags"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTags); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tags"] = transformedTags
	}

	transformedHostGroups, err := expandGkeonpremVmwareNodePoolConfigVsphereConfigHostGroups(original["host_groups"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostGroups); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostGroups"] = transformedHostGroups
	}

	return transformed, nil
}

func expandGkeonpremVmwareNodePoolConfigVsphereConfigDatastore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigVsphereConfigTags(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedCategory, err := expandGkeonpremVmwareNodePoolConfigVsphereConfigTagsCategory(original["category"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCategory); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["category"] = transformedCategory
		}

		transformedTag, err := expandGkeonpremVmwareNodePoolConfigVsphereConfigTagsTag(original["tag"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTag); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["tag"] = transformedTag
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandGkeonpremVmwareNodePoolConfigVsphereConfigTagsCategory(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigVsphereConfigTagsTag(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigVsphereConfigHostGroups(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolConfigEnableLoadBalancer(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandGkeonpremVmwareNodePoolEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
