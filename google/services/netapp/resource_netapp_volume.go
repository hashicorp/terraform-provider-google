// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/netapp/Volume.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package netapp

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

// Suppress diffs when the value read from api
// has the project ID instead of the project number
func ProjectIDDiffSuppress(_, old, new string, _ *schema.ResourceData) bool {

	const marker = "/locations"

	// Find the starting index of "/locations" in both strings.
	index1 := strings.Index(old, marker)
	index2 := strings.Index(new, marker)

	// If "/locations" is not found in either string, they can't be compared as requested.
	if index1 == -1 || index2 == -1 {
		return false
	}

	// Extract the substrings from the marker to the end.
	suffix1 := old[index1:]
	suffix2 := new[index2:]

	// Compare the extracted suffixes.
	return suffix1 == suffix2
}

func suppressSquashModeDiff(k, old, new string, d *schema.ResourceData) bool {
	// k: The key of the field, e.g., "export_policy.0.rules.1.squash_mode"
	// old: The value in the state (what the API returned on last read)
	// new: The value in the configuration (what the user set)
	// d: The ResourceData for the entire resource

	// 1. Only suppress if the user did NOT set squash_mode in the config.
	// According to the requirements, a "classic rule" is identified by the ABSENCE of squash_mode.
	if new == "ALL_SQUASH" {
		// If 'new' is not an empty string, the user has explicitly provided a value
		// for squash_mode in the Terraform configuration. In this scenario, any
		// difference between the API's value ('old') and the configured value ('new')
		// is a real change and should NOT be suppressed.
		return false
	}

	if new == "" && old != "ALL_SQUASH" {
		return true
	}

	// 2. The user did not specify squash_mode in the configuration ('new' is empty).
	// Now, we suppress the diff if the API/state value ('old') is one of the
	// specific values that should be treated as equivalent to an unset field.
	// These values are "NO_ROOT_SQUASH", "ROOT_SQUASH".
	switch old {
	case "NO_ROOT_SQUASH", "ROOT_SQUASH", "":
		// The API returned one of the values that we consider equivalent to the field
		// being unconfigured by the user. Since the user also didn't configure it,
		// we should suppress this diff.
		return true
	default:
		// If 'old' is not one of the values to be suppressed (and 'new' is empty),
		// we do not suppress the diff. This could happen if, for instance, the API
		// returned an unexpected value or if 'old' is also empty.
		return false
	}
	// Note: The previous logic involving parsing 'k' and checking 'has_root_access'
	// has been removed because squash_mode is independent of has_root_access,
	// and a "classic rule" is defined by the absence of squash_mode itself.
}

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceNetappVolume() *schema.Resource {
	return &schema.Resource{
		Create: resourceNetappVolumeCreate,
		Read:   resourceNetappVolumeRead,
		Update: resourceNetappVolumeUpdate,
		Delete: resourceNetappVolumeDelete,

		Importer: &schema.ResourceImporter{
			State: resourceNetappVolumeImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(50 * time.Minute),
			Update: schema.DefaultTimeout(30 * time.Minute),
			Delete: schema.DefaultTimeout(30 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"capacity_gib": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Capacity of the volume (in GiB).`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Name of the pool location. Usually a region name, expect for some STANDARD service level pools which require a zone name.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of the volume. Needs to be unique per location.`,
			},
			"protocols": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `The protocol of the volume. Allowed combinations are '['NFSV3']', '['NFSV4']', '['SMB']', '['NFSV3', 'NFSV4']', '['SMB', 'NFSV3']' and '['SMB', 'NFSV4']'. Possible values: ["NFSV3", "NFSV4", "SMB", "ISCSI"]`,
				Elem: &schema.Schema{
					Type:         schema.TypeString,
					ValidateFunc: verify.ValidateEnum([]string{"NFSV3", "NFSV4", "SMB", "ISCSI"}),
				},
			},
			"storage_pool": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Name of the storage pool to create the volume in. Pool needs enough spare capacity to accommodate the volume.`,
			},
			"backup_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Backup configuration for the volume.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"backup_policies": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Specify a single backup policy ID for scheduled backups. Format: 'projects/{{projectId}}/locations/{{location}}/backupPolicies/{{backupPolicyName}}'`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"backup_vault": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `ID of the backup vault to use. A backup vault is reqired to create manual or scheduled backups.
Format: 'projects/{{projectId}}/locations/{{location}}/backupVaults/{{backupVaultName}}'`,
						},
						"scheduled_backup_enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `When set to true, scheduled backup is enabled on the volume. Omit if no backup_policy is specified.`,
						},
					},
				},
			},
			"block_devices": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Block device represents the device(s) which are stored in the block volume.
Currently, only one block device is permitted per Volume.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"os_type": {
							Type:         schema.TypeString,
							Required:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"LINUX", "WINDOWS", "ESXI"}),
							Description: `The OS type of the volume.
This field can't be changed after the block device is created. Possible values: ["LINUX", "WINDOWS", "ESXI"]`,
						},
						"host_groups": {
							Type:             schema.TypeList,
							Computed:         true,
							Optional:         true,
							DiffSuppressFunc: ProjectIDDiffSuppress,
							Description: `A list of host groups that identify hosts that can mount the block volume.
Format:
'projects/{project_id}/locations/{location}/hostGroups/{host_group_id}'
This field can be updated after the block device is created.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"name": {
							Type:     schema.TypeString,
							Computed: true,
							Optional: true,
							Description: `User-defined name for the block device, unique within the Volume. In case
no user input is provided, name will be autogenerated in the backend.
The name must meet the following requirements:
*   Be between 1 and 255 characters long.
*   Contain only uppercase or lowercase letters (A-Z, a-z), numbers (0-9),
    and the following special characters: "-", "_", "}", "{", ".".
*   Spaces are not allowed.`,
						},
						"identifier": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Device identifier of the Block volume. This represents lun_serial_number
for ISCSI volumes`,
						},
						"size_gib": {
							Type:     schema.TypeInt,
							Computed: true,
							Description: `The size of the block device in GiB.
Any value provided in this field during Volume creation is IGNORED.
The block device's size is system-managed and will be set to match
the parent Volume's 'capacity_gib'.`,
						},
					},
				},
			},
			"cache_parameters": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Cache parameters for the volume.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cache_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Optional. Configuration of the cache volume.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"cifs_change_notify_enabled": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Optional. Flag indicating whether a CIFS change notification is enabled for the FlexCache volume.`,
									},
								},
							},
						},
						"enable_global_file_lock": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Optional. Field indicating whether cache volume as global file lock enabled.`,
						},
						"peer_cluster_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Required. Name of the origin volume's ONTAP cluster.`,
						},
						"peer_ip_addresses": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Required. List of IC LIF addresses of the origin volume's ONTAP cluster.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"peer_svm_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Required. Name of the origin volume's SVM.`,
						},
						"peer_volume_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Required. Name of the origin volume for the cache volume.`,
						},
						"peering_command_expiry_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Optional:    true,
							Description: `Optional. Expiration time for the peering command to be executed on user's ONTAP. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".`,
						},
						"cache_state": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `State of the cache volume indicating the peering status.`,
						},
						"command": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Copy-paste-able commands to be used on user's ONTAP to accept peering requests.`,
						},
						"passphrase": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Temporary passphrase generated to accept cluster peering command.`,
						},
						"state_details": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Detailed description of the current cache state.`,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An optional description of this resource.`,
			},
			"export_policy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Export policy of the volume for NFSV3 and/or NFSV4.1 access.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"rules": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Export rules (up to 5) control NFS volume access.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"access_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"READ_ONLY", "READ_WRITE", "READ_NONE", ""}),
										Description:  `Defines the access type for clients matching the 'allowedClients' specification. Possible values: ["READ_ONLY", "READ_WRITE", "READ_NONE"]`,
									},
									"allowed_clients": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Defines the client ingress specification (allowed clients) as a comma separated list with IPv4 CIDRs or IPv4 host addresses.`,
									},
									"anon_uid": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `An integer representing the anonymous user ID. Range is 0 to 4294967295. Required when 'squash_mode' is 'ALL_SQUASH'.`,
									},
									"has_root_access": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										Description: `If enabled, the root user (UID = 0) of the specified clients doesn't get mapped to nobody (UID = 65534). This is also known as no_root_squash.
It's overwritten by the squash_mode parameter. Use either squash_mode or has_root_access.`,
									},
									"kerberos5_read_only": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `If enabled (true) the rule defines a read only access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'authentication' kerberos security mode.`,
									},
									"kerberos5_read_write": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `If enabled (true) the rule defines read and write access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'authentication' kerberos security mode. The 'kerberos5ReadOnly' value is ignored if this is enabled.`,
									},
									"kerberos5i_read_only": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `If enabled (true) the rule defines a read only access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'integrity' kerberos security mode.`,
									},
									"kerberos5i_read_write": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `If enabled (true) the rule defines read and write access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'integrity' kerberos security mode. The 'kerberos5iReadOnly' value is ignored if this is enabled.`,
									},
									"kerberos5p_read_only": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `If enabled (true) the rule defines a read only access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'privacy' kerberos security mode.`,
									},
									"kerberos5p_read_write": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `If enabled (true) the rule defines read and write access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'privacy' kerberos security mode. The 'kerberos5pReadOnly' value is ignored if this is enabled.`,
									},
									"nfsv3": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Enable to apply the export rule to NFSV3 clients.`,
									},
									"nfsv4": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Enable to apply the export rule to NFSV4.1 clients.`,
									},
									"squash_mode": {
										Type:             schema.TypeString,
										Optional:         true,
										ValidateFunc:     verify.ValidateEnum([]string{"SQUASH_MODE_UNSPECIFIED", "NO_ROOT_SQUASH", "ROOT_SQUASH", "ALL_SQUASH", ""}),
										DiffSuppressFunc: suppressSquashModeDiff,
										Description: `SquashMode defines how remote user privileges are restricted when accessing an NFS export. It controls how the user identities (like root) are mapped to anonymous users to limit access and enforce security.
It overwrites the has_root_access parameter. Use either squash_mode or has_root_access. For ALL_SQUASH, access_type needs to be set to READ_WRITE. Possible values: ["SQUASH_MODE_UNSPECIFIED", "NO_ROOT_SQUASH", "ROOT_SQUASH", "ALL_SQUASH"]`,
									},
								},
							},
						},
					},
				},
			},
			"hybrid_replication_parameters": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The Hybrid Replication parameters for the volume.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cluster_location": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Optional. Name of source cluster location associated with the Hybrid replication. This is a free-form field for the display purpose only.`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Optional. Description of the replication.`,
						},
						"hybrid_replication_type": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"MIGRATION", "CONTINUOUS_REPLICATION", "ONPREM_REPLICATION", "REVERSE_ONPREM_REPLICATION", ""}),
							Description:  `Optional. Type of the volume's hybrid replication. Possible values: ["MIGRATION", "CONTINUOUS_REPLICATION", "ONPREM_REPLICATION", "REVERSE_ONPREM_REPLICATION"]`,
						},
						"labels": {
							Type:     schema.TypeMap,
							Optional: true,
							Description: `Optional. Labels to be added to the replication as the key value pairs.
An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"large_volume_constituent_count": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `Optional. Constituent volume count for large volume.`,
						},
						"peer_cluster_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Required. Name of the user's local source cluster to be peered with the destination cluster.`,
						},
						"peer_ip_addresses": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Required. List of node ip addresses to be peered with.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"peer_svm_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Required. Name of the user's local source vserver svm to be peered with the destination vserver svm.`,
						},
						"peer_volume_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Required. Name of the user's local source volume to be peered with the destination volume.`,
						},
						"replication": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Required. Desired name for the replication of this volume.`,
						},
						"replication_schedule": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"EVERY_10_MINUTES", "HOURLY", "DAILY", ""}),
							Description:  `Optional. Replication Schedule for the replication created. Possible values: ["EVERY_10_MINUTES", "HOURLY", "DAILY"]`,
						},
					},
				},
			},
			"kerberos_enabled": {
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Description: `Flag indicating if the volume is a kerberos volume or not, export policy rules control kerberos security modes (krb5, krb5i, krb5p).`,
				Default:     false,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Labels as key value pairs. Example: '{ "owner": "Bob", "department": "finance", "purpose": "testing" }'.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"large_capacity": {
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Description: `Optional. Flag indicating if the volume will be a large capacity volume or a regular volume.`,
			},
			"multiple_endpoints": {
				Type:     schema.TypeBool,
				Optional: true,
				Description: `Optional. Flag indicating if the volume will have an IP address per node for volumes supporting multiple IP endpoints.
Only the volume with largeCapacity will be allowed to have multiple endpoints.`,
			},
			"restore_parameters": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Used to create this volume from a snapshot (= cloning) or an backup.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"source_backup": {
							Type:     schema.TypeString,
							Optional: true,
							ForceNew: true,
							Description: `Full name of the backup to use for creating this volume.
'source_snapshot' and 'source_backup' cannot be used simultaneously.
Format: 'projects/{{project}}/locations/{{location}}/backupVaults/{{backupVaultId}}/backups/{{backup}}'.`,
							ExactlyOneOf: []string{"restore_parameters.0.source_backup", "restore_parameters.0.source_snapshot"},
						},
						"source_snapshot": {
							Type:     schema.TypeString,
							Optional: true,
							ForceNew: true,
							Description: `Full name of the snapshot to use for creating this volume.
'source_snapshot' and 'source_backup' cannot be used simultaneously.
Format: 'projects/{{project}}/locations/{{location}}/volumes/{{volume}}/snapshots/{{snapshot}}'.`,
							ExactlyOneOf: []string{"restore_parameters.0.source_backup", "restore_parameters.0.source_snapshot"},
						},
					},
				},
			},
			"restricted_actions": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `List of actions that are restricted on this volume. Possible values: ["DELETE"]`,
				Elem: &schema.Schema{
					Type:         schema.TypeString,
					ValidateFunc: verify.ValidateEnum([]string{"DELETE"}),
				},
			},
			"security_style": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"NTFS", "UNIX", ""}),
				Description: `Security Style of the Volume. Use UNIX to use UNIX or NFSV4 ACLs for file permissions.
Use NTFS to use NTFS ACLs for file permissions. Can only be set for volumes which use SMB together with NFS as protocol. Possible values: ["NTFS", "UNIX"]`,
			},
			"share_name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `Share name (SMB) or export path (NFS) of the volume. Needs to be unique per location.`,
			},
			"smb_settings": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Settings for volumes with SMB access. Possible values: ["ENCRYPT_DATA", "BROWSABLE", "CHANGE_NOTIFY", "NON_BROWSABLE", "OPLOCKS", "SHOW_SNAPSHOT", "SHOW_PREVIOUS_VERSIONS", "ACCESS_BASED_ENUMERATION", "CONTINUOUSLY_AVAILABLE"]`,
				Elem: &schema.Schema{
					Type:         schema.TypeString,
					ValidateFunc: verify.ValidateEnum([]string{"ENCRYPT_DATA", "BROWSABLE", "CHANGE_NOTIFY", "NON_BROWSABLE", "OPLOCKS", "SHOW_SNAPSHOT", "SHOW_PREVIOUS_VERSIONS", "ACCESS_BASED_ENUMERATION", "CONTINUOUSLY_AVAILABLE"}),
				},
			},
			"snapshot_directory": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `If enabled, a NFS volume will contain a read-only .snapshot directory which provides access to each of the volume's snapshots. Will enable "Previous Versions" support for SMB.`,
			},
			"snapshot_policy": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Snapshot policy defines the schedule for automatic snapshot creation.
To disable automatic snapshot creation you have to remove the whole snapshot_policy block.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"daily_schedule": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Daily schedule policy.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"snapshots_to_keep": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: `The maximum number of snapshots to keep for the daily schedule.`,
									},
									"hour": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Set the hour to create the snapshot (0-23), defaults to midnight (0).`,
										Default:     0,
									},
									"minute": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).`,
										Default:     0,
									},
								},
							},
						},
						"enabled": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Enables automated snapshot creation according to defined schedule. Default is false.
To disable automatic snapshot creation you have to remove the whole snapshot_policy block.`,
							Default: false,
						},
						"hourly_schedule": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Hourly schedule policy.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"snapshots_to_keep": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: `The maximum number of snapshots to keep for the hourly schedule.`,
									},
									"minute": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).`,
										Default:     0,
									},
								},
							},
						},
						"monthly_schedule": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Monthly schedule policy.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"snapshots_to_keep": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: `The maximum number of snapshots to keep for the monthly schedule`,
									},
									"days_of_month": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Set the day or days of the month to make a snapshot (1-31). Accepts a comma separated number of days. Defaults to '1'.`,
										Default:     "1",
									},
									"hour": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Set the hour to create the snapshot (0-23), defaults to midnight (0).`,
										Default:     0,
									},
									"minute": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).`,
										Default:     0,
									},
								},
							},
						},
						"weekly_schedule": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Weekly schedule policy.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"snapshots_to_keep": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: `The maximum number of snapshots to keep for the weekly schedule.`,
									},
									"day": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Set the day or days of the week to make a snapshot. Accepts a comma separated days of the week. Defaults to 'Sunday'.`,
										Default:     "Sunday",
									},
									"hour": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Set the hour to create the snapshot (0-23), defaults to midnight (0).`,
										Default:     0,
									},
									"minute": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).`,
										Default:     0,
									},
								},
							},
						},
					},
				},
			},
			"throughput_mibps": {
				Type:        schema.TypeFloat,
				Computed:    true,
				Optional:    true,
				Description: `Optional. Custom Performance Total Throughput of the pool (in MiB/s).`,
			},
			"tiering_policy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Tiering policy for the volume.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cooling_threshold_days": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `Optional. Time in days to mark the volume's data block as cold and make it eligible for tiering, can be range from 2-183.
Default is 31.`,
						},
						"hot_tier_bypass_mode_enabled": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Optional. Flag indicating that the hot tier bypass mode is enabled. Default is false.
Only applicable to Flex service level.`,
						},
						"tier_action": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"ENABLED", "PAUSED", ""}),
							Description:  `Optional. Flag indicating if the volume has tiering policy enable/pause. Default is PAUSED. Default value: "PAUSED" Possible values: ["ENABLED", "PAUSED"]`,
							Default:      "PAUSED",
						},
					},
				},
			},
			"unix_permissions": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				Description: `Unix permission the mount point will be created with. Default is 0770. Applicable for UNIX security style volumes only.`,
			},
			"active_directory": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Reports the resource name of the Active Directory policy being used. Inherited from storage pool.`,
			},
			"cold_tier_size_gib": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Size of the volume cold tier data in GiB.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Create time of the volume. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"encryption_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Reports the data-at-rest encryption type of the volume. Inherited from storage pool.`,
			},
			"has_replication": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `Indicates whether the volume is part of a volume replication relationship.`,
			},
			"hot_tier_size_used_gib": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Total hot tier data rounded down to the nearest GiB used by the volume. This field is only used for flex Service Level`,
			},
			"kms_config": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Reports the CMEK policy resurce name being used for volume encryption. Inherited from storage pool.`,
			},
			"ldap_enabled": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `Flag indicating if the volume is NFS LDAP enabled or not. Inherited from storage pool.`,
			},
			"mount_options": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Reports mount instructions for this volume.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"export": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Export path of the volume.`,
						},
						"export_full": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Full export path of the volume.

Format for NFS volumes: '<export_ip>:/<shareName>'

Format for SMB volumes: '\\\\netbios_prefix-four_random_hex_letters.domain_name\\shareName'`,
						},
						"instructions": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Human-readable mount instructions.`,
						},
						"ip_address": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `IP Address.`,
						},
						"protocol": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Protocol to mount with.`,
						},
					},
				},
			},
			"network": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `VPC network name with format: 'projects/{{project}}/global/networks/{{network}}'. Inherited from storage pool.`,
			},
			"psa_range": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Name of the Private Service Access allocated range. Inherited from storage pool.`,
			},
			"replica_zone": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Specifies the replica zone for regional volume.`,
			},
			"service_level": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Service level of the volume. Inherited from storage pool. Supported values are : PREMIUM, EXTREME, STANDARD, FLEX.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `State of the volume.`,
			},
			"state_details": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `State details of the volume.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"used_gib": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Used capacity of the volume (in GiB). This is computed periodically and it does not represent the realtime usage.`,
			},
			"zone": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Specifies the active zone for regional volume.`,
			},
			"deletion_policy": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Policy to determine if the volume should be deleted forcefully.
Volumes may have nested snapshot resources. Deleting such a volume will fail.
Setting this parameter to FORCE will delete volumes including nested snapshots.
Possible values: DEFAULT, FORCE.`,
				Default: "DEFAULT",
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceNetappVolumeCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	shareNameProp, err := expandNetappVolumeShareName(d.Get("share_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("share_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(shareNameProp)) && (ok || !reflect.DeepEqual(v, shareNameProp)) {
		obj["shareName"] = shareNameProp
	}
	storagePoolProp, err := expandNetappVolumeStoragePool(d.Get("storage_pool"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("storage_pool"); !tpgresource.IsEmptyValue(reflect.ValueOf(storagePoolProp)) && (ok || !reflect.DeepEqual(v, storagePoolProp)) {
		obj["storagePool"] = storagePoolProp
	}
	capacityGibProp, err := expandNetappVolumeCapacityGib(d.Get("capacity_gib"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("capacity_gib"); !tpgresource.IsEmptyValue(reflect.ValueOf(capacityGibProp)) && (ok || !reflect.DeepEqual(v, capacityGibProp)) {
		obj["capacityGib"] = capacityGibProp
	}
	exportPolicyProp, err := expandNetappVolumeExportPolicy(d.Get("export_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("export_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(exportPolicyProp)) && (ok || !reflect.DeepEqual(v, exportPolicyProp)) {
		obj["exportPolicy"] = exportPolicyProp
	}
	protocolsProp, err := expandNetappVolumeProtocols(d.Get("protocols"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("protocols"); !tpgresource.IsEmptyValue(reflect.ValueOf(protocolsProp)) && (ok || !reflect.DeepEqual(v, protocolsProp)) {
		obj["protocols"] = protocolsProp
	}
	smbSettingsProp, err := expandNetappVolumeSmbSettings(d.Get("smb_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("smb_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(smbSettingsProp)) && (ok || !reflect.DeepEqual(v, smbSettingsProp)) {
		obj["smbSettings"] = smbSettingsProp
	}
	unixPermissionsProp, err := expandNetappVolumeUnixPermissions(d.Get("unix_permissions"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("unix_permissions"); !tpgresource.IsEmptyValue(reflect.ValueOf(unixPermissionsProp)) && (ok || !reflect.DeepEqual(v, unixPermissionsProp)) {
		obj["unixPermissions"] = unixPermissionsProp
	}
	descriptionProp, err := expandNetappVolumeDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	snapshotDirectoryProp, err := expandNetappVolumeSnapshotDirectory(d.Get("snapshot_directory"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("snapshot_directory"); !tpgresource.IsEmptyValue(reflect.ValueOf(snapshotDirectoryProp)) && (ok || !reflect.DeepEqual(v, snapshotDirectoryProp)) {
		obj["snapshotDirectory"] = snapshotDirectoryProp
	}
	securityStyleProp, err := expandNetappVolumeSecurityStyle(d.Get("security_style"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("security_style"); !tpgresource.IsEmptyValue(reflect.ValueOf(securityStyleProp)) && (ok || !reflect.DeepEqual(v, securityStyleProp)) {
		obj["securityStyle"] = securityStyleProp
	}
	kerberosEnabledProp, err := expandNetappVolumeKerberosEnabled(d.Get("kerberos_enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("kerberos_enabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(kerberosEnabledProp)) && (ok || !reflect.DeepEqual(v, kerberosEnabledProp)) {
		obj["kerberosEnabled"] = kerberosEnabledProp
	}
	restoreParametersProp, err := expandNetappVolumeRestoreParameters(d.Get("restore_parameters"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("restore_parameters"); !tpgresource.IsEmptyValue(reflect.ValueOf(restoreParametersProp)) && (ok || !reflect.DeepEqual(v, restoreParametersProp)) {
		obj["restoreParameters"] = restoreParametersProp
	}
	restrictedActionsProp, err := expandNetappVolumeRestrictedActions(d.Get("restricted_actions"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("restricted_actions"); !tpgresource.IsEmptyValue(reflect.ValueOf(restrictedActionsProp)) && (ok || !reflect.DeepEqual(v, restrictedActionsProp)) {
		obj["restrictedActions"] = restrictedActionsProp
	}
	snapshotPolicyProp, err := expandNetappVolumeSnapshotPolicy(d.Get("snapshot_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("snapshot_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(snapshotPolicyProp)) && (ok || !reflect.DeepEqual(v, snapshotPolicyProp)) {
		obj["snapshotPolicy"] = snapshotPolicyProp
	}
	backupConfigProp, err := expandNetappVolumeBackupConfig(d.Get("backup_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backup_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(backupConfigProp)) && (ok || !reflect.DeepEqual(v, backupConfigProp)) {
		obj["backupConfig"] = backupConfigProp
	}
	largeCapacityProp, err := expandNetappVolumeLargeCapacity(d.Get("large_capacity"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("large_capacity"); !tpgresource.IsEmptyValue(reflect.ValueOf(largeCapacityProp)) && (ok || !reflect.DeepEqual(v, largeCapacityProp)) {
		obj["largeCapacity"] = largeCapacityProp
	}
	multipleEndpointsProp, err := expandNetappVolumeMultipleEndpoints(d.Get("multiple_endpoints"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("multiple_endpoints"); !tpgresource.IsEmptyValue(reflect.ValueOf(multipleEndpointsProp)) && (ok || !reflect.DeepEqual(v, multipleEndpointsProp)) {
		obj["multipleEndpoints"] = multipleEndpointsProp
	}
	tieringPolicyProp, err := expandNetappVolumeTieringPolicy(d.Get("tiering_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("tiering_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(tieringPolicyProp)) && (ok || !reflect.DeepEqual(v, tieringPolicyProp)) {
		obj["tieringPolicy"] = tieringPolicyProp
	}
	hybridReplicationParametersProp, err := expandNetappVolumeHybridReplicationParameters(d.Get("hybrid_replication_parameters"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("hybrid_replication_parameters"); !tpgresource.IsEmptyValue(reflect.ValueOf(hybridReplicationParametersProp)) && (ok || !reflect.DeepEqual(v, hybridReplicationParametersProp)) {
		obj["hybridReplicationParameters"] = hybridReplicationParametersProp
	}
	throughputMibpsProp, err := expandNetappVolumeThroughputMibps(d.Get("throughput_mibps"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("throughput_mibps"); !tpgresource.IsEmptyValue(reflect.ValueOf(throughputMibpsProp)) && (ok || !reflect.DeepEqual(v, throughputMibpsProp)) {
		obj["throughputMibps"] = throughputMibpsProp
	}
	cacheParametersProp, err := expandNetappVolumeCacheParameters(d.Get("cache_parameters"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cache_parameters"); !tpgresource.IsEmptyValue(reflect.ValueOf(cacheParametersProp)) && (ok || !reflect.DeepEqual(v, cacheParametersProp)) {
		obj["cacheParameters"] = cacheParametersProp
	}
	blockDevicesProp, err := expandNetappVolumeBlockDevices(d.Get("block_devices"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("block_devices"); !tpgresource.IsEmptyValue(reflect.ValueOf(blockDevicesProp)) && (ok || !reflect.DeepEqual(v, blockDevicesProp)) {
		obj["blockDevices"] = blockDevicesProp
	}
	effectiveLabelsProp, err := expandNetappVolumeEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetappBasePath}}projects/{{project}}/locations/{{location}}/volumes?volumeId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Volume: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Volume: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Volume: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/volumes/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = NetappOperationWaitTime(
		config, res, project, "Creating Volume", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Volume: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Volume %q: %#v", d.Id(), res)

	return resourceNetappVolumeRead(d, meta)
}

func resourceNetappVolumeRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetappBasePath}}projects/{{project}}/locations/{{location}}/volumes/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Volume: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("NetappVolume %q", d.Id()))
	}

	// Explicitly set virtual fields to default values if unset
	if _, ok := d.GetOkExists("deletion_policy"); !ok {
		if err := d.Set("deletion_policy", "DEFAULT"); err != nil {
			return fmt.Errorf("Error setting deletion_policy: %s", err)
		}
	}
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}

	if err := d.Set("state", flattenNetappVolumeState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("state_details", flattenNetappVolumeStateDetails(res["stateDetails"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("create_time", flattenNetappVolumeCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("share_name", flattenNetappVolumeShareName(res["shareName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("psa_range", flattenNetappVolumePsaRange(res["psaRange"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("storage_pool", flattenNetappVolumeStoragePool(res["storagePool"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("network", flattenNetappVolumeNetwork(res["network"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("service_level", flattenNetappVolumeServiceLevel(res["serviceLevel"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("capacity_gib", flattenNetappVolumeCapacityGib(res["capacityGib"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("export_policy", flattenNetappVolumeExportPolicy(res["exportPolicy"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("protocols", flattenNetappVolumeProtocols(res["protocols"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("smb_settings", flattenNetappVolumeSmbSettings(res["smbSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("unix_permissions", flattenNetappVolumeUnixPermissions(res["unixPermissions"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("labels", flattenNetappVolumeLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("description", flattenNetappVolumeDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("snapshot_directory", flattenNetappVolumeSnapshotDirectory(res["snapshotDirectory"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("used_gib", flattenNetappVolumeUsedGib(res["usedGib"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("security_style", flattenNetappVolumeSecurityStyle(res["securityStyle"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("kerberos_enabled", flattenNetappVolumeKerberosEnabled(res["kerberosEnabled"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("ldap_enabled", flattenNetappVolumeLdapEnabled(res["ldapEnabled"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("active_directory", flattenNetappVolumeActiveDirectory(res["activeDirectory"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("kms_config", flattenNetappVolumeKmsConfig(res["kmsConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("encryption_type", flattenNetappVolumeEncryptionType(res["encryptionType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("has_replication", flattenNetappVolumeHasReplication(res["hasReplication"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("restricted_actions", flattenNetappVolumeRestrictedActions(res["restrictedActions"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("mount_options", flattenNetappVolumeMountOptions(res["mountOptions"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("snapshot_policy", flattenNetappVolumeSnapshotPolicy(res["snapshotPolicy"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("backup_config", flattenNetappVolumeBackupConfig(res["backupConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("zone", flattenNetappVolumeZone(res["zone"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("replica_zone", flattenNetappVolumeReplicaZone(res["replicaZone"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("large_capacity", flattenNetappVolumeLargeCapacity(res["largeCapacity"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("multiple_endpoints", flattenNetappVolumeMultipleEndpoints(res["multipleEndpoints"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("cold_tier_size_gib", flattenNetappVolumeColdTierSizeGib(res["coldTierSizeGib"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("tiering_policy", flattenNetappVolumeTieringPolicy(res["tieringPolicy"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("hybrid_replication_parameters", flattenNetappVolumeHybridReplicationParameters(res["hybridReplicationParameters"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("throughput_mibps", flattenNetappVolumeThroughputMibps(res["throughputMibps"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("hot_tier_size_used_gib", flattenNetappVolumeHotTierSizeUsedGib(res["hotTierSizeUsedGib"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("cache_parameters", flattenNetappVolumeCacheParameters(res["cacheParameters"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("block_devices", flattenNetappVolumeBlockDevices(res["blockDevices"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("terraform_labels", flattenNetappVolumeTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}
	if err := d.Set("effective_labels", flattenNetappVolumeEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Volume: %s", err)
	}

	identity, err := d.Identity()
	if err != nil && identity != nil {
		if v, ok := identity.GetOk("location"); ok && v != "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("name"); ok && v != "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); ok && v != "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] identity not set: %s", err)
	}
	return nil
}

func resourceNetappVolumeUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Volume: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	storagePoolProp, err := expandNetappVolumeStoragePool(d.Get("storage_pool"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("storage_pool"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, storagePoolProp)) {
		obj["storagePool"] = storagePoolProp
	}
	capacityGibProp, err := expandNetappVolumeCapacityGib(d.Get("capacity_gib"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("capacity_gib"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, capacityGibProp)) {
		obj["capacityGib"] = capacityGibProp
	}
	exportPolicyProp, err := expandNetappVolumeExportPolicy(d.Get("export_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("export_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, exportPolicyProp)) {
		obj["exportPolicy"] = exportPolicyProp
	}
	smbSettingsProp, err := expandNetappVolumeSmbSettings(d.Get("smb_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("smb_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, smbSettingsProp)) {
		obj["smbSettings"] = smbSettingsProp
	}
	unixPermissionsProp, err := expandNetappVolumeUnixPermissions(d.Get("unix_permissions"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("unix_permissions"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, unixPermissionsProp)) {
		obj["unixPermissions"] = unixPermissionsProp
	}
	descriptionProp, err := expandNetappVolumeDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	snapshotDirectoryProp, err := expandNetappVolumeSnapshotDirectory(d.Get("snapshot_directory"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("snapshot_directory"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, snapshotDirectoryProp)) {
		obj["snapshotDirectory"] = snapshotDirectoryProp
	}
	restrictedActionsProp, err := expandNetappVolumeRestrictedActions(d.Get("restricted_actions"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("restricted_actions"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, restrictedActionsProp)) {
		obj["restrictedActions"] = restrictedActionsProp
	}
	snapshotPolicyProp, err := expandNetappVolumeSnapshotPolicy(d.Get("snapshot_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("snapshot_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, snapshotPolicyProp)) {
		obj["snapshotPolicy"] = snapshotPolicyProp
	}
	backupConfigProp, err := expandNetappVolumeBackupConfig(d.Get("backup_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backup_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, backupConfigProp)) {
		obj["backupConfig"] = backupConfigProp
	}
	multipleEndpointsProp, err := expandNetappVolumeMultipleEndpoints(d.Get("multiple_endpoints"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("multiple_endpoints"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, multipleEndpointsProp)) {
		obj["multipleEndpoints"] = multipleEndpointsProp
	}
	tieringPolicyProp, err := expandNetappVolumeTieringPolicy(d.Get("tiering_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("tiering_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, tieringPolicyProp)) {
		obj["tieringPolicy"] = tieringPolicyProp
	}
	hybridReplicationParametersProp, err := expandNetappVolumeHybridReplicationParameters(d.Get("hybrid_replication_parameters"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("hybrid_replication_parameters"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, hybridReplicationParametersProp)) {
		obj["hybridReplicationParameters"] = hybridReplicationParametersProp
	}
	throughputMibpsProp, err := expandNetappVolumeThroughputMibps(d.Get("throughput_mibps"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("throughput_mibps"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, throughputMibpsProp)) {
		obj["throughputMibps"] = throughputMibpsProp
	}
	cacheParametersProp, err := expandNetappVolumeCacheParameters(d.Get("cache_parameters"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cache_parameters"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, cacheParametersProp)) {
		obj["cacheParameters"] = cacheParametersProp
	}
	blockDevicesProp, err := expandNetappVolumeBlockDevices(d.Get("block_devices"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("block_devices"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, blockDevicesProp)) {
		obj["blockDevices"] = blockDevicesProp
	}
	effectiveLabelsProp, err := expandNetappVolumeEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetappBasePath}}projects/{{project}}/locations/{{location}}/volumes/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Volume %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("storage_pool") {
		updateMask = append(updateMask, "storagePool")
	}

	if d.HasChange("capacity_gib") {
		updateMask = append(updateMask, "capacityGib")
	}

	if d.HasChange("export_policy") {
		updateMask = append(updateMask, "exportPolicy")
	}

	if d.HasChange("smb_settings") {
		updateMask = append(updateMask, "smbSettings")
	}

	if d.HasChange("unix_permissions") {
		updateMask = append(updateMask, "unixPermissions")
	}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("snapshot_directory") {
		updateMask = append(updateMask, "snapshotDirectory")
	}

	if d.HasChange("restricted_actions") {
		updateMask = append(updateMask, "restrictedActions")
	}

	if d.HasChange("snapshot_policy") {
		updateMask = append(updateMask, "snapshotPolicy")
	}

	if d.HasChange("backup_config") {
		updateMask = append(updateMask, "backup_config.backup_policies",
			"backup_config.backup_vault",
			"backup_config.scheduled_backup_enabled")
	}

	if d.HasChange("multiple_endpoints") {
		updateMask = append(updateMask, "multipleEndpoints")
	}

	if d.HasChange("tiering_policy") {
		updateMask = append(updateMask, "tiering_policy.cooling_threshold_days",
			"tiering_policy.tier_action",
			"tiering_policy.hot_tier_bypass_mode_enabled")
	}

	if d.HasChange("hybrid_replication_parameters") {
		updateMask = append(updateMask, "hybridReplicationParameters")
	}

	if d.HasChange("throughput_mibps") {
		updateMask = append(updateMask, "throughputMibps")
	}

	if d.HasChange("cache_parameters") {
		updateMask = append(updateMask, "cacheParameters")
	}

	if d.HasChange("block_devices") {
		updateMask = append(updateMask, "blockDevices")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}
	// remove sizeGib and identifier from the update request for block_devices

	if v, ok := d.GetOk("block_devices"); ok {

		l := v.([]interface{})
		newBlockDevices := make([]interface{}, 0, len(l))

		for _, item := range v.([]interface{}) {
			if item == nil {
				continue
			}
			blockDevice := item.(map[string]interface{})
			newblockDevice := make(map[string]interface{})

			if val, exists := blockDevice["name"]; exists {
				newblockDevice["name"] = val
			}
			if val, exists := blockDevice["host_groups"]; exists {
				newblockDevice["host_groups"] = val
			}
			if val, exists := blockDevice["os_type"]; exists {
				newblockDevice["os_type"] = val
			}

			newBlockDevices = append(newBlockDevices, newblockDevice)
		}

		if len(newBlockDevices) > 0 {
			obj["blockDevices"] = newBlockDevices
		}
	}

	// detect export_policy presence in TF config of volume

	if v, ok := d.GetOk("export_policy"); ok {

		l := v.([]interface{})
		newExportPolicy := make([]interface{}, 0, len(l))

		for _, item := range v.([]interface{}) {
			if item == nil {
				continue
			}
			ruleSet := item.(map[string]interface{})

			if ruleMap, ruleMapExists := ruleSet["rules"]; ruleMapExists {

				l := ruleMap.([]interface{})
				newRuleMap := make([]interface{}, 0, len(l))
				for _, ruleMapItem := range ruleMap.([]interface{}) {
					if ruleMapItem == nil {
						continue
					}
					ruleMapItemSet := ruleMapItem.(map[string]interface{})
					newRuleMapItemSet := make(map[string]interface{})

					if val, exists := ruleMapItemSet["access_type"]; exists {
						newRuleMapItemSet["accessType"] = val
					}
					if val, exists := ruleMapItemSet["allowed_clients"]; exists {
						newRuleMapItemSet["allowedClients"] = val
					}
					if val, exists := ruleMapItemSet["has_root_access"]; exists {
						newRuleMapItemSet["hasRootAccess"] = val
					}
					if val, exists := ruleMapItemSet["nfsv3"]; exists {
						newRuleMapItemSet["nfsv3"] = val
					}
					if val, exists := ruleMapItemSet["kerberos5_read_only"]; exists {
						newRuleMapItemSet["kerberos5ReadOnly"] = val
					}
					if val, exists := ruleMapItemSet["kerberos5_read_write"]; exists {
						newRuleMapItemSet["kerberos5ReadWrite"] = val
					}
					if val, exists := ruleMapItemSet["kerberos5i_read_only"]; exists {
						newRuleMapItemSet["kerberos5iReadOnly"] = val
					}
					if val, exists := ruleMapItemSet["kerberos5i_read_write"]; exists {
						newRuleMapItemSet["kerberos5iReadWrite"] = val
					}
					if val, exists := ruleMapItemSet["kerberos5p_read_only"]; exists {
						newRuleMapItemSet["kerberos5pReadOnly"] = val
					}
					if val, exists := ruleMapItemSet["kerberos5p_read_write"]; exists {
						newRuleMapItemSet["kerberos5pReadWrite"] = val
					}

					// Handle "squash_mode":
					squashModeVal, squashModeExists := ruleMapItemSet["squash_mode"]

					// Only send if the user explicitly added it.
					// If not added, send as null.
					if squashModeExists && squashModeVal == "ALL_SQUASH" {
						// User provided the field, send their value
						newRuleMapItemSet["squashMode"] = squashModeVal
					} else {
						// User did NOT provide the field, or provided an empty value.
						// Explicitly send null to the API.
						newRuleMapItemSet["squashMode"] = nil
					}

					// Handle "anon_uid"
					anonUidVal, anonUidExists := ruleMapItemSet["anon_uid"]

					// Only send if the user explicitly added it.
					// If not added, send as null.
					if anonUidExists && anonUidVal != nil && anonUidVal != 0 {
						// User provided the field, send their value
						newRuleMapItemSet["anonUid"] = anonUidVal
					} else {
						// User did NOT provide the field, or provided an empty value.
						// Explicitly send null to the API.
						newRuleMapItemSet["anonUid"] = nil
					}

					newRuleMap = append(newRuleMap, newRuleMapItemSet)

				}
				ruleSet["rules"] = newRuleMap
				newExportPolicy = append(newExportPolicy, ruleSet)
			}
		}
		if len(newExportPolicy) > 0 {
			obj["exportPolicy"] = newExportPolicy[0]
		}
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Volume %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Volume %q: %#v", d.Id(), res)
		}

		err = NetappOperationWaitTime(
			config, res, project, "Updating Volume", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceNetappVolumeRead(d, meta)
}

func resourceNetappVolumeDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Volume: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{NetappBasePath}}projects/{{project}}/locations/{{location}}/volumes/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	// Delete volume even when nested snapshots do exist
	if deletionPolicy := d.Get("deletion_policy"); deletionPolicy == "FORCE" {
		url = url + "?force=true"
	}

	log.Printf("[DEBUG] Deleting Volume %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Volume")
	}

	err = NetappOperationWaitTime(
		config, res, project, "Deleting Volume", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Volume %q: %#v", d.Id(), res)
	return nil
}

func resourceNetappVolumeImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/volumes/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/volumes/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Explicitly set virtual fields to default values on import
	if err := d.Set("deletion_policy", "DEFAULT"); err != nil {
		return nil, fmt.Errorf("Error setting deletion_policy: %s", err)
	}

	return []*schema.ResourceData{d}, nil
}

func flattenNetappVolumeState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeStateDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeShareName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumePsaRange(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeStoragePool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeServiceLevel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCapacityGib(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["rules"] =
		flattenNetappVolumeExportPolicyRules(original["rules"], d, config)
	return []interface{}{transformed}
}
func flattenNetappVolumeExportPolicyRules(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"allowed_clients":       flattenNetappVolumeExportPolicyRulesAllowedClients(original["allowedClients"], d, config),
			"has_root_access":       flattenNetappVolumeExportPolicyRulesHasRootAccess(original["hasRootAccess"], d, config),
			"access_type":           flattenNetappVolumeExportPolicyRulesAccessType(original["accessType"], d, config),
			"nfsv3":                 flattenNetappVolumeExportPolicyRulesNfsv3(original["nfsv3"], d, config),
			"nfsv4":                 flattenNetappVolumeExportPolicyRulesNfsv4(original["nfsv4"], d, config),
			"kerberos5_read_only":   flattenNetappVolumeExportPolicyRulesKerberos5ReadOnly(original["kerberos5ReadOnly"], d, config),
			"kerberos5_read_write":  flattenNetappVolumeExportPolicyRulesKerberos5ReadWrite(original["kerberos5ReadWrite"], d, config),
			"kerberos5i_read_only":  flattenNetappVolumeExportPolicyRulesKerberos5iReadOnly(original["kerberos5iReadOnly"], d, config),
			"kerberos5i_read_write": flattenNetappVolumeExportPolicyRulesKerberos5iReadWrite(original["kerberos5iReadWrite"], d, config),
			"kerberos5p_read_only":  flattenNetappVolumeExportPolicyRulesKerberos5pReadOnly(original["kerberos5pReadOnly"], d, config),
			"kerberos5p_read_write": flattenNetappVolumeExportPolicyRulesKerberos5pReadWrite(original["kerberos5pReadWrite"], d, config),
			"squash_mode":           flattenNetappVolumeExportPolicyRulesSquashMode(original["squashMode"], d, config),
			"anon_uid":              flattenNetappVolumeExportPolicyRulesAnonUid(original["anonUid"], d, config),
		})
	}
	return transformed
}
func flattenNetappVolumeExportPolicyRulesAllowedClients(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesHasRootAccess(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesAccessType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesNfsv3(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesNfsv4(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesKerberos5ReadOnly(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesKerberos5ReadWrite(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesKerberos5iReadOnly(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesKerberos5iReadWrite(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesKerberos5pReadOnly(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesKerberos5pReadWrite(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesSquashMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeExportPolicyRulesAnonUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeProtocols(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeSmbSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeUnixPermissions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetappVolumeDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeSnapshotDirectory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeUsedGib(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeSecurityStyle(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeKerberosEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeLdapEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeActiveDirectory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeKmsConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeEncryptionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHasReplication(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeRestrictedActions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeMountOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"export":       flattenNetappVolumeMountOptionsExport(original["export"], d, config),
			"export_full":  flattenNetappVolumeMountOptionsExportFull(original["exportFull"], d, config),
			"instructions": flattenNetappVolumeMountOptionsInstructions(original["instructions"], d, config),
			"protocol":     flattenNetappVolumeMountOptionsProtocol(original["protocol"], d, config),
			"ip_address":   flattenNetappVolumeMountOptionsIpAddress(original["ipAddress"], d, config),
		})
	}
	return transformed
}
func flattenNetappVolumeMountOptionsExport(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeMountOptionsExportFull(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeMountOptionsInstructions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeMountOptionsProtocol(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeMountOptionsIpAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeSnapshotPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenNetappVolumeSnapshotPolicyEnabled(original["enabled"], d, config)
	transformed["hourly_schedule"] =
		flattenNetappVolumeSnapshotPolicyHourlySchedule(original["hourlySchedule"], d, config)
	transformed["daily_schedule"] =
		flattenNetappVolumeSnapshotPolicyDailySchedule(original["dailySchedule"], d, config)
	transformed["weekly_schedule"] =
		flattenNetappVolumeSnapshotPolicyWeeklySchedule(original["weeklySchedule"], d, config)
	transformed["monthly_schedule"] =
		flattenNetappVolumeSnapshotPolicyMonthlySchedule(original["monthlySchedule"], d, config)
	return []interface{}{transformed}
}
func flattenNetappVolumeSnapshotPolicyEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeSnapshotPolicyHourlySchedule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["snapshots_to_keep"] =
		flattenNetappVolumeSnapshotPolicyHourlyScheduleSnapshotsToKeep(original["snapshotsToKeep"], d, config)
	transformed["minute"] =
		flattenNetappVolumeSnapshotPolicyHourlyScheduleMinute(original["minute"], d, config)
	return []interface{}{transformed}
}
func flattenNetappVolumeSnapshotPolicyHourlyScheduleSnapshotsToKeep(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeSnapshotPolicyHourlyScheduleMinute(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeSnapshotPolicyDailySchedule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["snapshots_to_keep"] =
		flattenNetappVolumeSnapshotPolicyDailyScheduleSnapshotsToKeep(original["snapshotsToKeep"], d, config)
	transformed["minute"] =
		flattenNetappVolumeSnapshotPolicyDailyScheduleMinute(original["minute"], d, config)
	transformed["hour"] =
		flattenNetappVolumeSnapshotPolicyDailyScheduleHour(original["hour"], d, config)
	return []interface{}{transformed}
}
func flattenNetappVolumeSnapshotPolicyDailyScheduleSnapshotsToKeep(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeSnapshotPolicyDailyScheduleMinute(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeSnapshotPolicyDailyScheduleHour(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeSnapshotPolicyWeeklySchedule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["snapshots_to_keep"] =
		flattenNetappVolumeSnapshotPolicyWeeklyScheduleSnapshotsToKeep(original["snapshotsToKeep"], d, config)
	transformed["minute"] =
		flattenNetappVolumeSnapshotPolicyWeeklyScheduleMinute(original["minute"], d, config)
	transformed["hour"] =
		flattenNetappVolumeSnapshotPolicyWeeklyScheduleHour(original["hour"], d, config)
	transformed["day"] =
		flattenNetappVolumeSnapshotPolicyWeeklyScheduleDay(original["day"], d, config)
	return []interface{}{transformed}
}
func flattenNetappVolumeSnapshotPolicyWeeklyScheduleSnapshotsToKeep(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeSnapshotPolicyWeeklyScheduleMinute(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeSnapshotPolicyWeeklyScheduleHour(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeSnapshotPolicyWeeklyScheduleDay(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeSnapshotPolicyMonthlySchedule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["snapshots_to_keep"] =
		flattenNetappVolumeSnapshotPolicyMonthlyScheduleSnapshotsToKeep(original["snapshotsToKeep"], d, config)
	transformed["minute"] =
		flattenNetappVolumeSnapshotPolicyMonthlyScheduleMinute(original["minute"], d, config)
	transformed["hour"] =
		flattenNetappVolumeSnapshotPolicyMonthlyScheduleHour(original["hour"], d, config)
	transformed["days_of_month"] =
		flattenNetappVolumeSnapshotPolicyMonthlyScheduleDaysOfMonth(original["daysOfMonth"], d, config)
	return []interface{}{transformed}
}
func flattenNetappVolumeSnapshotPolicyMonthlyScheduleSnapshotsToKeep(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeSnapshotPolicyMonthlyScheduleMinute(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeSnapshotPolicyMonthlyScheduleHour(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeSnapshotPolicyMonthlyScheduleDaysOfMonth(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeBackupConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["backup_policies"] =
		flattenNetappVolumeBackupConfigBackupPolicies(original["backupPolicies"], d, config)
	transformed["backup_vault"] =
		flattenNetappVolumeBackupConfigBackupVault(original["backupVault"], d, config)
	transformed["scheduled_backup_enabled"] =
		flattenNetappVolumeBackupConfigScheduledBackupEnabled(original["scheduledBackupEnabled"], d, config)
	return []interface{}{transformed}
}
func flattenNetappVolumeBackupConfigBackupPolicies(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeBackupConfigBackupVault(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeBackupConfigScheduledBackupEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeReplicaZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeLargeCapacity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeMultipleEndpoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeColdTierSizeGib(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeTieringPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cooling_threshold_days"] =
		flattenNetappVolumeTieringPolicyCoolingThresholdDays(original["coolingThresholdDays"], d, config)
	transformed["tier_action"] =
		flattenNetappVolumeTieringPolicyTierAction(original["tierAction"], d, config)
	transformed["hot_tier_bypass_mode_enabled"] =
		flattenNetappVolumeTieringPolicyHotTierBypassModeEnabled(original["hotTierBypassModeEnabled"], d, config)
	return []interface{}{transformed}
}
func flattenNetappVolumeTieringPolicyCoolingThresholdDays(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeTieringPolicyTierAction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeTieringPolicyHotTierBypassModeEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHybridReplicationParameters(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["replication"] =
		flattenNetappVolumeHybridReplicationParametersReplication(original["replication"], d, config)
	transformed["peer_volume_name"] =
		flattenNetappVolumeHybridReplicationParametersPeerVolumeName(original["peerVolumeName"], d, config)
	transformed["peer_cluster_name"] =
		flattenNetappVolumeHybridReplicationParametersPeerClusterName(original["peerClusterName"], d, config)
	transformed["peer_svm_name"] =
		flattenNetappVolumeHybridReplicationParametersPeerSvmName(original["peerSvmName"], d, config)
	transformed["peer_ip_addresses"] =
		flattenNetappVolumeHybridReplicationParametersPeerIpAddresses(original["peerIpAddresses"], d, config)
	transformed["cluster_location"] =
		flattenNetappVolumeHybridReplicationParametersClusterLocation(original["clusterLocation"], d, config)
	transformed["description"] =
		flattenNetappVolumeHybridReplicationParametersDescription(original["description"], d, config)
	transformed["labels"] =
		flattenNetappVolumeHybridReplicationParametersLabels(original["labels"], d, config)
	transformed["replication_schedule"] =
		flattenNetappVolumeHybridReplicationParametersReplicationSchedule(original["replicationSchedule"], d, config)
	transformed["hybrid_replication_type"] =
		flattenNetappVolumeHybridReplicationParametersHybridReplicationType(original["hybridReplicationType"], d, config)
	transformed["large_volume_constituent_count"] =
		flattenNetappVolumeHybridReplicationParametersLargeVolumeConstituentCount(original["largeVolumeConstituentCount"], d, config)
	return []interface{}{transformed}
}
func flattenNetappVolumeHybridReplicationParametersReplication(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHybridReplicationParametersPeerVolumeName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHybridReplicationParametersPeerClusterName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHybridReplicationParametersPeerSvmName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHybridReplicationParametersPeerIpAddresses(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHybridReplicationParametersClusterLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHybridReplicationParametersDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHybridReplicationParametersLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHybridReplicationParametersReplicationSchedule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHybridReplicationParametersHybridReplicationType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHybridReplicationParametersLargeVolumeConstituentCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeThroughputMibps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeHotTierSizeUsedGib(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCacheParameters(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["peer_volume_name"] =
		flattenNetappVolumeCacheParametersPeerVolumeName(original["peerVolumeName"], d, config)
	transformed["peer_cluster_name"] =
		flattenNetappVolumeCacheParametersPeerClusterName(original["peerClusterName"], d, config)
	transformed["peer_svm_name"] =
		flattenNetappVolumeCacheParametersPeerSvmName(original["peerSvmName"], d, config)
	transformed["peer_ip_addresses"] =
		flattenNetappVolumeCacheParametersPeerIpAddresses(original["peerIpAddresses"], d, config)
	transformed["enable_global_file_lock"] =
		flattenNetappVolumeCacheParametersEnableGlobalFileLock(original["enableGlobalFileLock"], d, config)
	transformed["peering_command_expiry_time"] =
		flattenNetappVolumeCacheParametersPeeringCommandExpiryTime(original["peeringCommandExpiryTime"], d, config)
	transformed["cache_state"] =
		flattenNetappVolumeCacheParametersCacheState(original["cacheState"], d, config)
	transformed["command"] =
		flattenNetappVolumeCacheParametersCommand(original["command"], d, config)
	transformed["passphrase"] =
		flattenNetappVolumeCacheParametersPassphrase(original["passphrase"], d, config)
	transformed["state_details"] =
		flattenNetappVolumeCacheParametersStateDetails(original["stateDetails"], d, config)
	transformed["cache_config"] =
		flattenNetappVolumeCacheParametersCacheConfig(original["cacheConfig"], d, config)
	return []interface{}{transformed}
}
func flattenNetappVolumeCacheParametersPeerVolumeName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCacheParametersPeerClusterName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCacheParametersPeerSvmName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCacheParametersPeerIpAddresses(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCacheParametersEnableGlobalFileLock(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCacheParametersPeeringCommandExpiryTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCacheParametersCacheState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCacheParametersCommand(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCacheParametersPassphrase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCacheParametersStateDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeCacheParametersCacheConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cifs_change_notify_enabled"] =
		flattenNetappVolumeCacheParametersCacheConfigCifsChangeNotifyEnabled(original["cifsChangeNotifyEnabled"], d, config)
	return []interface{}{transformed}
}
func flattenNetappVolumeCacheParametersCacheConfigCifsChangeNotifyEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeBlockDevices(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":        flattenNetappVolumeBlockDevicesName(original["name"], d, config),
			"host_groups": flattenNetappVolumeBlockDevicesHostGroups(original["hostGroups"], d, config),
			"identifier":  flattenNetappVolumeBlockDevicesIdentifier(original["identifier"], d, config),
			"size_gib":    flattenNetappVolumeBlockDevicesSizeGib(original["sizeGib"], d, config),
			"os_type":     flattenNetappVolumeBlockDevicesOsType(original["osType"], d, config),
		})
	}
	return transformed
}
func flattenNetappVolumeBlockDevicesName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeBlockDevicesHostGroups(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeBlockDevicesIdentifier(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeBlockDevicesSizeGib(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetappVolumeBlockDevicesOsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappVolumeTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetappVolumeEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandNetappVolumeShareName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeStoragePool(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCapacityGib(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRules, err := expandNetappVolumeExportPolicyRules(original["rules"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRules); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rules"] = transformedRules
	}

	return transformed, nil
}

func expandNetappVolumeExportPolicyRules(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAllowedClients, err := expandNetappVolumeExportPolicyRulesAllowedClients(original["allowed_clients"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAllowedClients); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["allowedClients"] = transformedAllowedClients
		}

		transformedHasRootAccess, err := expandNetappVolumeExportPolicyRulesHasRootAccess(original["has_root_access"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHasRootAccess); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hasRootAccess"] = transformedHasRootAccess
		}

		transformedAccessType, err := expandNetappVolumeExportPolicyRulesAccessType(original["access_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAccessType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["accessType"] = transformedAccessType
		}

		transformedNfsv3, err := expandNetappVolumeExportPolicyRulesNfsv3(original["nfsv3"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNfsv3); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["nfsv3"] = transformedNfsv3
		}

		transformedNfsv4, err := expandNetappVolumeExportPolicyRulesNfsv4(original["nfsv4"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNfsv4); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["nfsv4"] = transformedNfsv4
		}

		transformedKerberos5ReadOnly, err := expandNetappVolumeExportPolicyRulesKerberos5ReadOnly(original["kerberos5_read_only"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKerberos5ReadOnly); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["kerberos5ReadOnly"] = transformedKerberos5ReadOnly
		}

		transformedKerberos5ReadWrite, err := expandNetappVolumeExportPolicyRulesKerberos5ReadWrite(original["kerberos5_read_write"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKerberos5ReadWrite); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["kerberos5ReadWrite"] = transformedKerberos5ReadWrite
		}

		transformedKerberos5iReadOnly, err := expandNetappVolumeExportPolicyRulesKerberos5iReadOnly(original["kerberos5i_read_only"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKerberos5iReadOnly); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["kerberos5iReadOnly"] = transformedKerberos5iReadOnly
		}

		transformedKerberos5iReadWrite, err := expandNetappVolumeExportPolicyRulesKerberos5iReadWrite(original["kerberos5i_read_write"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKerberos5iReadWrite); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["kerberos5iReadWrite"] = transformedKerberos5iReadWrite
		}

		transformedKerberos5pReadOnly, err := expandNetappVolumeExportPolicyRulesKerberos5pReadOnly(original["kerberos5p_read_only"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKerberos5pReadOnly); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["kerberos5pReadOnly"] = transformedKerberos5pReadOnly
		}

		transformedKerberos5pReadWrite, err := expandNetappVolumeExportPolicyRulesKerberos5pReadWrite(original["kerberos5p_read_write"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKerberos5pReadWrite); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["kerberos5pReadWrite"] = transformedKerberos5pReadWrite
		}

		transformedSquashMode, err := expandNetappVolumeExportPolicyRulesSquashMode(original["squash_mode"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSquashMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["squashMode"] = transformedSquashMode
		}

		transformedAnonUid, err := expandNetappVolumeExportPolicyRulesAnonUid(original["anon_uid"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAnonUid); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["anonUid"] = transformedAnonUid
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetappVolumeExportPolicyRulesAllowedClients(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesHasRootAccess(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesAccessType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesNfsv3(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesNfsv4(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesKerberos5ReadOnly(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesKerberos5ReadWrite(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesKerberos5iReadOnly(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesKerberos5iReadWrite(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesKerberos5pReadOnly(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesKerberos5pReadWrite(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesSquashMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeExportPolicyRulesAnonUid(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeProtocols(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSmbSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeUnixPermissions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotDirectory(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSecurityStyle(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeKerberosEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeRestoreParameters(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSourceSnapshot, err := expandNetappVolumeRestoreParametersSourceSnapshot(original["source_snapshot"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSourceSnapshot); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sourceSnapshot"] = transformedSourceSnapshot
	}

	transformedSourceBackup, err := expandNetappVolumeRestoreParametersSourceBackup(original["source_backup"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSourceBackup); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sourceBackup"] = transformedSourceBackup
	}

	return transformed, nil
}

func expandNetappVolumeRestoreParametersSourceSnapshot(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeRestoreParametersSourceBackup(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeRestrictedActions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandNetappVolumeSnapshotPolicyEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["enabled"] = transformedEnabled
	}

	transformedHourlySchedule, err := expandNetappVolumeSnapshotPolicyHourlySchedule(original["hourly_schedule"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHourlySchedule); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hourlySchedule"] = transformedHourlySchedule
	}

	transformedDailySchedule, err := expandNetappVolumeSnapshotPolicyDailySchedule(original["daily_schedule"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDailySchedule); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dailySchedule"] = transformedDailySchedule
	}

	transformedWeeklySchedule, err := expandNetappVolumeSnapshotPolicyWeeklySchedule(original["weekly_schedule"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWeeklySchedule); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["weeklySchedule"] = transformedWeeklySchedule
	}

	transformedMonthlySchedule, err := expandNetappVolumeSnapshotPolicyMonthlySchedule(original["monthly_schedule"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMonthlySchedule); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["monthlySchedule"] = transformedMonthlySchedule
	}

	return transformed, nil
}

func expandNetappVolumeSnapshotPolicyEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyHourlySchedule(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSnapshotsToKeep, err := expandNetappVolumeSnapshotPolicyHourlyScheduleSnapshotsToKeep(original["snapshots_to_keep"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSnapshotsToKeep); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["snapshotsToKeep"] = transformedSnapshotsToKeep
	}

	transformedMinute, err := expandNetappVolumeSnapshotPolicyHourlyScheduleMinute(original["minute"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinute); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minute"] = transformedMinute
	}

	return transformed, nil
}

func expandNetappVolumeSnapshotPolicyHourlyScheduleSnapshotsToKeep(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyHourlyScheduleMinute(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyDailySchedule(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSnapshotsToKeep, err := expandNetappVolumeSnapshotPolicyDailyScheduleSnapshotsToKeep(original["snapshots_to_keep"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSnapshotsToKeep); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["snapshotsToKeep"] = transformedSnapshotsToKeep
	}

	transformedMinute, err := expandNetappVolumeSnapshotPolicyDailyScheduleMinute(original["minute"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinute); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minute"] = transformedMinute
	}

	transformedHour, err := expandNetappVolumeSnapshotPolicyDailyScheduleHour(original["hour"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHour); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hour"] = transformedHour
	}

	return transformed, nil
}

func expandNetappVolumeSnapshotPolicyDailyScheduleSnapshotsToKeep(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyDailyScheduleMinute(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyDailyScheduleHour(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyWeeklySchedule(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSnapshotsToKeep, err := expandNetappVolumeSnapshotPolicyWeeklyScheduleSnapshotsToKeep(original["snapshots_to_keep"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSnapshotsToKeep); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["snapshotsToKeep"] = transformedSnapshotsToKeep
	}

	transformedMinute, err := expandNetappVolumeSnapshotPolicyWeeklyScheduleMinute(original["minute"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinute); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minute"] = transformedMinute
	}

	transformedHour, err := expandNetappVolumeSnapshotPolicyWeeklyScheduleHour(original["hour"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHour); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hour"] = transformedHour
	}

	transformedDay, err := expandNetappVolumeSnapshotPolicyWeeklyScheduleDay(original["day"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDay); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["day"] = transformedDay
	}

	return transformed, nil
}

func expandNetappVolumeSnapshotPolicyWeeklyScheduleSnapshotsToKeep(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyWeeklyScheduleMinute(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyWeeklyScheduleHour(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyWeeklyScheduleDay(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyMonthlySchedule(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSnapshotsToKeep, err := expandNetappVolumeSnapshotPolicyMonthlyScheduleSnapshotsToKeep(original["snapshots_to_keep"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSnapshotsToKeep); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["snapshotsToKeep"] = transformedSnapshotsToKeep
	}

	transformedMinute, err := expandNetappVolumeSnapshotPolicyMonthlyScheduleMinute(original["minute"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinute); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minute"] = transformedMinute
	}

	transformedHour, err := expandNetappVolumeSnapshotPolicyMonthlyScheduleHour(original["hour"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHour); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hour"] = transformedHour
	}

	transformedDaysOfMonth, err := expandNetappVolumeSnapshotPolicyMonthlyScheduleDaysOfMonth(original["days_of_month"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDaysOfMonth); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["daysOfMonth"] = transformedDaysOfMonth
	}

	return transformed, nil
}

func expandNetappVolumeSnapshotPolicyMonthlyScheduleSnapshotsToKeep(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyMonthlyScheduleMinute(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyMonthlyScheduleHour(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeSnapshotPolicyMonthlyScheduleDaysOfMonth(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeBackupConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBackupPolicies, err := expandNetappVolumeBackupConfigBackupPolicies(original["backup_policies"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBackupPolicies); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["backupPolicies"] = transformedBackupPolicies
	}

	transformedBackupVault, err := expandNetappVolumeBackupConfigBackupVault(original["backup_vault"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBackupVault); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["backupVault"] = transformedBackupVault
	}

	transformedScheduledBackupEnabled, err := expandNetappVolumeBackupConfigScheduledBackupEnabled(original["scheduled_backup_enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScheduledBackupEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scheduledBackupEnabled"] = transformedScheduledBackupEnabled
	}

	return transformed, nil
}

func expandNetappVolumeBackupConfigBackupPolicies(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeBackupConfigBackupVault(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeBackupConfigScheduledBackupEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeLargeCapacity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeMultipleEndpoints(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeTieringPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCoolingThresholdDays, err := expandNetappVolumeTieringPolicyCoolingThresholdDays(original["cooling_threshold_days"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCoolingThresholdDays); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["coolingThresholdDays"] = transformedCoolingThresholdDays
	}

	transformedTierAction, err := expandNetappVolumeTieringPolicyTierAction(original["tier_action"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTierAction); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tierAction"] = transformedTierAction
	}

	transformedHotTierBypassModeEnabled, err := expandNetappVolumeTieringPolicyHotTierBypassModeEnabled(original["hot_tier_bypass_mode_enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHotTierBypassModeEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hotTierBypassModeEnabled"] = transformedHotTierBypassModeEnabled
	}

	return transformed, nil
}

func expandNetappVolumeTieringPolicyCoolingThresholdDays(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeTieringPolicyTierAction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeTieringPolicyHotTierBypassModeEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeHybridReplicationParameters(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedReplication, err := expandNetappVolumeHybridReplicationParametersReplication(original["replication"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReplication); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["replication"] = transformedReplication
	}

	transformedPeerVolumeName, err := expandNetappVolumeHybridReplicationParametersPeerVolumeName(original["peer_volume_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeerVolumeName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["peerVolumeName"] = transformedPeerVolumeName
	}

	transformedPeerClusterName, err := expandNetappVolumeHybridReplicationParametersPeerClusterName(original["peer_cluster_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeerClusterName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["peerClusterName"] = transformedPeerClusterName
	}

	transformedPeerSvmName, err := expandNetappVolumeHybridReplicationParametersPeerSvmName(original["peer_svm_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeerSvmName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["peerSvmName"] = transformedPeerSvmName
	}

	transformedPeerIpAddresses, err := expandNetappVolumeHybridReplicationParametersPeerIpAddresses(original["peer_ip_addresses"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeerIpAddresses); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["peerIpAddresses"] = transformedPeerIpAddresses
	}

	transformedClusterLocation, err := expandNetappVolumeHybridReplicationParametersClusterLocation(original["cluster_location"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClusterLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clusterLocation"] = transformedClusterLocation
	}

	transformedDescription, err := expandNetappVolumeHybridReplicationParametersDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedLabels, err := expandNetappVolumeHybridReplicationParametersLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedReplicationSchedule, err := expandNetappVolumeHybridReplicationParametersReplicationSchedule(original["replication_schedule"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReplicationSchedule); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["replicationSchedule"] = transformedReplicationSchedule
	}

	transformedHybridReplicationType, err := expandNetappVolumeHybridReplicationParametersHybridReplicationType(original["hybrid_replication_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHybridReplicationType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hybridReplicationType"] = transformedHybridReplicationType
	}

	transformedLargeVolumeConstituentCount, err := expandNetappVolumeHybridReplicationParametersLargeVolumeConstituentCount(original["large_volume_constituent_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLargeVolumeConstituentCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["largeVolumeConstituentCount"] = transformedLargeVolumeConstituentCount
	}

	return transformed, nil
}

func expandNetappVolumeHybridReplicationParametersReplication(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeHybridReplicationParametersPeerVolumeName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeHybridReplicationParametersPeerClusterName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeHybridReplicationParametersPeerSvmName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeHybridReplicationParametersPeerIpAddresses(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeHybridReplicationParametersClusterLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeHybridReplicationParametersDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeHybridReplicationParametersLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandNetappVolumeHybridReplicationParametersReplicationSchedule(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeHybridReplicationParametersHybridReplicationType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeHybridReplicationParametersLargeVolumeConstituentCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeThroughputMibps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCacheParameters(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPeerVolumeName, err := expandNetappVolumeCacheParametersPeerVolumeName(original["peer_volume_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeerVolumeName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["peerVolumeName"] = transformedPeerVolumeName
	}

	transformedPeerClusterName, err := expandNetappVolumeCacheParametersPeerClusterName(original["peer_cluster_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeerClusterName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["peerClusterName"] = transformedPeerClusterName
	}

	transformedPeerSvmName, err := expandNetappVolumeCacheParametersPeerSvmName(original["peer_svm_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeerSvmName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["peerSvmName"] = transformedPeerSvmName
	}

	transformedPeerIpAddresses, err := expandNetappVolumeCacheParametersPeerIpAddresses(original["peer_ip_addresses"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeerIpAddresses); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["peerIpAddresses"] = transformedPeerIpAddresses
	}

	transformedEnableGlobalFileLock, err := expandNetappVolumeCacheParametersEnableGlobalFileLock(original["enable_global_file_lock"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableGlobalFileLock); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableGlobalFileLock"] = transformedEnableGlobalFileLock
	}

	transformedPeeringCommandExpiryTime, err := expandNetappVolumeCacheParametersPeeringCommandExpiryTime(original["peering_command_expiry_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeeringCommandExpiryTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["peeringCommandExpiryTime"] = transformedPeeringCommandExpiryTime
	}

	transformedCacheState, err := expandNetappVolumeCacheParametersCacheState(original["cache_state"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCacheState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cacheState"] = transformedCacheState
	}

	transformedCommand, err := expandNetappVolumeCacheParametersCommand(original["command"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommand); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["command"] = transformedCommand
	}

	transformedPassphrase, err := expandNetappVolumeCacheParametersPassphrase(original["passphrase"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassphrase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["passphrase"] = transformedPassphrase
	}

	transformedStateDetails, err := expandNetappVolumeCacheParametersStateDetails(original["state_details"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStateDetails); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["stateDetails"] = transformedStateDetails
	}

	transformedCacheConfig, err := expandNetappVolumeCacheParametersCacheConfig(original["cache_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCacheConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cacheConfig"] = transformedCacheConfig
	}

	return transformed, nil
}

func expandNetappVolumeCacheParametersPeerVolumeName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCacheParametersPeerClusterName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCacheParametersPeerSvmName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCacheParametersPeerIpAddresses(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCacheParametersEnableGlobalFileLock(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCacheParametersPeeringCommandExpiryTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCacheParametersCacheState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCacheParametersCommand(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCacheParametersPassphrase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCacheParametersStateDetails(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeCacheParametersCacheConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCifsChangeNotifyEnabled, err := expandNetappVolumeCacheParametersCacheConfigCifsChangeNotifyEnabled(original["cifs_change_notify_enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCifsChangeNotifyEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cifsChangeNotifyEnabled"] = transformedCifsChangeNotifyEnabled
	}

	return transformed, nil
}

func expandNetappVolumeCacheParametersCacheConfigCifsChangeNotifyEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeBlockDevices(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandNetappVolumeBlockDevicesName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedHostGroups, err := expandNetappVolumeBlockDevicesHostGroups(original["host_groups"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHostGroups); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hostGroups"] = transformedHostGroups
		}

		transformedIdentifier, err := expandNetappVolumeBlockDevicesIdentifier(original["identifier"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIdentifier); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["identifier"] = transformedIdentifier
		}

		transformedSizeGib, err := expandNetappVolumeBlockDevicesSizeGib(original["size_gib"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSizeGib); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["sizeGib"] = transformedSizeGib
		}

		transformedOsType, err := expandNetappVolumeBlockDevicesOsType(original["os_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOsType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["osType"] = transformedOsType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandNetappVolumeBlockDevicesName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeBlockDevicesHostGroups(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeBlockDevicesIdentifier(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeBlockDevicesSizeGib(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeBlockDevicesOsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappVolumeEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
