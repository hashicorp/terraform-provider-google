// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package netapp

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceNetappActiveDirectory() *schema.Resource {
	return &schema.Resource{
		Create: resourceNetappActiveDirectoryCreate,
		Read:   resourceNetappActiveDirectoryRead,
		Update: resourceNetappActiveDirectoryUpdate,
		Delete: resourceNetappActiveDirectoryDelete,

		Importer: &schema.ResourceImporter{
			State: resourceNetappActiveDirectoryImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"dns": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Comma separated list of DNS server IP addresses for the Active Directory domain.`,
			},
			"domain": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Fully qualified domain name for the Active Directory domain.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Name of the region for the policy to apply to.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The resource name of the Active Directory pool. Needs to be unique per location.`,
			},
			"net_bios_prefix": {
				Type:     schema.TypeString,
				Required: true,
				Description: `NetBIOS name prefix of the server to be created.
A five-character random ID is generated automatically, for example, -6f9a, and appended to the prefix. The full UNC share path will have the following format:
'\\NetBIOS_PREFIX-ABCD.DOMAIN_NAME\SHARE_NAME'`,
			},
			"password": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Password for specified username. Note - Manual changes done to the password will not be detected. Terraform will not re-apply the password, unless you use a new password in Terraform.`,
				Sensitive:   true,
			},
			"username": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Username for the Active Directory account with permissions to create the compute account within the specified organizational unit.`,
			},
			"administrators": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Domain user accounts to be added to the local Administrators group of the SMB service. Comma-separated list of domain users or groups. The Domain Admin group is automatically added when the service joins your domain as a hidden group.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"aes_encryption": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Enables AES-128 and AES-256 encryption for Kerberos-based communication with Active Directory.`,
				Default:     true,
			},
			"backup_operators": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Domain user/group accounts to be added to the Backup Operators group of the SMB service. The Backup Operators group allows members to backup and restore files regardless of whether they have read or write access to the files. Comma-separated list.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An optional description of this resource.`,
			},
			"encrypt_dc_connections": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `If enabled, traffic between the SMB server to Domain Controller (DC) will be encrypted.`,
			},
			"kdc_hostname": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Hostname of the Active Directory server used as Kerberos Key Distribution Center. Only required for volumes using kerberized NFSv4.1`,
			},
			"kdc_ip": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `IP address of the Active Directory server used as Kerberos Key Distribution Center.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Labels as key value pairs. Example: '{ "owner": "Bob", "department": "finance", "purpose": "testing" }'.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"ldap_signing": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Specifies whether or not the LDAP traffic needs to be signed.`,
			},
			"nfs_users_with_ldap": {
				Type:     schema.TypeBool,
				Optional: true,
				Description: `Local UNIX users on clients without valid user information in Active Directory are blocked from access to LDAP enabled volumes.
This option can be used to temporarily switch such volumes to AUTH_SYS authentication (user ID + 1-16 groups).`,
			},
			"organizational_unit": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				Description: `Name of the Organizational Unit where you intend to create the computer account for NetApp Volumes.
Defaults to 'CN=Computers' if left empty.`,
			},
			"security_operators": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Domain accounts that require elevated privileges such as 'SeSecurityPrivilege' to manage security logs. Comma-separated list.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"site": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Specifies an Active Directory site to manage domain controller selection.
Use when Active Directory domain controllers in multiple regions are configured. Defaults to 'Default-First-Site-Name' if left empty.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Create time of the active directory. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The state of the Active Directory policy (not the Active Directory itself).`,
			},
			"state_details": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The state details of the Active Directory.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceNetappActiveDirectoryCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	domainProp, err := expandNetappActiveDirectoryDomain(d.Get("domain"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("domain"); !tpgresource.IsEmptyValue(reflect.ValueOf(domainProp)) && (ok || !reflect.DeepEqual(v, domainProp)) {
		obj["domain"] = domainProp
	}
	siteProp, err := expandNetappActiveDirectorySite(d.Get("site"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("site"); !tpgresource.IsEmptyValue(reflect.ValueOf(siteProp)) && (ok || !reflect.DeepEqual(v, siteProp)) {
		obj["site"] = siteProp
	}
	dnsProp, err := expandNetappActiveDirectoryDns(d.Get("dns"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dns"); !tpgresource.IsEmptyValue(reflect.ValueOf(dnsProp)) && (ok || !reflect.DeepEqual(v, dnsProp)) {
		obj["dns"] = dnsProp
	}
	netBiosPrefixProp, err := expandNetappActiveDirectoryNetBiosPrefix(d.Get("net_bios_prefix"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("net_bios_prefix"); !tpgresource.IsEmptyValue(reflect.ValueOf(netBiosPrefixProp)) && (ok || !reflect.DeepEqual(v, netBiosPrefixProp)) {
		obj["netBiosPrefix"] = netBiosPrefixProp
	}
	organizationalUnitProp, err := expandNetappActiveDirectoryOrganizationalUnit(d.Get("organizational_unit"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("organizational_unit"); !tpgresource.IsEmptyValue(reflect.ValueOf(organizationalUnitProp)) && (ok || !reflect.DeepEqual(v, organizationalUnitProp)) {
		obj["organizationalUnit"] = organizationalUnitProp
	}
	aesEncryptionProp, err := expandNetappActiveDirectoryAesEncryption(d.Get("aes_encryption"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("aes_encryption"); !tpgresource.IsEmptyValue(reflect.ValueOf(aesEncryptionProp)) && (ok || !reflect.DeepEqual(v, aesEncryptionProp)) {
		obj["aesEncryption"] = aesEncryptionProp
	}
	usernameProp, err := expandNetappActiveDirectoryUsername(d.Get("username"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("username"); !tpgresource.IsEmptyValue(reflect.ValueOf(usernameProp)) && (ok || !reflect.DeepEqual(v, usernameProp)) {
		obj["username"] = usernameProp
	}
	passwordProp, err := expandNetappActiveDirectoryPassword(d.Get("password"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("password"); !tpgresource.IsEmptyValue(reflect.ValueOf(passwordProp)) && (ok || !reflect.DeepEqual(v, passwordProp)) {
		obj["password"] = passwordProp
	}
	backupOperatorsProp, err := expandNetappActiveDirectoryBackupOperators(d.Get("backup_operators"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backup_operators"); !tpgresource.IsEmptyValue(reflect.ValueOf(backupOperatorsProp)) && (ok || !reflect.DeepEqual(v, backupOperatorsProp)) {
		obj["backupOperators"] = backupOperatorsProp
	}
	administratorsProp, err := expandNetappActiveDirectoryAdministrators(d.Get("administrators"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("administrators"); !tpgresource.IsEmptyValue(reflect.ValueOf(administratorsProp)) && (ok || !reflect.DeepEqual(v, administratorsProp)) {
		obj["administrators"] = administratorsProp
	}
	securityOperatorsProp, err := expandNetappActiveDirectorySecurityOperators(d.Get("security_operators"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("security_operators"); !tpgresource.IsEmptyValue(reflect.ValueOf(securityOperatorsProp)) && (ok || !reflect.DeepEqual(v, securityOperatorsProp)) {
		obj["securityOperators"] = securityOperatorsProp
	}
	kdcHostnameProp, err := expandNetappActiveDirectoryKdcHostname(d.Get("kdc_hostname"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("kdc_hostname"); !tpgresource.IsEmptyValue(reflect.ValueOf(kdcHostnameProp)) && (ok || !reflect.DeepEqual(v, kdcHostnameProp)) {
		obj["kdcHostname"] = kdcHostnameProp
	}
	kdcIpProp, err := expandNetappActiveDirectoryKdcIp(d.Get("kdc_ip"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("kdc_ip"); !tpgresource.IsEmptyValue(reflect.ValueOf(kdcIpProp)) && (ok || !reflect.DeepEqual(v, kdcIpProp)) {
		obj["kdcIp"] = kdcIpProp
	}
	nfsUsersWithLdapProp, err := expandNetappActiveDirectoryNfsUsersWithLdap(d.Get("nfs_users_with_ldap"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("nfs_users_with_ldap"); !tpgresource.IsEmptyValue(reflect.ValueOf(nfsUsersWithLdapProp)) && (ok || !reflect.DeepEqual(v, nfsUsersWithLdapProp)) {
		obj["nfsUsersWithLdap"] = nfsUsersWithLdapProp
	}
	descriptionProp, err := expandNetappActiveDirectoryDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	ldapSigningProp, err := expandNetappActiveDirectoryLdapSigning(d.Get("ldap_signing"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ldap_signing"); !tpgresource.IsEmptyValue(reflect.ValueOf(ldapSigningProp)) && (ok || !reflect.DeepEqual(v, ldapSigningProp)) {
		obj["ldapSigning"] = ldapSigningProp
	}
	encryptDcConnectionsProp, err := expandNetappActiveDirectoryEncryptDcConnections(d.Get("encrypt_dc_connections"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("encrypt_dc_connections"); !tpgresource.IsEmptyValue(reflect.ValueOf(encryptDcConnectionsProp)) && (ok || !reflect.DeepEqual(v, encryptDcConnectionsProp)) {
		obj["encryptDcConnections"] = encryptDcConnectionsProp
	}
	labelsProp, err := expandNetappActiveDirectoryEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetappBasePath}}projects/{{project}}/locations/{{location}}/activeDirectories?activeDirectoryId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new ActiveDirectory: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ActiveDirectory: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating ActiveDirectory: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/activeDirectories/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = NetappOperationWaitTime(
		config, res, project, "Creating ActiveDirectory", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create ActiveDirectory: %s", err)
	}

	log.Printf("[DEBUG] Finished creating ActiveDirectory %q: %#v", d.Id(), res)

	return resourceNetappActiveDirectoryRead(d, meta)
}

func resourceNetappActiveDirectoryRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetappBasePath}}projects/{{project}}/locations/{{location}}/activeDirectories/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ActiveDirectory: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("NetappActiveDirectory %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}

	if err := d.Set("create_time", flattenNetappActiveDirectoryCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("state", flattenNetappActiveDirectoryState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("domain", flattenNetappActiveDirectoryDomain(res["domain"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("site", flattenNetappActiveDirectorySite(res["site"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("dns", flattenNetappActiveDirectoryDns(res["dns"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("net_bios_prefix", flattenNetappActiveDirectoryNetBiosPrefix(res["netBiosPrefix"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("organizational_unit", flattenNetappActiveDirectoryOrganizationalUnit(res["organizationalUnit"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("aes_encryption", flattenNetappActiveDirectoryAesEncryption(res["aesEncryption"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("username", flattenNetappActiveDirectoryUsername(res["username"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("backup_operators", flattenNetappActiveDirectoryBackupOperators(res["backupOperators"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("administrators", flattenNetappActiveDirectoryAdministrators(res["administrators"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("security_operators", flattenNetappActiveDirectorySecurityOperators(res["securityOperators"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("kdc_hostname", flattenNetappActiveDirectoryKdcHostname(res["kdcHostname"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("kdc_ip", flattenNetappActiveDirectoryKdcIp(res["kdcIp"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("nfs_users_with_ldap", flattenNetappActiveDirectoryNfsUsersWithLdap(res["nfsUsersWithLdap"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("description", flattenNetappActiveDirectoryDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("ldap_signing", flattenNetappActiveDirectoryLdapSigning(res["ldapSigning"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("encrypt_dc_connections", flattenNetappActiveDirectoryEncryptDcConnections(res["encryptDcConnections"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("labels", flattenNetappActiveDirectoryLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("state_details", flattenNetappActiveDirectoryStateDetails(res["stateDetails"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("terraform_labels", flattenNetappActiveDirectoryTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}
	if err := d.Set("effective_labels", flattenNetappActiveDirectoryEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading ActiveDirectory: %s", err)
	}

	return nil
}

func resourceNetappActiveDirectoryUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ActiveDirectory: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	domainProp, err := expandNetappActiveDirectoryDomain(d.Get("domain"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("domain"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, domainProp)) {
		obj["domain"] = domainProp
	}
	siteProp, err := expandNetappActiveDirectorySite(d.Get("site"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("site"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, siteProp)) {
		obj["site"] = siteProp
	}
	dnsProp, err := expandNetappActiveDirectoryDns(d.Get("dns"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dns"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dnsProp)) {
		obj["dns"] = dnsProp
	}
	netBiosPrefixProp, err := expandNetappActiveDirectoryNetBiosPrefix(d.Get("net_bios_prefix"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("net_bios_prefix"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, netBiosPrefixProp)) {
		obj["netBiosPrefix"] = netBiosPrefixProp
	}
	organizationalUnitProp, err := expandNetappActiveDirectoryOrganizationalUnit(d.Get("organizational_unit"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("organizational_unit"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, organizationalUnitProp)) {
		obj["organizationalUnit"] = organizationalUnitProp
	}
	aesEncryptionProp, err := expandNetappActiveDirectoryAesEncryption(d.Get("aes_encryption"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("aes_encryption"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, aesEncryptionProp)) {
		obj["aesEncryption"] = aesEncryptionProp
	}
	usernameProp, err := expandNetappActiveDirectoryUsername(d.Get("username"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("username"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, usernameProp)) {
		obj["username"] = usernameProp
	}
	passwordProp, err := expandNetappActiveDirectoryPassword(d.Get("password"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("password"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, passwordProp)) {
		obj["password"] = passwordProp
	}
	backupOperatorsProp, err := expandNetappActiveDirectoryBackupOperators(d.Get("backup_operators"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backup_operators"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, backupOperatorsProp)) {
		obj["backupOperators"] = backupOperatorsProp
	}
	administratorsProp, err := expandNetappActiveDirectoryAdministrators(d.Get("administrators"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("administrators"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, administratorsProp)) {
		obj["administrators"] = administratorsProp
	}
	securityOperatorsProp, err := expandNetappActiveDirectorySecurityOperators(d.Get("security_operators"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("security_operators"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, securityOperatorsProp)) {
		obj["securityOperators"] = securityOperatorsProp
	}
	kdcHostnameProp, err := expandNetappActiveDirectoryKdcHostname(d.Get("kdc_hostname"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("kdc_hostname"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, kdcHostnameProp)) {
		obj["kdcHostname"] = kdcHostnameProp
	}
	kdcIpProp, err := expandNetappActiveDirectoryKdcIp(d.Get("kdc_ip"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("kdc_ip"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, kdcIpProp)) {
		obj["kdcIp"] = kdcIpProp
	}
	nfsUsersWithLdapProp, err := expandNetappActiveDirectoryNfsUsersWithLdap(d.Get("nfs_users_with_ldap"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("nfs_users_with_ldap"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nfsUsersWithLdapProp)) {
		obj["nfsUsersWithLdap"] = nfsUsersWithLdapProp
	}
	descriptionProp, err := expandNetappActiveDirectoryDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	ldapSigningProp, err := expandNetappActiveDirectoryLdapSigning(d.Get("ldap_signing"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ldap_signing"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, ldapSigningProp)) {
		obj["ldapSigning"] = ldapSigningProp
	}
	encryptDcConnectionsProp, err := expandNetappActiveDirectoryEncryptDcConnections(d.Get("encrypt_dc_connections"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("encrypt_dc_connections"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, encryptDcConnectionsProp)) {
		obj["encryptDcConnections"] = encryptDcConnectionsProp
	}
	labelsProp, err := expandNetappActiveDirectoryEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetappBasePath}}projects/{{project}}/locations/{{location}}/activeDirectories/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating ActiveDirectory %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("domain") {
		updateMask = append(updateMask, "domain")
	}

	if d.HasChange("site") {
		updateMask = append(updateMask, "site")
	}

	if d.HasChange("dns") {
		updateMask = append(updateMask, "dns")
	}

	if d.HasChange("net_bios_prefix") {
		updateMask = append(updateMask, "netBiosPrefix")
	}

	if d.HasChange("organizational_unit") {
		updateMask = append(updateMask, "organizationalUnit")
	}

	if d.HasChange("aes_encryption") {
		updateMask = append(updateMask, "aesEncryption")
	}

	if d.HasChange("username") {
		updateMask = append(updateMask, "username")
	}

	if d.HasChange("password") {
		updateMask = append(updateMask, "password")
	}

	if d.HasChange("backup_operators") {
		updateMask = append(updateMask, "backupOperators")
	}

	if d.HasChange("administrators") {
		updateMask = append(updateMask, "administrators")
	}

	if d.HasChange("security_operators") {
		updateMask = append(updateMask, "securityOperators")
	}

	if d.HasChange("kdc_hostname") {
		updateMask = append(updateMask, "kdcHostname")
	}

	if d.HasChange("kdc_ip") {
		updateMask = append(updateMask, "kdcIp")
	}

	if d.HasChange("nfs_users_with_ldap") {
		updateMask = append(updateMask, "nfsUsersWithLdap")
	}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("ldap_signing") {
		updateMask = append(updateMask, "ldapSigning")
	}

	if d.HasChange("encrypt_dc_connections") {
		updateMask = append(updateMask, "encryptDcConnections")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating ActiveDirectory %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating ActiveDirectory %q: %#v", d.Id(), res)
		}

		err = NetappOperationWaitTime(
			config, res, project, "Updating ActiveDirectory", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceNetappActiveDirectoryRead(d, meta)
}

func resourceNetappActiveDirectoryDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ActiveDirectory: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{NetappBasePath}}projects/{{project}}/locations/{{location}}/activeDirectories/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting ActiveDirectory %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "ActiveDirectory")
	}

	err = NetappOperationWaitTime(
		config, res, project, "Deleting ActiveDirectory", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting ActiveDirectory %q: %#v", d.Id(), res)
	return nil
}

func resourceNetappActiveDirectoryImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/activeDirectories/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/activeDirectories/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenNetappActiveDirectoryCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryDomain(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectorySite(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryDns(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryNetBiosPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryOrganizationalUnit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryAesEncryption(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryBackupOperators(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryAdministrators(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectorySecurityOperators(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryKdcHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryKdcIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryNfsUsersWithLdap(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryLdapSigning(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryEncryptDcConnections(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetappActiveDirectoryStateDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetappActiveDirectoryTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetappActiveDirectoryEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandNetappActiveDirectoryDomain(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectorySite(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryDns(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryNetBiosPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryOrganizationalUnit(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryAesEncryption(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryBackupOperators(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryAdministrators(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectorySecurityOperators(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryKdcHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryKdcIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryNfsUsersWithLdap(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryLdapSigning(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryEncryptDcConnections(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetappActiveDirectoryEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
