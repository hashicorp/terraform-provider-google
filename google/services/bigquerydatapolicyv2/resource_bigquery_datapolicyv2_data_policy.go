// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/bigquerydatapolicyv2/DataPolicy.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package bigquerydatapolicyv2

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceBigqueryDatapolicyv2DataPolicy() *schema.Resource {
	return &schema.Resource{
		Create: resourceBigqueryDatapolicyv2DataPolicyCreate,
		Read:   resourceBigqueryDatapolicyv2DataPolicyRead,
		Update: resourceBigqueryDatapolicyv2DataPolicyUpdate,
		Delete: resourceBigqueryDatapolicyv2DataPolicyDelete,

		Importer: &schema.ResourceImporter{
			State: resourceBigqueryDatapolicyv2DataPolicyImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"data_policy_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"data_policy_id": {
				Type:     schema.TypeString,
				Required: true,
				Description: `User-assigned (human readable) ID of the data policy that needs to be
unique within a project. Used as {data_policy_id} in part of the resource
name.`,
			},
			"data_policy_type": {
				Type:     schema.TypeString,
				Required: true,
				Description: `Type of data policy.
Possible values:
DATA_MASKING_POLICY
RAW_DATA_ACCESS_POLICY
COLUMN_LEVEL_SECURITY_POLICY`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"data_masking_policy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The policy used to specify data masking rule.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"predefined_expression": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `A predefined masking expression.
Possible values:
SHA256
ALWAYS_NULL
DEFAULT_MASKING_VALUE
LAST_FOUR_CHARACTERS
FIRST_FOUR_CHARACTERS
EMAIL_MASK
DATE_YEAR_MASK
RANDOM_HASH`,
						},
						"routine": {
							Type:             schema.TypeString,
							Optional:         true,
							DiffSuppressFunc: tpgresource.ProjectNumberDiffSuppress,
							Description: `The name of the BigQuery routine that contains the custom masking
routine, in the format of
'projects/{project_number}/datasets/{dataset_id}/routines/{routine_id}'.`,
						},
					},
				},
			},
			"grantees": {
				Type:     schema.TypeList,
				Computed: true,
				Optional: true,
				Description: `The list of IAM principals that have Fine Grained Access to the underlying
data goverened by this data policy.

Uses the [IAM V2 principal
syntax](https://cloud.google.com/iam/docs/principal-identifiers#v2) Only
supports principal types users, groups, serviceaccounts, cloudidentity.
This field is supported in V2 Data Policy only. In case of V1 data policies
(i.e. verion = 1 and policy_tag is set), this field is not populated.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				Description: `The etag for this Data Policy.
This field is used for UpdateDataPolicy calls. If Data Policy exists, this
field is required and must match the server's etag. It will also be
populated in the response of GetDataPolicy, CreateDataPolicy, and
UpdateDataPolicy calls.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. Resource name of this data policy, in the format of
'projects/{project_number}/locations/{location_id}/dataPolicies/{data_policy_id}'.`,
			},
			"policy_tag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Policy tag resource name, in the format of
'projects/{project_number}/locations/{location_id}/taxonomies/{taxonomy_id}/policyTags/{policyTag_id}'.
policy_tag is supported only for V1 data policies.`,
			},
			"version": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The version of the Data Policy resource.
Possible values:
V1
V2`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceBigqueryDatapolicyv2DataPolicyCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	dataMaskingPolicyProp, err := expandBigqueryDatapolicyv2DataPolicyDataMaskingPolicy(d.Get("data_masking_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_masking_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(dataMaskingPolicyProp)) && (ok || !reflect.DeepEqual(v, dataMaskingPolicyProp)) {
		obj["dataMaskingPolicy"] = dataMaskingPolicyProp
	}
	dataPolicyTypeProp, err := expandBigqueryDatapolicyv2DataPolicyDataPolicyType(d.Get("data_policy_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_policy_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(dataPolicyTypeProp)) && (ok || !reflect.DeepEqual(v, dataPolicyTypeProp)) {
		obj["dataPolicyType"] = dataPolicyTypeProp
	}
	etagProp, err := expandBigqueryDatapolicyv2DataPolicyEtag(d.Get("etag"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("etag"); !tpgresource.IsEmptyValue(reflect.ValueOf(etagProp)) && (ok || !reflect.DeepEqual(v, etagProp)) {
		obj["etag"] = etagProp
	}
	granteesProp, err := expandBigqueryDatapolicyv2DataPolicyGrantees(d.Get("grantees"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("grantees"); !tpgresource.IsEmptyValue(reflect.ValueOf(granteesProp)) && (ok || !reflect.DeepEqual(v, granteesProp)) {
		obj["grantees"] = granteesProp
	}
	dataPolicyIdProp, err := expandBigqueryDatapolicyv2DataPolicyDataPolicyId(d.Get("data_policy_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_policy_id"); !tpgresource.IsEmptyValue(reflect.ValueOf(dataPolicyIdProp)) && (ok || !reflect.DeepEqual(v, dataPolicyIdProp)) {
		obj["dataPolicyId"] = dataPolicyIdProp
	}

	obj, err = resourceBigqueryDatapolicyv2DataPolicyEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BigqueryDatapolicyv2BasePath}}projects/{{project}}/locations/{{location}}/dataPolicies")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new DataPolicy: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for DataPolicy: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating DataPolicy: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/dataPolicies/{{data_policy_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating DataPolicy %q: %#v", d.Id(), res)

	return resourceBigqueryDatapolicyv2DataPolicyRead(d, meta)
}

func resourceBigqueryDatapolicyv2DataPolicyRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BigqueryDatapolicyv2BasePath}}projects/{{project}}/locations/{{location}}/dataPolicies/{{data_policy_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for DataPolicy: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("BigqueryDatapolicyv2DataPolicy %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading DataPolicy: %s", err)
	}

	if err := d.Set("data_masking_policy", flattenBigqueryDatapolicyv2DataPolicyDataMaskingPolicy(res["dataMaskingPolicy"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataPolicy: %s", err)
	}
	if err := d.Set("data_policy_type", flattenBigqueryDatapolicyv2DataPolicyDataPolicyType(res["dataPolicyType"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataPolicy: %s", err)
	}
	if err := d.Set("etag", flattenBigqueryDatapolicyv2DataPolicyEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataPolicy: %s", err)
	}
	if err := d.Set("grantees", flattenBigqueryDatapolicyv2DataPolicyGrantees(res["grantees"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataPolicy: %s", err)
	}
	if err := d.Set("name", flattenBigqueryDatapolicyv2DataPolicyName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataPolicy: %s", err)
	}
	if err := d.Set("policy_tag", flattenBigqueryDatapolicyv2DataPolicyPolicyTag(res["policyTag"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataPolicy: %s", err)
	}
	if err := d.Set("version", flattenBigqueryDatapolicyv2DataPolicyVersion(res["version"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataPolicy: %s", err)
	}
	if err := d.Set("data_policy_id", flattenBigqueryDatapolicyv2DataPolicyDataPolicyId(res["dataPolicyId"], d, config)); err != nil {
		return fmt.Errorf("Error reading DataPolicy: %s", err)
	}

	identity, err := d.Identity()
	if err != nil && identity != nil {
		if v, ok := identity.GetOk("data_policy_id"); ok && v != "" {
			err = identity.Set("data_policy_id", d.Get("data_policy_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting data_policy_id: %s", err)
			}
		}
		if v, ok := identity.GetOk("location"); ok && v != "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); ok && v != "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] identity not set: %s", err)
	}
	return nil
}

func resourceBigqueryDatapolicyv2DataPolicyUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for DataPolicy: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	dataMaskingPolicyProp, err := expandBigqueryDatapolicyv2DataPolicyDataMaskingPolicy(d.Get("data_masking_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_masking_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dataMaskingPolicyProp)) {
		obj["dataMaskingPolicy"] = dataMaskingPolicyProp
	}
	dataPolicyTypeProp, err := expandBigqueryDatapolicyv2DataPolicyDataPolicyType(d.Get("data_policy_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_policy_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dataPolicyTypeProp)) {
		obj["dataPolicyType"] = dataPolicyTypeProp
	}
	etagProp, err := expandBigqueryDatapolicyv2DataPolicyEtag(d.Get("etag"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("etag"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, etagProp)) {
		obj["etag"] = etagProp
	}
	granteesProp, err := expandBigqueryDatapolicyv2DataPolicyGrantees(d.Get("grantees"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("grantees"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, granteesProp)) {
		obj["grantees"] = granteesProp
	}
	dataPolicyIdProp, err := expandBigqueryDatapolicyv2DataPolicyDataPolicyId(d.Get("data_policy_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_policy_id"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dataPolicyIdProp)) {
		obj["dataPolicyId"] = dataPolicyIdProp
	}

	obj, err = resourceBigqueryDatapolicyv2DataPolicyUpdateEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BigqueryDatapolicyv2BasePath}}projects/{{project}}/locations/{{location}}/dataPolicies/{{data_policy_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating DataPolicy %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("data_masking_policy") {
		updateMask = append(updateMask, "dataMaskingPolicy")
	}

	if d.HasChange("data_policy_type") {
		updateMask = append(updateMask, "dataPolicyType")
	}

	if d.HasChange("etag") {
		updateMask = append(updateMask, "etag")
	}

	if d.HasChange("grantees") {
		updateMask = append(updateMask, "grantees")
	}

	if d.HasChange("data_policy_id") {
		updateMask = append(updateMask, "dataPolicyId")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating DataPolicy %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating DataPolicy %q: %#v", d.Id(), res)
		}

	}

	return resourceBigqueryDatapolicyv2DataPolicyRead(d, meta)
}

func resourceBigqueryDatapolicyv2DataPolicyDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for DataPolicy: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{BigqueryDatapolicyv2BasePath}}projects/{{project}}/locations/{{location}}/dataPolicies/{{data_policy_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting DataPolicy %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "DataPolicy")
	}

	log.Printf("[DEBUG] Finished deleting DataPolicy %q: %#v", d.Id(), res)
	return nil
}

func resourceBigqueryDatapolicyv2DataPolicyImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/dataPolicies/(?P<data_policy_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<data_policy_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<data_policy_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/dataPolicies/{{data_policy_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenBigqueryDatapolicyv2DataPolicyDataMaskingPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["predefined_expression"] =
		flattenBigqueryDatapolicyv2DataPolicyDataMaskingPolicyPredefinedExpression(original["predefinedExpression"], d, config)
	transformed["routine"] =
		flattenBigqueryDatapolicyv2DataPolicyDataMaskingPolicyRoutine(original["routine"], d, config)
	return []interface{}{transformed}
}
func flattenBigqueryDatapolicyv2DataPolicyDataMaskingPolicyPredefinedExpression(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBigqueryDatapolicyv2DataPolicyDataMaskingPolicyRoutine(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBigqueryDatapolicyv2DataPolicyDataPolicyType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBigqueryDatapolicyv2DataPolicyEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBigqueryDatapolicyv2DataPolicyGrantees(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBigqueryDatapolicyv2DataPolicyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBigqueryDatapolicyv2DataPolicyPolicyTag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBigqueryDatapolicyv2DataPolicyVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBigqueryDatapolicyv2DataPolicyDataPolicyId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandBigqueryDatapolicyv2DataPolicyDataMaskingPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPredefinedExpression, err := expandBigqueryDatapolicyv2DataPolicyDataMaskingPolicyPredefinedExpression(original["predefined_expression"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPredefinedExpression); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["predefinedExpression"] = transformedPredefinedExpression
	}

	transformedRoutine, err := expandBigqueryDatapolicyv2DataPolicyDataMaskingPolicyRoutine(original["routine"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRoutine); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["routine"] = transformedRoutine
	}

	return transformed, nil
}

func expandBigqueryDatapolicyv2DataPolicyDataMaskingPolicyPredefinedExpression(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBigqueryDatapolicyv2DataPolicyDataMaskingPolicyRoutine(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBigqueryDatapolicyv2DataPolicyDataPolicyType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBigqueryDatapolicyv2DataPolicyEtag(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBigqueryDatapolicyv2DataPolicyGrantees(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBigqueryDatapolicyv2DataPolicyDataPolicyId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceBigqueryDatapolicyv2DataPolicyEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	// The create request is not in the same format as the resource.
	// The API request needs resource to be nested inside the "data_policy" field.
	newObj := make(map[string]interface{})
	newObj["dataPolicy"] = obj
	newObj["dataPolicyId"] = obj["dataPolicyId"].(string)
	return newObj, nil
}

func resourceBigqueryDatapolicyv2DataPolicyUpdateEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	return obj, nil
}
