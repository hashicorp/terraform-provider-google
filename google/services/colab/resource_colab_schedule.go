// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/colab/Schedule.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package colab

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func modifyScheduleState(config *transport_tpg.Config, d *schema.ResourceData, project string, billingProject string, userAgent string, state string) (map[string]interface{}, error) {
	url, err := tpgresource.ReplaceVars(d, config, "{{ColabBasePath}}projects/{{project}}/locations/{{location}}/schedules/{{name}}:"+state)
	if err != nil {
		return nil, err
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return nil, fmt.Errorf("Unable to %q google_colab_schedule %q: %s", state, d.Id(), err)
	}
	return res, nil
}

func ResourceColabSchedule() *schema.Resource {
	return &schema.Resource{
		Create: resourceColabScheduleCreate,
		Read:   resourceColabScheduleRead,
		Update: resourceColabScheduleUpdate,
		Delete: resourceColabScheduleDelete,

		Importer: &schema.ResourceImporter{
			State: resourceColabScheduleImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"create_notebook_execution_job_request": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `Request for google_colab_notebook_execution.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"notebook_execution_job": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `The NotebookExecutionJob to create.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"display_name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Required. The display name of the Notebook Execution.`,
									},
									"gcs_output_uri": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The Cloud Storage location to upload the result to. Format:'gs://bucket-name'`,
									},
									"notebook_runtime_template_resource_name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The NotebookRuntimeTemplate to source compute configuration from.`,
									},
									"dataform_repository_source": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `The Dataform Repository containing the input notebook.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"dataform_repository_resource_name": {
													Type:             schema.TypeString,
													Required:         true,
													DiffSuppressFunc: tpgresource.CompareSelfLinkRelativePaths,
													Description:      `The resource name of the Dataform Repository.`,
												},
												"commit_sha": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The commit SHA to read repository with. If unset, the file will be read at HEAD.`,
												},
											},
										},
										ExactlyOneOf: []string{"create_notebook_execution_job_request.0.notebook_execution_job.0.dataform_repository_source", "create_notebook_execution_job_request.0.notebook_execution_job.0.gcs_notebook_source"},
									},
									"execution_timeout": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Max running time of the execution job in seconds (default 86400s / 24 hrs). A duration in seconds with up to nine fractional digits, ending with "s". Example: "3.5s".`,
									},
									"execution_user": {
										Type:         schema.TypeString,
										Optional:     true,
										Description:  `The user email to run the execution as.`,
										ExactlyOneOf: []string{"create_notebook_execution_job_request.0.notebook_execution_job.0.execution_user", "create_notebook_execution_job_request.0.notebook_execution_job.0.service_account"},
									},
									"gcs_notebook_source": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `The Cloud Storage uri for the input notebook.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"uri": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The Cloud Storage uri pointing to the ipynb file. Format: gs://bucket/notebook_file.ipynb`,
												},
												"generation": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The version of the Cloud Storage object to read. If unset, the current version of the object is read. See https://cloud.google.com/storage/docs/metadata#generation-number.`,
												},
											},
										},
										ExactlyOneOf: []string{"create_notebook_execution_job_request.0.notebook_execution_job.0.dataform_repository_source", "create_notebook_execution_job_request.0.notebook_execution_job.0.gcs_notebook_source"},
									},
									"service_account": {
										Type:         schema.TypeString,
										Optional:     true,
										Description:  `The service account to run the execution as.`,
										ExactlyOneOf: []string{"create_notebook_execution_job_request.0.notebook_execution_job.0.execution_user", "create_notebook_execution_job_request.0.notebook_execution_job.0.service_account"},
									},
								},
							},
						},
					},
				},
			},
			"cron": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs.`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Required. The display name of the Schedule.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The location for the resource: https://cloud.google.com/colab/docs/locations`,
			},
			"max_concurrent_run_count": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the notebook execution jobs created by the requests.`,
			},
			"allow_queueing": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.`,
			},
			"end_time": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Timestamp after which no new runs can be scheduled. If specified, the schedule will be completed when either end_time is reached or when scheduled_run_count >= max_run_count. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.`,
			},
			"max_run_count": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Maximum run count of the schedule. If specified, The schedule will be completed when either startedRunCount >= maxRunCount or when endTime is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.`,
			},
			"start_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				Description: `The timestamp after which the first run can be scheduled. Defaults to the schedule creation time. Must be in the RFC 3339 (https://www.ietf.org/rfc/rfc3339.txt) format.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The resource name of the Schedule`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The state of the schedule.`,
			},
			"desired_state": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Desired state of the Colab Schedule. Set this field to 'ACTIVE' to start/resume the schedule, and 'PAUSED' to pause the schedule.`,
				Default:     "ACTIVE",
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceColabScheduleCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandColabScheduleDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	startTimeProp, err := expandColabScheduleStartTime(d.Get("start_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("start_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(startTimeProp)) && (ok || !reflect.DeepEqual(v, startTimeProp)) {
		obj["startTime"] = startTimeProp
	}
	endTimeProp, err := expandColabScheduleEndTime(d.Get("end_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("end_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(endTimeProp)) && (ok || !reflect.DeepEqual(v, endTimeProp)) {
		obj["endTime"] = endTimeProp
	}
	maxRunCountProp, err := expandColabScheduleMaxRunCount(d.Get("max_run_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("max_run_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(maxRunCountProp)) && (ok || !reflect.DeepEqual(v, maxRunCountProp)) {
		obj["maxRunCount"] = maxRunCountProp
	}
	cronProp, err := expandColabScheduleCron(d.Get("cron"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cron"); !tpgresource.IsEmptyValue(reflect.ValueOf(cronProp)) && (ok || !reflect.DeepEqual(v, cronProp)) {
		obj["cron"] = cronProp
	}
	maxConcurrentRunCountProp, err := expandColabScheduleMaxConcurrentRunCount(d.Get("max_concurrent_run_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("max_concurrent_run_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(maxConcurrentRunCountProp)) && (ok || !reflect.DeepEqual(v, maxConcurrentRunCountProp)) {
		obj["maxConcurrentRunCount"] = maxConcurrentRunCountProp
	}
	allowQueueingProp, err := expandColabScheduleAllowQueueing(d.Get("allow_queueing"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("allow_queueing"); ok || !reflect.DeepEqual(v, allowQueueingProp) {
		obj["allowQueueing"] = allowQueueingProp
	}
	createNotebookExecutionJobRequestProp, err := expandColabScheduleCreateNotebookExecutionJobRequest(d.Get("create_notebook_execution_job_request"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("create_notebook_execution_job_request"); !tpgresource.IsEmptyValue(reflect.ValueOf(createNotebookExecutionJobRequestProp)) && (ok || !reflect.DeepEqual(v, createNotebookExecutionJobRequestProp)) {
		obj["createNotebookExecutionJobRequest"] = createNotebookExecutionJobRequestProp
	}

	obj, err = resourceColabScheduleEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ColabBasePath}}projects/{{project}}/locations/{{location}}/schedules")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Schedule: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Schedule: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Schedule: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/schedules/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// The response for create request contains the generated name generated name that we need
	// in order to perform a READ. We need to access the object inside of it as
	// a map[string]interface, so let's do that.

	longName := res["name"].(string)
	name := tpgresource.GetResourceNameFromSelfLink(longName)
	log.Printf("[DEBUG] Setting resource name to %s", name)
	if err := d.Set("name", name); err != nil {
		return fmt.Errorf("Error setting name: %s", err)
	}

	parts := strings.Split(longName, "/")
	parts[1] = project
	updatedLongName := strings.Join(parts, "/")
	d.SetId(updatedLongName)

	if p, ok := d.GetOk("desired_state"); ok && p.(string) == "PAUSED" {
		_, err := modifyScheduleState(config, d, project, billingProject, userAgent, "pause")
		if err != nil {
			return err
		}
	}

	log.Printf("[DEBUG] Finished creating Schedule %q: %#v", d.Id(), res)

	return resourceColabScheduleRead(d, meta)
}

func resourceColabScheduleRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ColabBasePath}}projects/{{project}}/locations/{{location}}/schedules/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Schedule: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ColabSchedule %q", d.Id()))
	}

	// Explicitly set virtual fields to default values if unset
	if _, ok := d.GetOkExists("desired_state"); !ok {
		if err := d.Set("desired_state", "ACTIVE"); err != nil {
			return fmt.Errorf("Error setting desired_state: %s", err)
		}
	}
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Schedule: %s", err)
	}

	if err := d.Set("name", flattenColabScheduleName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Schedule: %s", err)
	}
	if err := d.Set("display_name", flattenColabScheduleDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Schedule: %s", err)
	}
	if err := d.Set("start_time", flattenColabScheduleStartTime(res["startTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Schedule: %s", err)
	}
	if err := d.Set("end_time", flattenColabScheduleEndTime(res["endTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Schedule: %s", err)
	}
	if err := d.Set("max_run_count", flattenColabScheduleMaxRunCount(res["maxRunCount"], d, config)); err != nil {
		return fmt.Errorf("Error reading Schedule: %s", err)
	}
	if err := d.Set("cron", flattenColabScheduleCron(res["cron"], d, config)); err != nil {
		return fmt.Errorf("Error reading Schedule: %s", err)
	}
	if err := d.Set("max_concurrent_run_count", flattenColabScheduleMaxConcurrentRunCount(res["maxConcurrentRunCount"], d, config)); err != nil {
		return fmt.Errorf("Error reading Schedule: %s", err)
	}
	if err := d.Set("allow_queueing", flattenColabScheduleAllowQueueing(res["allowQueueing"], d, config)); err != nil {
		return fmt.Errorf("Error reading Schedule: %s", err)
	}
	if err := d.Set("state", flattenColabScheduleState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Schedule: %s", err)
	}
	if err := d.Set("create_notebook_execution_job_request", flattenColabScheduleCreateNotebookExecutionJobRequest(res["createNotebookExecutionJobRequest"], d, config)); err != nil {
		return fmt.Errorf("Error reading Schedule: %s", err)
	}

	return nil
}

func resourceColabScheduleUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Schedule: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	displayNameProp, err := expandColabScheduleDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	startTimeProp, err := expandColabScheduleStartTime(d.Get("start_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("start_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, startTimeProp)) {
		obj["startTime"] = startTimeProp
	}
	endTimeProp, err := expandColabScheduleEndTime(d.Get("end_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("end_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, endTimeProp)) {
		obj["endTime"] = endTimeProp
	}
	maxRunCountProp, err := expandColabScheduleMaxRunCount(d.Get("max_run_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("max_run_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, maxRunCountProp)) {
		obj["maxRunCount"] = maxRunCountProp
	}
	cronProp, err := expandColabScheduleCron(d.Get("cron"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cron"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, cronProp)) {
		obj["cron"] = cronProp
	}
	maxConcurrentRunCountProp, err := expandColabScheduleMaxConcurrentRunCount(d.Get("max_concurrent_run_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("max_concurrent_run_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, maxConcurrentRunCountProp)) {
		obj["maxConcurrentRunCount"] = maxConcurrentRunCountProp
	}
	allowQueueingProp, err := expandColabScheduleAllowQueueing(d.Get("allow_queueing"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("allow_queueing"); ok || !reflect.DeepEqual(v, allowQueueingProp) {
		obj["allowQueueing"] = allowQueueingProp
	}

	obj, err = resourceColabScheduleEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ColabBasePath}}projects/{{project}}/locations/{{location}}/schedules/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Schedule %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("start_time") {
		updateMask = append(updateMask, "startTime")
	}

	if d.HasChange("end_time") {
		updateMask = append(updateMask, "endTime")
	}

	if d.HasChange("max_run_count") {
		updateMask = append(updateMask, "maxRunCount")
	}

	if d.HasChange("cron") {
		updateMask = append(updateMask, "cron")
	}

	if d.HasChange("max_concurrent_run_count") {
		updateMask = append(updateMask, "maxConcurrentRunCount")
	}

	if d.HasChange("allow_queueing") {
		updateMask = append(updateMask, "allowQueueing")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Schedule %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Schedule %q: %#v", d.Id(), res)
		}

	}

	name := d.Get("name").(string)
	state := d.Get("state").(string)
	desired_state := d.Get("desired_state").(string)

	if desired_state != "" && state != desired_state {
		var verb string

		switch desired_state {
		case "PAUSED":
			verb = "pause"
		case "ACTIVE":
			verb = "resume"
		default:
			return fmt.Errorf("desired_state has to be ACTIVE or PAUSED")
		}

		_, err := modifyScheduleState(config, d, project, billingProject, userAgent, verb)
		if err != nil {
			return err
		}

	} else {
		log.Printf("[DEBUG] Colab Schedule %q has state %q.", name, state)
	}
	return resourceColabScheduleRead(d, meta)
}

func resourceColabScheduleDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Schedule: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{ColabBasePath}}projects/{{project}}/locations/{{location}}/schedules/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Schedule %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Schedule")
	}

	err = ColabOperationWaitTime(
		config, res, project, "Deleting Schedule", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Schedule %q: %#v", d.Id(), res)
	return nil
}

func resourceColabScheduleImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/schedules/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/schedules/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Explicitly set virtual fields to default values on import
	if err := d.Set("desired_state", "ACTIVE"); err != nil {
		return nil, fmt.Errorf("Error setting desired_state: %s", err)
	}

	return []*schema.ResourceData{d}, nil
}

func flattenColabScheduleName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.NameFromSelfLinkStateFunc(v)
}

func flattenColabScheduleDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleMaxRunCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleCron(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleMaxConcurrentRunCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleAllowQueueing(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleCreateNotebookExecutionJobRequest(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["notebook_execution_job"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJob(original["notebookExecutionJob"], d, config)
	return []interface{}{transformed}
}
func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJob(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["display_name"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDisplayName(original["displayName"], d, config)
	transformed["dataform_repository_source"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySource(original["dataformRepositorySource"], d, config)
	transformed["gcs_notebook_source"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSource(original["gcsNotebookSource"], d, config)
	transformed["execution_timeout"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobExecutionTimeout(original["executionTimeout"], d, config)
	transformed["notebook_runtime_template_resource_name"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobNotebookRuntimeTemplateResourceName(original["notebookRuntimeTemplateResourceName"], d, config)
	transformed["gcs_output_uri"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsOutputUri(original["gcsOutputUri"], d, config)
	transformed["execution_user"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobExecutionUser(original["executionUser"], d, config)
	transformed["service_account"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobServiceAccount(original["serviceAccount"], d, config)
	return []interface{}{transformed}
}
func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dataform_repository_resource_name"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceDataformRepositoryResourceName(original["dataformRepositoryResourceName"], d, config)
	transformed["commit_sha"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceCommitSha(original["commitSha"], d, config)
	return []interface{}{transformed}
}
func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceDataformRepositoryResourceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceCommitSha(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceUri(original["uri"], d, config)
	transformed["generation"] =
		flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceGeneration(original["generation"], d, config)
	return []interface{}{transformed}
}
func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceGeneration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobExecutionTimeout(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobNotebookRuntimeTemplateResourceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsOutputUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobExecutionUser(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandColabScheduleDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleStartTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleEndTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleMaxRunCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleCron(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleMaxConcurrentRunCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleAllowQueueing(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequest(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNotebookExecutionJob, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJob(original["notebook_execution_job"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNotebookExecutionJob); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["notebookExecutionJob"] = transformedNotebookExecutionJob
	}

	return transformed, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJob(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDisplayName, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDisplayName(original["display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayName"] = transformedDisplayName
	}

	transformedDataformRepositorySource, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySource(original["dataform_repository_source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataformRepositorySource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataformRepositorySource"] = transformedDataformRepositorySource
	}

	transformedGcsNotebookSource, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSource(original["gcs_notebook_source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcsNotebookSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcsNotebookSource"] = transformedGcsNotebookSource
	}

	transformedExecutionTimeout, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobExecutionTimeout(original["execution_timeout"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExecutionTimeout); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["executionTimeout"] = transformedExecutionTimeout
	}

	transformedNotebookRuntimeTemplateResourceName, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobNotebookRuntimeTemplateResourceName(original["notebook_runtime_template_resource_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNotebookRuntimeTemplateResourceName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["notebookRuntimeTemplateResourceName"] = transformedNotebookRuntimeTemplateResourceName
	}

	transformedGcsOutputUri, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsOutputUri(original["gcs_output_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcsOutputUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcsOutputUri"] = transformedGcsOutputUri
	}

	transformedExecutionUser, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobExecutionUser(original["execution_user"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExecutionUser); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["executionUser"] = transformedExecutionUser
	}

	transformedServiceAccount, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobServiceAccount(original["service_account"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccount"] = transformedServiceAccount
	}

	return transformed, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDataformRepositoryResourceName, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceDataformRepositoryResourceName(original["dataform_repository_resource_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataformRepositoryResourceName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataformRepositoryResourceName"] = transformedDataformRepositoryResourceName
	}

	transformedCommitSha, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceCommitSha(original["commit_sha"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommitSha); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["commitSha"] = transformedCommitSha
	}

	return transformed, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceDataformRepositoryResourceName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobDataformRepositorySourceCommitSha(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	transformedGeneration, err := expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceGeneration(original["generation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGeneration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["generation"] = transformedGeneration
	}

	return transformed, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsNotebookSourceGeneration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobExecutionTimeout(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobNotebookRuntimeTemplateResourceName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobGcsOutputUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobExecutionUser(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandColabScheduleCreateNotebookExecutionJobRequestNotebookExecutionJobServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceColabScheduleEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	config := meta.(*transport_tpg.Config)
	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return nil, err
	}

	location, err := tpgresource.GetRegion(d, config)
	if err != nil {
		return nil, err
	}

	// createNotebookExecutionJobRequest does not exist in update requests
	if obj["createNotebookExecutionJobRequest"] == nil {
		return obj, nil
	}

	jobRequest, ok := obj["createNotebookExecutionJobRequest"].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("createNotebookExecutionJobRequest is not of type map[string]interface{} or is nil")
	}
	jobRequest["parent"] = fmt.Sprintf("projects/%s/locations/%s", project, location)

	return obj, nil
}
