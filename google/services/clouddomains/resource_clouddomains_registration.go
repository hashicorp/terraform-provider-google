// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package clouddomains

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

// waitForRegistrationActive waits for a registration to leave the
// "REGISTRATION_PENDING" state and become "ACTIVE" or any other state.
func waitForRegistrationActive(d *schema.ResourceData, config *transport_tpg.Config, timeout time.Duration) error {
	return retry.Retry(timeout, func() *retry.RetryError {
		if err := resourceClouddomainsRegistrationRead(d, config); err != nil {
			return retry.NonRetryableError(err)
		}

		name := d.Get("name").(string)
		state := d.Get("state").(string)
		if state == "REGISTRATION_PENDING" {
			return retry.RetryableError(fmt.Errorf("Registration %q has state %q.", name, state))
		} else if state == "REGISTRATION_FAILED" {
			return retry.NonRetryableError(fmt.Errorf("Registration %q has failed with state %q.", name, state))
		} else {
			log.Printf("[DEBUG] Registration %q has state %q.", name, state)
			return nil
		}
	})
}

func ResourceClouddomainsRegistration() *schema.Resource {
	return &schema.Resource{
		Create: resourceClouddomainsRegistrationCreate,
		Read:   resourceClouddomainsRegistrationRead,
		Update: resourceClouddomainsRegistrationUpdate,
		Delete: resourceClouddomainsRegistrationDelete,

		Importer: &schema.ResourceImporter{
			State: resourceClouddomainsRegistrationImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"contact_settings": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `Required. Settings for contact information linked to the Registration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"admin_contact": {
							Type:     schema.TypeList,
							Required: true,
							ForceNew: true,
							Description: `Caution: Anyone with access to this email address, phone number, and/or postal address can take control of the domain.

Warning: For new Registrations, the registrant receives an email confirmation that they must complete within 15 days to
avoid domain suspension.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"email": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Required. Email address of the contact.`,
									},
									"phone_number": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Required. Phone number of the contact in international format. For example, "+1-800-555-0123".`,
									},
									"postal_address": {
										Type:        schema.TypeList,
										Required:    true,
										ForceNew:    true,
										Description: `Required. Postal address of the contact.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"region_code": {
													Type:     schema.TypeString,
													Required: true,
													ForceNew: true,
													Description: `Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to
ensure the value is correct. See https://cldr.unicode.org/ and
https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.`,
												},
												"address_lines": {
													Type:     schema.TypeList,
													Optional: true,
													ForceNew: true,
													Description: `Unstructured address lines describing the lower levels of an address.
Because values in addressLines do not have type information and may sometimes contain multiple values in a single
field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be
"envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language
is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way,
the most specific line of an address can be selected based on the language.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"administrative_area": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state,
a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community
(e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland
this should be left unpopulated.`,
												},
												"locality": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world
where localities are not well defined or do not fit into this structure well, leave locality empty and use addressLines.`,
												},
												"organization": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `The name of the organization at the address.`,
												},
												"postal_code": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `Postal code of the address. Not all countries use or require postal codes to be present, but where they are used,
they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).`,
												},
												"recipients": {
													Type:     schema.TypeList,
													Optional: true,
													ForceNew: true,
													Description: `The recipient at the address. This field may, under certain circumstances, contain multiline information. For example,
it might contain "care of" information.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"fax_number": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Fax number of the contact in international format. For example, "+1-800-555-0123".`,
									},
								},
							},
						},
						"privacy": {
							Type:     schema.TypeString,
							Required: true,
							ForceNew: true,
							Description: `Required. Privacy setting for the contacts associated with the Registration.
Values are PUBLIC_CONTACT_DATA, PRIVATE_CONTACT_DATA, and REDACTED_CONTACT_DATA`,
						},
						"registrant_contact": {
							Type:     schema.TypeList,
							Required: true,
							ForceNew: true,
							Description: `Caution: Anyone with access to this email address, phone number, and/or postal address can take control of the domain.

Warning: For new Registrations, the registrant receives an email confirmation that they must complete within 15 days to
avoid domain suspension.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"email": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Required. Email address of the contact.`,
									},
									"phone_number": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Required. Phone number of the contact in international format. For example, "+1-800-555-0123".`,
									},
									"postal_address": {
										Type:        schema.TypeList,
										Required:    true,
										ForceNew:    true,
										Description: `Required. Postal address of the contact.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"region_code": {
													Type:     schema.TypeString,
													Required: true,
													ForceNew: true,
													Description: `Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to
ensure the value is correct. See https://cldr.unicode.org/ and
https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.`,
												},
												"address_lines": {
													Type:     schema.TypeList,
													Optional: true,
													ForceNew: true,
													Description: `Unstructured address lines describing the lower levels of an address.
Because values in addressLines do not have type information and may sometimes contain multiple values in a single
field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be
"envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language
is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way,
the most specific line of an address can be selected based on the language.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"administrative_area": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state,
a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community
(e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland
this should be left unpopulated.`,
												},
												"locality": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world
where localities are not well defined or do not fit into this structure well, leave locality empty and use addressLines.`,
												},
												"organization": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `The name of the organization at the address.`,
												},
												"postal_code": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `Postal code of the address. Not all countries use or require postal codes to be present, but where they are used,
they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).`,
												},
												"recipients": {
													Type:     schema.TypeList,
													Optional: true,
													ForceNew: true,
													Description: `The recipient at the address. This field may, under certain circumstances, contain multiline information. For example,
it might contain "care of" information.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"fax_number": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Fax number of the contact in international format. For example, "+1-800-555-0123".`,
									},
								},
							},
						},
						"technical_contact": {
							Type:     schema.TypeList,
							Required: true,
							ForceNew: true,
							Description: `Caution: Anyone with access to this email address, phone number, and/or postal address can take control of the domain.

Warning: For new Registrations, the registrant receives an email confirmation that they must complete within 15 days to
avoid domain suspension.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"email": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Required. Email address of the contact.`,
									},
									"phone_number": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Required. Phone number of the contact in international format. For example, "+1-800-555-0123".`,
									},
									"postal_address": {
										Type:        schema.TypeList,
										Required:    true,
										ForceNew:    true,
										Description: `Required. Postal address of the contact.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"region_code": {
													Type:     schema.TypeString,
													Required: true,
													ForceNew: true,
													Description: `Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to
ensure the value is correct. See https://cldr.unicode.org/ and
https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.`,
												},
												"address_lines": {
													Type:     schema.TypeList,
													Optional: true,
													ForceNew: true,
													Description: `Unstructured address lines describing the lower levels of an address.
Because values in addressLines do not have type information and may sometimes contain multiple values in a single
field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be
"envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language
is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way,
the most specific line of an address can be selected based on the language.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"administrative_area": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state,
a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community
(e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland
this should be left unpopulated.`,
												},
												"locality": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world
where localities are not well defined or do not fit into this structure well, leave locality empty and use addressLines.`,
												},
												"organization": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `The name of the organization at the address.`,
												},
												"postal_code": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `Postal code of the address. Not all countries use or require postal codes to be present, but where they are used,
they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).`,
												},
												"recipients": {
													Type:     schema.TypeList,
													Optional: true,
													ForceNew: true,
													Description: `The recipient at the address. This field may, under certain circumstances, contain multiline information. For example,
it might contain "care of" information.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"fax_number": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `Fax number of the contact in international format. For example, "+1-800-555-0123".`,
									},
								},
							},
						},
					},
				},
			},
			"domain_name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Required. The domain name. Unicode domain names must be expressed in Punycode format.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location for the resource`,
			},
			"yearly_price": {
				Type:     schema.TypeList,
				Required: true,
				ForceNew: true,
				Description: `Required. Yearly price to register or renew the domain. The value that should be put here can be obtained from
registrations.retrieveRegisterParameters or registrations.searchDomains calls.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"currency_code": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `The three-letter currency code defined in ISO 4217.`,
						},
						"units": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `The whole units of the amount. For example if currencyCode is "USD", then 1 unit is one US dollar.`,
						},
					},
				},
			},
			"contact_notices": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `The list of contact notices that the caller acknowledges. Possible value is PUBLIC_CONTACT_DATA_ACKNOWLEDGEMENT`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"dns_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Settings controlling the DNS configuration of the Registration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"custom_dns": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Configuration for an arbitrary DNS provider.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name_servers": {
										Type:     schema.TypeList,
										Required: true,
										ForceNew: true,
										Description: `Required. A list of name servers that store the DNS zone for this domain. Each name server is a domain
name, with Unicode domain names expressed in Punycode format.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"ds_records": {
										Type:     schema.TypeList,
										Optional: true,
										ForceNew: true,
										Description: `The list of DS records for this domain, which are used to enable DNSSEC. The domain's DNS provider can provide
the values to set here. If this field is empty, DNSSEC is disabled.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"algorithm": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `The algorithm used to generate the referenced DNSKEY.`,
												},
												"digest": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `The digest generated from the referenced DNSKEY.`,
												},
												"digest_type": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `The hash function used to generate the digest of the referenced DNSKEY.`,
												},
												"key_tag": {
													Type:        schema.TypeInt,
													Optional:    true,
													ForceNew:    true,
													Description: `The key tag of the record. Must be set in range 0 -- 65535.`,
												},
											},
										},
									},
								},
							},
						},
						"glue_records": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `The list of glue records for this Registration. Commonly empty.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"host_name": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Required. Domain name of the host in Punycode format.`,
									},
									"ipv4_addresses": {
										Type:     schema.TypeList,
										Optional: true,
										ForceNew: true,
										Description: `List of IPv4 addresses corresponding to this host in the standard decimal format (e.g. 198.51.100.1).
At least one of ipv4_address and ipv6_address must be set.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"ipv6_addresses": {
										Type:     schema.TypeList,
										Optional: true,
										ForceNew: true,
										Description: `List of IPv4 addresses corresponding to this host in the standard decimal format (e.g. 198.51.100.1).
At least one of ipv4_address and ipv6_address must be set.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
					},
				},
			},
			"domain_notices": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `The list of domain notices that you acknowledge. Possible value is HSTS_PRELOADED`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Set of labels associated with the Registration.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"management_settings": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `Settings for management of the Registration, including renewal, billing, and transfer`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"preferred_renewal_method": {
							Type:     schema.TypeString,
							Computed: true,
							Optional: true,
							ForceNew: true,
							Description: `The desired renewal method for this Registration. The actual renewalMethod is automatically updated to reflect this choice.
If unset or equal to RENEWAL_METHOD_UNSPECIFIED, the actual renewalMethod is treated as if it were set to AUTOMATIC_RENEWAL.
You cannot use RENEWAL_DISABLED during resource creation, and you can update the renewal status only when the Registration
resource has state ACTIVE or SUSPENDED.

When preferredRenewalMethod is set to AUTOMATIC_RENEWAL, the actual renewalMethod can be set to RENEWAL_DISABLED in case of
problems with the billing account or reported domain abuse. In such cases, check the issues field on the Registration. After
the problem is resolved, the renewalMethod is automatically updated to preferredRenewalMethod in a few hours.`,
							AtLeastOneOf: []string{"management_settings.0.preferred_renewal_method", "management_settings.0.transfer_lock_state"},
						},
						"transfer_lock_state": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ForceNew:     true,
							Description:  `Controls whether the domain can be transferred to another registrar. Values are UNLOCKED or LOCKED.`,
							AtLeastOneOf: []string{"management_settings.0.preferred_renewal_method", "management_settings.0.transfer_lock_state"},
						},
						"renewal_method": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. The actual renewal method for this Registration. When preferredRenewalMethod is set to AUTOMATIC_RENEWAL,
the actual renewalMethod can be equal to RENEWAL_DISABLEDâ€”for example, when there are problems with the billing account
or reported domain abuse. In such cases, check the issues field on the Registration. After the problem is resolved, the
renewalMethod is automatically updated to preferredRenewalMethod in a few hours.`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Time at which the automation was created.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				ForceNew:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"expire_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Time at which the automation was updated.`,
			},
			"issues": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. The set of issues with the Registration that require attention.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Name of the Registration resource, in the format projects/*/locations/*/registrations/<domain_name>.`,
			},
			"register_failure_reason": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The reason the domain registration failed. Only set for domains in REGISTRATION_FAILED state.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The current state of the Registration.`,
			},
			"supported_privacy": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. Set of options for the contactSettings.privacy field that this Registration supports.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceClouddomainsRegistrationCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	domainNoticesProp, err := expandClouddomainsRegistrationDomainNotices(d.Get("domain_notices"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("domain_notices"); !tpgresource.IsEmptyValue(reflect.ValueOf(domainNoticesProp)) && (ok || !reflect.DeepEqual(v, domainNoticesProp)) {
		obj["domainNotices"] = domainNoticesProp
	}
	contactNoticesProp, err := expandClouddomainsRegistrationContactNotices(d.Get("contact_notices"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("contact_notices"); !tpgresource.IsEmptyValue(reflect.ValueOf(contactNoticesProp)) && (ok || !reflect.DeepEqual(v, contactNoticesProp)) {
		obj["contactNotices"] = contactNoticesProp
	}
	yearlyPriceProp, err := expandClouddomainsRegistrationYearlyPrice(d.Get("yearly_price"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("yearly_price"); !tpgresource.IsEmptyValue(reflect.ValueOf(yearlyPriceProp)) && (ok || !reflect.DeepEqual(v, yearlyPriceProp)) {
		obj["yearlyPrice"] = yearlyPriceProp
	}
	managementSettingsProp, err := expandClouddomainsRegistrationManagementSettings(d.Get("management_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("management_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(managementSettingsProp)) && (ok || !reflect.DeepEqual(v, managementSettingsProp)) {
		obj["managementSettings"] = managementSettingsProp
	}
	dnsSettingsProp, err := expandClouddomainsRegistrationDnsSettings(d.Get("dns_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("dns_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(dnsSettingsProp)) && (ok || !reflect.DeepEqual(v, dnsSettingsProp)) {
		obj["dnsSettings"] = dnsSettingsProp
	}
	contactSettingsProp, err := expandClouddomainsRegistrationContactSettings(d.Get("contact_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("contact_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(contactSettingsProp)) && (ok || !reflect.DeepEqual(v, contactSettingsProp)) {
		obj["contactSettings"] = contactSettingsProp
	}
	labelsProp, err := expandClouddomainsRegistrationEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	domainNameProp, err := expandClouddomainsRegistrationDomainName(d.Get("domain_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("domain_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(domainNameProp)) && (ok || !reflect.DeepEqual(v, domainNameProp)) {
		obj["domainName"] = domainNameProp
	}

	obj, err = resourceClouddomainsRegistrationEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ClouddomainsBasePath}}projects/{{project}}/locations/{{location}}/registrations:register")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Registration: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Registration: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Registration: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/registrations/{{domain_name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = ClouddomainsOperationWaitTime(
		config, res, project, "Creating Registration", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Registration: %s", err)
	}

	if err := waitForRegistrationActive(d, config, d.Timeout(schema.TimeoutCreate)-time.Minute); err != nil {
		return fmt.Errorf("Error waiting for Registration %q to be ACTIVE during creation: %q", d.Get("name").(string), err)
	}

	log.Printf("[DEBUG] Finished creating Registration %q: %#v", d.Id(), res)

	return resourceClouddomainsRegistrationRead(d, meta)
}

func resourceClouddomainsRegistrationRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ClouddomainsBasePath}}projects/{{project}}/locations/{{location}}/registrations/{{domain_name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Registration: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ClouddomainsRegistration %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}

	if err := d.Set("name", flattenClouddomainsRegistrationName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("create_time", flattenClouddomainsRegistrationCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("expire_time", flattenClouddomainsRegistrationExpireTime(res["expireTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("state", flattenClouddomainsRegistrationState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("issues", flattenClouddomainsRegistrationIssues(res["issues"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("labels", flattenClouddomainsRegistrationLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("supported_privacy", flattenClouddomainsRegistrationSupportedPrivacy(res["supportedPrivacy"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("register_failure_reason", flattenClouddomainsRegistrationRegisterFailureReason(res["registerFailureReason"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("management_settings", flattenClouddomainsRegistrationManagementSettings(res["managementSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("dns_settings", flattenClouddomainsRegistrationDnsSettings(res["dnsSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("contact_settings", flattenClouddomainsRegistrationContactSettings(res["contactSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("terraform_labels", flattenClouddomainsRegistrationTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("effective_labels", flattenClouddomainsRegistrationEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}
	if err := d.Set("domain_name", flattenClouddomainsRegistrationDomainName(res["domainName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Registration: %s", err)
	}

	return nil
}

func resourceClouddomainsRegistrationUpdate(d *schema.ResourceData, meta interface{}) error {
	// Only the root field "labels" and "terraform_labels" are mutable
	return resourceClouddomainsRegistrationRead(d, meta)
}

func resourceClouddomainsRegistrationDelete(d *schema.ResourceData, meta interface{}) error {
	log.Printf("[WARNING] Clouddomains Registration resources"+
		" cannot be deleted from Google Cloud. The resource %s will be removed from Terraform"+
		" state, but will still be present on Google Cloud.", d.Id())
	d.SetId("")

	return nil
}

func resourceClouddomainsRegistrationImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/registrations/(?P<domain_name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<domain_name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<domain_name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/registrations/{{domain_name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenClouddomainsRegistrationName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationExpireTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationIssues(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenClouddomainsRegistrationSupportedPrivacy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationRegisterFailureReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationManagementSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["renewal_method"] =
		flattenClouddomainsRegistrationManagementSettingsRenewalMethod(original["renewalMethod"], d, config)
	transformed["preferred_renewal_method"] =
		flattenClouddomainsRegistrationManagementSettingsPreferredRenewalMethod(original["preferredRenewalMethod"], d, config)
	transformed["transfer_lock_state"] =
		flattenClouddomainsRegistrationManagementSettingsTransferLockState(original["transferLockState"], d, config)
	return []interface{}{transformed}
}
func flattenClouddomainsRegistrationManagementSettingsRenewalMethod(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationManagementSettingsPreferredRenewalMethod(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationManagementSettingsTransferLockState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationDnsSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["custom_dns"] =
		flattenClouddomainsRegistrationDnsSettingsCustomDns(original["customDns"], d, config)
	transformed["glue_records"] =
		flattenClouddomainsRegistrationDnsSettingsGlueRecords(original["glueRecords"], d, config)
	return []interface{}{transformed}
}
func flattenClouddomainsRegistrationDnsSettingsCustomDns(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name_servers"] =
		flattenClouddomainsRegistrationDnsSettingsCustomDnsNameServers(original["nameServers"], d, config)
	transformed["ds_records"] =
		flattenClouddomainsRegistrationDnsSettingsCustomDnsDsRecords(original["dsRecords"], d, config)
	return []interface{}{transformed}
}
func flattenClouddomainsRegistrationDnsSettingsCustomDnsNameServers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationDnsSettingsCustomDnsDsRecords(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key_tag":     flattenClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsKeyTag(original["keyTag"], d, config),
			"algorithm":   flattenClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsAlgorithm(original["algorithm"], d, config),
			"digest_type": flattenClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsDigestType(original["digestType"], d, config),
			"digest":      flattenClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsDigest(original["digest"], d, config),
		})
	}
	return transformed
}
func flattenClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsKeyTag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsAlgorithm(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsDigestType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsDigest(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationDnsSettingsGlueRecords(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"host_name":      flattenClouddomainsRegistrationDnsSettingsGlueRecordsHostName(original["hostName"], d, config),
			"ipv4_addresses": flattenClouddomainsRegistrationDnsSettingsGlueRecordsIpv4Addresses(original["ipv4Addresses"], d, config),
			"ipv6_addresses": flattenClouddomainsRegistrationDnsSettingsGlueRecordsIpv6Addresses(original["ipv6Addresses"], d, config),
		})
	}
	return transformed
}
func flattenClouddomainsRegistrationDnsSettingsGlueRecordsHostName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationDnsSettingsGlueRecordsIpv4Addresses(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationDnsSettingsGlueRecordsIpv6Addresses(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationContactSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["privacy"] =
		flattenClouddomainsRegistrationContactSettingsPrivacy(original["privacy"], d, config)
	transformed["registrant_contact"] =
		flattenClouddomainsRegistrationContactSettingsRegistrantContact(original["registrantContact"], d, config)
	transformed["admin_contact"] =
		flattenClouddomainsRegistrationContactSettingsAdminContact(original["adminContact"], d, config)
	transformed["technical_contact"] =
		flattenClouddomainsRegistrationContactSettingsTechnicalContact(original["technicalContact"], d, config)
	return []interface{}{transformed}
}
func flattenClouddomainsRegistrationContactSettingsPrivacy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationContactSettingsRegistrantContact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})

	// Skip reading the following due to ambiguous accept vs return values
	transformed["phone_number"] = d.Get("contact_settings.0.registrant_contact.0.phone_number")
	transformed["fax_number"] = d.Get("contact_settings.0.registrant_contact.0.fax_number")
	transformed["postal_address"] = d.Get("contact_settings.0.registrant_contact.0.postal_address")

	// Don't skip email as it is not normalized
	transformed["email"] = original["email"]
	return []interface{}{transformed}
}

func flattenClouddomainsRegistrationContactSettingsAdminContact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})

	// Skip reading the following due to ambiguous accept vs return values
	transformed["phone_number"] = d.Get("contact_settings.0.admin_contact.0.phone_number")
	transformed["fax_number"] = d.Get("contact_settings.0.admin_contact.0.fax_number")
	transformed["postal_address"] = d.Get("contact_settings.0.admin_contact.0.postal_address")

	// Don't skip email as it is not normalized
	transformed["email"] = original["email"]
	return []interface{}{transformed}
}

func flattenClouddomainsRegistrationContactSettingsTechnicalContact(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})

	// Skip reading the following due to ambiguous accept vs return values
	transformed["phone_number"] = d.Get("contact_settings.0.technical_contact.0.phone_number")
	transformed["fax_number"] = d.Get("contact_settings.0.technical_contact.0.fax_number")
	transformed["postal_address"] = d.Get("contact_settings.0.technical_contact.0.postal_address")

	// Don't skip email as it is not normalized
	transformed["email"] = original["email"]
	return []interface{}{transformed}
}

func flattenClouddomainsRegistrationTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenClouddomainsRegistrationEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenClouddomainsRegistrationDomainName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandClouddomainsRegistrationDomainNotices(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactNotices(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationYearlyPrice(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCurrencyCode, err := expandClouddomainsRegistrationYearlyPriceCurrencyCode(original["currency_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCurrencyCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["currencyCode"] = transformedCurrencyCode
	}

	transformedUnits, err := expandClouddomainsRegistrationYearlyPriceUnits(original["units"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUnits); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["units"] = transformedUnits
	}

	return transformed, nil
}

func expandClouddomainsRegistrationYearlyPriceCurrencyCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationYearlyPriceUnits(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationManagementSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRenewalMethod, err := expandClouddomainsRegistrationManagementSettingsRenewalMethod(original["renewal_method"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRenewalMethod); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["renewalMethod"] = transformedRenewalMethod
	}

	transformedPreferredRenewalMethod, err := expandClouddomainsRegistrationManagementSettingsPreferredRenewalMethod(original["preferred_renewal_method"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPreferredRenewalMethod); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["preferredRenewalMethod"] = transformedPreferredRenewalMethod
	}

	transformedTransferLockState, err := expandClouddomainsRegistrationManagementSettingsTransferLockState(original["transfer_lock_state"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTransferLockState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["transferLockState"] = transformedTransferLockState
	}

	return transformed, nil
}

func expandClouddomainsRegistrationManagementSettingsRenewalMethod(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationManagementSettingsPreferredRenewalMethod(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationManagementSettingsTransferLockState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationDnsSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCustomDns, err := expandClouddomainsRegistrationDnsSettingsCustomDns(original["custom_dns"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCustomDns); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["customDns"] = transformedCustomDns
	}

	transformedGlueRecords, err := expandClouddomainsRegistrationDnsSettingsGlueRecords(original["glue_records"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGlueRecords); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["glueRecords"] = transformedGlueRecords
	}

	return transformed, nil
}

func expandClouddomainsRegistrationDnsSettingsCustomDns(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNameServers, err := expandClouddomainsRegistrationDnsSettingsCustomDnsNameServers(original["name_servers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNameServers); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nameServers"] = transformedNameServers
	}

	transformedDsRecords, err := expandClouddomainsRegistrationDnsSettingsCustomDnsDsRecords(original["ds_records"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDsRecords); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dsRecords"] = transformedDsRecords
	}

	return transformed, nil
}

func expandClouddomainsRegistrationDnsSettingsCustomDnsNameServers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationDnsSettingsCustomDnsDsRecords(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKeyTag, err := expandClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsKeyTag(original["key_tag"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKeyTag); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["keyTag"] = transformedKeyTag
		}

		transformedAlgorithm, err := expandClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsAlgorithm(original["algorithm"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAlgorithm); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["algorithm"] = transformedAlgorithm
		}

		transformedDigestType, err := expandClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsDigestType(original["digest_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDigestType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["digestType"] = transformedDigestType
		}

		transformedDigest, err := expandClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsDigest(original["digest"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDigest); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["digest"] = transformedDigest
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsKeyTag(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsAlgorithm(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsDigestType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationDnsSettingsCustomDnsDsRecordsDigest(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationDnsSettingsGlueRecords(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedHostName, err := expandClouddomainsRegistrationDnsSettingsGlueRecordsHostName(original["host_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHostName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hostName"] = transformedHostName
		}

		transformedIpv4Addresses, err := expandClouddomainsRegistrationDnsSettingsGlueRecordsIpv4Addresses(original["ipv4_addresses"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIpv4Addresses); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ipv4Addresses"] = transformedIpv4Addresses
		}

		transformedIpv6Addresses, err := expandClouddomainsRegistrationDnsSettingsGlueRecordsIpv6Addresses(original["ipv6_addresses"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIpv6Addresses); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ipv6Addresses"] = transformedIpv6Addresses
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandClouddomainsRegistrationDnsSettingsGlueRecordsHostName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationDnsSettingsGlueRecordsIpv4Addresses(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationDnsSettingsGlueRecordsIpv6Addresses(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPrivacy, err := expandClouddomainsRegistrationContactSettingsPrivacy(original["privacy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrivacy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["privacy"] = transformedPrivacy
	}

	transformedRegistrantContact, err := expandClouddomainsRegistrationContactSettingsRegistrantContact(original["registrant_contact"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRegistrantContact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["registrantContact"] = transformedRegistrantContact
	}

	transformedAdminContact, err := expandClouddomainsRegistrationContactSettingsAdminContact(original["admin_contact"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdminContact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["adminContact"] = transformedAdminContact
	}

	transformedTechnicalContact, err := expandClouddomainsRegistrationContactSettingsTechnicalContact(original["technical_contact"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTechnicalContact); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["technicalContact"] = transformedTechnicalContact
	}

	return transformed, nil
}

func expandClouddomainsRegistrationContactSettingsPrivacy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEmail, err := expandClouddomainsRegistrationContactSettingsRegistrantContactEmail(original["email"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEmail); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["email"] = transformedEmail
	}

	transformedPhoneNumber, err := expandClouddomainsRegistrationContactSettingsRegistrantContactPhoneNumber(original["phone_number"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPhoneNumber); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["phoneNumber"] = transformedPhoneNumber
	}

	transformedFaxNumber, err := expandClouddomainsRegistrationContactSettingsRegistrantContactFaxNumber(original["fax_number"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFaxNumber); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["faxNumber"] = transformedFaxNumber
	}

	transformedPostalAddress, err := expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddress(original["postal_address"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPostalAddress); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["postalAddress"] = transformedPostalAddress
	}

	return transformed, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContactEmail(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContactPhoneNumber(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContactFaxNumber(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRegionCode, err := expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressRegionCode(original["region_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRegionCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["regionCode"] = transformedRegionCode
	}

	transformedPostalCode, err := expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressPostalCode(original["postal_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPostalCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["postalCode"] = transformedPostalCode
	}

	transformedAdministrativeArea, err := expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressAdministrativeArea(original["administrative_area"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdministrativeArea); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["administrativeArea"] = transformedAdministrativeArea
	}

	transformedLocality, err := expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressLocality(original["locality"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocality); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["locality"] = transformedLocality
	}

	transformedOrganization, err := expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressOrganization(original["organization"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOrganization); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["organization"] = transformedOrganization
	}

	transformedAddressLines, err := expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressAddressLines(original["address_lines"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAddressLines); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["addressLines"] = transformedAddressLines
	}

	transformedRecipients, err := expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressRecipients(original["recipients"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRecipients); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["recipients"] = transformedRecipients
	}

	return transformed, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressRegionCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressPostalCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressAdministrativeArea(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressLocality(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressOrganization(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressAddressLines(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsRegistrantContactPostalAddressRecipients(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEmail, err := expandClouddomainsRegistrationContactSettingsAdminContactEmail(original["email"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEmail); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["email"] = transformedEmail
	}

	transformedPhoneNumber, err := expandClouddomainsRegistrationContactSettingsAdminContactPhoneNumber(original["phone_number"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPhoneNumber); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["phoneNumber"] = transformedPhoneNumber
	}

	transformedFaxNumber, err := expandClouddomainsRegistrationContactSettingsAdminContactFaxNumber(original["fax_number"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFaxNumber); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["faxNumber"] = transformedFaxNumber
	}

	transformedPostalAddress, err := expandClouddomainsRegistrationContactSettingsAdminContactPostalAddress(original["postal_address"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPostalAddress); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["postalAddress"] = transformedPostalAddress
	}

	return transformed, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContactEmail(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContactPhoneNumber(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContactFaxNumber(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContactPostalAddress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRegionCode, err := expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressRegionCode(original["region_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRegionCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["regionCode"] = transformedRegionCode
	}

	transformedPostalCode, err := expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressPostalCode(original["postal_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPostalCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["postalCode"] = transformedPostalCode
	}

	transformedAdministrativeArea, err := expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressAdministrativeArea(original["administrative_area"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdministrativeArea); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["administrativeArea"] = transformedAdministrativeArea
	}

	transformedLocality, err := expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressLocality(original["locality"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocality); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["locality"] = transformedLocality
	}

	transformedOrganization, err := expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressOrganization(original["organization"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOrganization); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["organization"] = transformedOrganization
	}

	transformedAddressLines, err := expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressAddressLines(original["address_lines"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAddressLines); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["addressLines"] = transformedAddressLines
	}

	transformedRecipients, err := expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressRecipients(original["recipients"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRecipients); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["recipients"] = transformedRecipients
	}

	return transformed, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressRegionCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressPostalCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressAdministrativeArea(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressLocality(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressOrganization(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressAddressLines(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsAdminContactPostalAddressRecipients(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContact(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEmail, err := expandClouddomainsRegistrationContactSettingsTechnicalContactEmail(original["email"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEmail); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["email"] = transformedEmail
	}

	transformedPhoneNumber, err := expandClouddomainsRegistrationContactSettingsTechnicalContactPhoneNumber(original["phone_number"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPhoneNumber); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["phoneNumber"] = transformedPhoneNumber
	}

	transformedFaxNumber, err := expandClouddomainsRegistrationContactSettingsTechnicalContactFaxNumber(original["fax_number"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFaxNumber); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["faxNumber"] = transformedFaxNumber
	}

	transformedPostalAddress, err := expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddress(original["postal_address"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPostalAddress); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["postalAddress"] = transformedPostalAddress
	}

	return transformed, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContactEmail(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContactPhoneNumber(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContactFaxNumber(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRegionCode, err := expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressRegionCode(original["region_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRegionCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["regionCode"] = transformedRegionCode
	}

	transformedPostalCode, err := expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressPostalCode(original["postal_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPostalCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["postalCode"] = transformedPostalCode
	}

	transformedAdministrativeArea, err := expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressAdministrativeArea(original["administrative_area"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdministrativeArea); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["administrativeArea"] = transformedAdministrativeArea
	}

	transformedLocality, err := expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressLocality(original["locality"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocality); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["locality"] = transformedLocality
	}

	transformedOrganization, err := expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressOrganization(original["organization"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOrganization); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["organization"] = transformedOrganization
	}

	transformedAddressLines, err := expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressAddressLines(original["address_lines"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAddressLines); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["addressLines"] = transformedAddressLines
	}

	transformedRecipients, err := expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressRecipients(original["recipients"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRecipients); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["recipients"] = transformedRecipients
	}

	return transformed, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressRegionCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressPostalCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressAdministrativeArea(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressLocality(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressOrganization(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressAddressLines(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationContactSettingsTechnicalContactPostalAddressRecipients(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandClouddomainsRegistrationEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandClouddomainsRegistrationDomainName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceClouddomainsRegistrationEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {

	// Request body is registration object with additional fields
	// See https://cloud.google.com/domains/docs/reference/rest/v1beta1/projects.locations.registrations/register

	newObj := make(map[string]interface{})

	newObj["domainNotices"] = obj["domainNotices"]
	delete(obj, "domainNotices")
	newObj["contactNotices"] = obj["contactNotices"]
	delete(obj, "contactNotices")
	newObj["yearlyPrice"] = obj["yearlyPrice"]
	delete(obj, "yearlyPrice")

	newObj["registration"] = obj

	return newObj, nil
}
