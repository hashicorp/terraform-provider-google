// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package transcoder

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceTranscoderJob() *schema.Resource {
	return &schema.Resource{
		Create: resourceTranscoderJobCreate,
		Read:   resourceTranscoderJobRead,
		Update: resourceTranscoderJobUpdate,
		Delete: resourceTranscoderJobDelete,

		Importer: &schema.ResourceImporter{
			State: resourceTranscoderJobImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the transcoding job resource.`,
			},
			"config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `The configuration for this template.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ad_breaks": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Ad break.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"start_time_offset": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Start time in seconds for the ad break, relative to the output file timeline`,
									},
								},
							},
						},
						"edit_list": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `List of input assets stored in Cloud Storage.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"inputs": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `List of values identifying files that should be used in this atom.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"key": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `A unique key for this atom.`,
									},
									"start_time_offset": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Start time in seconds for the atom, relative to the input file timeline. The default is '0s'.`,
									},
								},
							},
						},
						"elementary_streams": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `List of input assets stored in Cloud Storage.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"audio_stream": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Encoding of an audio stream.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"bitrate_bps": {
													Type:        schema.TypeInt,
													Required:    true,
													ForceNew:    true,
													Description: `Audio bitrate in bits per second.`,
												},
												"channel_count": {
													Type:        schema.TypeInt,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `Number of audio channels. The default is '2'.`,
												},
												"channel_layout": {
													Type:        schema.TypeList,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `A list of channel names specifying layout of the audio channels. The default is ["fl", "fr"].`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"codec": {
													Type:        schema.TypeString,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `The codec for this audio stream. The default is 'aac'.`,
												},
												"sample_rate_hertz": {
													Type:        schema.TypeInt,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `The audio sample rate in Hertz. The default is '48000'.`,
												},
											},
										},
									},
									"key": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `A unique key for this atom.`,
									},
									"video_stream": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Encoding of a video stream.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"h264": {
													Type:        schema.TypeList,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `H264 codec settings`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"bitrate_bps": {
																Type:        schema.TypeInt,
																Required:    true,
																ForceNew:    true,
																Description: `The video bitrate in bits per second.`,
															},
															"frame_rate": {
																Type:        schema.TypeInt,
																Required:    true,
																ForceNew:    true,
																Description: `The target video frame rate in frames per second (FPS).`,
															},
															"crf_level": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Target CRF level. The default is '21'.`,
															},
															"entropy_coder": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `The entropy coder to use. The default is 'cabac'.`,
															},
															"gop_duration": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Select the GOP size based on the specified duration. The default is '3s'.`,
															},
															"height_pixels": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `The height of the video in pixels.`,
															},
															"hlg": {
																Type:        schema.TypeList,
																Optional:    true,
																ForceNew:    true,
																Description: `HLG color format setting for H264.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},
															"pixel_format": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Pixel format to use. The default is 'yuv420p'.`,
															},
															"preset": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Enforces the specified codec preset. The default is 'veryfast'.`,
															},
															"profile": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Enforces the specified codec profile.`,
															},
															"rate_control_mode": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Specify the mode. The default is 'vbr'.`,
															},
															"sdr": {
																Type:        schema.TypeList,
																Optional:    true,
																ForceNew:    true,
																Description: `SDR color format setting for H264.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},
															"vbv_fullness_bits": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Initial fullness of the Video Buffering Verifier (VBV) buffer in bits.`,
															},
															"vbv_size_bits": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Size of the Video Buffering Verifier (VBV) buffer in bits.`,
															},
															"width_pixels": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `The width of the video in pixels.`,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"encryptions": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `List of encryption configurations for the content.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Identifier for this set of encryption options.`,
									},
									"aes128": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Configuration for AES-128 encryption.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},
									"drm_systems": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `DRM system(s) to use; at least one must be specified. If a DRM system is omitted, it is considered disabled.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"clearkey": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Clearkey configuration.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
												"fairplay": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Fairplay configuration.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
												"playready": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Playready configuration.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
												"widevine": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Widevine configuration.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
											},
										},
									},
									"mpeg_cenc": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Configuration for MPEG Common Encryption (MPEG-CENC).`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"scheme": {
													Type:        schema.TypeString,
													Required:    true,
													ForceNew:    true,
													Description: `Specify the encryption scheme.`,
												},
											},
										},
									},
									"sample_aes": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Configuration for SAMPLE-AES encryption.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},
									"secret_manager_key_source": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Configuration for secrets stored in Google Secret Manager.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:        schema.TypeString,
													Required:    true,
													ForceNew:    true,
													Description: `The name of the Secret Version containing the encryption key in the following format: projects/{project}/secrets/{secret_id}/versions/{version_number}.`,
												},
											},
										},
									},
								},
							},
						},
						"inputs": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `List of input assets stored in Cloud Storage.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `A unique key for this input. Must be specified when using advanced mapping and edit lists.`,
									},
									"uri": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										ForceNew: true,
										Description: `URI of the media. Input files must be at least 5 seconds in duration and stored in Cloud Storage (for example, gs://bucket/inputs/file.mp4).
If empty, the value is populated from Job.input_uri.`,
									},
								},
							},
						},
						"manifests": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Manifest configuration.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"type": {
										Type:         schema.TypeString,
										Computed:     true,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"MANIFEST_TYPE_UNSPECIFIED", "HLS", "DASH"}),
										Description:  `Type of the manifest. Possible values: ["MANIFEST_TYPE_UNSPECIFIED", "HLS", "DASH"]`,
									},
									"file_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `The name of the generated file. The default is 'manifest'.`,
									},
									"mux_streams": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `List of user supplied MuxStream.key values that should appear in this manifest.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"mux_streams": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Multiplexing settings for output stream.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"container": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `The container format. The default is 'mp4'.`,
									},
									"elementary_streams": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `List of ElementaryStream.key values multiplexed in this stream.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"encryption_id": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Identifier of the encryption configuration to use.`,
									},
									"file_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `The name of the generated file.`,
									},
									"key": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `A unique key for this multiplexed stream.`,
									},
									"segment_settings": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Segment settings for ts, fmp4 and vtt.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"segment_duration": {
													Type:        schema.TypeString,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `Duration of the segments in seconds. The default is '6.0s'.`,
												},
											},
										},
									},
								},
							},
						},
						"output": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Location of output file(s) in a Cloud Storage bucket.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"uri": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `URI for the output file(s). For example, gs://my-bucket/outputs/.`,
									},
								},
							},
						},
						"overlays": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `List of overlays on the output video, in descending Z-order.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"animations": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `List of animations. The list should be chronological, without any time overlap.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"animation_fade": {
													Type:        schema.TypeList,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `Display overlay object with fade animation.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"fade_type": {
																Type:         schema.TypeString,
																Required:     true,
																ForceNew:     true,
																ValidateFunc: verify.ValidateEnum([]string{"FADE_TYPE_UNSPECIFIED", "FADE_IN", "FADE_OUT"}),
																Description: `Required. Type of fade animation: 'FADE_IN' or 'FADE_OUT'.
The possible values are:

* 'FADE_TYPE_UNSPECIFIED': The fade type is not specified.

* 'FADE_IN': Fade the overlay object into view.

* 'FADE_OUT': Fade the overlay object out of view. Possible values: ["FADE_TYPE_UNSPECIFIED", "FADE_IN", "FADE_OUT"]`,
															},
															"end_time_offset": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `The time to end the fade animation, in seconds.`,
															},
															"start_time_offset": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `The time to start the fade animation, in seconds.`,
															},
															"xy": {
																Type:        schema.TypeList,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Normalized coordinates based on output video resolution.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"x": {
																			Type:        schema.TypeFloat,
																			Computed:    true,
																			Optional:    true,
																			ForceNew:    true,
																			Description: `Normalized x coordinate.`,
																		},
																		"y": {
																			Type:        schema.TypeFloat,
																			Computed:    true,
																			Optional:    true,
																			ForceNew:    true,
																			Description: `Normalized y coordinate.`,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"image": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Image overlay.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"uri": {
													Type:        schema.TypeString,
													Required:    true,
													ForceNew:    true,
													Description: `URI of the image in Cloud Storage. For example, gs://bucket/inputs/image.png.`,
												},
											},
										},
									},
								},
							},
						},
						"pubsub_destination": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Pub/Sub destination.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"topic": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `The name of the Pub/Sub topic to publish job completion notification to. For example: projects/{project}/topics/{topic}.`,
									},
								},
							},
						},
					},
				},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `The labels associated with this job. You can use these to organize and group your jobs.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"template_id": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				ForceNew: true,
				Description: `Specify the templateId to use for populating Job.config.
The default is preset/web-hd, which is the only supported preset.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time the job was created.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				ForceNew:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"end_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time the transcoding finished.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The resource name of the job.`,
			},
			"start_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time the transcoding started.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The current state of the job.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceTranscoderJobCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	templateIdProp, err := expandTranscoderJobTemplateId(d.Get("template_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("template_id"); !tpgresource.IsEmptyValue(reflect.ValueOf(templateIdProp)) && (ok || !reflect.DeepEqual(v, templateIdProp)) {
		obj["templateId"] = templateIdProp
	}
	configProp, err := expandTranscoderJobConfig(d.Get("config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("config"); !tpgresource.IsEmptyValue(reflect.ValueOf(configProp)) && (ok || !reflect.DeepEqual(v, configProp)) {
		obj["config"] = configProp
	}
	labelsProp, err := expandTranscoderJobEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{TranscoderBasePath}}projects/{{project}}/locations/{{location}}/jobs")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Job: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Job: %s", err)
	}
	if err := d.Set("name", flattenTranscoderJobName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Job %q: %#v", d.Id(), res)

	return resourceTranscoderJobRead(d, meta)
}

func resourceTranscoderJobRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{TranscoderBasePath}}{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("TranscoderJob %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}

	if err := d.Set("name", flattenTranscoderJobName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}
	if err := d.Set("create_time", flattenTranscoderJobCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}
	if err := d.Set("start_time", flattenTranscoderJobStartTime(res["startTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}
	if err := d.Set("end_time", flattenTranscoderJobEndTime(res["endTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}
	if err := d.Set("state", flattenTranscoderJobState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}
	if err := d.Set("labels", flattenTranscoderJobLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}
	if err := d.Set("config", flattenTranscoderJobConfig(res["config"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}
	if err := d.Set("terraform_labels", flattenTranscoderJobTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}
	if err := d.Set("effective_labels", flattenTranscoderJobEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}

	return nil
}

func resourceTranscoderJobUpdate(d *schema.ResourceData, meta interface{}) error {
	// Only the root field "labels" and "terraform_labels" are mutable
	return resourceTranscoderJobRead(d, meta)
}

func resourceTranscoderJobDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{TranscoderBasePath}}{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Job %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Job")
	}

	log.Printf("[DEBUG] Finished deleting Job %q: %#v", d.Id(), res)
	return nil
}

func resourceTranscoderJobImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {

	config := meta.(*transport_tpg.Config)

	// current import_formats can't import fields with forward slashes in their value
	if err := tpgresource.ParseImportId([]string{"(?P<project>[^ ]+) (?P<name>[^ ]+)", "(?P<name>[^ ]+)"}, d, config); err != nil {
		return nil, err
	}

	return []*schema.ResourceData{d}, nil
}

func flattenTranscoderJobName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenTranscoderJobConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["inputs"] =
		flattenTranscoderJobConfigInputs(original["inputs"], d, config)
	transformed["edit_list"] =
		flattenTranscoderJobConfigEditList(original["editList"], d, config)
	transformed["elementary_streams"] =
		flattenTranscoderJobConfigElementaryStreams(original["elementaryStreams"], d, config)
	transformed["mux_streams"] =
		flattenTranscoderJobConfigMuxStreams(original["muxStreams"], d, config)
	transformed["manifests"] =
		flattenTranscoderJobConfigManifests(original["manifests"], d, config)
	transformed["output"] =
		flattenTranscoderJobConfigOutput(original["output"], d, config)
	transformed["ad_breaks"] =
		flattenTranscoderJobConfigAdBreaks(original["adBreaks"], d, config)
	transformed["pubsub_destination"] =
		flattenTranscoderJobConfigPubsubDestination(original["pubsubDestination"], d, config)
	transformed["overlays"] =
		flattenTranscoderJobConfigOverlays(original["overlays"], d, config)
	transformed["encryptions"] =
		flattenTranscoderJobConfigEncryptions(original["encryptions"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigInputs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key": flattenTranscoderJobConfigInputsKey(original["key"], d, config),
			"uri": flattenTranscoderJobConfigInputsUri(original["uri"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobConfigInputsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigInputsUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigEditList(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":               flattenTranscoderJobConfigEditListKey(original["key"], d, config),
			"inputs":            flattenTranscoderJobConfigEditListInputs(original["inputs"], d, config),
			"start_time_offset": flattenTranscoderJobConfigEditListStartTimeOffset(original["startTimeOffset"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobConfigEditListKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigEditListInputs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigEditListStartTimeOffset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigElementaryStreams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":          flattenTranscoderJobConfigElementaryStreamsKey(original["key"], d, config),
			"video_stream": flattenTranscoderJobConfigElementaryStreamsVideoStream(original["videoStream"], d, config),
			"audio_stream": flattenTranscoderJobConfigElementaryStreamsAudioStream(original["audioStream"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobConfigElementaryStreamsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigElementaryStreamsVideoStream(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["h264"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264(original["h264"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["width_pixels"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264WidthPixels(original["widthPixels"], d, config)
	transformed["height_pixels"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264HeightPixels(original["heightPixels"], d, config)
	transformed["frame_rate"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264FrameRate(original["frameRate"], d, config)
	transformed["bitrate_bps"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264BitrateBps(original["bitrateBps"], d, config)
	transformed["pixel_format"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264PixelFormat(original["pixelFormat"], d, config)
	transformed["rate_control_mode"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264RateControlMode(original["rateControlMode"], d, config)
	transformed["crf_level"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264CrfLevel(original["crfLevel"], d, config)
	transformed["vbv_size_bits"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264VbvSizeBits(original["vbvSizeBits"], d, config)
	transformed["vbv_fullness_bits"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264VbvFullnessBits(original["vbvFullnessBits"], d, config)
	transformed["entropy_coder"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264EntropyCoder(original["entropyCoder"], d, config)
	transformed["profile"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264Profile(original["profile"], d, config)
	transformed["preset"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264Preset(original["preset"], d, config)
	transformed["gop_duration"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264GopDuration(original["gopDuration"], d, config)
	transformed["sdr"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264Sdr(original["sdr"], d, config)
	transformed["hlg"] =
		flattenTranscoderJobConfigElementaryStreamsVideoStreamH264Hlg(original["hlg"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264WidthPixels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264HeightPixels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264FrameRate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264BitrateBps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264PixelFormat(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264RateControlMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264CrfLevel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264VbvSizeBits(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264VbvFullnessBits(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264EntropyCoder(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264Profile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264Preset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264GopDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264Sdr(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobConfigElementaryStreamsVideoStreamH264Hlg(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobConfigElementaryStreamsAudioStream(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["codec"] =
		flattenTranscoderJobConfigElementaryStreamsAudioStreamCodec(original["codec"], d, config)
	transformed["bitrate_bps"] =
		flattenTranscoderJobConfigElementaryStreamsAudioStreamBitrateBps(original["bitrateBps"], d, config)
	transformed["channel_count"] =
		flattenTranscoderJobConfigElementaryStreamsAudioStreamChannelCount(original["channelCount"], d, config)
	transformed["channel_layout"] =
		flattenTranscoderJobConfigElementaryStreamsAudioStreamChannelLayout(original["channelLayout"], d, config)
	transformed["sample_rate_hertz"] =
		flattenTranscoderJobConfigElementaryStreamsAudioStreamSampleRateHertz(original["sampleRateHertz"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigElementaryStreamsAudioStreamCodec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigElementaryStreamsAudioStreamBitrateBps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobConfigElementaryStreamsAudioStreamChannelCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobConfigElementaryStreamsAudioStreamChannelLayout(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigElementaryStreamsAudioStreamSampleRateHertz(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobConfigMuxStreams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":                flattenTranscoderJobConfigMuxStreamsKey(original["key"], d, config),
			"file_name":          flattenTranscoderJobConfigMuxStreamsFileName(original["fileName"], d, config),
			"container":          flattenTranscoderJobConfigMuxStreamsContainer(original["container"], d, config),
			"elementary_streams": flattenTranscoderJobConfigMuxStreamsElementaryStreams(original["elementaryStreams"], d, config),
			"segment_settings":   flattenTranscoderJobConfigMuxStreamsSegmentSettings(original["segmentSettings"], d, config),
			"encryption_id":      flattenTranscoderJobConfigMuxStreamsEncryptionId(original["encryptionId"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobConfigMuxStreamsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigMuxStreamsFileName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigMuxStreamsContainer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigMuxStreamsElementaryStreams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigMuxStreamsSegmentSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["segment_duration"] =
		flattenTranscoderJobConfigMuxStreamsSegmentSettingsSegmentDuration(original["segmentDuration"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigMuxStreamsSegmentSettingsSegmentDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigMuxStreamsEncryptionId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigManifests(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"file_name":   flattenTranscoderJobConfigManifestsFileName(original["fileName"], d, config),
			"type":        flattenTranscoderJobConfigManifestsType(original["type"], d, config),
			"mux_streams": flattenTranscoderJobConfigManifestsMuxStreams(original["muxStreams"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobConfigManifestsFileName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigManifestsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigManifestsMuxStreams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigOutput(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenTranscoderJobConfigOutputUri(original["uri"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigOutputUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigAdBreaks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"start_time_offset": flattenTranscoderJobConfigAdBreaksStartTimeOffset(original["startTimeOffset"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobConfigAdBreaksStartTimeOffset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigPubsubDestination(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["topic"] =
		flattenTranscoderJobConfigPubsubDestinationTopic(original["topic"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigPubsubDestinationTopic(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigOverlays(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"image":      flattenTranscoderJobConfigOverlaysImage(original["image"], d, config),
			"animations": flattenTranscoderJobConfigOverlaysAnimations(original["animations"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobConfigOverlaysImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenTranscoderJobConfigOverlaysImageUri(original["uri"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigOverlaysImageUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigOverlaysAnimations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"animation_fade": flattenTranscoderJobConfigOverlaysAnimationsAnimationFade(original["animationFade"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobConfigOverlaysAnimationsAnimationFade(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["xy"] =
		flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeXy(original["xy"], d, config)
	transformed["start_time_offset"] =
		flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeStartTimeOffset(original["startTimeOffset"], d, config)
	transformed["end_time_offset"] =
		flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeEndTimeOffset(original["endTimeOffset"], d, config)
	transformed["fade_type"] =
		flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeFadeType(original["fadeType"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeXy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["x"] =
		flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeXyX(original["x"], d, config)
	transformed["y"] =
		flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeXyY(original["y"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeXyX(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeXyY(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeStartTimeOffset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeEndTimeOffset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigOverlaysAnimationsAnimationFadeFadeType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigEncryptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"id":                        flattenTranscoderJobConfigEncryptionsId(original["id"], d, config),
			"drm_systems":               flattenTranscoderJobConfigEncryptionsDrmSystems(original["drmSystems"], d, config),
			"aes128":                    flattenTranscoderJobConfigEncryptionsAes128(original["aes128"], d, config),
			"sample_aes":                flattenTranscoderJobConfigEncryptionsSampleAes(original["sampleAes"], d, config),
			"mpeg_cenc":                 flattenTranscoderJobConfigEncryptionsMpegCenc(original["mpegCenc"], d, config),
			"secret_manager_key_source": flattenTranscoderJobConfigEncryptionsSecretManagerKeySource(original["secretManagerKeySource"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobConfigEncryptionsId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigEncryptionsDrmSystems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["widevine"] =
		flattenTranscoderJobConfigEncryptionsDrmSystemsWidevine(original["widevine"], d, config)
	transformed["fairplay"] =
		flattenTranscoderJobConfigEncryptionsDrmSystemsFairplay(original["fairplay"], d, config)
	transformed["playready"] =
		flattenTranscoderJobConfigEncryptionsDrmSystemsPlayready(original["playready"], d, config)
	transformed["clearkey"] =
		flattenTranscoderJobConfigEncryptionsDrmSystemsClearkey(original["clearkey"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigEncryptionsDrmSystemsWidevine(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobConfigEncryptionsDrmSystemsFairplay(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobConfigEncryptionsDrmSystemsPlayready(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobConfigEncryptionsDrmSystemsClearkey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobConfigEncryptionsAes128(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobConfigEncryptionsSampleAes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobConfigEncryptionsMpegCenc(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["scheme"] =
		flattenTranscoderJobConfigEncryptionsMpegCencScheme(original["scheme"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigEncryptionsMpegCencScheme(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobConfigEncryptionsSecretManagerKeySource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenTranscoderJobConfigEncryptionsSecretManagerKeySourceSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobConfigEncryptionsSecretManagerKeySourceSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenTranscoderJobEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandTranscoderJobTemplateId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInputs, err := expandTranscoderJobConfigInputs(original["inputs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInputs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inputs"] = transformedInputs
	}

	transformedEditList, err := expandTranscoderJobConfigEditList(original["edit_list"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEditList); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["editList"] = transformedEditList
	}

	transformedElementaryStreams, err := expandTranscoderJobConfigElementaryStreams(original["elementary_streams"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedElementaryStreams); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["elementaryStreams"] = transformedElementaryStreams
	}

	transformedMuxStreams, err := expandTranscoderJobConfigMuxStreams(original["mux_streams"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMuxStreams); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["muxStreams"] = transformedMuxStreams
	}

	transformedManifests, err := expandTranscoderJobConfigManifests(original["manifests"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedManifests); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["manifests"] = transformedManifests
	}

	transformedOutput, err := expandTranscoderJobConfigOutput(original["output"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutput); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["output"] = transformedOutput
	}

	transformedAdBreaks, err := expandTranscoderJobConfigAdBreaks(original["ad_breaks"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdBreaks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["adBreaks"] = transformedAdBreaks
	}

	transformedPubsubDestination, err := expandTranscoderJobConfigPubsubDestination(original["pubsub_destination"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPubsubDestination); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pubsubDestination"] = transformedPubsubDestination
	}

	transformedOverlays, err := expandTranscoderJobConfigOverlays(original["overlays"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOverlays); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["overlays"] = transformedOverlays
	}

	transformedEncryptions, err := expandTranscoderJobConfigEncryptions(original["encryptions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEncryptions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["encryptions"] = transformedEncryptions
	}

	return transformed, nil
}

func expandTranscoderJobConfigInputs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandTranscoderJobConfigInputsKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedUri, err := expandTranscoderJobConfigInputsUri(original["uri"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["uri"] = transformedUri
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobConfigInputsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigInputsUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigEditList(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandTranscoderJobConfigEditListKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedInputs, err := expandTranscoderJobConfigEditListInputs(original["inputs"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInputs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["inputs"] = transformedInputs
		}

		transformedStartTimeOffset, err := expandTranscoderJobConfigEditListStartTimeOffset(original["start_time_offset"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStartTimeOffset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["startTimeOffset"] = transformedStartTimeOffset
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobConfigEditListKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigEditListInputs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigEditListStartTimeOffset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandTranscoderJobConfigElementaryStreamsKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedVideoStream, err := expandTranscoderJobConfigElementaryStreamsVideoStream(original["video_stream"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVideoStream); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["videoStream"] = transformedVideoStream
		}

		transformedAudioStream, err := expandTranscoderJobConfigElementaryStreamsAudioStream(original["audio_stream"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAudioStream); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["audioStream"] = transformedAudioStream
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobConfigElementaryStreamsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStream(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedH264, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264(original["h264"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedH264); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["h264"] = transformedH264
	}

	return transformed, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedWidthPixels, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264WidthPixels(original["width_pixels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWidthPixels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["widthPixels"] = transformedWidthPixels
	}

	transformedHeightPixels, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264HeightPixels(original["height_pixels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHeightPixels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["heightPixels"] = transformedHeightPixels
	}

	transformedFrameRate, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264FrameRate(original["frame_rate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFrameRate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["frameRate"] = transformedFrameRate
	}

	transformedBitrateBps, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264BitrateBps(original["bitrate_bps"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBitrateBps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bitrateBps"] = transformedBitrateBps
	}

	transformedPixelFormat, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264PixelFormat(original["pixel_format"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPixelFormat); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pixelFormat"] = transformedPixelFormat
	}

	transformedRateControlMode, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264RateControlMode(original["rate_control_mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRateControlMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rateControlMode"] = transformedRateControlMode
	}

	transformedCrfLevel, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264CrfLevel(original["crf_level"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCrfLevel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["crfLevel"] = transformedCrfLevel
	}

	transformedVbvSizeBits, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264VbvSizeBits(original["vbv_size_bits"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVbvSizeBits); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vbvSizeBits"] = transformedVbvSizeBits
	}

	transformedVbvFullnessBits, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264VbvFullnessBits(original["vbv_fullness_bits"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVbvFullnessBits); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vbvFullnessBits"] = transformedVbvFullnessBits
	}

	transformedEntropyCoder, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264EntropyCoder(original["entropy_coder"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEntropyCoder); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["entropyCoder"] = transformedEntropyCoder
	}

	transformedProfile, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264Profile(original["profile"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProfile); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["profile"] = transformedProfile
	}

	transformedPreset, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264Preset(original["preset"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPreset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["preset"] = transformedPreset
	}

	transformedGopDuration, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264GopDuration(original["gop_duration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGopDuration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gopDuration"] = transformedGopDuration
	}

	transformedSdr, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264Sdr(original["sdr"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["sdr"] = transformedSdr
	}

	transformedHlg, err := expandTranscoderJobConfigElementaryStreamsVideoStreamH264Hlg(original["hlg"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["hlg"] = transformedHlg
	}

	return transformed, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264WidthPixels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264HeightPixels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264FrameRate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264BitrateBps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264PixelFormat(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264RateControlMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264CrfLevel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264VbvSizeBits(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264VbvFullnessBits(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264EntropyCoder(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264Profile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264Preset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264GopDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264Sdr(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobConfigElementaryStreamsVideoStreamH264Hlg(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobConfigElementaryStreamsAudioStream(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCodec, err := expandTranscoderJobConfigElementaryStreamsAudioStreamCodec(original["codec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCodec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["codec"] = transformedCodec
	}

	transformedBitrateBps, err := expandTranscoderJobConfigElementaryStreamsAudioStreamBitrateBps(original["bitrate_bps"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBitrateBps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bitrateBps"] = transformedBitrateBps
	}

	transformedChannelCount, err := expandTranscoderJobConfigElementaryStreamsAudioStreamChannelCount(original["channel_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedChannelCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["channelCount"] = transformedChannelCount
	}

	transformedChannelLayout, err := expandTranscoderJobConfigElementaryStreamsAudioStreamChannelLayout(original["channel_layout"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedChannelLayout); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["channelLayout"] = transformedChannelLayout
	}

	transformedSampleRateHertz, err := expandTranscoderJobConfigElementaryStreamsAudioStreamSampleRateHertz(original["sample_rate_hertz"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSampleRateHertz); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sampleRateHertz"] = transformedSampleRateHertz
	}

	return transformed, nil
}

func expandTranscoderJobConfigElementaryStreamsAudioStreamCodec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsAudioStreamBitrateBps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsAudioStreamChannelCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsAudioStreamChannelLayout(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigElementaryStreamsAudioStreamSampleRateHertz(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigMuxStreams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandTranscoderJobConfigMuxStreamsKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedFileName, err := expandTranscoderJobConfigMuxStreamsFileName(original["file_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFileName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["fileName"] = transformedFileName
		}

		transformedContainer, err := expandTranscoderJobConfigMuxStreamsContainer(original["container"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContainer); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["container"] = transformedContainer
		}

		transformedElementaryStreams, err := expandTranscoderJobConfigMuxStreamsElementaryStreams(original["elementary_streams"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedElementaryStreams); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["elementaryStreams"] = transformedElementaryStreams
		}

		transformedSegmentSettings, err := expandTranscoderJobConfigMuxStreamsSegmentSettings(original["segment_settings"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSegmentSettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["segmentSettings"] = transformedSegmentSettings
		}

		transformedEncryptionId, err := expandTranscoderJobConfigMuxStreamsEncryptionId(original["encryption_id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEncryptionId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["encryptionId"] = transformedEncryptionId
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobConfigMuxStreamsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigMuxStreamsFileName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigMuxStreamsContainer(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigMuxStreamsElementaryStreams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigMuxStreamsSegmentSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSegmentDuration, err := expandTranscoderJobConfigMuxStreamsSegmentSettingsSegmentDuration(original["segment_duration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSegmentDuration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["segmentDuration"] = transformedSegmentDuration
	}

	return transformed, nil
}

func expandTranscoderJobConfigMuxStreamsSegmentSettingsSegmentDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigMuxStreamsEncryptionId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigManifests(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedFileName, err := expandTranscoderJobConfigManifestsFileName(original["file_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFileName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["fileName"] = transformedFileName
		}

		transformedType, err := expandTranscoderJobConfigManifestsType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedMuxStreams, err := expandTranscoderJobConfigManifestsMuxStreams(original["mux_streams"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMuxStreams); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["muxStreams"] = transformedMuxStreams
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobConfigManifestsFileName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigManifestsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigManifestsMuxStreams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigOutput(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandTranscoderJobConfigOutputUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	return transformed, nil
}

func expandTranscoderJobConfigOutputUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigAdBreaks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedStartTimeOffset, err := expandTranscoderJobConfigAdBreaksStartTimeOffset(original["start_time_offset"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStartTimeOffset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["startTimeOffset"] = transformedStartTimeOffset
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobConfigAdBreaksStartTimeOffset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigPubsubDestination(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTopic, err := expandTranscoderJobConfigPubsubDestinationTopic(original["topic"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTopic); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["topic"] = transformedTopic
	}

	return transformed, nil
}

func expandTranscoderJobConfigPubsubDestinationTopic(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigOverlays(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedImage, err := expandTranscoderJobConfigOverlaysImage(original["image"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedImage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["image"] = transformedImage
		}

		transformedAnimations, err := expandTranscoderJobConfigOverlaysAnimations(original["animations"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAnimations); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["animations"] = transformedAnimations
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobConfigOverlaysImage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandTranscoderJobConfigOverlaysImageUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	return transformed, nil
}

func expandTranscoderJobConfigOverlaysImageUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigOverlaysAnimations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAnimationFade, err := expandTranscoderJobConfigOverlaysAnimationsAnimationFade(original["animation_fade"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAnimationFade); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["animationFade"] = transformedAnimationFade
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobConfigOverlaysAnimationsAnimationFade(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedXy, err := expandTranscoderJobConfigOverlaysAnimationsAnimationFadeXy(original["xy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedXy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["xy"] = transformedXy
	}

	transformedStartTimeOffset, err := expandTranscoderJobConfigOverlaysAnimationsAnimationFadeStartTimeOffset(original["start_time_offset"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStartTimeOffset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["startTimeOffset"] = transformedStartTimeOffset
	}

	transformedEndTimeOffset, err := expandTranscoderJobConfigOverlaysAnimationsAnimationFadeEndTimeOffset(original["end_time_offset"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEndTimeOffset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["endTimeOffset"] = transformedEndTimeOffset
	}

	transformedFadeType, err := expandTranscoderJobConfigOverlaysAnimationsAnimationFadeFadeType(original["fade_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFadeType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fadeType"] = transformedFadeType
	}

	return transformed, nil
}

func expandTranscoderJobConfigOverlaysAnimationsAnimationFadeXy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedX, err := expandTranscoderJobConfigOverlaysAnimationsAnimationFadeXyX(original["x"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedX); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["x"] = transformedX
	}

	transformedY, err := expandTranscoderJobConfigOverlaysAnimationsAnimationFadeXyY(original["y"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedY); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["y"] = transformedY
	}

	return transformed, nil
}

func expandTranscoderJobConfigOverlaysAnimationsAnimationFadeXyX(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigOverlaysAnimationsAnimationFadeXyY(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigOverlaysAnimationsAnimationFadeStartTimeOffset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigOverlaysAnimationsAnimationFadeEndTimeOffset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigOverlaysAnimationsAnimationFadeFadeType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigEncryptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedId, err := expandTranscoderJobConfigEncryptionsId(original["id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["id"] = transformedId
		}

		transformedDrmSystems, err := expandTranscoderJobConfigEncryptionsDrmSystems(original["drm_systems"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDrmSystems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["drmSystems"] = transformedDrmSystems
		}

		transformedAes128, err := expandTranscoderJobConfigEncryptionsAes128(original["aes128"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["aes128"] = transformedAes128
		}

		transformedSampleAes, err := expandTranscoderJobConfigEncryptionsSampleAes(original["sample_aes"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["sampleAes"] = transformedSampleAes
		}

		transformedMpegCenc, err := expandTranscoderJobConfigEncryptionsMpegCenc(original["mpeg_cenc"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMpegCenc); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["mpegCenc"] = transformedMpegCenc
		}

		transformedSecretManagerKeySource, err := expandTranscoderJobConfigEncryptionsSecretManagerKeySource(original["secret_manager_key_source"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSecretManagerKeySource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["secretManagerKeySource"] = transformedSecretManagerKeySource
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobConfigEncryptionsId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigEncryptionsDrmSystems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedWidevine, err := expandTranscoderJobConfigEncryptionsDrmSystemsWidevine(original["widevine"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["widevine"] = transformedWidevine
	}

	transformedFairplay, err := expandTranscoderJobConfigEncryptionsDrmSystemsFairplay(original["fairplay"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["fairplay"] = transformedFairplay
	}

	transformedPlayready, err := expandTranscoderJobConfigEncryptionsDrmSystemsPlayready(original["playready"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["playready"] = transformedPlayready
	}

	transformedClearkey, err := expandTranscoderJobConfigEncryptionsDrmSystemsClearkey(original["clearkey"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["clearkey"] = transformedClearkey
	}

	return transformed, nil
}

func expandTranscoderJobConfigEncryptionsDrmSystemsWidevine(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobConfigEncryptionsDrmSystemsFairplay(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobConfigEncryptionsDrmSystemsPlayready(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobConfigEncryptionsDrmSystemsClearkey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobConfigEncryptionsAes128(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobConfigEncryptionsSampleAes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobConfigEncryptionsMpegCenc(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedScheme, err := expandTranscoderJobConfigEncryptionsMpegCencScheme(original["scheme"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScheme); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scheme"] = transformedScheme
	}

	return transformed, nil
}

func expandTranscoderJobConfigEncryptionsMpegCencScheme(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobConfigEncryptionsSecretManagerKeySource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandTranscoderJobConfigEncryptionsSecretManagerKeySourceSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandTranscoderJobConfigEncryptionsSecretManagerKeySourceSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
