// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package transcoder

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceTranscoderJobTemplate() *schema.Resource {
	return &schema.Resource{
		Create: resourceTranscoderJobTemplateCreate,
		Read:   resourceTranscoderJobTemplateRead,
		Update: resourceTranscoderJobTemplateUpdate,
		Delete: resourceTranscoderJobTemplateDelete,

		Importer: &schema.ResourceImporter{
			State: resourceTranscoderJobTemplateImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"job_template_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `ID to use for the Transcoding job template.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the transcoding job template resource.`,
			},
			"config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `The configuration for this template.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ad_breaks": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Ad break.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"start_time_offset": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Start time in seconds for the ad break, relative to the output file timeline`,
									},
								},
							},
						},
						"edit_list": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `List of input assets stored in Cloud Storage.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"inputs": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `List of values identifying files that should be used in this atom.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"key": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `A unique key for this atom.`,
									},
									"start_time_offset": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Start time in seconds for the atom, relative to the input file timeline.  The default is '0s'.`,
									},
								},
							},
						},
						"elementary_streams": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `List of input assets stored in Cloud Storage.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"audio_stream": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Encoding of an audio stream.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"bitrate_bps": {
													Type:        schema.TypeInt,
													Required:    true,
													ForceNew:    true,
													Description: `Audio bitrate in bits per second.`,
												},
												"channel_count": {
													Type:        schema.TypeInt,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `Number of audio channels. The default is '2'.`,
												},
												"channel_layout": {
													Type:        schema.TypeList,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `A list of channel names specifying layout of the audio channels.  The default is ["fl", "fr"].`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"codec": {
													Type:        schema.TypeString,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `The codec for this audio stream. The default is 'aac'.`,
												},
												"sample_rate_hertz": {
													Type:        schema.TypeInt,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `The audio sample rate in Hertz. The default is '48000'.`,
												},
											},
										},
									},
									"key": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `A unique key for this atom.`,
									},
									"video_stream": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Encoding of a video stream.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"h264": {
													Type:        schema.TypeList,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `H264 codec settings`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"bitrate_bps": {
																Type:        schema.TypeInt,
																Required:    true,
																ForceNew:    true,
																Description: `The video bitrate in bits per second.`,
															},
															"frame_rate": {
																Type:        schema.TypeInt,
																Required:    true,
																ForceNew:    true,
																Description: `The target video frame rate in frames per second (FPS).`,
															},
															"crf_level": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Target CRF level. The default is '21'.`,
															},
															"entropy_coder": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `The entropy coder to use. The default is 'cabac'.`,
															},
															"gop_duration": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Select the GOP size based on the specified duration. The default is '3s'.`,
															},
															"height_pixels": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `The height of the video in pixels.`,
															},
															"hlg": {
																Type:        schema.TypeList,
																Optional:    true,
																ForceNew:    true,
																Description: `HLG color format setting for H264.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},
															"pixel_format": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Pixel format to use. The default is 'yuv420p'.`,
															},
															"preset": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Enforces the specified codec preset. The default is 'veryfast'.`,
															},
															"profile": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Enforces the specified codec profile.`,
															},
															"rate_control_mode": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Specify the mode. The default is 'vbr'.`,
															},
															"sdr": {
																Type:        schema.TypeList,
																Optional:    true,
																ForceNew:    true,
																Description: `SDR color format setting for H264.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},
															"vbv_fullness_bits": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Initial fullness of the Video Buffering Verifier (VBV) buffer in bits.`,
															},
															"vbv_size_bits": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Size of the Video Buffering Verifier (VBV) buffer in bits.`,
															},
															"width_pixels": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `The width of the video in pixels.`,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"encryptions": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `List of encryption configurations for the content.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Identifier for this set of encryption options.`,
									},
									"aes128": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Configuration for AES-128 encryption.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},
									"drm_systems": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `DRM system(s) to use; at least one must be specified. If a DRM system is omitted, it is considered disabled.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"clearkey": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Clearkey configuration.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
												"fairplay": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Fairplay configuration.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
												"playready": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Playready configuration.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
												"widevine": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Widevine configuration.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
											},
										},
									},
									"mpeg_cenc": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Configuration for MPEG Common Encryption (MPEG-CENC).`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"scheme": {
													Type:        schema.TypeString,
													Required:    true,
													ForceNew:    true,
													Description: `Specify the encryption scheme.`,
												},
											},
										},
									},
									"sample_aes": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Configuration for SAMPLE-AES encryption.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},
									"secret_manager_key_source": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Configuration for secrets stored in Google Secret Manager.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:        schema.TypeString,
													Required:    true,
													ForceNew:    true,
													Description: `The name of the Secret Version containing the encryption key in the following format: projects/{project}/secrets/{secret_id}/versions/{version_number}.`,
												},
											},
										},
									},
								},
							},
						},
						"inputs": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `List of input assets stored in Cloud Storage.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `A unique key for this input. Must be specified when using advanced mapping and edit lists.`,
									},
									"uri": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										ForceNew: true,
										Description: `URI of the media. Input files must be at least 5 seconds in duration and stored in Cloud Storage (for example, gs://bucket/inputs/file.mp4).
If empty, the value is populated from Job.input_uri.`,
									},
								},
							},
						},
						"manifests": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Manifest configuration.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"type": {
										Type:         schema.TypeString,
										Computed:     true,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"MANIFEST_TYPE_UNSPECIFIED", "HLS", "DASH"}),
										Description:  `Type of the manifest. Possible values: ["MANIFEST_TYPE_UNSPECIFIED", "HLS", "DASH"]`,
									},
									"file_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `The name of the generated file. The default is 'manifest'.`,
									},
									"mux_streams": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `List of user supplied MuxStream.key values that should appear in this manifest.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"mux_streams": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Multiplexing settings for output stream.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"container": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `The container format. The default is 'mp4'.`,
									},
									"elementary_streams": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `List of ElementaryStream.key values multiplexed in this stream.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"encryption_id": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Identifier of the encryption configuration to use.`,
									},
									"file_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `The name of the generated file.`,
									},
									"key": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `A unique key for this multiplexed stream.`,
									},
									"segment_settings": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Segment settings for ts, fmp4 and vtt.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"segment_duration": {
													Type:        schema.TypeString,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `Duration of the segments in seconds. The default is '6.0s'.`,
												},
											},
										},
									},
								},
							},
						},
						"output": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Location of output file(s) in a Cloud Storage bucket.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"uri": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `URI for the output file(s). For example, gs://my-bucket/outputs/.`,
									},
								},
							},
						},
						"overlays": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `List of overlays on the output video, in descending Z-order.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"animations": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `List of animations. The list should be chronological, without any time overlap.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"animation_fade": {
													Type:        schema.TypeList,
													Computed:    true,
													Optional:    true,
													ForceNew:    true,
													Description: `Display overlay object with fade animation.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"fade_type": {
																Type:         schema.TypeString,
																Required:     true,
																ForceNew:     true,
																ValidateFunc: verify.ValidateEnum([]string{"FADE_TYPE_UNSPECIFIED", "FADE_IN", "FADE_OUT"}),
																Description: `Required. Type of fade animation: 'FADE_IN' or 'FADE_OUT'.
The possible values are:

* 'FADE_TYPE_UNSPECIFIED': The fade type is not specified.

* 'FADE_IN': Fade the overlay object into view.

* 'FADE_OUT': Fade the overlay object out of view. Possible values: ["FADE_TYPE_UNSPECIFIED", "FADE_IN", "FADE_OUT"]`,
															},
															"end_time_offset": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `The time to end the fade animation, in seconds.`,
															},
															"start_time_offset": {
																Type:        schema.TypeString,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `The time to start the fade animation, in seconds.`,
															},
															"xy": {
																Type:        schema.TypeList,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Normalized coordinates based on output video resolution.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"x": {
																			Type:        schema.TypeFloat,
																			Computed:    true,
																			Optional:    true,
																			ForceNew:    true,
																			Description: `Normalized x coordinate.`,
																		},
																		"y": {
																			Type:        schema.TypeFloat,
																			Computed:    true,
																			Optional:    true,
																			ForceNew:    true,
																			Description: `Normalized y coordinate.`,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"image": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Image overlay.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"uri": {
													Type:        schema.TypeString,
													Required:    true,
													ForceNew:    true,
													Description: `URI of the image in Cloud Storage. For example, gs://bucket/inputs/image.png.`,
												},
											},
										},
									},
								},
							},
						},
						"pubsub_destination": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Pub/Sub destination.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"topic": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `The name of the Pub/Sub topic to publish job completion notification to. For example: projects/{project}/topics/{topic}.`,
									},
								},
							},
						},
					},
				},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `The labels associated with this job template. You can use these to organize and group your job templates.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				ForceNew:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The resource name of the job template.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceTranscoderJobTemplateCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	configProp, err := expandTranscoderJobTemplateConfig(d.Get("config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("config"); !tpgresource.IsEmptyValue(reflect.ValueOf(configProp)) && (ok || !reflect.DeepEqual(v, configProp)) {
		obj["config"] = configProp
	}
	labelsProp, err := expandTranscoderJobTemplateEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{TranscoderBasePath}}projects/{{project}}/locations/{{location}}/jobTemplates?jobTemplateId={{job_template_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new JobTemplate: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for JobTemplate: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating JobTemplate: %s", err)
	}
	if err := d.Set("name", flattenTranscoderJobTemplateName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/jobTemplates/{{job_template_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating JobTemplate %q: %#v", d.Id(), res)

	return resourceTranscoderJobTemplateRead(d, meta)
}

func resourceTranscoderJobTemplateRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{TranscoderBasePath}}projects/{{project}}/locations/{{location}}/jobTemplates/{{job_template_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for JobTemplate: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("TranscoderJobTemplate %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading JobTemplate: %s", err)
	}

	if err := d.Set("name", flattenTranscoderJobTemplateName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading JobTemplate: %s", err)
	}
	if err := d.Set("labels", flattenTranscoderJobTemplateLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading JobTemplate: %s", err)
	}
	if err := d.Set("config", flattenTranscoderJobTemplateConfig(res["config"], d, config)); err != nil {
		return fmt.Errorf("Error reading JobTemplate: %s", err)
	}
	if err := d.Set("terraform_labels", flattenTranscoderJobTemplateTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading JobTemplate: %s", err)
	}
	if err := d.Set("effective_labels", flattenTranscoderJobTemplateEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading JobTemplate: %s", err)
	}

	return nil
}

func resourceTranscoderJobTemplateUpdate(d *schema.ResourceData, meta interface{}) error {
	// Only the root field "labels" and "terraform_labels" are mutable
	return resourceTranscoderJobTemplateRead(d, meta)
}

func resourceTranscoderJobTemplateDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for JobTemplate: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{TranscoderBasePath}}projects/{{project}}/locations/{{location}}/jobTemplates/{{job_template_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting JobTemplate %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "JobTemplate")
	}

	log.Printf("[DEBUG] Finished deleting JobTemplate %q: %#v", d.Id(), res)
	return nil
}

func resourceTranscoderJobTemplateImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/jobTemplates/(?P<job_template_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<job_template_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<job_template_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/jobTemplates/{{job_template_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenTranscoderJobTemplateName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.NameFromSelfLinkStateFunc(v)
}

func flattenTranscoderJobTemplateLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenTranscoderJobTemplateConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["inputs"] =
		flattenTranscoderJobTemplateConfigInputs(original["inputs"], d, config)
	transformed["edit_list"] =
		flattenTranscoderJobTemplateConfigEditList(original["editList"], d, config)
	transformed["elementary_streams"] =
		flattenTranscoderJobTemplateConfigElementaryStreams(original["elementaryStreams"], d, config)
	transformed["mux_streams"] =
		flattenTranscoderJobTemplateConfigMuxStreams(original["muxStreams"], d, config)
	transformed["manifests"] =
		flattenTranscoderJobTemplateConfigManifests(original["manifests"], d, config)
	transformed["output"] =
		flattenTranscoderJobTemplateConfigOutput(original["output"], d, config)
	transformed["ad_breaks"] =
		flattenTranscoderJobTemplateConfigAdBreaks(original["adBreaks"], d, config)
	transformed["pubsub_destination"] =
		flattenTranscoderJobTemplateConfigPubsubDestination(original["pubsubDestination"], d, config)
	transformed["overlays"] =
		flattenTranscoderJobTemplateConfigOverlays(original["overlays"], d, config)
	transformed["encryptions"] =
		flattenTranscoderJobTemplateConfigEncryptions(original["encryptions"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigInputs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key": flattenTranscoderJobTemplateConfigInputsKey(original["key"], d, config),
			"uri": flattenTranscoderJobTemplateConfigInputsUri(original["uri"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobTemplateConfigInputsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigInputsUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigEditList(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":               flattenTranscoderJobTemplateConfigEditListKey(original["key"], d, config),
			"inputs":            flattenTranscoderJobTemplateConfigEditListInputs(original["inputs"], d, config),
			"start_time_offset": flattenTranscoderJobTemplateConfigEditListStartTimeOffset(original["startTimeOffset"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobTemplateConfigEditListKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigEditListInputs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigEditListStartTimeOffset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigElementaryStreams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":          flattenTranscoderJobTemplateConfigElementaryStreamsKey(original["key"], d, config),
			"video_stream": flattenTranscoderJobTemplateConfigElementaryStreamsVideoStream(original["videoStream"], d, config),
			"audio_stream": flattenTranscoderJobTemplateConfigElementaryStreamsAudioStream(original["audioStream"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobTemplateConfigElementaryStreamsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStream(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["h264"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264(original["h264"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["width_pixels"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264WidthPixels(original["widthPixels"], d, config)
	transformed["height_pixels"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264HeightPixels(original["heightPixels"], d, config)
	transformed["frame_rate"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264FrameRate(original["frameRate"], d, config)
	transformed["bitrate_bps"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264BitrateBps(original["bitrateBps"], d, config)
	transformed["pixel_format"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264PixelFormat(original["pixelFormat"], d, config)
	transformed["rate_control_mode"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264RateControlMode(original["rateControlMode"], d, config)
	transformed["crf_level"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264CrfLevel(original["crfLevel"], d, config)
	transformed["vbv_size_bits"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264VbvSizeBits(original["vbvSizeBits"], d, config)
	transformed["vbv_fullness_bits"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264VbvFullnessBits(original["vbvFullnessBits"], d, config)
	transformed["entropy_coder"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264EntropyCoder(original["entropyCoder"], d, config)
	transformed["profile"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Profile(original["profile"], d, config)
	transformed["preset"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Preset(original["preset"], d, config)
	transformed["gop_duration"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264GopDuration(original["gopDuration"], d, config)
	transformed["sdr"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Sdr(original["sdr"], d, config)
	transformed["hlg"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Hlg(original["hlg"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264WidthPixels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264HeightPixels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264FrameRate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264BitrateBps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264PixelFormat(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264RateControlMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264CrfLevel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264VbvSizeBits(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264VbvFullnessBits(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264EntropyCoder(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Profile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Preset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264GopDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Sdr(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Hlg(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobTemplateConfigElementaryStreamsAudioStream(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["codec"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsAudioStreamCodec(original["codec"], d, config)
	transformed["bitrate_bps"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsAudioStreamBitrateBps(original["bitrateBps"], d, config)
	transformed["channel_count"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsAudioStreamChannelCount(original["channelCount"], d, config)
	transformed["channel_layout"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsAudioStreamChannelLayout(original["channelLayout"], d, config)
	transformed["sample_rate_hertz"] =
		flattenTranscoderJobTemplateConfigElementaryStreamsAudioStreamSampleRateHertz(original["sampleRateHertz"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigElementaryStreamsAudioStreamCodec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigElementaryStreamsAudioStreamBitrateBps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobTemplateConfigElementaryStreamsAudioStreamChannelCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobTemplateConfigElementaryStreamsAudioStreamChannelLayout(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigElementaryStreamsAudioStreamSampleRateHertz(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenTranscoderJobTemplateConfigMuxStreams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":                flattenTranscoderJobTemplateConfigMuxStreamsKey(original["key"], d, config),
			"file_name":          flattenTranscoderJobTemplateConfigMuxStreamsFileName(original["fileName"], d, config),
			"container":          flattenTranscoderJobTemplateConfigMuxStreamsContainer(original["container"], d, config),
			"elementary_streams": flattenTranscoderJobTemplateConfigMuxStreamsElementaryStreams(original["elementaryStreams"], d, config),
			"segment_settings":   flattenTranscoderJobTemplateConfigMuxStreamsSegmentSettings(original["segmentSettings"], d, config),
			"encryption_id":      flattenTranscoderJobTemplateConfigMuxStreamsEncryptionId(original["encryptionId"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobTemplateConfigMuxStreamsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigMuxStreamsFileName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigMuxStreamsContainer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigMuxStreamsElementaryStreams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigMuxStreamsSegmentSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["segment_duration"] =
		flattenTranscoderJobTemplateConfigMuxStreamsSegmentSettingsSegmentDuration(original["segmentDuration"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigMuxStreamsSegmentSettingsSegmentDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigMuxStreamsEncryptionId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigManifests(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"file_name":   flattenTranscoderJobTemplateConfigManifestsFileName(original["fileName"], d, config),
			"type":        flattenTranscoderJobTemplateConfigManifestsType(original["type"], d, config),
			"mux_streams": flattenTranscoderJobTemplateConfigManifestsMuxStreams(original["muxStreams"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobTemplateConfigManifestsFileName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigManifestsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigManifestsMuxStreams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigOutput(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenTranscoderJobTemplateConfigOutputUri(original["uri"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigOutputUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigAdBreaks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"start_time_offset": flattenTranscoderJobTemplateConfigAdBreaksStartTimeOffset(original["startTimeOffset"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobTemplateConfigAdBreaksStartTimeOffset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigPubsubDestination(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["topic"] =
		flattenTranscoderJobTemplateConfigPubsubDestinationTopic(original["topic"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigPubsubDestinationTopic(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigOverlays(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"image":      flattenTranscoderJobTemplateConfigOverlaysImage(original["image"], d, config),
			"animations": flattenTranscoderJobTemplateConfigOverlaysAnimations(original["animations"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobTemplateConfigOverlaysImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenTranscoderJobTemplateConfigOverlaysImageUri(original["uri"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigOverlaysImageUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigOverlaysAnimations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"animation_fade": flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFade(original["animationFade"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFade(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["xy"] =
		flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXy(original["xy"], d, config)
	transformed["start_time_offset"] =
		flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeStartTimeOffset(original["startTimeOffset"], d, config)
	transformed["end_time_offset"] =
		flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeEndTimeOffset(original["endTimeOffset"], d, config)
	transformed["fade_type"] =
		flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeFadeType(original["fadeType"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["x"] =
		flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXyX(original["x"], d, config)
	transformed["y"] =
		flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXyY(original["y"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXyX(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXyY(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeStartTimeOffset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeEndTimeOffset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeFadeType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigEncryptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"id":                        flattenTranscoderJobTemplateConfigEncryptionsId(original["id"], d, config),
			"drm_systems":               flattenTranscoderJobTemplateConfigEncryptionsDrmSystems(original["drmSystems"], d, config),
			"aes128":                    flattenTranscoderJobTemplateConfigEncryptionsAes128(original["aes128"], d, config),
			"sample_aes":                flattenTranscoderJobTemplateConfigEncryptionsSampleAes(original["sampleAes"], d, config),
			"mpeg_cenc":                 flattenTranscoderJobTemplateConfigEncryptionsMpegCenc(original["mpegCenc"], d, config),
			"secret_manager_key_source": flattenTranscoderJobTemplateConfigEncryptionsSecretManagerKeySource(original["secretManagerKeySource"], d, config),
		})
	}
	return transformed
}
func flattenTranscoderJobTemplateConfigEncryptionsId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigEncryptionsDrmSystems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["widevine"] =
		flattenTranscoderJobTemplateConfigEncryptionsDrmSystemsWidevine(original["widevine"], d, config)
	transformed["fairplay"] =
		flattenTranscoderJobTemplateConfigEncryptionsDrmSystemsFairplay(original["fairplay"], d, config)
	transformed["playready"] =
		flattenTranscoderJobTemplateConfigEncryptionsDrmSystemsPlayready(original["playready"], d, config)
	transformed["clearkey"] =
		flattenTranscoderJobTemplateConfigEncryptionsDrmSystemsClearkey(original["clearkey"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigEncryptionsDrmSystemsWidevine(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobTemplateConfigEncryptionsDrmSystemsFairplay(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobTemplateConfigEncryptionsDrmSystemsPlayready(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobTemplateConfigEncryptionsDrmSystemsClearkey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobTemplateConfigEncryptionsAes128(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobTemplateConfigEncryptionsSampleAes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenTranscoderJobTemplateConfigEncryptionsMpegCenc(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["scheme"] =
		flattenTranscoderJobTemplateConfigEncryptionsMpegCencScheme(original["scheme"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigEncryptionsMpegCencScheme(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateConfigEncryptionsSecretManagerKeySource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenTranscoderJobTemplateConfigEncryptionsSecretManagerKeySourceSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenTranscoderJobTemplateConfigEncryptionsSecretManagerKeySourceSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenTranscoderJobTemplateTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenTranscoderJobTemplateEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandTranscoderJobTemplateConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInputs, err := expandTranscoderJobTemplateConfigInputs(original["inputs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInputs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inputs"] = transformedInputs
	}

	transformedEditList, err := expandTranscoderJobTemplateConfigEditList(original["edit_list"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEditList); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["editList"] = transformedEditList
	}

	transformedElementaryStreams, err := expandTranscoderJobTemplateConfigElementaryStreams(original["elementary_streams"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedElementaryStreams); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["elementaryStreams"] = transformedElementaryStreams
	}

	transformedMuxStreams, err := expandTranscoderJobTemplateConfigMuxStreams(original["mux_streams"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMuxStreams); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["muxStreams"] = transformedMuxStreams
	}

	transformedManifests, err := expandTranscoderJobTemplateConfigManifests(original["manifests"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedManifests); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["manifests"] = transformedManifests
	}

	transformedOutput, err := expandTranscoderJobTemplateConfigOutput(original["output"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutput); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["output"] = transformedOutput
	}

	transformedAdBreaks, err := expandTranscoderJobTemplateConfigAdBreaks(original["ad_breaks"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdBreaks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["adBreaks"] = transformedAdBreaks
	}

	transformedPubsubDestination, err := expandTranscoderJobTemplateConfigPubsubDestination(original["pubsub_destination"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPubsubDestination); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pubsubDestination"] = transformedPubsubDestination
	}

	transformedOverlays, err := expandTranscoderJobTemplateConfigOverlays(original["overlays"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOverlays); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["overlays"] = transformedOverlays
	}

	transformedEncryptions, err := expandTranscoderJobTemplateConfigEncryptions(original["encryptions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEncryptions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["encryptions"] = transformedEncryptions
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigInputs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandTranscoderJobTemplateConfigInputsKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedUri, err := expandTranscoderJobTemplateConfigInputsUri(original["uri"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["uri"] = transformedUri
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobTemplateConfigInputsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigInputsUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigEditList(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandTranscoderJobTemplateConfigEditListKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedInputs, err := expandTranscoderJobTemplateConfigEditListInputs(original["inputs"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInputs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["inputs"] = transformedInputs
		}

		transformedStartTimeOffset, err := expandTranscoderJobTemplateConfigEditListStartTimeOffset(original["start_time_offset"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStartTimeOffset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["startTimeOffset"] = transformedStartTimeOffset
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobTemplateConfigEditListKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigEditListInputs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigEditListStartTimeOffset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandTranscoderJobTemplateConfigElementaryStreamsKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedVideoStream, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStream(original["video_stream"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVideoStream); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["videoStream"] = transformedVideoStream
		}

		transformedAudioStream, err := expandTranscoderJobTemplateConfigElementaryStreamsAudioStream(original["audio_stream"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAudioStream); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["audioStream"] = transformedAudioStream
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStream(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedH264, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264(original["h264"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedH264); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["h264"] = transformedH264
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedWidthPixels, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264WidthPixels(original["width_pixels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWidthPixels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["widthPixels"] = transformedWidthPixels
	}

	transformedHeightPixels, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264HeightPixels(original["height_pixels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHeightPixels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["heightPixels"] = transformedHeightPixels
	}

	transformedFrameRate, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264FrameRate(original["frame_rate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFrameRate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["frameRate"] = transformedFrameRate
	}

	transformedBitrateBps, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264BitrateBps(original["bitrate_bps"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBitrateBps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bitrateBps"] = transformedBitrateBps
	}

	transformedPixelFormat, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264PixelFormat(original["pixel_format"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPixelFormat); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pixelFormat"] = transformedPixelFormat
	}

	transformedRateControlMode, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264RateControlMode(original["rate_control_mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRateControlMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rateControlMode"] = transformedRateControlMode
	}

	transformedCrfLevel, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264CrfLevel(original["crf_level"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCrfLevel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["crfLevel"] = transformedCrfLevel
	}

	transformedVbvSizeBits, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264VbvSizeBits(original["vbv_size_bits"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVbvSizeBits); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vbvSizeBits"] = transformedVbvSizeBits
	}

	transformedVbvFullnessBits, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264VbvFullnessBits(original["vbv_fullness_bits"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVbvFullnessBits); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vbvFullnessBits"] = transformedVbvFullnessBits
	}

	transformedEntropyCoder, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264EntropyCoder(original["entropy_coder"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEntropyCoder); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["entropyCoder"] = transformedEntropyCoder
	}

	transformedProfile, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Profile(original["profile"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProfile); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["profile"] = transformedProfile
	}

	transformedPreset, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Preset(original["preset"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPreset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["preset"] = transformedPreset
	}

	transformedGopDuration, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264GopDuration(original["gop_duration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGopDuration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gopDuration"] = transformedGopDuration
	}

	transformedSdr, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Sdr(original["sdr"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["sdr"] = transformedSdr
	}

	transformedHlg, err := expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Hlg(original["hlg"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["hlg"] = transformedHlg
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264WidthPixels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264HeightPixels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264FrameRate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264BitrateBps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264PixelFormat(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264RateControlMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264CrfLevel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264VbvSizeBits(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264VbvFullnessBits(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264EntropyCoder(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Profile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Preset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264GopDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Sdr(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsVideoStreamH264Hlg(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsAudioStream(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCodec, err := expandTranscoderJobTemplateConfigElementaryStreamsAudioStreamCodec(original["codec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCodec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["codec"] = transformedCodec
	}

	transformedBitrateBps, err := expandTranscoderJobTemplateConfigElementaryStreamsAudioStreamBitrateBps(original["bitrate_bps"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBitrateBps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bitrateBps"] = transformedBitrateBps
	}

	transformedChannelCount, err := expandTranscoderJobTemplateConfigElementaryStreamsAudioStreamChannelCount(original["channel_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedChannelCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["channelCount"] = transformedChannelCount
	}

	transformedChannelLayout, err := expandTranscoderJobTemplateConfigElementaryStreamsAudioStreamChannelLayout(original["channel_layout"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedChannelLayout); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["channelLayout"] = transformedChannelLayout
	}

	transformedSampleRateHertz, err := expandTranscoderJobTemplateConfigElementaryStreamsAudioStreamSampleRateHertz(original["sample_rate_hertz"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSampleRateHertz); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sampleRateHertz"] = transformedSampleRateHertz
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsAudioStreamCodec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsAudioStreamBitrateBps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsAudioStreamChannelCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsAudioStreamChannelLayout(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigElementaryStreamsAudioStreamSampleRateHertz(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigMuxStreams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandTranscoderJobTemplateConfigMuxStreamsKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedFileName, err := expandTranscoderJobTemplateConfigMuxStreamsFileName(original["file_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFileName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["fileName"] = transformedFileName
		}

		transformedContainer, err := expandTranscoderJobTemplateConfigMuxStreamsContainer(original["container"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContainer); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["container"] = transformedContainer
		}

		transformedElementaryStreams, err := expandTranscoderJobTemplateConfigMuxStreamsElementaryStreams(original["elementary_streams"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedElementaryStreams); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["elementaryStreams"] = transformedElementaryStreams
		}

		transformedSegmentSettings, err := expandTranscoderJobTemplateConfigMuxStreamsSegmentSettings(original["segment_settings"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSegmentSettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["segmentSettings"] = transformedSegmentSettings
		}

		transformedEncryptionId, err := expandTranscoderJobTemplateConfigMuxStreamsEncryptionId(original["encryption_id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEncryptionId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["encryptionId"] = transformedEncryptionId
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobTemplateConfigMuxStreamsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigMuxStreamsFileName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigMuxStreamsContainer(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigMuxStreamsElementaryStreams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigMuxStreamsSegmentSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSegmentDuration, err := expandTranscoderJobTemplateConfigMuxStreamsSegmentSettingsSegmentDuration(original["segment_duration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSegmentDuration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["segmentDuration"] = transformedSegmentDuration
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigMuxStreamsSegmentSettingsSegmentDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigMuxStreamsEncryptionId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigManifests(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedFileName, err := expandTranscoderJobTemplateConfigManifestsFileName(original["file_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFileName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["fileName"] = transformedFileName
		}

		transformedType, err := expandTranscoderJobTemplateConfigManifestsType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedMuxStreams, err := expandTranscoderJobTemplateConfigManifestsMuxStreams(original["mux_streams"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMuxStreams); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["muxStreams"] = transformedMuxStreams
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobTemplateConfigManifestsFileName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigManifestsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigManifestsMuxStreams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigOutput(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandTranscoderJobTemplateConfigOutputUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigOutputUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigAdBreaks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedStartTimeOffset, err := expandTranscoderJobTemplateConfigAdBreaksStartTimeOffset(original["start_time_offset"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStartTimeOffset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["startTimeOffset"] = transformedStartTimeOffset
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobTemplateConfigAdBreaksStartTimeOffset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigPubsubDestination(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTopic, err := expandTranscoderJobTemplateConfigPubsubDestinationTopic(original["topic"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTopic); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["topic"] = transformedTopic
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigPubsubDestinationTopic(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigOverlays(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedImage, err := expandTranscoderJobTemplateConfigOverlaysImage(original["image"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedImage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["image"] = transformedImage
		}

		transformedAnimations, err := expandTranscoderJobTemplateConfigOverlaysAnimations(original["animations"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAnimations); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["animations"] = transformedAnimations
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobTemplateConfigOverlaysImage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUri, err := expandTranscoderJobTemplateConfigOverlaysImageUri(original["uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uri"] = transformedUri
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigOverlaysImageUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigOverlaysAnimations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAnimationFade, err := expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFade(original["animation_fade"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAnimationFade); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["animationFade"] = transformedAnimationFade
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFade(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedXy, err := expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXy(original["xy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedXy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["xy"] = transformedXy
	}

	transformedStartTimeOffset, err := expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeStartTimeOffset(original["start_time_offset"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStartTimeOffset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["startTimeOffset"] = transformedStartTimeOffset
	}

	transformedEndTimeOffset, err := expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeEndTimeOffset(original["end_time_offset"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEndTimeOffset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["endTimeOffset"] = transformedEndTimeOffset
	}

	transformedFadeType, err := expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeFadeType(original["fade_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFadeType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fadeType"] = transformedFadeType
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedX, err := expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXyX(original["x"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedX); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["x"] = transformedX
	}

	transformedY, err := expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXyY(original["y"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedY); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["y"] = transformedY
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXyX(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeXyY(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeStartTimeOffset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeEndTimeOffset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigOverlaysAnimationsAnimationFadeFadeType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigEncryptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedId, err := expandTranscoderJobTemplateConfigEncryptionsId(original["id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["id"] = transformedId
		}

		transformedDrmSystems, err := expandTranscoderJobTemplateConfigEncryptionsDrmSystems(original["drm_systems"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDrmSystems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["drmSystems"] = transformedDrmSystems
		}

		transformedAes128, err := expandTranscoderJobTemplateConfigEncryptionsAes128(original["aes128"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["aes128"] = transformedAes128
		}

		transformedSampleAes, err := expandTranscoderJobTemplateConfigEncryptionsSampleAes(original["sample_aes"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["sampleAes"] = transformedSampleAes
		}

		transformedMpegCenc, err := expandTranscoderJobTemplateConfigEncryptionsMpegCenc(original["mpeg_cenc"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMpegCenc); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["mpegCenc"] = transformedMpegCenc
		}

		transformedSecretManagerKeySource, err := expandTranscoderJobTemplateConfigEncryptionsSecretManagerKeySource(original["secret_manager_key_source"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSecretManagerKeySource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["secretManagerKeySource"] = transformedSecretManagerKeySource
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandTranscoderJobTemplateConfigEncryptionsId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigEncryptionsDrmSystems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedWidevine, err := expandTranscoderJobTemplateConfigEncryptionsDrmSystemsWidevine(original["widevine"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["widevine"] = transformedWidevine
	}

	transformedFairplay, err := expandTranscoderJobTemplateConfigEncryptionsDrmSystemsFairplay(original["fairplay"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["fairplay"] = transformedFairplay
	}

	transformedPlayready, err := expandTranscoderJobTemplateConfigEncryptionsDrmSystemsPlayready(original["playready"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["playready"] = transformedPlayready
	}

	transformedClearkey, err := expandTranscoderJobTemplateConfigEncryptionsDrmSystemsClearkey(original["clearkey"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["clearkey"] = transformedClearkey
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigEncryptionsDrmSystemsWidevine(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobTemplateConfigEncryptionsDrmSystemsFairplay(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobTemplateConfigEncryptionsDrmSystemsPlayready(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobTemplateConfigEncryptionsDrmSystemsClearkey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobTemplateConfigEncryptionsAes128(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobTemplateConfigEncryptionsSampleAes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandTranscoderJobTemplateConfigEncryptionsMpegCenc(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedScheme, err := expandTranscoderJobTemplateConfigEncryptionsMpegCencScheme(original["scheme"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScheme); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scheme"] = transformedScheme
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigEncryptionsMpegCencScheme(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateConfigEncryptionsSecretManagerKeySource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandTranscoderJobTemplateConfigEncryptionsSecretManagerKeySourceSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandTranscoderJobTemplateConfigEncryptionsSecretManagerKeySourceSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandTranscoderJobTemplateEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
