// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package workbench

import (
	"fmt"
	"log"
	"reflect"
	"sort"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

var WorkbenchInstanceProvidedLabels = []string{
	"consumer-project-id",
	"consumer-project-number",
	"notebooks-product",
	"resource-name",
}

func WorkbenchInstanceLabelsDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the labels
	for _, label := range WorkbenchInstanceProvidedLabels {
		if strings.Contains(k, label) && new == "" {
			return true
		}
	}

	// Let diff be determined by labels (above)
	if strings.Contains(k, "labels.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

var WorkbenchInstanceProvidedMetadata = []string{
	"disable-swap-binaries",
	"enable-guest-attributes",
	"proxy-backend-id",
	"proxy-registration-url",
	"agent-health-check-interval-seconds",
	"agent-health-check-path",
	"container",
	"data-disk-uri",
	"dataproc-allow-custom-clusters",
	"dataproc-cluster-name",
	"dataproc-configs",
	"dataproc-default-subnet",
	"dataproc-locations-list",
	"dataproc-machine-types-list",
	"dataproc-notebooks-url",
	"dataproc-region",
	"dataproc-service-account",
	"disable-check-xsrf",
	"framework",
	"gcs-data-bucket",
	"generate-diagnostics-bucket",
	"generate-diagnostics-file",
	"generate-diagnostics-options",
	"image-url",
	"install-monitoring-agent",
	"install-nvidia-driver",
	"installed-extensions",
	"notebooks-api",
	"notebooks-api-version",
	"notebooks-examples-location",
	"notebooks-location",
	"nvidia-driver-gcs-path",
	"proxy-mode",
	"proxy-status",
	"proxy-url",
	"proxy-user-mail",
	"report-container-health",
	"report-notebook-metrics",
	"report-system-health",
	"report-system-status",
	"restriction",
	"serial-port-logging-enable",
	"shutdown-script",
	"title",
	"use-collaborative",
	"version",
	"enable-oslogin",
}

func WorkbenchInstanceMetadataDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the Metadata
	for _, metadata := range WorkbenchInstanceProvidedMetadata {
		if strings.Contains(k, metadata) && new == "" {
			return true
		}
	}

	// Let diff be determined by metadata
	if strings.Contains(k, "gce_setup.0.metadata.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

var WorkbenchInstanceProvidedTags = []string{
	"deeplearning-vm",
	"notebook-instance",
}

func WorkbenchInstanceTagsDiffSuppress(_, _, _ string, d *schema.ResourceData) bool {
	old, new := d.GetChange("gce_setup.0.tags")
	oldValue := old.([]interface{})
	newValue := new.([]interface{})
	oldValueList := []string{}
	newValueList := []string{}

	for _, item := range oldValue {
		oldValueList = append(oldValueList, item.(string))
	}

	for _, item := range newValue {
		newValueList = append(newValueList, item.(string))
	}
	newValueList = append(newValueList, WorkbenchInstanceProvidedTags...)

	sort.Strings(oldValueList)
	sort.Strings(newValueList)
	if reflect.DeepEqual(oldValueList, newValueList) {
		return true
	}
	return false
}

// waitForWorkbenchInstanceActive waits for an workbench instance to become "ACTIVE"
func waitForWorkbenchInstanceActive(d *schema.ResourceData, config *transport_tpg.Config, timeout time.Duration) error {
	return resource.Retry(timeout, func() *resource.RetryError {
		if err := resourceWorkbenchInstanceRead(d, config); err != nil {
			return resource.NonRetryableError(err)
		}

		name := d.Get("name").(string)
		state := d.Get("state").(string)
		if state == "ACTIVE" {
			log.Printf("[DEBUG] Workbench Instance %q has state %q.", name, state)
			return nil
		} else {
			return resource.RetryableError(fmt.Errorf("Workbench Instance %q has state %q. Waiting for ACTIVE state", name, state))
		}

	})
}

func ResourceWorkbenchInstance() *schema.Resource {
	return &schema.Resource{
		Create: resourceWorkbenchInstanceCreate,
		Read:   resourceWorkbenchInstanceRead,
		Update: resourceWorkbenchInstanceUpdate,
		Delete: resourceWorkbenchInstanceDelete,

		Importer: &schema.ResourceImporter{
			State: resourceWorkbenchInstanceImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(10 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Part of 'parent'. See documentation of 'projectsId'.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of this workbench instance. Format: 'projects/{project_id}/locations/{location}/instances/{instance_id}'`,
			},
			"disable_proxy_access": {
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Description: `Optional. If true, the workbench instance will not register with the proxy.`,
			},
			"gce_setup": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `The definition of how to configure a VM instance outside of Resources and Identity.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"accelerator_configs": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `The hardware accelerators used on this instance. If you use accelerators, make sure that your configuration has
[enough vCPUs and memory to support the 'machine_type' you have selected](https://cloud.google.com/compute/docs/gpus/#gpus-list).
Currently supports only one accelerator configuration.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"core_count": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Optional. Count of cores of this accelerator.`,
									},
									"type": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"NVIDIA_TESLA_P100", "NVIDIA_TESLA_V100", "NVIDIA_TESLA_P4", "NVIDIA_TESLA_T4", "NVIDIA_TESLA_A100", "NVIDIA_A100_80GB", "NVIDIA_L4", "NVIDIA_TESLA_T4_VWS", "NVIDIA_TESLA_P100_VWS", "NVIDIA_TESLA_P4_VWS", ""}),
										Description:  `Optional. Type of this accelerator. Possible values: ["NVIDIA_TESLA_P100", "NVIDIA_TESLA_V100", "NVIDIA_TESLA_P4", "NVIDIA_TESLA_T4", "NVIDIA_TESLA_A100", "NVIDIA_A100_80GB", "NVIDIA_L4", "NVIDIA_TESLA_T4_VWS", "NVIDIA_TESLA_P100_VWS", "NVIDIA_TESLA_P4_VWS"]`,
									},
								},
							},
						},
						"boot_disk": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `The definition of a boot disk.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"disk_encryption": {
										Type:         schema.TypeString,
										Computed:     true,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"GMEK", "CMEK", ""}),
										Description: `Optional. Input only. Disk encryption method used on the boot and
data disks, defaults to GMEK. Possible values: ["GMEK", "CMEK"]`,
									},
									"disk_size_gb": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										ForceNew: true,
										Description: `Optional. The size of the boot disk in GB attached to this instance,
up to a maximum of 64000 GB (64 TB). If not specified, this defaults to the
recommended value of 150GB.`,
									},
									"disk_type": {
										Type:         schema.TypeString,
										Computed:     true,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"PD_STANDARD", "PD_SSD", "PD_BALANCED", "PD_EXTREME", ""}),
										Description:  `Optional. Indicates the type of the disk. Possible values: ["PD_STANDARD", "PD_SSD", "PD_BALANCED", "PD_EXTREME"]`,
									},
									"kms_key": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `'Optional. Input only. The KMS key used to encrypt the disks, only
applicable if disk_encryption is CMEK. Format: 'projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}'
Learn more about using your own encryption keys.'`,
									},
								},
							},
						},
						"data_disks": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Data disks attached to the VM instance. Currently supports only one data disk.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"disk_encryption": {
										Type:         schema.TypeString,
										Computed:     true,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"GMEK", "CMEK", ""}),
										Description: `Optional. Input only. Disk encryption method used on the boot
and data disks, defaults to GMEK. Possible values: ["GMEK", "CMEK"]`,
									},
									"disk_size_gb": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										ForceNew: true,
										Description: `Optional. The size of the disk in GB attached to this VM instance,
up to a maximum of 64000 GB (64 TB). If not specified, this defaults to
100.`,
									},
									"disk_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"PD_STANDARD", "PD_SSD", "PD_BALANCED", "PD_EXTREME", ""}),
										Description:  `Optional. Input only. Indicates the type of the disk. Possible values: ["PD_STANDARD", "PD_SSD", "PD_BALANCED", "PD_EXTREME"]`,
									},
									"kms_key": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `'Optional. Input only. The KMS key used to encrypt the disks,
only applicable if disk_encryption is CMEK. Format: 'projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}'
Learn more about using your own encryption keys.'`,
									},
								},
							},
						},
						"disable_public_ip": {
							Type:        schema.TypeBool,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. If true, no external IP will be assigned to this VM instance.`,
						},
						"enable_ip_forwarding": {
							Type:     schema.TypeBool,
							Optional: true,
							ForceNew: true,
							Description: `Optional. Flag to enable ip forwarding or not, default false/off.
https://cloud.google.com/vpc/docs/using-routes#canipforward`,
						},
						"machine_type": {
							Type:             schema.TypeString,
							Computed:         true,
							Optional:         true,
							DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
							Description:      `Optional. The machine type of the VM instance. https://cloud.google.com/compute/docs/machine-resource`,
						},
						"metadata": {
							Type:             schema.TypeMap,
							Computed:         true,
							Optional:         true,
							DiffSuppressFunc: WorkbenchInstanceMetadataDiffSuppress,
							Description:      `Optional. Custom metadata to apply to this instance.`,
							Elem:             &schema.Schema{Type: schema.TypeString},
						},
						"network_interfaces": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `The network interfaces for the VM. Supports only one interface.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"network": {
										Type:             schema.TypeString,
										Computed:         true,
										Optional:         true,
										ForceNew:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkRelativePaths,
										Description:      `Optional. The name of the VPC that this VM instance is in.`,
									},
									"nic_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"VIRTIO_NET", "GVNIC", ""}),
										Description: `Optional. The type of vNIC to be used on this interface. This
may be gVNIC or VirtioNet. Possible values: ["VIRTIO_NET", "GVNIC"]`,
									},
									"subnet": {
										Type:             schema.TypeString,
										Computed:         true,
										Optional:         true,
										ForceNew:         true,
										DiffSuppressFunc: tpgresource.CompareSelfLinkRelativePaths,
										Description:      `Optional. The name of the subnet that this VM instance is in.`,
									},
								},
							},
						},
						"service_accounts": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `The service account that serves as an identity for the VM instance. Currently supports only one service account.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"email": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										ForceNew:    true,
										Description: `Optional. Email address of the service account.`,
									},
									"scopes": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Output only. The list of scopes to be made available for this
service account. Set by the CLH to https://www.googleapis.com/auth/cloud-platform`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"tags": {
							Type:             schema.TypeList,
							Computed:         true,
							Optional:         true,
							ForceNew:         true,
							DiffSuppressFunc: WorkbenchInstanceTagsDiffSuppress,
							Description: `Optional. The Compute Engine tags to add to instance (see [Tagging
instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"vm_image": {
							Type:     schema.TypeList,
							Computed: true,
							Optional: true,
							ForceNew: true,
							Description: `Definition of a custom Compute Engine virtual machine image for starting
a workbench instance with the environment installed directly on the VM.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"family": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `Optional. Use this VM image family to find the image; the newest
image in this family will be used.`,
										ExactlyOneOf: []string{},
									},
									"name": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										Description:  `Optional. Use VM image name to find the image.`,
										ExactlyOneOf: []string{},
									},
									"project": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `The name of the Google Cloud project that this VM image belongs to.
Format: {project_id}`,
									},
								},
							},
						},
					},
				},
			},
			"instance_id": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `Required. User-defined unique ID of this instance.`,
			},
			"instance_owners": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				Description: `'Optional. Input only. The owner of this instance after creation. Format:
'alias@example.com' Currently supports one owner only. If not specified, all of
the service account users of your VM instance''s service account can use the instance.'`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"labels": {
				Type:             schema.TypeMap,
				Optional:         true,
				DiffSuppressFunc: WorkbenchInstanceLabelsDiffSuppress,
				Description: `Optional. Labels to apply to this instance. These can be later modified
by the UpdateInstance method.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"create_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `An RFC3339 timestamp in UTC time. This in the format of yyyy-MM-ddTHH:mm:ss.SSSZ.
The milliseconds portion (".SSS") is optional.`,
			},
			"creator": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Email address of entity that sent original CreateInstance request.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"health_info": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `'Output only. Additional information about instance health. Example:
healthInfo": { "docker_proxy_agent_status": "1", "docker_status": "1", "jupyterlab_api_status":
"-1", "jupyterlab_status": "-1", "updated": "2020-10-18 09:40:03.573409" }'`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{},
				},
			},
			"health_state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Instance health_state.`,
			},
			"proxy_uri": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The proxy endpoint that is used to access the Jupyter notebook.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The state of this instance.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `An RFC3339 timestamp in UTC time. This in the format of yyyy-MM-ddTHH:mm:ss.SSSZ.
The milliseconds portion (".SSS") is optional.`,
			},
			"upgrade_history": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. The upgrade history of this instance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"action": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Optional. Action. Rolloback or Upgrade.`,
						},
						"container_image": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Optional. The container image before this instance upgrade.`,
						},
						"create_time": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `An RFC3339 timestamp in UTC time. This in the format of yyyy-MM-ddTHH:mm:ss.SSSZ.
The milliseconds portion (".SSS") is optional.`,
						},
						"framework": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Optional. The framework of this workbench instance.`,
						},
						"snapshot": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Optional. The snapshot of the boot disk of this workbench instance before upgrade.`,
						},
						"target_version": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Optional. Target VM Version, like m63.`,
						},
						"version": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Optional. The version of the workbench instance before this upgrade.`,
						},
						"vm_image": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Optional. The VM image before this instance upgrade.`,
						},
						"state": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. The state of this instance upgrade history entry.`,
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceWorkbenchInstanceCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	gceSetupProp, err := expandWorkbenchInstanceGceSetup(d.Get("gce_setup"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("gce_setup"); !tpgresource.IsEmptyValue(reflect.ValueOf(gceSetupProp)) && (ok || !reflect.DeepEqual(v, gceSetupProp)) {
		obj["gceSetup"] = gceSetupProp
	}
	instanceOwnersProp, err := expandWorkbenchInstanceInstanceOwners(d.Get("instance_owners"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("instance_owners"); !tpgresource.IsEmptyValue(reflect.ValueOf(instanceOwnersProp)) && (ok || !reflect.DeepEqual(v, instanceOwnersProp)) {
		obj["instanceOwners"] = instanceOwnersProp
	}
	disableProxyAccessProp, err := expandWorkbenchInstanceDisableProxyAccess(d.Get("disable_proxy_access"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("disable_proxy_access"); !tpgresource.IsEmptyValue(reflect.ValueOf(disableProxyAccessProp)) && (ok || !reflect.DeepEqual(v, disableProxyAccessProp)) {
		obj["disableProxyAccess"] = disableProxyAccessProp
	}
	labelsProp, err := expandWorkbenchInstanceEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{WorkbenchBasePath}}projects/{{project}}/locations/{{location}}/instances?instanceId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Instance: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating Instance: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = WorkbenchOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating Instance", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create Instance: %s", err)
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	if err := waitForWorkbenchInstanceActive(d, config, d.Timeout(schema.TimeoutCreate)-time.Minute); err != nil {
		return fmt.Errorf("Workbench instance %q did not reach ACTIVE state: %q", d.Get("name").(string), err)
	}

	log.Printf("[DEBUG] Finished creating Instance %q: %#v", d.Id(), res)

	return resourceWorkbenchInstanceRead(d, meta)
}

func resourceWorkbenchInstanceRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{WorkbenchBasePath}}projects/{{project}}/locations/{{location}}/instances/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("WorkbenchInstance %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}

	if err := d.Set("gce_setup", flattenWorkbenchInstanceGceSetup(res["gceSetup"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("proxy_uri", flattenWorkbenchInstanceProxyUri(res["proxyUri"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("creator", flattenWorkbenchInstanceCreator(res["creator"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("state", flattenWorkbenchInstanceState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("upgrade_history", flattenWorkbenchInstanceUpgradeHistory(res["upgradeHistory"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("health_state", flattenWorkbenchInstanceHealthState(res["healthState"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("health_info", flattenWorkbenchInstanceHealthInfo(res["healthInfo"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("create_time", flattenWorkbenchInstanceCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("update_time", flattenWorkbenchInstanceUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("disable_proxy_access", flattenWorkbenchInstanceDisableProxyAccess(res["disableProxyAccess"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("labels", flattenWorkbenchInstanceLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("terraform_labels", flattenWorkbenchInstanceTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("effective_labels", flattenWorkbenchInstanceEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}

	return nil
}

func resourceWorkbenchInstanceUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	gceSetupProp, err := expandWorkbenchInstanceGceSetup(d.Get("gce_setup"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("gce_setup"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, gceSetupProp)) {
		obj["gceSetup"] = gceSetupProp
	}
	labelsProp, err := expandWorkbenchInstanceEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{WorkbenchBasePath}}projects/{{project}}/locations/{{location}}/instances/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Instance %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("gce_setup") {
		updateMask = append(updateMask, "gceSetup")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}
	name := d.Get("name").(string)
	if d.HasChange("gce_setup.0.machine_type") || d.HasChange("gce_setup.0.accelerator_configs") {
		state := d.Get("state").(string)
		if state != "STOPPED" {
			stopURL, err := tpgresource.ReplaceVars(d, config, "{{WorkbenchBasePath}}projects/{{project}}/locations/{{location}}/instances/{{name}}:stop")
			if err != nil {
				return err
			}

			log.Printf("[DEBUG] Stopping Workbench Instance: %q", name)

			emptyReqBody := make(map[string]interface{})

			dRes, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
				Config:    config,
				Method:    "POST",
				Project:   billingProject,
				RawURL:    stopURL,
				UserAgent: userAgent,
				Body:      emptyReqBody,
			})
			if err != nil {
				return fmt.Errorf("Error Stopping Workbench Instance: %s", err)
			}

			var opRes map[string]interface{}
			err = WorkbenchOperationWaitTimeWithResponse(
				config, dRes, &opRes, project, "Stopping Workbench Instance", userAgent,
				d.Timeout(schema.TimeoutUpdate))
			if err != nil {
				return fmt.Errorf("Error waiting to stop Workbench Instance: %s", err)
			}

		} else {
			log.Printf("[DEBUG] Workbench Instance %q has state %q.", name, state)
		}

	} else {
		log.Printf("[DEBUG] Workbench Instance %q need not be stopped for the update.", name)
	}

	// Build custom mask since the notebooks API does not support gce_setup as a valid mask
	newUpdateMask := []string{}
	if d.HasChange("gce_setup.0.machine_type") {
		newUpdateMask = append(newUpdateMask, "gce_setup.machine_type")
	}
	if d.HasChange("gce_setup.0.accelerator_configs") {
		newUpdateMask = append(newUpdateMask, "gce_setup.accelerator_configs")
	}
	if d.HasChange("gce_setup.0.metadata") {
		newUpdateMask = append(newUpdateMask, "gceSetup.metadata")
	}
	if d.HasChange("effective_labels") {
		newUpdateMask = append(newUpdateMask, "labels")
	}

	// Overwrite the previously set mask.
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(newUpdateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
		})

		if err != nil {
			return fmt.Errorf("Error updating Instance %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Instance %q: %#v", d.Id(), res)
		}

		err = WorkbenchOperationWaitTime(
			config, res, project, "Updating Instance", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	state := d.Get("state").(string)

	if state != "ACTIVE" {
		startURL, err := tpgresource.ReplaceVars(d, config, "{{WorkbenchBasePath}}projects/{{project}}/locations/{{location}}/instances/{{name}}:start")
		if err != nil {
			return err
		}

		log.Printf("[DEBUG] Starting Workbench Instance: %q", name)

		emptyReqBody := make(map[string]interface{})

		pRes, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "POST",
			Project:   billingProject,
			RawURL:    startURL,
			UserAgent: userAgent,
			Body:      emptyReqBody,
		})
		if err != nil {
			return fmt.Errorf("Error Starting Workbench Instance: %s", err)
		}

		var opResp map[string]interface{}
		err = WorkbenchOperationWaitTimeWithResponse(
			config, pRes, &opResp, project, "Starting Workbench Instance", userAgent,
			d.Timeout(schema.TimeoutUpdate))
		if err != nil {
			return fmt.Errorf("Error waiting to start Workbench Instance: %s", err)
		}

	} else {
		log.Printf("[DEBUG] Workbench Instance %q has state %q.", name, state)
	}
	return resourceWorkbenchInstanceRead(d, meta)
}

func resourceWorkbenchInstanceDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{WorkbenchBasePath}}projects/{{project}}/locations/{{location}}/instances/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting Instance %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Instance")
	}

	err = WorkbenchOperationWaitTime(
		config, res, project, "Deleting Instance", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Instance %q: %#v", d.Id(), res)
	return nil
}

func resourceWorkbenchInstanceImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/instances/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenWorkbenchInstanceGceSetup(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["machine_type"] =
		flattenWorkbenchInstanceGceSetupMachineType(original["machineType"], d, config)
	transformed["accelerator_configs"] =
		flattenWorkbenchInstanceGceSetupAcceleratorConfigs(original["acceleratorConfigs"], d, config)
	transformed["service_accounts"] =
		flattenWorkbenchInstanceGceSetupServiceAccounts(original["serviceAccounts"], d, config)
	transformed["vm_image"] =
		flattenWorkbenchInstanceGceSetupVmImage(original["vmImage"], d, config)
	transformed["boot_disk"] =
		flattenWorkbenchInstanceGceSetupBootDisk(original["bootDisk"], d, config)
	transformed["data_disks"] =
		flattenWorkbenchInstanceGceSetupDataDisks(original["dataDisks"], d, config)
	transformed["network_interfaces"] =
		flattenWorkbenchInstanceGceSetupNetworkInterfaces(original["networkInterfaces"], d, config)
	transformed["disable_public_ip"] =
		flattenWorkbenchInstanceGceSetupDisablePublicIp(original["disablePublicIp"], d, config)
	transformed["tags"] =
		flattenWorkbenchInstanceGceSetupTags(original["tags"], d, config)
	transformed["metadata"] =
		flattenWorkbenchInstanceGceSetupMetadata(original["metadata"], d, config)
	transformed["enable_ip_forwarding"] =
		flattenWorkbenchInstanceGceSetupEnableIpForwarding(original["enableIpForwarding"], d, config)
	return []interface{}{transformed}
}
func flattenWorkbenchInstanceGceSetupMachineType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.NameFromSelfLinkStateFunc(v)
}

func flattenWorkbenchInstanceGceSetupAcceleratorConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":       flattenWorkbenchInstanceGceSetupAcceleratorConfigsType(original["type"], d, config),
			"core_count": flattenWorkbenchInstanceGceSetupAcceleratorConfigsCoreCount(original["coreCount"], d, config),
		})
	}
	return transformed
}
func flattenWorkbenchInstanceGceSetupAcceleratorConfigsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupAcceleratorConfigsCoreCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupServiceAccounts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"email":  flattenWorkbenchInstanceGceSetupServiceAccountsEmail(original["email"], d, config),
			"scopes": flattenWorkbenchInstanceGceSetupServiceAccountsScopes(original["scopes"], d, config),
		})
	}
	return transformed
}
func flattenWorkbenchInstanceGceSetupServiceAccountsEmail(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupServiceAccountsScopes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupVmImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("gce_setup.0.vm_image")
}

func flattenWorkbenchInstanceGceSetupBootDisk(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disk_size_gb"] =
		flattenWorkbenchInstanceGceSetupBootDiskDiskSizeGb(original["diskSizeGb"], d, config)
	transformed["disk_type"] =
		flattenWorkbenchInstanceGceSetupBootDiskDiskType(original["diskType"], d, config)
	transformed["disk_encryption"] =
		flattenWorkbenchInstanceGceSetupBootDiskDiskEncryption(original["diskEncryption"], d, config)
	transformed["kms_key"] =
		flattenWorkbenchInstanceGceSetupBootDiskKmsKey(original["kmsKey"], d, config)
	return []interface{}{transformed}
}
func flattenWorkbenchInstanceGceSetupBootDiskDiskSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupBootDiskDiskType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("gce_setup.0.boot_disk.0.disk_type")
}

func flattenWorkbenchInstanceGceSetupBootDiskDiskEncryption(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("gce_setup.0.boot_disk.0.disk_encryption")
}

func flattenWorkbenchInstanceGceSetupBootDiskKmsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("gce_setup.0.boot_disk.0.kms_key")
}

func flattenWorkbenchInstanceGceSetupDataDisks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"disk_size_gb":    flattenWorkbenchInstanceGceSetupDataDisksDiskSizeGb(original["diskSizeGb"], d, config),
			"disk_type":       flattenWorkbenchInstanceGceSetupDataDisksDiskType(original["diskType"], d, config),
			"disk_encryption": flattenWorkbenchInstanceGceSetupDataDisksDiskEncryption(original["diskEncryption"], d, config),
			"kms_key":         flattenWorkbenchInstanceGceSetupDataDisksKmsKey(original["kmsKey"], d, config),
		})
	}
	return transformed
}
func flattenWorkbenchInstanceGceSetupDataDisksDiskSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupDataDisksDiskType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("gce_setup.0.data_disks.0.disk_type")
}

func flattenWorkbenchInstanceGceSetupDataDisksDiskEncryption(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("gce_setup.0.data_disks.0.disk_encryption")
}

func flattenWorkbenchInstanceGceSetupDataDisksKmsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("gce_setup.0.data_disks.0.kms_key")
}

func flattenWorkbenchInstanceGceSetupNetworkInterfaces(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"network":  flattenWorkbenchInstanceGceSetupNetworkInterfacesNetwork(original["network"], d, config),
			"subnet":   flattenWorkbenchInstanceGceSetupNetworkInterfacesSubnet(original["subnet"], d, config),
			"nic_type": flattenWorkbenchInstanceGceSetupNetworkInterfacesNicType(original["nicType"], d, config),
		})
	}
	return transformed
}
func flattenWorkbenchInstanceGceSetupNetworkInterfacesNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupNetworkInterfacesSubnet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupNetworkInterfacesNicType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupDisablePublicIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupTags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupMetadata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceGceSetupEnableIpForwarding(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceProxyUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceCreator(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceUpgradeHistory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"snapshot":        flattenWorkbenchInstanceUpgradeHistorySnapshot(original["snapshot"], d, config),
			"vm_image":        flattenWorkbenchInstanceUpgradeHistoryVmImage(original["vmImage"], d, config),
			"container_image": flattenWorkbenchInstanceUpgradeHistoryContainerImage(original["containerImage"], d, config),
			"framework":       flattenWorkbenchInstanceUpgradeHistoryFramework(original["framework"], d, config),
			"version":         flattenWorkbenchInstanceUpgradeHistoryVersion(original["version"], d, config),
			"state":           flattenWorkbenchInstanceUpgradeHistoryState(original["state"], d, config),
			"create_time":     flattenWorkbenchInstanceUpgradeHistoryCreateTime(original["createTime"], d, config),
			"action":          flattenWorkbenchInstanceUpgradeHistoryAction(original["action"], d, config),
			"target_version":  flattenWorkbenchInstanceUpgradeHistoryTargetVersion(original["targetVersion"], d, config),
		})
	}
	return transformed
}
func flattenWorkbenchInstanceUpgradeHistorySnapshot(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceUpgradeHistoryVmImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceUpgradeHistoryContainerImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceUpgradeHistoryFramework(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceUpgradeHistoryVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceUpgradeHistoryState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceUpgradeHistoryCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceUpgradeHistoryAction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceUpgradeHistoryTargetVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceHealthState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceHealthInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenWorkbenchInstanceCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceDisableProxyAccess(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenWorkbenchInstanceLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenWorkbenchInstanceTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenWorkbenchInstanceEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandWorkbenchInstanceGceSetup(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMachineType, err := expandWorkbenchInstanceGceSetupMachineType(original["machine_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMachineType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["machineType"] = transformedMachineType
	}

	transformedAcceleratorConfigs, err := expandWorkbenchInstanceGceSetupAcceleratorConfigs(original["accelerator_configs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAcceleratorConfigs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["acceleratorConfigs"] = transformedAcceleratorConfigs
	}

	transformedServiceAccounts, err := expandWorkbenchInstanceGceSetupServiceAccounts(original["service_accounts"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccounts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccounts"] = transformedServiceAccounts
	}

	transformedVmImage, err := expandWorkbenchInstanceGceSetupVmImage(original["vm_image"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVmImage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vmImage"] = transformedVmImage
	}

	transformedBootDisk, err := expandWorkbenchInstanceGceSetupBootDisk(original["boot_disk"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBootDisk); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bootDisk"] = transformedBootDisk
	}

	transformedDataDisks, err := expandWorkbenchInstanceGceSetupDataDisks(original["data_disks"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataDisks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataDisks"] = transformedDataDisks
	}

	transformedNetworkInterfaces, err := expandWorkbenchInstanceGceSetupNetworkInterfaces(original["network_interfaces"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetworkInterfaces); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["networkInterfaces"] = transformedNetworkInterfaces
	}

	transformedDisablePublicIp, err := expandWorkbenchInstanceGceSetupDisablePublicIp(original["disable_public_ip"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisablePublicIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disablePublicIp"] = transformedDisablePublicIp
	}

	transformedTags, err := expandWorkbenchInstanceGceSetupTags(original["tags"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTags); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tags"] = transformedTags
	}

	transformedMetadata, err := expandWorkbenchInstanceGceSetupMetadata(original["metadata"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMetadata); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["metadata"] = transformedMetadata
	}

	transformedEnableIpForwarding, err := expandWorkbenchInstanceGceSetupEnableIpForwarding(original["enable_ip_forwarding"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableIpForwarding); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableIpForwarding"] = transformedEnableIpForwarding
	}

	return transformed, nil
}

func expandWorkbenchInstanceGceSetupMachineType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupAcceleratorConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandWorkbenchInstanceGceSetupAcceleratorConfigsType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedCoreCount, err := expandWorkbenchInstanceGceSetupAcceleratorConfigsCoreCount(original["core_count"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCoreCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["coreCount"] = transformedCoreCount
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandWorkbenchInstanceGceSetupAcceleratorConfigsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupAcceleratorConfigsCoreCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupServiceAccounts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedEmail, err := expandWorkbenchInstanceGceSetupServiceAccountsEmail(original["email"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEmail); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["email"] = transformedEmail
		}

		transformedScopes, err := expandWorkbenchInstanceGceSetupServiceAccountsScopes(original["scopes"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedScopes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["scopes"] = transformedScopes
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandWorkbenchInstanceGceSetupServiceAccountsEmail(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupServiceAccountsScopes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupVmImage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProject, err := expandWorkbenchInstanceGceSetupVmImageProject(original["project"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["project"] = transformedProject
	}

	transformedName, err := expandWorkbenchInstanceGceSetupVmImageName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedFamily, err := expandWorkbenchInstanceGceSetupVmImageFamily(original["family"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFamily); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["family"] = transformedFamily
	}

	return transformed, nil
}

func expandWorkbenchInstanceGceSetupVmImageProject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupVmImageName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupVmImageFamily(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupBootDisk(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDiskSizeGb, err := expandWorkbenchInstanceGceSetupBootDiskDiskSizeGb(original["disk_size_gb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDiskSizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["diskSizeGb"] = transformedDiskSizeGb
	}

	transformedDiskType, err := expandWorkbenchInstanceGceSetupBootDiskDiskType(original["disk_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDiskType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["diskType"] = transformedDiskType
	}

	transformedDiskEncryption, err := expandWorkbenchInstanceGceSetupBootDiskDiskEncryption(original["disk_encryption"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDiskEncryption); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["diskEncryption"] = transformedDiskEncryption
	}

	transformedKmsKey, err := expandWorkbenchInstanceGceSetupBootDiskKmsKey(original["kms_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKey"] = transformedKmsKey
	}

	return transformed, nil
}

func expandWorkbenchInstanceGceSetupBootDiskDiskSizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupBootDiskDiskType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupBootDiskDiskEncryption(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupBootDiskKmsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupDataDisks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDiskSizeGb, err := expandWorkbenchInstanceGceSetupDataDisksDiskSizeGb(original["disk_size_gb"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDiskSizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["diskSizeGb"] = transformedDiskSizeGb
		}

		transformedDiskType, err := expandWorkbenchInstanceGceSetupDataDisksDiskType(original["disk_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDiskType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["diskType"] = transformedDiskType
		}

		transformedDiskEncryption, err := expandWorkbenchInstanceGceSetupDataDisksDiskEncryption(original["disk_encryption"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDiskEncryption); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["diskEncryption"] = transformedDiskEncryption
		}

		transformedKmsKey, err := expandWorkbenchInstanceGceSetupDataDisksKmsKey(original["kms_key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKmsKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["kmsKey"] = transformedKmsKey
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandWorkbenchInstanceGceSetupDataDisksDiskSizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupDataDisksDiskType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupDataDisksDiskEncryption(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupDataDisksKmsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupNetworkInterfaces(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedNetwork, err := expandWorkbenchInstanceGceSetupNetworkInterfacesNetwork(original["network"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["network"] = transformedNetwork
		}

		transformedSubnet, err := expandWorkbenchInstanceGceSetupNetworkInterfacesSubnet(original["subnet"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSubnet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["subnet"] = transformedSubnet
		}

		transformedNicType, err := expandWorkbenchInstanceGceSetupNetworkInterfacesNicType(original["nic_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNicType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["nicType"] = transformedNicType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandWorkbenchInstanceGceSetupNetworkInterfacesNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil || v.(string) == "" {
		return "", nil
	} else if strings.HasPrefix(v.(string), "https://") {
		return v, nil
	}
	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}"+v.(string))
	if err != nil {
		return "", err
	}
	return tpgresource.ConvertSelfLinkToV1(url), nil
}

func expandWorkbenchInstanceGceSetupNetworkInterfacesSubnet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupNetworkInterfacesNicType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupDisablePublicIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupTags(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceGceSetupMetadata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandWorkbenchInstanceGceSetupEnableIpForwarding(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceInstanceOwners(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceDisableProxyAccess(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandWorkbenchInstanceEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
