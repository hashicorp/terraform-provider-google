// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/compute/Reservation.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package compute

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

import "net/url"

var _ = url.Parse

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceComputeReservation() *schema.Resource {
	return &schema.Resource{
		Create: resourceComputeReservationCreate,
		Read:   resourceComputeReservationRead,
		Update: resourceComputeReservationUpdate,
		Delete: resourceComputeReservationDelete,

		Importer: &schema.ResourceImporter{
			State: resourceComputeReservationImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"zone": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Name of the resource. Provided by the client when the resource is
created. The name must be 1-63 characters long, and comply with
RFC1035. Specifically, the name must be 1-63 characters long and match
the regular expression '[a-z]([-a-z0-9]*[a-z0-9])?' which means the
first character must be a lowercase letter, and all following
characters must be a dash, lowercase letter, or digit, except the last
character, which cannot be a dash.`,
			},
			"specific_reservation": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `Reservation for instances with specific machine shapes.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"count": {
							Type:         schema.TypeInt,
							Required:     true,
							ValidateFunc: validation.IntAtLeast(1),
							Description:  `The number of resources that are allocated.`,
						},
						"instance_properties": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `The instance properties for the reservation.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"machine_type": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `The name of the machine type to reserve.`,
									},
									"guest_accelerators": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Guest accelerator type and count.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"accelerator_count": {
													Type:     schema.TypeInt,
													Required: true,
													ForceNew: true,
													Description: `The number of the guest accelerator cards exposed to
this instance.`,
												},
												"accelerator_type": {
													Type:     schema.TypeString,
													Required: true,
													ForceNew: true,
													Description: `The full or partial URL of the accelerator type to
attach to this instance. For example:
'projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100'

If you are creating an instance template, specify only the accelerator name.`,
												},
											},
										},
									},
									"local_ssds": {
										Type:     schema.TypeList,
										Optional: true,
										ForceNew: true,
										Description: `The amount of local ssd to reserve with each instance. This
reserves disks of type 'local-ssd'.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"disk_size_gb": {
													Type:        schema.TypeInt,
													Required:    true,
													ForceNew:    true,
													Description: `The size of the disk in base-2 GB.`,
												},
												"interface": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"SCSI", "NVME", ""}),
													Description:  `The disk interface to use for attaching this disk. Default value: "SCSI" Possible values: ["SCSI", "NVME"]`,
													Default:      "SCSI",
												},
											},
										},
									},
									"min_cpu_platform": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										ForceNew: true,
										Description: `The minimum CPU platform for the reservation. For example,
'"Intel Skylake"'. See
the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
for information on available CPU platforms.`,
									},
									"location_hint": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.`,
									},
								},
							},
							ExactlyOneOf: []string{"specific_reservation.0.instance_properties", "specific_reservation.0.source_instance_template"},
						},
						"source_instance_template": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `Specifies the instance template to create the reservation. If you use this field, you must exclude the
instanceProperties field.`,
							ExactlyOneOf: []string{"specific_reservation.0.instance_properties", "specific_reservation.0.source_instance_template"},
						},
						"assured_count": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `Indicates how many instances are actually usable currently.`,
						},
						"in_use_count": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `How many instances are in use.`,
						},
					},
				},
			},
			"zone": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description:      `The zone where the reservation is made.`,
			},
			"delete_after_duration": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Duration after which the reservation will be auto-deleted by Compute Engine. Cannot be used with delete_at_time.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"nanos": {
							Type:          schema.TypeInt,
							Optional:      true,
							ForceNew:      true,
							Description:   `Number of nanoseconds for the auto-delete duration.`,
							ConflictsWith: []string{"delete_at_time"},
						},
						"seconds": {
							Type:          schema.TypeString,
							Optional:      true,
							ForceNew:      true,
							Description:   `Number of seconds for the auto-delete duration.`,
							ConflictsWith: []string{"delete_at_time"},
						},
					},
				},
			},
			"delete_at_time": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				ForceNew: true,
				Description: `Absolute time in future when the reservation will be auto-deleted by Compute Engine. Timestamp is represented in RFC3339 text format.
Cannot be used with delete_after_duration.`,
				ConflictsWith: []string{"delete_after_duration.0.nanos", "delete_after_duration.0.seconds"},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `An optional description of this resource.`,
			},
			"reservation_sharing_policy": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Sharing policy for reservations with Google Cloud managed services.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"service_share_type": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"ALLOW_ALL", "DISALLOW_ALL", ""}),
							Description:  `Sharing config for all Google Cloud services. Possible values: ["ALLOW_ALL", "DISALLOW_ALL"]`,
						},
					},
				},
			},
			"share_settings": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `The share setting for reservations.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"project_map": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: `A map of project number and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:     schema.TypeString,
										Required: true,
									},
									"project_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The project id/number, should be same as the key of this project config in the project map.`,
									},
								},
							},
						},
						"share_type": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"LOCAL", "SPECIFIC_PROJECTS", ""}),
							Description:  `Type of sharing for this shared-reservation Possible values: ["LOCAL", "SPECIFIC_PROJECTS"]`,
						},
					},
				},
			},
			"specific_reservation_required": {
				Type:     schema.TypeBool,
				Optional: true,
				ForceNew: true,
				Description: `When set to true, only VMs that target this reservation by name can
consume this reservation. Otherwise, it can be consumed by VMs with
affinity for any reservation. Defaults to false.`,
				Default: false,
			},
			"commitment": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Full or partial URL to a parent commitment. This field displays for
reservations that are tied to a commitment.`,
			},
			"creation_timestamp": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Creation timestamp in RFC3339 text format.`,
			},
			"id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The unique identifier for the resource. This identifier is defined by the server.`,
			},
			"kind": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Type of the resource. Always compute#reservations for reservations.`,
			},
			"linked_commitments": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Full or partial URL to parent commitments. This field displays for reservations that are tied to multiple commitments.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"reservation_block_count": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The number of reservation blocks associated with this reservation.`,
			},
			"resource_status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Status information for Reservation resource.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"health_info": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Health information for the reservation.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"degraded_block_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `The number of reservation blocks that are degraded.`,
									},
									"health_status": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The health status of the reservation.`,
									},
									"healthy_block_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `The number of reservation blocks that are healthy.`,
									},
								},
							},
						},
						"reservation_block_count": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The number of reservation blocks associated with this reservation.`,
						},
						"reservation_maintenance": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Maintenance information for this reservation`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"instance_maintenance_ongoing_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Describes number of instances that have ongoing maintenance.`,
									},
									"instance_maintenance_pending_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Describes number of instances that have pending maintenance.`,
									},
									"maintenance_ongoing_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Progress for ongoing maintenance for this group of VMs/hosts. Describes number of hosts in the block that have ongoing maintenance.`,
									},
									"maintenance_pending_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Progress for ongoing maintenance for this group of VMs/hosts. Describes number of hosts in the block that have pending maintenance.`,
									},
									"scheduling_type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The type of maintenance for the reservation.`,
									},
									"subblock_infra_maintenance_ongoing_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Describes number of subblock Infrastructure that has ongoing maintenance. Here, Subblock Infrastructure Maintenance pertains to upstream hardware contained in the Subblock that is necessary for a VM Family(e.g. NVLink Domains). Not all VM Families will support this field.`,
									},
									"subblock_infra_maintenance_pending_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Describes number of subblock Infrastructure that has pending maintenance. Here, Subblock Infrastructure Maintenance pertains to upstream hardware contained in the Subblock that is necessary for a VM Family (e.g. NVLink Domains). Not all VM Families will support this field.`,
									},
									"upcoming_group_maintenance": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Maintenance information on this group of VMs.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"can_reschedule": {
													Type:        schema.TypeBool,
													Computed:    true,
													Description: `Indicates if the maintenance can be customer triggered.`,
												},
												"latest_window_start_time": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The latest time for the planned maintenance window to start. This timestamp value is in RFC3339 text format.`,
												},
												"maintenance_on_shutdown": {
													Type:        schema.TypeBool,
													Computed:    true,
													Description: `Indicates whether the UpcomingMaintenance will be triggered on VM shutdown.`,
												},
												"maintenance_reasons": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `The reasons for the maintenance. Only valid for vms.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"maintenance_status": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Status of the maintenance.`,
												},
												"type": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Defines the type of maintenance.`,
												},
												"window_end_time": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The time by which the maintenance disruption will be completed. This timestamp value is in RFC3339 text format.`,
												},
												"window_start_time": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The current start time of the maintenance window. This timestamp value is in RFC3339 text format.`,
												},
											},
										},
									},
								},
							},
						},
						"specific_sku_allocation": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Allocation Properties of this reservation.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"source_instance_template_id": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `ID of the instance template used to populate reservation properties.`,
									},
									"utilizations": {
										Type:        schema.TypeMap,
										Computed:    true,
										Description: `Per service utilization breakdown. The Key is the Google Cloud managed service name.`,
										Elem:        &schema.Schema{Type: schema.TypeString},
									},
								},
							},
						},
					},
				},
			},
			"satisfies_pzs": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `Reserved for future use.`,
			},
			"status": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The status of the reservation.`,
			},
			"block_names": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `List of all reservation block names in the parent reservation.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"self_link": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceComputeReservationCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandComputeReservationDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	nameProp, err := expandComputeReservationName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	specificReservationRequiredProp, err := expandComputeReservationSpecificReservationRequired(d.Get("specific_reservation_required"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("specific_reservation_required"); !tpgresource.IsEmptyValue(reflect.ValueOf(specificReservationRequiredProp)) && (ok || !reflect.DeepEqual(v, specificReservationRequiredProp)) {
		obj["specificReservationRequired"] = specificReservationRequiredProp
	}
	shareSettingsProp, err := expandComputeReservationShareSettings(d.Get("share_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("share_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(shareSettingsProp)) && (ok || !reflect.DeepEqual(v, shareSettingsProp)) {
		obj["shareSettings"] = shareSettingsProp
	}
	specificReservationProp, err := expandComputeReservationSpecificReservation(d.Get("specific_reservation"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("specific_reservation"); !tpgresource.IsEmptyValue(reflect.ValueOf(specificReservationProp)) && (ok || !reflect.DeepEqual(v, specificReservationProp)) {
		obj["specificReservation"] = specificReservationProp
	}
	deleteAtTimeProp, err := expandComputeReservationDeleteAtTime(d.Get("delete_at_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("delete_at_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(deleteAtTimeProp)) && (ok || !reflect.DeepEqual(v, deleteAtTimeProp)) {
		obj["deleteAtTime"] = deleteAtTimeProp
	}
	deleteAfterDurationProp, err := expandComputeReservationDeleteAfterDuration(d.Get("delete_after_duration"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("delete_after_duration"); !tpgresource.IsEmptyValue(reflect.ValueOf(deleteAfterDurationProp)) && (ok || !reflect.DeepEqual(v, deleteAfterDurationProp)) {
		obj["deleteAfterDuration"] = deleteAfterDurationProp
	}
	reservationSharingPolicyProp, err := expandComputeReservationReservationSharingPolicy(d.Get("reservation_sharing_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("reservation_sharing_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(reservationSharingPolicyProp)) && (ok || !reflect.DeepEqual(v, reservationSharingPolicyProp)) {
		obj["reservationSharingPolicy"] = reservationSharingPolicyProp
	}
	zoneProp, err := expandComputeReservationZone(d.Get("zone"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("zone"); !tpgresource.IsEmptyValue(reflect.ValueOf(zoneProp)) && (ok || !reflect.DeepEqual(v, zoneProp)) {
		obj["zone"] = zoneProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/reservations")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Reservation: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Reservation: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Reservation: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/zones/{{zone}}/reservations/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if zoneValue, ok := d.GetOk("zone"); ok && zoneValue.(string) != "" {
			if err = identity.Set("zone", zoneValue.(string)); err != nil {
				return fmt.Errorf("Error setting zone: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = ComputeOperationWaitTime(
		config, res, project, "Creating Reservation", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Reservation: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Reservation %q: %#v", d.Id(), res)

	return resourceComputeReservationRead(d, meta)
}

func resourceComputeReservationRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/reservations/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Reservation: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ComputeReservation %q", d.Id()))
	}

	zone, err := tpgresource.GetZone(d, config)
	if err != nil {
		return err
	}
	name := d.Get("name").(string)

	// Fetch the list of all reservation blocks from this reservation
	listUrl := fmt.Sprintf("https://compute.googleapis.com/compute/v1/projects/%s/zones/%s/reservations/%s/reservationBlocks?alt=json&maxResults=500", project, zone, name)

	listRes, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   project,
		RawURL:    listUrl,
		UserAgent: userAgent,
	})
	if err != nil {
		return fmt.Errorf("Error listing ReservationBlocks: %s", err)
	}

	blockNames := []string{}
	if listRes != nil {
		if items, ok := listRes["items"].([]interface{}); ok {
			for _, item := range items {
				if block, ok := item.(map[string]interface{}); ok {
					if blockName, ok := block["name"].(string); ok {
						blockNames = append(blockNames, blockName)
					}
				}
			}
		}
	}

	if err := d.Set("block_names", blockNames); err != nil {
		return fmt.Errorf("Error setting block_names: %s", err)
	}

	// Explicitly set virtual fields to default values if unset
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}

	if err := d.Set("creation_timestamp", flattenComputeReservationCreationTimestamp(res["creationTimestamp"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("description", flattenComputeReservationDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("name", flattenComputeReservationName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("commitment", flattenComputeReservationCommitment(res["commitment"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("specific_reservation_required", flattenComputeReservationSpecificReservationRequired(res["specificReservationRequired"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("status", flattenComputeReservationStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("specific_reservation", flattenComputeReservationSpecificReservation(res["specificReservation"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("delete_at_time", flattenComputeReservationDeleteAtTime(res["deleteAtTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("reservation_sharing_policy", flattenComputeReservationReservationSharingPolicy(res["reservationSharingPolicy"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("reservation_block_count", flattenComputeReservationReservationBlockCount(res["reservationBlockCount"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("kind", flattenComputeReservationKind(res["kind"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("id", flattenComputeReservationId(res["id"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("linked_commitments", flattenComputeReservationLinkedCommitments(res["linkedCommitments"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("satisfies_pzs", flattenComputeReservationSatisfiesPzs(res["satisfiesPzs"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("resource_status", flattenComputeReservationResourceStatus(res["resourceStatus"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("zone", flattenComputeReservationZone(res["zone"], d, config)); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}
	if err := d.Set("self_link", tpgresource.ConvertSelfLinkToV1(res["selfLink"].(string))); err != nil {
		return fmt.Errorf("Error reading Reservation: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("name"); !ok && v == "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("zone"); !ok && v == "" {
			err = identity.Set("zone", d.Get("zone").(string))
			if err != nil {
				return fmt.Errorf("Error setting zone: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceComputeReservationUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if zoneValue, ok := d.GetOk("zone"); ok && zoneValue.(string) != "" {
			if err = identity.Set("zone", zoneValue.(string)); err != nil {
				return fmt.Errorf("Error setting zone: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Reservation: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	shareSettingsProp, err := expandComputeReservationShareSettings(d.Get("share_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("share_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, shareSettingsProp)) {
		obj["shareSettings"] = shareSettingsProp
	}
	deleteAfterDurationProp, err := expandComputeReservationDeleteAfterDuration(d.Get("delete_after_duration"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("delete_after_duration"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, deleteAfterDurationProp)) {
		obj["deleteAfterDuration"] = deleteAfterDurationProp
	}
	reservationSharingPolicyProp, err := expandComputeReservationReservationSharingPolicy(d.Get("reservation_sharing_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("reservation_sharing_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, reservationSharingPolicyProp)) {
		obj["reservationSharingPolicy"] = reservationSharingPolicyProp
	}

	obj, err = resourceComputeReservationUpdateEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/reservations/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Reservation %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("share_settings") {
		updateMask = append(updateMask, "shareSettings")
	}

	if d.HasChange("delete_after_duration") {
		updateMask = append(updateMask, "deleteAfterDuration")
	}

	if d.HasChange("reservation_sharing_policy") {
		updateMask = append(updateMask, "reservationSharingPolicy")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}
	if d.HasChange("share_settings") {
		url, err = tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/reservations/{{name}}")
		if err != nil {
			return err
		}
		urlUpdateMask := obj["urlUpdateMask"]
		if urlUpdateMask != nil {
			url = url + urlUpdateMask.(string)
			delete(obj, "urlUpdateMask")
		}
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Reservation %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Reservation %q: %#v", d.Id(), res)
		}

		err = ComputeOperationWaitTime(
			config, res, project, "Updating Reservation", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}
	d.Partial(true)

	if d.HasChange("specific_reservation") {
		obj := make(map[string]interface{})

		specificReservationProp, err := expandComputeReservationSpecificReservation(d.Get("specific_reservation"), d, config)
		if err != nil {
			return err
		} else if v, ok := d.GetOkExists("specific_reservation"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, specificReservationProp)) {
			obj["specificReservation"] = specificReservationProp
		}

		obj, err = resourceComputeReservationUpdateEncoder(d, meta, obj)
		if err != nil {
			return err
		}

		url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/reservations/{{name}}/resize")
		if err != nil {
			return err
		}

		headers := make(http.Header)
		if d.HasChange("share_settings") {
			url, err = tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/reservations/{{name}}")
			if err != nil {
				return err
			}
			urlUpdateMask := obj["urlUpdateMask"]
			if urlUpdateMask != nil {
				url = url + urlUpdateMask.(string)
				delete(obj, "urlUpdateMask")
			}
		}

		// err == nil indicates that the billing_project value was found
		if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
			billingProject = bp
		}

		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "POST",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})
		if err != nil {
			return fmt.Errorf("Error updating Reservation %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Reservation %q: %#v", d.Id(), res)
		}

		err = ComputeOperationWaitTime(
			config, res, project, "Updating Reservation", userAgent,
			d.Timeout(schema.TimeoutUpdate))
		if err != nil {
			return err
		}
	}

	d.Partial(false)

	return resourceComputeReservationRead(d, meta)
}

func resourceComputeReservationDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Reservation: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/reservations/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Reservation %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Reservation")
	}

	err = ComputeOperationWaitTime(
		config, res, project, "Deleting Reservation", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Reservation %q: %#v", d.Id(), res)
	return nil
}

func resourceComputeReservationImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/zones/(?P<zone>[^/]+)/reservations/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<zone>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<zone>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/zones/{{zone}}/reservations/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Explicitly set virtual fields to default values on import

	return []*schema.ResourceData{d}, nil
}

func flattenComputeReservationCreationTimestamp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationCommitment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationSpecificReservationRequired(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationSpecificReservation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["count"] =
		flattenComputeReservationSpecificReservationCount(original["count"], d, config)
	transformed["in_use_count"] =
		flattenComputeReservationSpecificReservationInUseCount(original["inUseCount"], d, config)
	transformed["assured_count"] =
		flattenComputeReservationSpecificReservationAssuredCount(original["assuredCount"], d, config)
	transformed["instance_properties"] =
		flattenComputeReservationSpecificReservationInstanceProperties(original["instanceProperties"], d, config)
	transformed["source_instance_template"] =
		flattenComputeReservationSpecificReservationSourceInstanceTemplate(original["sourceInstanceTemplate"], d, config)
	return []interface{}{transformed}
}
func flattenComputeReservationSpecificReservationCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationSpecificReservationInUseCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationSpecificReservationAssuredCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationSpecificReservationInstanceProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["machine_type"] =
		flattenComputeReservationSpecificReservationInstancePropertiesMachineType(original["machineType"], d, config)
	transformed["min_cpu_platform"] =
		flattenComputeReservationSpecificReservationInstancePropertiesMinCpuPlatform(original["minCpuPlatform"], d, config)
	transformed["guest_accelerators"] =
		flattenComputeReservationSpecificReservationInstancePropertiesGuestAccelerators(original["guestAccelerators"], d, config)
	transformed["local_ssds"] =
		flattenComputeReservationSpecificReservationInstancePropertiesLocalSsds(original["localSsds"], d, config)
	transformed["location_hint"] =
		flattenComputeReservationSpecificReservationInstancePropertiesLocationHint(original["locationHint"], d, config)
	return []interface{}{transformed}
}
func flattenComputeReservationSpecificReservationInstancePropertiesMachineType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationSpecificReservationInstancePropertiesMinCpuPlatform(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationSpecificReservationInstancePropertiesGuestAccelerators(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"accelerator_type":  flattenComputeReservationSpecificReservationInstancePropertiesGuestAcceleratorsAcceleratorType(original["acceleratorType"], d, config),
			"accelerator_count": flattenComputeReservationSpecificReservationInstancePropertiesGuestAcceleratorsAcceleratorCount(original["acceleratorCount"], d, config),
		})
	}
	return transformed
}
func flattenComputeReservationSpecificReservationInstancePropertiesGuestAcceleratorsAcceleratorType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationSpecificReservationInstancePropertiesGuestAcceleratorsAcceleratorCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationSpecificReservationInstancePropertiesLocalSsds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"interface":    flattenComputeReservationSpecificReservationInstancePropertiesLocalSsdsInterface(original["interface"], d, config),
			"disk_size_gb": flattenComputeReservationSpecificReservationInstancePropertiesLocalSsdsDiskSizeGb(original["diskSizeGb"], d, config),
		})
	}
	return transformed
}
func flattenComputeReservationSpecificReservationInstancePropertiesLocalSsdsInterface(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationSpecificReservationInstancePropertiesLocalSsdsDiskSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationSpecificReservationInstancePropertiesLocationHint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationSpecificReservationSourceInstanceTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationDeleteAtTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationReservationSharingPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_share_type"] =
		flattenComputeReservationReservationSharingPolicyServiceShareType(original["serviceShareType"], d, config)
	return []interface{}{transformed}
}
func flattenComputeReservationReservationSharingPolicyServiceShareType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationReservationBlockCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationKind(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationLinkedCommitments(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationSatisfiesPzs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["specific_sku_allocation"] =
		flattenComputeReservationResourceStatusSpecificSkuAllocation(original["specificSkuAllocation"], d, config)
	transformed["reservation_maintenance"] =
		flattenComputeReservationResourceStatusReservationMaintenance(original["reservationMaintenance"], d, config)
	transformed["reservation_block_count"] =
		flattenComputeReservationResourceStatusReservationBlockCount(original["reservationBlockCount"], d, config)
	transformed["health_info"] =
		flattenComputeReservationResourceStatusHealthInfo(original["healthInfo"], d, config)
	return []interface{}{transformed}
}
func flattenComputeReservationResourceStatusSpecificSkuAllocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["source_instance_template_id"] =
		flattenComputeReservationResourceStatusSpecificSkuAllocationSourceInstanceTemplateId(original["sourceInstanceTemplateId"], d, config)
	transformed["utilizations"] =
		flattenComputeReservationResourceStatusSpecificSkuAllocationUtilizations(original["utilizations"], d, config)
	return []interface{}{transformed}
}
func flattenComputeReservationResourceStatusSpecificSkuAllocationSourceInstanceTemplateId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusSpecificSkuAllocationUtilizations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusReservationMaintenance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["upcoming_group_maintenance"] =
		flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenance(original["upcomingGroupMaintenance"], d, config)
	transformed["maintenance_ongoing_count"] =
		flattenComputeReservationResourceStatusReservationMaintenanceMaintenanceOngoingCount(original["maintenanceOngoingCount"], d, config)
	transformed["maintenance_pending_count"] =
		flattenComputeReservationResourceStatusReservationMaintenanceMaintenancePendingCount(original["maintenancePendingCount"], d, config)
	transformed["scheduling_type"] =
		flattenComputeReservationResourceStatusReservationMaintenanceSchedulingType(original["schedulingType"], d, config)
	transformed["subblock_infra_maintenance_ongoing_count"] =
		flattenComputeReservationResourceStatusReservationMaintenanceSubblockInfraMaintenanceOngoingCount(original["subblockInfraMaintenanceOngoingCount"], d, config)
	transformed["subblock_infra_maintenance_pending_count"] =
		flattenComputeReservationResourceStatusReservationMaintenanceSubblockInfraMaintenancePendingCount(original["subblockInfraMaintenancePendingCount"], d, config)
	transformed["instance_maintenance_ongoing_count"] =
		flattenComputeReservationResourceStatusReservationMaintenanceInstanceMaintenanceOngoingCount(original["instanceMaintenanceOngoingCount"], d, config)
	transformed["instance_maintenance_pending_count"] =
		flattenComputeReservationResourceStatusReservationMaintenanceInstanceMaintenancePendingCount(original["instanceMaintenancePendingCount"], d, config)
	return []interface{}{transformed}
}
func flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["type"] =
		flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceType(original["type"], d, config)
	transformed["can_reschedule"] =
		flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceCanReschedule(original["canReschedule"], d, config)
	transformed["window_start_time"] =
		flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceWindowStartTime(original["windowStartTime"], d, config)
	transformed["window_end_time"] =
		flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceWindowEndTime(original["windowEndTime"], d, config)
	transformed["latest_window_start_time"] =
		flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceLatestWindowStartTime(original["latestWindowStartTime"], d, config)
	transformed["maintenance_status"] =
		flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceMaintenanceStatus(original["maintenanceStatus"], d, config)
	transformed["maintenance_on_shutdown"] =
		flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceMaintenanceOnShutdown(original["maintenanceOnShutdown"], d, config)
	transformed["maintenance_reasons"] =
		flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceMaintenanceReasons(original["maintenanceReasons"], d, config)
	return []interface{}{transformed}
}
func flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceCanReschedule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceWindowStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceWindowEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceLatestWindowStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceMaintenanceStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceMaintenanceOnShutdown(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusReservationMaintenanceUpcomingGroupMaintenanceMaintenanceReasons(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusReservationMaintenanceMaintenanceOngoingCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationResourceStatusReservationMaintenanceMaintenancePendingCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationResourceStatusReservationMaintenanceSchedulingType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusReservationMaintenanceSubblockInfraMaintenanceOngoingCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationResourceStatusReservationMaintenanceSubblockInfraMaintenancePendingCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationResourceStatusReservationMaintenanceInstanceMaintenanceOngoingCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationResourceStatusReservationMaintenanceInstanceMaintenancePendingCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationResourceStatusReservationBlockCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationResourceStatusHealthInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["health_status"] =
		flattenComputeReservationResourceStatusHealthInfoHealthStatus(original["healthStatus"], d, config)
	transformed["healthy_block_count"] =
		flattenComputeReservationResourceStatusHealthInfoHealthyBlockCount(original["healthyBlockCount"], d, config)
	transformed["degraded_block_count"] =
		flattenComputeReservationResourceStatusHealthInfoDegradedBlockCount(original["degradedBlockCount"], d, config)
	return []interface{}{transformed}
}
func flattenComputeReservationResourceStatusHealthInfoHealthStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeReservationResourceStatusHealthInfoHealthyBlockCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationResourceStatusHealthInfoDegradedBlockCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeReservationZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.ConvertSelfLinkToV1(v.(string))
}

func expandComputeReservationDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservationRequired(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationShareSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedShareType, err := expandComputeReservationShareSettingsShareType(original["share_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedShareType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["shareType"] = transformedShareType
	}

	transformedProjectMap, err := expandComputeReservationShareSettingsProjectMap(original["project_map"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProjectMap); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["projectMap"] = transformedProjectMap
	}

	return transformed, nil
}

func expandComputeReservationShareSettingsShareType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationShareSettingsProjectMap(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedProjectId, err := expandComputeReservationShareSettingsProjectMapProjectId(original["project_id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["projectId"] = transformedProjectId
		}

		transformedId, err := tpgresource.ExpandString(original["id"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedId] = transformed
	}
	return m, nil
}

func expandComputeReservationShareSettingsProjectMapProjectId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCount, err := expandComputeReservationSpecificReservationCount(original["count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["count"] = transformedCount
	}

	transformedInUseCount, err := expandComputeReservationSpecificReservationInUseCount(original["in_use_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInUseCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inUseCount"] = transformedInUseCount
	}

	transformedAssuredCount, err := expandComputeReservationSpecificReservationAssuredCount(original["assured_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAssuredCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["assuredCount"] = transformedAssuredCount
	}

	transformedInstanceProperties, err := expandComputeReservationSpecificReservationInstanceProperties(original["instance_properties"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstanceProperties); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instanceProperties"] = transformedInstanceProperties
	}

	transformedSourceInstanceTemplate, err := expandComputeReservationSpecificReservationSourceInstanceTemplate(original["source_instance_template"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSourceInstanceTemplate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sourceInstanceTemplate"] = transformedSourceInstanceTemplate
	}

	return transformed, nil
}

func expandComputeReservationSpecificReservationCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservationInUseCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservationAssuredCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservationInstanceProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMachineType, err := expandComputeReservationSpecificReservationInstancePropertiesMachineType(original["machine_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMachineType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["machineType"] = transformedMachineType
	}

	transformedMinCpuPlatform, err := expandComputeReservationSpecificReservationInstancePropertiesMinCpuPlatform(original["min_cpu_platform"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinCpuPlatform); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minCpuPlatform"] = transformedMinCpuPlatform
	}

	transformedGuestAccelerators, err := expandComputeReservationSpecificReservationInstancePropertiesGuestAccelerators(original["guest_accelerators"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGuestAccelerators); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["guestAccelerators"] = transformedGuestAccelerators
	}

	transformedLocalSsds, err := expandComputeReservationSpecificReservationInstancePropertiesLocalSsds(original["local_ssds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalSsds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["localSsds"] = transformedLocalSsds
	}

	transformedLocationHint, err := expandComputeReservationSpecificReservationInstancePropertiesLocationHint(original["location_hint"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocationHint); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["locationHint"] = transformedLocationHint
	}

	return transformed, nil
}

func expandComputeReservationSpecificReservationInstancePropertiesMachineType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservationInstancePropertiesMinCpuPlatform(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservationInstancePropertiesGuestAccelerators(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAcceleratorType, err := expandComputeReservationSpecificReservationInstancePropertiesGuestAcceleratorsAcceleratorType(original["accelerator_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAcceleratorType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["acceleratorType"] = transformedAcceleratorType
		}

		transformedAcceleratorCount, err := expandComputeReservationSpecificReservationInstancePropertiesGuestAcceleratorsAcceleratorCount(original["accelerator_count"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAcceleratorCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["acceleratorCount"] = transformedAcceleratorCount
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandComputeReservationSpecificReservationInstancePropertiesGuestAcceleratorsAcceleratorType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservationInstancePropertiesGuestAcceleratorsAcceleratorCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservationInstancePropertiesLocalSsds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedInterface, err := expandComputeReservationSpecificReservationInstancePropertiesLocalSsdsInterface(original["interface"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInterface); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["interface"] = transformedInterface
		}

		transformedDiskSizeGb, err := expandComputeReservationSpecificReservationInstancePropertiesLocalSsdsDiskSizeGb(original["disk_size_gb"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDiskSizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["diskSizeGb"] = transformedDiskSizeGb
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandComputeReservationSpecificReservationInstancePropertiesLocalSsdsInterface(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservationInstancePropertiesLocalSsdsDiskSizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservationInstancePropertiesLocationHint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationSpecificReservationSourceInstanceTemplate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationDeleteAtTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationDeleteAfterDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSeconds, err := expandComputeReservationDeleteAfterDurationSeconds(original["seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["seconds"] = transformedSeconds
	}

	transformedNanos, err := expandComputeReservationDeleteAfterDurationNanos(original["nanos"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNanos); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nanos"] = transformedNanos
	}

	return transformed, nil
}

func expandComputeReservationDeleteAfterDurationSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationDeleteAfterDurationNanos(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationReservationSharingPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServiceShareType, err := expandComputeReservationReservationSharingPolicyServiceShareType(original["service_share_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceShareType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceShareType"] = transformedServiceShareType
	}

	return transformed, nil
}

func expandComputeReservationReservationSharingPolicyServiceShareType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeReservationZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	f, err := tpgresource.ParseGlobalFieldValue("zones", v.(string), "project", d, config, true)
	if err != nil {
		return nil, fmt.Errorf("Invalid value for zone: %s", err)
	}
	return f.RelativeLink(), nil
}

func resourceComputeReservationUpdateEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	newObj := make(map[string]interface{})
	config := meta.(*transport_tpg.Config)
	maskId := ""
	firstProject := true
	urlUpdateMask := ""

	if d.HasChange("share_settings") {
		// Get name.
		nameProp, err := expandComputeReservationName(d.Get("name"), d, config)
		if err != nil {
			return nil, fmt.Errorf("Invalid value for name: %s", err)
		} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
			newObj["name"] = nameProp
		}
		// 	Get zone.
		zoneProp, err := expandComputeReservationZone(d.Get("zone"), d, config)
		if err != nil {
			return nil, fmt.Errorf("Invalid value for zone: %s", err)
		} else if v, ok := d.GetOkExists("zone"); !tpgresource.IsEmptyValue(reflect.ValueOf(zoneProp)) && (ok || !reflect.DeepEqual(v, zoneProp)) {
			newObj["zone"] = zoneProp
		}
		transformed := make(map[string]interface{})
		// Set shareType.
		transformed["shareType"] = "SPECIFIC_PROJECTS"
		// Set project_map.
		projectMap := make(map[string]interface{})
		old, new := d.GetChange("share_settings")

		var before *schema.Set
		if oldSlice, ok := old.([]interface{}); ok && len(oldSlice) > 0 {
			if oldMap, ok := oldSlice[0].(map[string]interface{})["project_map"]; ok {
				before = oldMap.(*schema.Set)
			} else {
				before = schema.NewSet(schema.HashString, []interface{}{})
			}
		} else {
			before = schema.NewSet(schema.HashString, []interface{}{})
		}
		var after *schema.Set
		if newSlice, ok := new.([]interface{}); ok && len(newSlice) > 0 {
			if newMap, ok := newSlice[0].(map[string]interface{})["project_map"]; ok {
				after = newMap.(*schema.Set)
			} else {
				after = schema.NewSet(schema.HashString, []interface{}{})
			}
		} else {
			after = schema.NewSet(schema.HashString, []interface{}{})
		}

		for _, raw := range after.Difference(before).List() {
			original := raw.(map[string]interface{})
			singleProject := make(map[string]interface{})
			// set up project_map.
			transformedProjectId := original["project_id"]
			if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
				singleProject["projectId"] = transformedProjectId
			}
			transformedId, err := tpgresource.ExpandString(original["id"], d, config)
			if err != nil {
				return nil, fmt.Errorf("Invalid value for id: %s", err)
			}
			projectMap[transformedId] = singleProject
			// add added projects to updateMask
			if !firstProject {
				maskId = fmt.Sprintf("%s%s", "&paths=shareSettings.projectMap.", original["id"])
			} else {
				maskId = fmt.Sprintf("%s%s", "?paths=shareSettings.projectMap.", original["id"])
				firstProject = false
			}
			decodedPath, _ := url.QueryUnescape(maskId)
			urlUpdateMask = urlUpdateMask + decodedPath
		}
		transformed["projectMap"] = projectMap
		newObj["shareSettings"] = transformed

		// add removed projects to updateMask
		firstProject = true
		for _, raw := range before.Difference(after).List() {
			original := raw.(map[string]interface{})
			// To remove a project we need project number.
			projectId := fmt.Sprintf("%s", original["project_id"])
			projectIdOrNum := projectId
			_, err := strconv.Atoi(projectId)
			// convert id to number.
			if err != nil {
				config := meta.(*transport_tpg.Config)
				project, err := config.NewResourceManagerClient(config.UserAgent).Projects.Get(projectId).Do()
				if err != nil {
					return nil, fmt.Errorf("Invalid value for projectId: %s", err)
				}
				projectNum := project.ProjectNumber
				projectIdOrNum = fmt.Sprintf("%d", projectNum)
			}
			if !firstProject {
				maskId = fmt.Sprintf("%s%s", "&paths=shareSettings.projectMap.", projectIdOrNum)
			} else {
				maskId = fmt.Sprintf("%s%s", "?paths=shareSettings.projectMap.", projectIdOrNum)
				firstProject = false
			}
			decodedPath, _ := url.QueryUnescape(maskId)
			urlUpdateMask = urlUpdateMask + decodedPath
		}
		newObj["urlUpdateMask"] = urlUpdateMask
	}

	// Resize.
	if obj["specificReservation"] != nil {
		count := obj["specificReservation"].(map[string]interface{})["count"]
		if count != nil {
			newObj["specificSkuCount"] = obj["specificReservation"].(map[string]interface{})["count"]
		}
	}

	return newObj, nil
}
