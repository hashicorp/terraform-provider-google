// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/compute/StoragePool.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package compute

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceComputeStoragePool() *schema.Resource {
	return &schema.Resource{
		Create: resourceComputeStoragePoolCreate,
		Read:   resourceComputeStoragePoolRead,
		Update: resourceComputeStoragePoolUpdate,
		Delete: resourceComputeStoragePoolDelete,

		Importer: &schema.ResourceImporter{
			State: resourceComputeStoragePoolImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Name of the resource. Provided by the client when the resource is created.
The name must be 1-63 characters long, and comply with RFC1035.
Specifically, the name must be 1-63 characters long and match
the regular expression '[a-z]([-a-z0-9]*[a-z0-9])?'
which means the first character must be a lowercase letter,
and all following characters must be a dash, lowercase letter, or digit,
except the last character, which cannot be a dash.`,
			},
			"pool_provisioned_capacity_gb": {
				Type:     schema.TypeString,
				Required: true,
				Description: `Size, in GiB, of the storage pool. For more information about the size limits,
see https://cloud.google.com/compute/docs/disks/storage-pools.`,
			},
			"pool_provisioned_throughput": {
				Type:     schema.TypeString,
				Required: true,
				Description: `Provisioned throughput, in MB/s, of the storage pool.
Only relevant if the storage pool type is 'hyperdisk-balanced' or 'hyperdisk-throughput'.`,
			},
			"storage_pool_type": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description: `Type of the storage pool. For example, the
following are valid values:

* 'https://www.googleapis.com/compute/v1/projects/{project_id}/zones/{zone}/storagePoolTypes/hyperdisk-balanced'
* 'hyperdisk-throughput'`,
			},
			"capacity_provisioning_type": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"STANDARD", "ADVANCED", ""}),
				Description:  `Provisioning type of the byte capacity of the pool. Possible values: ["STANDARD", "ADVANCED"]`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `A description of this resource. Provide this property when you create the resource.`,
			},
			"performance_provisioning_type": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"STANDARD", "ADVANCED", ""}),
				Description:  `Provisioning type of the performance-related parameters of the pool, such as throughput and IOPS. Possible values: ["STANDARD", "ADVANCED"]`,
			},
			"pool_provisioned_iops": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Provisioned IOPS of the storage pool.
Only relevant if the storage pool type is 'hyperdisk-balanced'.`,
			},
			"zone": {
				Type:             schema.TypeString,
				Computed:         true,
				Optional:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description:      `A reference to the zone where the storage pool resides.`,
			},
			"creation_timestamp": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Creation timestamp in RFC3339 text format.`,
			},
			"id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The unique identifier for the resource. This identifier is defined by the server.`,
			},
			"kind": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Type of the resource.`,
			},
			"label_fingerprint": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The fingerprint used for optimistic locking of this resource.
Used internally during updates.`,
			},
			"resource_status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Status information for the storage pool resource.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"disk_count": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Number of disks used.`,
						},
						"last_resize_timestamp": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Timestamp of the last successful resize in RFC3339 text format.`,
						},
						"max_total_provisioned_disk_capacity_gb": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Maximum allowed aggregate disk size in gigabytes.`,
						},
						"pool_used_capacity_bytes": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Space used by data stored in disks within the storage pool (in bytes).
This will reflect the total number of bytes written to the disks in the pool,
in contrast to the capacity of those disks.`,
						},
						"pool_used_iops": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Sum of all the disks' provisioned IOPS, minus some amount
that is allowed per disk that is not counted towards pool's IOPS capacity.
For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.`,
						},
						"pool_used_throughput": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Sum of all the disks' provisioned throughput in MB/s.`,
						},
						"pool_user_written_bytes": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Amount of data written into the pool, before it is compacted.`,
						},
						"total_provisioned_disk_capacity_gb": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Sum of all the capacity provisioned in disks in this storage pool.
A disk's provisioned capacity is the same as its total capacity.`,
						},
						"total_provisioned_disk_iops": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Sum of all the disks' provisioned IOPS.`,
						},
						"total_provisioned_disk_throughput": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Sum of all the disks' provisioned throughput in MB/s,
minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.`,
						},
					},
				},
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Status information for the storage pool resource.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"disk_count": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Number of disks used.`,
						},
						"last_resize_timestamp": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Timestamp of the last successful resize in RFC3339 text format.`,
						},
						"max_total_provisioned_disk_capacity_gb": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Maximum allowed aggregate disk size in gigabytes.`,
						},
						"pool_used_capacity_bytes": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Space used by data stored in disks within the storage pool (in bytes).
This will reflect the total number of bytes written to the disks in the pool, in contrast to the capacity of those disks.`,
						},
						"pool_used_iops": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Sum of all the disks' provisioned IOPS, minus some amount that is allowed per disk that is not counted towards pool's IOPS capacity. For more information, see https://cloud.google.com/compute/docs/disks/storage-pools.`,
						},
						"pool_used_throughput": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Sum of all the disks' provisioned throughput in MB/s.`,
						},
						"pool_user_written_bytes": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Amount of data written into the pool, before it is compacted.`,
						},
						"total_provisioned_disk_capacity_gb": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Sum of all the capacity provisioned in disks in this storage pool.
A disk's provisioned capacity is the same as its total capacity.`,
						},
						"total_provisioned_disk_iops": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Sum of all the disks' provisioned IOPS.`,
						},
						"total_provisioned_disk_throughput": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Sum of all the disks' provisioned throughput in MB/s,
minus some amount that is allowed per disk that is not counted towards pool's throughput capacity.`,
						},
					},
				},
			},
			"deletion_protection": {
				Type:     schema.TypeBool,
				Optional: true,
				Description: `Whether Terraform will be prevented from destroying the StoragePool.
When the field is set to true or unset in Terraform state, a 'terraform apply'
or 'terraform destroy' that would delete the StoragePool will fail.
When the field is set to false, deleting the StoragePool is allowed.`,
				Default: true,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceComputeStoragePoolCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandComputeStoragePoolName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	descriptionProp, err := expandComputeStoragePoolDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	poolProvisionedCapacityGbProp, err := expandComputeStoragePoolPoolProvisionedCapacityGb(d.Get("pool_provisioned_capacity_gb"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("pool_provisioned_capacity_gb"); !tpgresource.IsEmptyValue(reflect.ValueOf(poolProvisionedCapacityGbProp)) && (ok || !reflect.DeepEqual(v, poolProvisionedCapacityGbProp)) {
		obj["poolProvisionedCapacityGb"] = poolProvisionedCapacityGbProp
	}
	poolProvisionedIopsProp, err := expandComputeStoragePoolPoolProvisionedIops(d.Get("pool_provisioned_iops"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("pool_provisioned_iops"); !tpgresource.IsEmptyValue(reflect.ValueOf(poolProvisionedIopsProp)) && (ok || !reflect.DeepEqual(v, poolProvisionedIopsProp)) {
		obj["poolProvisionedIops"] = poolProvisionedIopsProp
	}
	poolProvisionedThroughputProp, err := expandComputeStoragePoolPoolProvisionedThroughput(d.Get("pool_provisioned_throughput"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("pool_provisioned_throughput"); !tpgresource.IsEmptyValue(reflect.ValueOf(poolProvisionedThroughputProp)) && (ok || !reflect.DeepEqual(v, poolProvisionedThroughputProp)) {
		obj["poolProvisionedThroughput"] = poolProvisionedThroughputProp
	}
	labelFingerprintProp, err := expandComputeStoragePoolLabelFingerprint(d.Get("label_fingerprint"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("label_fingerprint"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelFingerprintProp)) && (ok || !reflect.DeepEqual(v, labelFingerprintProp)) {
		obj["labelFingerprint"] = labelFingerprintProp
	}
	storagePoolTypeProp, err := expandComputeStoragePoolStoragePoolType(d.Get("storage_pool_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("storage_pool_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(storagePoolTypeProp)) && (ok || !reflect.DeepEqual(v, storagePoolTypeProp)) {
		obj["storagePoolType"] = storagePoolTypeProp
	}
	capacityProvisioningTypeProp, err := expandComputeStoragePoolCapacityProvisioningType(d.Get("capacity_provisioning_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("capacity_provisioning_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(capacityProvisioningTypeProp)) && (ok || !reflect.DeepEqual(v, capacityProvisioningTypeProp)) {
		obj["capacityProvisioningType"] = capacityProvisioningTypeProp
	}
	performanceProvisioningTypeProp, err := expandComputeStoragePoolPerformanceProvisioningType(d.Get("performance_provisioning_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("performance_provisioning_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(performanceProvisioningTypeProp)) && (ok || !reflect.DeepEqual(v, performanceProvisioningTypeProp)) {
		obj["performanceProvisioningType"] = performanceProvisioningTypeProp
	}
	zoneProp, err := expandComputeStoragePoolZone(d.Get("zone"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("zone"); !tpgresource.IsEmptyValue(reflect.ValueOf(zoneProp)) && (ok || !reflect.DeepEqual(v, zoneProp)) {
		obj["zone"] = zoneProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/storagePools")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new StoragePool: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for StoragePool: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating StoragePool: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/zones/{{zone}}/storagePools/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = ComputeOperationWaitTime(
		config, res, project, "Creating StoragePool", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create StoragePool: %s", err)
	}

	log.Printf("[DEBUG] Finished creating StoragePool %q: %#v", d.Id(), res)

	return resourceComputeStoragePoolRead(d, meta)
}

func resourceComputeStoragePoolRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/storagePools/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for StoragePool: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ComputeStoragePool %q", d.Id()))
	}

	// Explicitly set virtual fields to default values if unset
	if _, ok := d.GetOkExists("deletion_protection"); !ok {
		if err := d.Set("deletion_protection", true); err != nil {
			return fmt.Errorf("Error setting deletion_protection: %s", err)
		}
	}
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}

	if err := d.Set("kind", flattenComputeStoragePoolKind(res["kind"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("id", flattenComputeStoragePoolId(res["id"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("creation_timestamp", flattenComputeStoragePoolCreationTimestamp(res["creationTimestamp"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("name", flattenComputeStoragePoolName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("description", flattenComputeStoragePoolDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("pool_provisioned_capacity_gb", flattenComputeStoragePoolPoolProvisionedCapacityGb(res["poolProvisionedCapacityGb"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("pool_provisioned_iops", flattenComputeStoragePoolPoolProvisionedIops(res["poolProvisionedIops"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("pool_provisioned_throughput", flattenComputeStoragePoolPoolProvisionedThroughput(res["poolProvisionedThroughput"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("label_fingerprint", flattenComputeStoragePoolLabelFingerprint(res["labelFingerprint"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("resource_status", flattenComputeStoragePoolResourceStatus(res["resourceStatus"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("storage_pool_type", flattenComputeStoragePoolStoragePoolType(res["storagePoolType"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("status", flattenComputeStoragePoolStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("capacity_provisioning_type", flattenComputeStoragePoolCapacityProvisioningType(res["capacityProvisioningType"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("performance_provisioning_type", flattenComputeStoragePoolPerformanceProvisioningType(res["performanceProvisioningType"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}
	if err := d.Set("zone", flattenComputeStoragePoolZone(res["zone"], d, config)); err != nil {
		return fmt.Errorf("Error reading StoragePool: %s", err)
	}

	return nil
}

func resourceComputeStoragePoolUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for StoragePool: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	poolProvisionedCapacityGbProp, err := expandComputeStoragePoolPoolProvisionedCapacityGb(d.Get("pool_provisioned_capacity_gb"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("pool_provisioned_capacity_gb"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, poolProvisionedCapacityGbProp)) {
		obj["poolProvisionedCapacityGb"] = poolProvisionedCapacityGbProp
	}
	poolProvisionedIopsProp, err := expandComputeStoragePoolPoolProvisionedIops(d.Get("pool_provisioned_iops"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("pool_provisioned_iops"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, poolProvisionedIopsProp)) {
		obj["poolProvisionedIops"] = poolProvisionedIopsProp
	}
	poolProvisionedThroughputProp, err := expandComputeStoragePoolPoolProvisionedThroughput(d.Get("pool_provisioned_throughput"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("pool_provisioned_throughput"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, poolProvisionedThroughputProp)) {
		obj["poolProvisionedThroughput"] = poolProvisionedThroughputProp
	}
	labelFingerprintProp, err := expandComputeStoragePoolLabelFingerprint(d.Get("label_fingerprint"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("label_fingerprint"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelFingerprintProp)) {
		obj["labelFingerprint"] = labelFingerprintProp
	}
	zoneProp, err := expandComputeStoragePoolZone(d.Get("zone"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("zone"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, zoneProp)) {
		obj["zone"] = zoneProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/storagePools/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating StoragePool %q: %#v", d.Id(), obj)
	headers := make(http.Header)

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "PATCH",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutUpdate),
		Headers:   headers,
	})

	if err != nil {
		return fmt.Errorf("Error updating StoragePool %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating StoragePool %q: %#v", d.Id(), res)
	}

	err = ComputeOperationWaitTime(
		config, res, project, "Updating StoragePool", userAgent,
		d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return err
	}

	return resourceComputeStoragePoolRead(d, meta)
}

func resourceComputeStoragePoolDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for StoragePool: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/storagePools/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	if d.Get("deletion_protection").(bool) {
		return fmt.Errorf("cannot destroy storage pool without setting deletion_protection=false and running `terraform apply`")
	}

	log.Printf("[DEBUG] Deleting StoragePool %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "StoragePool")
	}

	err = ComputeOperationWaitTime(
		config, res, project, "Deleting StoragePool", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting StoragePool %q: %#v", d.Id(), res)
	return nil
}

func resourceComputeStoragePoolImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/zones/(?P<zone>[^/]+)/storagePools/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<zone>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<zone>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/zones/{{zone}}/storagePools/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Explicitly set virtual fields to default values on import
	if err := d.Set("deletion_protection", true); err != nil {
		return nil, fmt.Errorf("Error setting deletion_protection: %s", err)
	}

	return []*schema.ResourceData{d}, nil
}

func flattenComputeStoragePoolKind(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolCreationTimestamp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolPoolProvisionedCapacityGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolPoolProvisionedIops(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolPoolProvisionedThroughput(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolLabelFingerprint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolResourceStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["last_resize_timestamp"] =
		flattenComputeStoragePoolResourceStatusLastResizeTimestamp(original["lastResizeTimestamp"], d, config)
	transformed["disk_count"] =
		flattenComputeStoragePoolResourceStatusDiskCount(original["diskCount"], d, config)
	transformed["pool_used_capacity_bytes"] =
		flattenComputeStoragePoolResourceStatusPoolUsedCapacityBytes(original["poolUsedCapacityBytes"], d, config)
	transformed["pool_user_written_bytes"] =
		flattenComputeStoragePoolResourceStatusPoolUserWrittenBytes(original["poolUserWrittenBytes"], d, config)
	transformed["total_provisioned_disk_capacity_gb"] =
		flattenComputeStoragePoolResourceStatusTotalProvisionedDiskCapacityGb(original["totalProvisionedDiskCapacityGb"], d, config)
	transformed["max_total_provisioned_disk_capacity_gb"] =
		flattenComputeStoragePoolResourceStatusMaxTotalProvisionedDiskCapacityGb(original["maxTotalProvisionedDiskCapacityGb"], d, config)
	transformed["pool_used_iops"] =
		flattenComputeStoragePoolResourceStatusPoolUsedIops(original["poolUsedIops"], d, config)
	transformed["total_provisioned_disk_iops"] =
		flattenComputeStoragePoolResourceStatusTotalProvisionedDiskIops(original["totalProvisionedDiskIops"], d, config)
	transformed["pool_used_throughput"] =
		flattenComputeStoragePoolResourceStatusPoolUsedThroughput(original["poolUsedThroughput"], d, config)
	transformed["total_provisioned_disk_throughput"] =
		flattenComputeStoragePoolResourceStatusTotalProvisionedDiskThroughput(original["totalProvisionedDiskThroughput"], d, config)
	return []interface{}{transformed}
}
func flattenComputeStoragePoolResourceStatusLastResizeTimestamp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolResourceStatusDiskCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolResourceStatusPoolUsedCapacityBytes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolResourceStatusPoolUserWrittenBytes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolResourceStatusTotalProvisionedDiskCapacityGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolResourceStatusMaxTotalProvisionedDiskCapacityGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolResourceStatusPoolUsedIops(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolResourceStatusTotalProvisionedDiskIops(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolResourceStatusPoolUsedThroughput(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolResourceStatusTotalProvisionedDiskThroughput(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolStoragePoolType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.ConvertSelfLinkToV1(v.(string))
}

func flattenComputeStoragePoolStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["last_resize_timestamp"] =
		flattenComputeStoragePoolStatusLastResizeTimestamp(original["lastResizeTimestamp"], d, config)
	transformed["disk_count"] =
		flattenComputeStoragePoolStatusDiskCount(original["diskCount"], d, config)
	transformed["pool_used_capacity_bytes"] =
		flattenComputeStoragePoolStatusPoolUsedCapacityBytes(original["poolUsedCapacityBytes"], d, config)
	transformed["pool_user_written_bytes"] =
		flattenComputeStoragePoolStatusPoolUserWrittenBytes(original["poolUserWrittenBytes"], d, config)
	transformed["total_provisioned_disk_capacity_gb"] =
		flattenComputeStoragePoolStatusTotalProvisionedDiskCapacityGb(original["totalProvisionedDiskCapacityGb"], d, config)
	transformed["max_total_provisioned_disk_capacity_gb"] =
		flattenComputeStoragePoolStatusMaxTotalProvisionedDiskCapacityGb(original["maxTotalProvisionedDiskCapacityGb"], d, config)
	transformed["pool_used_iops"] =
		flattenComputeStoragePoolStatusPoolUsedIops(original["poolUsedIops"], d, config)
	transformed["total_provisioned_disk_iops"] =
		flattenComputeStoragePoolStatusTotalProvisionedDiskIops(original["totalProvisionedDiskIops"], d, config)
	transformed["pool_used_throughput"] =
		flattenComputeStoragePoolStatusPoolUsedThroughput(original["poolUsedThroughput"], d, config)
	transformed["total_provisioned_disk_throughput"] =
		flattenComputeStoragePoolStatusTotalProvisionedDiskThroughput(original["totalProvisionedDiskThroughput"], d, config)
	return []interface{}{transformed}
}
func flattenComputeStoragePoolStatusLastResizeTimestamp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolStatusDiskCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolStatusPoolUsedCapacityBytes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolStatusPoolUserWrittenBytes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolStatusTotalProvisionedDiskCapacityGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolStatusMaxTotalProvisionedDiskCapacityGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolStatusPoolUsedIops(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolStatusTotalProvisionedDiskIops(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolStatusPoolUsedThroughput(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolStatusTotalProvisionedDiskThroughput(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolCapacityProvisioningType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolPerformanceProvisioningType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeStoragePoolZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.NameFromSelfLinkStateFunc(v)
}

func expandComputeStoragePoolName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeStoragePoolDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeStoragePoolPoolProvisionedCapacityGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeStoragePoolPoolProvisionedIops(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeStoragePoolPoolProvisionedThroughput(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeStoragePoolLabelFingerprint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeStoragePoolStoragePoolType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	f, err := tpgresource.ParseZonalFieldValue("storagePoolTypes", v.(string), "project", "zone", d, config, true)
	if err != nil {
		return nil, fmt.Errorf("Invalid value for storage_pool_type: %s", err)
	}
	return f.RelativeLink(), nil
}

func expandComputeStoragePoolCapacityProvisioningType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeStoragePoolPerformanceProvisioningType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeStoragePoolZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	f, err := tpgresource.ParseGlobalFieldValue("zones", v.(string), "project", d, config, true)
	if err != nil {
		return nil, fmt.Errorf("Invalid value for zone: %s", err)
	}
	return f.RelativeLink(), nil
}
