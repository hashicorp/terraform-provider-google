// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/compute/firewall_policy_utils.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package compute

import "fmt"

// It adjusts obj in case network scope/context fields are used - in beta API both network scope/context fields are available.
// The GET method returns both of them with the same value (you can think of network scope field as an alias for the network context field).
// Terraform allows only one of them to be used (using 'conflicts' annotation) but because the terraform state has both of them we have
// to remove one of them if there's a change so that it's obvious what is the new value and to prevent terraform to report differences
// after the changes are applied.
func adjustFirewallPolicyRuleNetworkContextFields(obj map[string]interface{}, oldMatch interface{}, newMatch interface{}) error {

	match, exists := obj["match"]

	if !exists {
		return nil
	}

	err := adjustFields(match.(map[string]interface{}), oldMatch, newMatch, "src_network_scope", "src_network_context")
	if err != nil {
		return err
	}
	err = adjustFields(match.(map[string]interface{}), oldMatch, newMatch, "dest_network_scope", "dest_network_context")
	if err != nil {
		return err
	}
	return nil
}

func adjustFields(match map[string]interface{}, oldMatch interface{}, newMatch interface{}, fieldName1 string, fieldName2 string) error {
	oldField1 := getFieldValue(oldMatch, fieldName1)
	newField1 := getFieldValue(newMatch, fieldName1)
	oldField2 := getFieldValue(oldMatch, fieldName2)
	newField2 := getFieldValue(newMatch, fieldName2)

	field1Changed := newField1 != oldField1
	field2Changed := newField2 != oldField2

	if field1Changed && field2Changed {
		// it should not be possible because one cannot use both fields at the same time (using 'conflicts' in schema)
		return fmt.Errorf("Cannot change both %s and %s at the same time", fieldName1, fieldName2)
	}

	if field1Changed {
		delete(match, fieldName2)
	} else if field2Changed {
		delete(match, fieldName1)
	}
	return nil
}

func getFieldValue(match any, fieldName string) string {
	// Extract the nested field value from the old match
	if valuesList := match.([]interface{}); len(valuesList) > 0 {
		if data := valuesList[0].(map[string]interface{}); data != nil {
			if val, ok := data[fieldName].(string); ok {
				return val
			}
		}
	}
	return ""
}
