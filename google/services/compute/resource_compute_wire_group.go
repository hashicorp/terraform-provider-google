// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/compute/WireGroup.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package compute

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceComputeWireGroup() *schema.Resource {
	return &schema.Resource{
		Create: resourceComputeWireGroupCreate,
		Read:   resourceComputeWireGroupRead,
		Update: resourceComputeWireGroupUpdate,
		Delete: resourceComputeWireGroupDelete,

		Importer: &schema.ResourceImporter{
			State: resourceComputeWireGroupImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"cross_site_network": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"cross_site_network": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareResourceNames,
				Description:      `Required cross site network to which wire group belongs.`,
			},
			"name": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: verify.ValidateRegexp(`^[a-z]([-a-z0-9]*[a-z0-9])?$`),
				Description: `Name of the resource. Provided by the client when the resource is created. The name must be
1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters
long and match the regular expression '[a-z]([-a-z0-9]*[a-z0-9])?' which means the first
character must be a lowercase letter, and all following characters must be a dash,
lowercase letter, or digit, except the last character, which cannot be a dash.`,
			},
			"admin_enabled": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Indicates whether the wire group is administratively enabled.`,
				Default:     true,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An optional description of this resource. Provide this property when you create the resource.`,
			},
			"endpoints": {
				Type:        schema.TypeSet,
				Optional:    true,
				Description: `Endpoints grouped by location, each mapping to interconnect configurations.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"endpoint": {
							Type:     schema.TypeString,
							Required: true,
						},
						"interconnects": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: ``,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"interconnect_name": {
										Type:     schema.TypeString,
										Required: true,
									},
									"interconnect": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: ``,
									},
									"vlan_tags": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `VLAN tags for the interconnect.`,
										Elem: &schema.Schema{
											Type: schema.TypeInt,
										},
									},
								},
							},
						},
					},
				},
			},
			"wire_properties": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Default properties for wires within the group.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bandwidth_allocation": {
							Type:     schema.TypeString,
							Required: true,
							Description: `The configuration of a wire's bandwidth allocation.
ALLOCATE_PER_WIRE: configures a separate unmetered bandwidth allocation (and associated charges) for each wire in the group.
SHARED_WITH_WIRE_GROUP: this is the default behavior, which configures one unmetered bandwidth allocation for the wire group. The unmetered bandwidth is divided equally across each wire in the group, but dynamic
throttling reallocates unused unmetered bandwidth from unused or underused wires to other wires in the group.`,
						},
						"bandwidth_unmetered": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `The unmetered bandwidth setting.`,
						},
						"fault_response": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `Response when a fault is detected in a pseudowire:
NONE: default.
DISABLE_PORT: set the port line protocol down when inline probes detect a fault. This setting is only permitted on port mode pseudowires.`,
						},
					},
				},
			},
			"creation_timestamp": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Creation timestamp in RFC3339 text format.`,
			},
			"topology": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Topology details for the wire group configuration.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"endpoints": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: ``,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"city": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: ``,
									},
									"label": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: ``,
									},
								},
							},
						},
					},
				},
			},
			"wires": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The single/redundant wire(s) managed by the wire group.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"admin_enabled": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: ``,
						},
						"endpoints": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `'Wire endpoints are specific Interconnect connections.'`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"interconnect": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: ``,
									},
									"vlan_tag": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: ``,
									},
								},
							},
						},
						"label": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: ``,
						},
						"wire_properties": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `A nested object resource.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"bandwidth_unmetered": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: ``,
									},
									"fault_response": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: ``,
									},
								},
							},
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceComputeWireGroupCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandComputeWireGroupDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	nameProp, err := expandComputeWireGroupName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	endpointsProp, err := expandComputeWireGroupEndpoints(d.Get("endpoints"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("endpoints"); !tpgresource.IsEmptyValue(reflect.ValueOf(endpointsProp)) && (ok || !reflect.DeepEqual(v, endpointsProp)) {
		obj["endpoints"] = endpointsProp
	}
	adminEnabledProp, err := expandComputeWireGroupAdminEnabled(d.Get("admin_enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("admin_enabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(adminEnabledProp)) && (ok || !reflect.DeepEqual(v, adminEnabledProp)) {
		obj["adminEnabled"] = adminEnabledProp
	}
	wirePropertiesProp, err := expandComputeWireGroupWireProperties(d.Get("wire_properties"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("wire_properties"); !tpgresource.IsEmptyValue(reflect.ValueOf(wirePropertiesProp)) && (ok || !reflect.DeepEqual(v, wirePropertiesProp)) {
		obj["wireProperties"] = wirePropertiesProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/crossSiteNetworks/{{cross_site_network}}/wireGroups")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new WireGroup: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for WireGroup: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating WireGroup: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/global/crossSiteNetworks/{{cross_site_network}}/wireGroups/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if crossSiteNetworkValue, ok := d.GetOk("cross_site_network"); ok && crossSiteNetworkValue.(string) != "" {
			if err = identity.Set("cross_site_network", crossSiteNetworkValue.(string)); err != nil {
				return fmt.Errorf("Error setting cross_site_network: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = ComputeOperationWaitTime(
		config, res, project, "Creating WireGroup", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create WireGroup: %s", err)
	}

	log.Printf("[DEBUG] Finished creating WireGroup %q: %#v", d.Id(), res)

	return resourceComputeWireGroupRead(d, meta)
}

func resourceComputeWireGroupRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/crossSiteNetworks/{{cross_site_network}}/wireGroups/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for WireGroup: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ComputeWireGroup %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading WireGroup: %s", err)
	}

	if err := d.Set("description", flattenComputeWireGroupDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading WireGroup: %s", err)
	}
	if err := d.Set("creation_timestamp", flattenComputeWireGroupCreationTimestamp(res["creationTimestamp"], d, config)); err != nil {
		return fmt.Errorf("Error reading WireGroup: %s", err)
	}
	if err := d.Set("name", flattenComputeWireGroupName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading WireGroup: %s", err)
	}
	if err := d.Set("endpoints", flattenComputeWireGroupEndpoints(res["endpoints"], d, config)); err != nil {
		return fmt.Errorf("Error reading WireGroup: %s", err)
	}
	if err := d.Set("admin_enabled", flattenComputeWireGroupAdminEnabled(res["adminEnabled"], d, config)); err != nil {
		return fmt.Errorf("Error reading WireGroup: %s", err)
	}
	if err := d.Set("wire_properties", flattenComputeWireGroupWireProperties(res["wireProperties"], d, config)); err != nil {
		return fmt.Errorf("Error reading WireGroup: %s", err)
	}
	if err := d.Set("wires", flattenComputeWireGroupWires(res["wires"], d, config)); err != nil {
		return fmt.Errorf("Error reading WireGroup: %s", err)
	}
	if err := d.Set("topology", flattenComputeWireGroupTopology(res["topology"], d, config)); err != nil {
		return fmt.Errorf("Error reading WireGroup: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("name"); !ok && v == "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("cross_site_network"); !ok && v == "" {
			err = identity.Set("cross_site_network", d.Get("cross_site_network").(string))
			if err != nil {
				return fmt.Errorf("Error setting cross_site_network: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceComputeWireGroupUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if crossSiteNetworkValue, ok := d.GetOk("cross_site_network"); ok && crossSiteNetworkValue.(string) != "" {
			if err = identity.Set("cross_site_network", crossSiteNetworkValue.(string)); err != nil {
				return fmt.Errorf("Error setting cross_site_network: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for WireGroup: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandComputeWireGroupDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	nameProp, err := expandComputeWireGroupName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	endpointsProp, err := expandComputeWireGroupEndpoints(d.Get("endpoints"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("endpoints"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, endpointsProp)) {
		obj["endpoints"] = endpointsProp
	}
	adminEnabledProp, err := expandComputeWireGroupAdminEnabled(d.Get("admin_enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("admin_enabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, adminEnabledProp)) {
		obj["adminEnabled"] = adminEnabledProp
	}
	wirePropertiesProp, err := expandComputeWireGroupWireProperties(d.Get("wire_properties"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("wire_properties"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, wirePropertiesProp)) {
		obj["wireProperties"] = wirePropertiesProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/crossSiteNetworks/{{cross_site_network}}/wireGroups/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating WireGroup %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("name") {
		updateMask = append(updateMask, "name")
	}

	if d.HasChange("endpoints") {
		updateMask = append(updateMask, "endpoints")
	}

	if d.HasChange("admin_enabled") {
		updateMask = append(updateMask, "adminEnabled")
	}

	if d.HasChange("wire_properties") {
		updateMask = append(updateMask, "wireProperties")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating WireGroup %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating WireGroup %q: %#v", d.Id(), res)
		}

		err = ComputeOperationWaitTime(
			config, res, project, "Updating WireGroup", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceComputeWireGroupRead(d, meta)
}

func resourceComputeWireGroupDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for WireGroup: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/crossSiteNetworks/{{cross_site_network}}/wireGroups/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting WireGroup %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "WireGroup")
	}

	err = ComputeOperationWaitTime(
		config, res, project, "Deleting WireGroup", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting WireGroup %q: %#v", d.Id(), res)
	return nil
}

func resourceComputeWireGroupImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/global/crossSiteNetworks/(?P<cross_site_network>[^/]+)/wireGroups/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<cross_site_network>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<cross_site_network>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/global/crossSiteNetworks/{{cross_site_network}}/wireGroups/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenComputeWireGroupDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupCreationTimestamp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupEndpoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"endpoint":      k,
			"interconnects": flattenComputeWireGroupEndpointsInterconnects(original["interconnects"], d, config),
		})
	}
	return transformed
}
func flattenComputeWireGroupEndpointsInterconnects(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"interconnect_name": k,
			"interconnect":      flattenComputeWireGroupEndpointsInterconnectsInterconnect(original["interconnect"], d, config),
			"vlan_tags":         flattenComputeWireGroupEndpointsInterconnectsVlanTags(original["vlanTags"], d, config),
		})
	}
	return transformed
}
func flattenComputeWireGroupEndpointsInterconnectsInterconnect(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupEndpointsInterconnectsVlanTags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupAdminEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupWireProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["bandwidth_unmetered"] =
		flattenComputeWireGroupWirePropertiesBandwidthUnmetered(original["bandwidthUnmetered"], d, config)
	transformed["fault_response"] =
		flattenComputeWireGroupWirePropertiesFaultResponse(original["faultResponse"], d, config)
	transformed["bandwidth_allocation"] =
		flattenComputeWireGroupWirePropertiesBandwidthAllocation(original["bandwidthAllocation"], d, config)
	return []interface{}{transformed}
}
func flattenComputeWireGroupWirePropertiesBandwidthUnmetered(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeWireGroupWirePropertiesFaultResponse(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupWirePropertiesBandwidthAllocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupWires(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"label":           flattenComputeWireGroupWiresLabel(original["label"], d, config),
			"endpoints":       flattenComputeWireGroupWiresEndpoints(original["endpoints"], d, config),
			"wire_properties": flattenComputeWireGroupWiresWireProperties(original["wireProperties"], d, config),
			"admin_enabled":   flattenComputeWireGroupWiresAdminEnabled(original["adminEnabled"], d, config),
		})
	}
	return transformed
}
func flattenComputeWireGroupWiresLabel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupWiresEndpoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"interconnect": flattenComputeWireGroupWiresEndpointsInterconnect(original["interconnect"], d, config),
			"vlan_tag":     flattenComputeWireGroupWiresEndpointsVlanTag(original["vlanTag"], d, config),
		})
	}
	return transformed
}
func flattenComputeWireGroupWiresEndpointsInterconnect(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupWiresEndpointsVlanTag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeWireGroupWiresWireProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["bandwidth_unmetered"] =
		flattenComputeWireGroupWiresWirePropertiesBandwidthUnmetered(original["bandwidthUnmetered"], d, config)
	transformed["fault_response"] =
		flattenComputeWireGroupWiresWirePropertiesFaultResponse(original["faultResponse"], d, config)
	return []interface{}{transformed}
}
func flattenComputeWireGroupWiresWirePropertiesBandwidthUnmetered(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeWireGroupWiresWirePropertiesFaultResponse(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupWiresAdminEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupTopology(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["endpoints"] =
		flattenComputeWireGroupTopologyEndpoints(original["endpoints"], d, config)
	return []interface{}{transformed}
}
func flattenComputeWireGroupTopologyEndpoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"label": flattenComputeWireGroupTopologyEndpointsLabel(original["label"], d, config),
			"city":  flattenComputeWireGroupTopologyEndpointsCity(original["city"], d, config),
		})
	}
	return transformed
}
func flattenComputeWireGroupTopologyEndpointsLabel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeWireGroupTopologyEndpointsCity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandComputeWireGroupDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeWireGroupName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeWireGroupEndpoints(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedInterconnects, err := expandComputeWireGroupEndpointsInterconnects(original["interconnects"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInterconnects); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["interconnects"] = transformedInterconnects
		}

		transformedEndpoint, err := tpgresource.ExpandString(original["endpoint"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedEndpoint] = transformed
	}
	return m, nil
}

func expandComputeWireGroupEndpointsInterconnects(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedInterconnect, err := expandComputeWireGroupEndpointsInterconnectsInterconnect(original["interconnect"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInterconnect); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["interconnect"] = transformedInterconnect
		}

		transformedVlanTags, err := expandComputeWireGroupEndpointsInterconnectsVlanTags(original["vlan_tags"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVlanTags); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["vlanTags"] = transformedVlanTags
		}

		transformedInterconnectName, err := tpgresource.ExpandString(original["interconnect_name"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedInterconnectName] = transformed
	}
	return m, nil
}

func expandComputeWireGroupEndpointsInterconnectsInterconnect(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeWireGroupEndpointsInterconnectsVlanTags(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeWireGroupAdminEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeWireGroupWireProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBandwidthUnmetered, err := expandComputeWireGroupWirePropertiesBandwidthUnmetered(original["bandwidth_unmetered"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBandwidthUnmetered); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bandwidthUnmetered"] = transformedBandwidthUnmetered
	}

	transformedFaultResponse, err := expandComputeWireGroupWirePropertiesFaultResponse(original["fault_response"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFaultResponse); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["faultResponse"] = transformedFaultResponse
	}

	transformedBandwidthAllocation, err := expandComputeWireGroupWirePropertiesBandwidthAllocation(original["bandwidth_allocation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBandwidthAllocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bandwidthAllocation"] = transformedBandwidthAllocation
	}

	return transformed, nil
}

func expandComputeWireGroupWirePropertiesBandwidthUnmetered(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeWireGroupWirePropertiesFaultResponse(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeWireGroupWirePropertiesBandwidthAllocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
