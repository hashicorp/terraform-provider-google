// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package compute

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceComputeResizeRequest() *schema.Resource {
	return &schema.Resource{
		Create: resourceComputeResizeRequestCreate,
		Read:   resourceComputeResizeRequestRead,
		Delete: resourceComputeResizeRequestDelete,

		Importer: &schema.ResourceImporter{
			State: resourceComputeResizeRequestImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"instance_group_manager": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description: `The name of the managed instance group. The name should conform to RFC1035 or be a resource ID.
Authorization requires the following IAM permission on the specified resource instanceGroupManager:
*compute.instanceGroupManagers.update`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of this resize request. The name must be 1-63 characters long, and comply with RFC1035.`,
			},
			"resize_by": {
				Type:        schema.TypeInt,
				Required:    true,
				ForceNew:    true,
				Description: `The number of instances to be created by this resize request. The group's target size will be increased by this number.`,
			},
			"zone": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description:      `Name of the compute zone scoping this request. Name should conform to RFC1035.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `An optional description of this resize-request.`,
			},
			"requested_run_duration": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Requested run duration for instances that will be created by this request. At the end of the run duration instance will be deleted.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"seconds": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years`,
						},
						"nanos": {
							Type:        schema.TypeInt,
							Optional:    true,
							ForceNew:    true,
							Description: `Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.`,
						},
					},
				},
			},
			"creation_timestamp": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The creation timestamp for this resize request in RFC3339 text format.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `[Output only] Current state of the request.`,
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `[Output only] Status of the request.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"error": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `[Output only] Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"errors": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `[Output Only] The array of errors encountered while processing this operation.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"code": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `[Output Only] The error type identifier for this error.`,
												},
												"error_details": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `[Output Only] An optional list of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"error_info": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `[Output Only]`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"domain": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com". If the error is generated by some common infrastructure, the error domain must be a globally unique value that identifies the infrastructure. For Google API infrastructure, the error domain is "googleapis.com".`,
																		},
																		"metadatas": {
																			Type:     schema.TypeMap,
																			Computed: true,
																			Description: `Additional structured details about this error.
Keys must match /[a-z][a-zA-Z0-9-_]+/ but should ideally be lowerCamelCase. Also they must be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {"instanceLimit": "100/request"}, should be returned as, {"instanceLimitPerRequest": "100"}, if the client exceeds the number of instances that can be created in a single (batch) request.`,
																			Elem: &schema.Schema{Type: schema.TypeString},
																		},
																		"reason": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors. This should be at most 63 characters and match a regular expression of [A-Z][A-Z0-9_]+[A-Z0-9], which represents UPPER_SNAKE_CASE.`,
																		},
																	},
																},
															},
															"help": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `[Output Only]`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"links": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `[Output Only]`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"description": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `Describes what the link offers.`,
																					},
																					"url": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The URL of the link.`,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"localized_message": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `[Output Only]`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"locale": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"`,
																		},
																		"message": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The localized error message in the above locale.`,
																		},
																	},
																},
															},
															"quota_info": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `[Output Only]`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"dimensions": {
																			Type:        schema.TypeMap,
																			Computed:    true,
																			Description: `The map holding related quota dimensions`,
																			Elem:        &schema.Schema{Type: schema.TypeString},
																		},
																		"future_limit": {
																			Type:        schema.TypeInt,
																			Computed:    true,
																			Description: `Future quota limit being rolled out. The limit's unit depends on the quota type or metric.`,
																		},
																		"limit": {
																			Type:        schema.TypeInt,
																			Computed:    true,
																			Description: `Current effective quota limit. The limit's unit depends on the quota type or metric.`,
																		},
																		"limit_name": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The name of the quota limit.`,
																		},
																		"metric_name": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The Compute Engine quota metric name.`,
																		},
																		"rollout_status": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `Rollout status of the future quota limit.`,
																		},
																	},
																},
															},
														},
													},
												},
												"location": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Output Only] Indicates the field in the request that caused the error. This property is optional.`,
												},
												"message": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `[Output Only] An optional, human-readable error message.`,
												},
											},
										},
									},
								},
							},
						},
						"last_attempt": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `[Output only] Information about the last attempt to fulfill the request. The value is temporary since the ResizeRequest can retry, as long as it's still active and the last attempt value can either be cleared or replaced with a different error. Since ResizeRequest retries infrequently, the value may be stale and no longer show an active problem. The value is cleared when ResizeRequest transitions to the final state (becomes inactive). If the final state is FAILED the error describing it will be storred in the "error" field only.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"error": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `[Output only] Fatal errors encountered during the queueing or provisioning phases of the ResizeRequest that caused the transition to the FAILED state. Contrary to the lastAttempt errors, this field is final and errors are never removed from here, as the ResizeRequest is not going to retry.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"errors": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `[Output Only] The array of errors encountered while processing this operation.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"code": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `[Output Only] The error type identifier for this error.`,
															},
															"error_details": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `[Output Only] An optional list of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"error_info": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `[Output Only]`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"domain": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com". If the error is generated by some common infrastructure, the error domain must be a globally unique value that identifies the infrastructure. For Google API infrastructure, the error domain is "googleapis.com".`,
																					},
																					"metadatas": {
																						Type:     schema.TypeMap,
																						Computed: true,
																						Description: `Additional structured details about this error.
Keys must match /[a-z][a-zA-Z0-9-_]+/ but should ideally be lowerCamelCase. Also they must be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {"instanceLimit": "100/request"}, should be returned as, {"instanceLimitPerRequest": "100"}, if the client exceeds the number of instances that can be created in a single (batch) request.`,
																						Elem: &schema.Schema{Type: schema.TypeString},
																					},
																					"reason": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors. This should be at most 63 characters and match a regular expression of [A-Z][A-Z0-9_]+[A-Z0-9], which represents UPPER_SNAKE_CASE.`,
																					},
																				},
																			},
																		},
																		"help": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `[Output Only]`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"links": {
																						Type:        schema.TypeList,
																						Computed:    true,
																						Description: `[Output Only]`,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"description": {
																									Type:        schema.TypeString,
																									Computed:    true,
																									Description: `Describes what the link offers.`,
																								},
																								"url": {
																									Type:        schema.TypeString,
																									Computed:    true,
																									Description: `The URL of the link.`,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"localized_message": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `[Output Only]`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"locale": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"`,
																					},
																					"message": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The localized error message in the above locale.`,
																					},
																				},
																			},
																		},
																		"quota_info": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `[Output Only]`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"dimensions": {
																						Type:        schema.TypeMap,
																						Computed:    true,
																						Description: `The map holding related quota dimensions`,
																						Elem:        &schema.Schema{Type: schema.TypeString},
																					},
																					"future_limit": {
																						Type:        schema.TypeInt,
																						Computed:    true,
																						Description: `Future quota limit being rolled out. The limit's unit depends on the quota type or metric.`,
																					},
																					"limit": {
																						Type:        schema.TypeInt,
																						Computed:    true,
																						Description: `Current effective quota limit. The limit's unit depends on the quota type or metric.`,
																					},
																					"limit_name": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The name of the quota limit.`,
																					},
																					"metric_name": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The Compute Engine quota metric name.`,
																					},
																					"rollout_status": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `Rollout status of the future quota limit.`,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"location": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Output Only] Indicates the field in the request that caused the error. This property is optional.`,
															},
															"message": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `[Output Only] An optional, human-readable error message.`,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceComputeResizeRequestCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandComputeResizeRequestName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	descriptionProp, err := expandComputeResizeRequestDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	resizeByProp, err := expandComputeResizeRequestResizeBy(d.Get("resize_by"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("resize_by"); !tpgresource.IsEmptyValue(reflect.ValueOf(resizeByProp)) && (ok || !reflect.DeepEqual(v, resizeByProp)) {
		obj["resizeBy"] = resizeByProp
	}
	requestedRunDurationProp, err := expandComputeResizeRequestRequestedRunDuration(d.Get("requested_run_duration"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("requested_run_duration"); !tpgresource.IsEmptyValue(reflect.ValueOf(requestedRunDurationProp)) && (ok || !reflect.DeepEqual(v, requestedRunDurationProp)) {
		obj["requestedRunDuration"] = requestedRunDurationProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new ResizeRequest: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ResizeRequest: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating ResizeRequest: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/zones/{{zone}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = ComputeOperationWaitTime(
		config, res, project, "Creating ResizeRequest", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create ResizeRequest: %s", err)
	}

	log.Printf("[DEBUG] Finished creating ResizeRequest %q: %#v", d.Id(), res)

	return resourceComputeResizeRequestRead(d, meta)
}

func resourceComputeResizeRequestRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ResizeRequest: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ComputeResizeRequest %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading ResizeRequest: %s", err)
	}

	if err := d.Set("creation_timestamp", flattenComputeResizeRequestCreationTimestamp(res["creationTimestamp"], d, config)); err != nil {
		return fmt.Errorf("Error reading ResizeRequest: %s", err)
	}
	if err := d.Set("state", flattenComputeResizeRequestState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading ResizeRequest: %s", err)
	}
	if err := d.Set("name", flattenComputeResizeRequestName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading ResizeRequest: %s", err)
	}
	if err := d.Set("description", flattenComputeResizeRequestDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading ResizeRequest: %s", err)
	}
	if err := d.Set("resize_by", flattenComputeResizeRequestResizeBy(res["resizeBy"], d, config)); err != nil {
		return fmt.Errorf("Error reading ResizeRequest: %s", err)
	}
	if err := d.Set("requested_run_duration", flattenComputeResizeRequestRequestedRunDuration(res["requestedRunDuration"], d, config)); err != nil {
		return fmt.Errorf("Error reading ResizeRequest: %s", err)
	}
	if err := d.Set("status", flattenComputeResizeRequestStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading ResizeRequest: %s", err)
	}

	return nil
}

func resourceComputeResizeRequestDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	// Get project id
	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for resize request: %s", err)
	}

	// Get cancel url
	var cancelUrl string
	cancelUrl, err = tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests/{{name}}/cancel")

	if err != nil {
		return err
	}

	// Get delete url
	var deleteUrl string
	deleteUrl, err = tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/zones/{{zone}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests/{{name}}")
	if err != nil {
		return err
	}

	// Get current state (accepted or not) and delete
	if d.Get("state") == "ACCEPTED" {
		// cancel resize request
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "POST",
			Project:   project,
			RawURL:    cancelUrl,
			UserAgent: userAgent,
			Timeout:   d.Timeout(schema.TimeoutDelete),
		})

		if err != nil {
			return transport_tpg.HandleNotFoundError(err, d, "ResizeRequest")
		}

		err = ComputeOperationWaitTime(
			config, res, project, "Cancelling the resize request", userAgent,
			d.Timeout(schema.TimeoutDelete))

		if err != nil {
			return err
		}
	}

	// delete resize request
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   project,
		RawURL:    deleteUrl,
		UserAgent: userAgent,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})

	err = ComputeOperationWaitTime(
		config, res, project, "Cancelling the resize request", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}
	return nil
}

func resourceComputeResizeRequestImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/zones/(?P<zone>[^/]+)/instanceGroupManagers/(?P<instance_group_manager>[^/]+)/resizeRequests/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<zone>[^/]+)/(?P<instance_group_manager>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<zone>[^/]+)/(?P<instance_group_manager>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<instance_group_manager>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/zones/{{zone}}/instanceGroupManagers/{{instance_group_manager}}/resizeRequests/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenComputeResizeRequestCreationTimestamp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestResizeBy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeResizeRequestRequestedRunDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["seconds"] =
		flattenComputeResizeRequestRequestedRunDurationSeconds(original["seconds"], d, config)
	transformed["nanos"] =
		flattenComputeResizeRequestRequestedRunDurationNanos(original["nanos"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestRequestedRunDurationSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestRequestedRunDurationNanos(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeResizeRequestStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error"] =
		flattenComputeResizeRequestStatusError(original["error"], d, config)
	transformed["last_attempt"] =
		flattenComputeResizeRequestStatusLastAttempt(original["lastAttempt"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusError(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["errors"] =
		flattenComputeResizeRequestStatusErrorErrors(original["errors"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusErrorErrors(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["code"] =
		flattenComputeResizeRequestStatusErrorErrorsCode(original["code"], d, config)
	transformed["location"] =
		flattenComputeResizeRequestStatusErrorErrorsLocation(original["location"], d, config)
	transformed["message"] =
		flattenComputeResizeRequestStatusErrorErrorsMessage(original["message"], d, config)
	transformed["error_details"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetails(original["errorDetails"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusErrorErrorsCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error_info"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsErrorInfo(original["errorInfo"], d, config)
	transformed["quota_info"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfo(original["quotaInfo"], d, config)
	transformed["help"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsHelp(original["help"], d, config)
	transformed["localized_message"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessage(original["localizedMessage"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsErrorInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["reason"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsErrorInfoReason(original["reason"], d, config)
	transformed["domain"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsErrorInfoDomain(original["domain"], d, config)
	transformed["metadatas"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsErrorInfoMetadatas(original["metadatas"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsErrorInfoReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsErrorInfoDomain(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsErrorInfoMetadatas(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["metric_name"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoMetricName(original["metricName"], d, config)
	transformed["limit_name"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoLimitName(original["limitName"], d, config)
	transformed["dimensions"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoDimensions(original["dimensions"], d, config)
	transformed["limit"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoLimit(original["limit"], d, config)
	transformed["future_limit"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoFutureLimit(original["futureLimit"], d, config)
	transformed["rollout_status"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoRolloutStatus(original["rolloutStatus"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoMetricName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoLimitName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoDimensions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoLimit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoFutureLimit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsQuotaInfoRolloutStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsHelp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["links"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsHelpLinks(original["links"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsHelpLinks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsHelpLinksDescription(original["description"], d, config)
	transformed["url"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsHelpLinksUrl(original["url"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsHelpLinksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsHelpLinksUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["locale"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessageLocale(original["locale"], d, config)
	transformed["message"] =
		flattenComputeResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessageMessage(original["message"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessageLocale(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusErrorErrorsErrorDetailsLocalizedMessageMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttempt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error"] =
		flattenComputeResizeRequestStatusLastAttemptError(original["error"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusLastAttemptError(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["errors"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrors(original["errors"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusLastAttemptErrorErrors(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["code"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsCode(original["code"], d, config)
	transformed["location"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsLocation(original["location"], d, config)
	transformed["message"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsMessage(original["message"], d, config)
	transformed["error_details"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetails(original["errorDetails"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusLastAttemptErrorErrorsCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["error_info"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfo(original["errorInfo"], d, config)
	transformed["quota_info"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfo(original["quotaInfo"], d, config)
	transformed["help"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelp(original["help"], d, config)
	transformed["localized_message"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessage(original["localizedMessage"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["reason"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoReason(original["reason"], d, config)
	transformed["domain"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoDomain(original["domain"], d, config)
	transformed["metadatas"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoMetadatas(original["metadatas"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoDomain(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsErrorInfoMetadatas(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["metric_name"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoMetricName(original["metricName"], d, config)
	transformed["limit_name"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoLimitName(original["limitName"], d, config)
	transformed["dimensions"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoDimensions(original["dimensions"], d, config)
	transformed["limit"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoLimit(original["limit"], d, config)
	transformed["future_limit"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoFutureLimit(original["futureLimit"], d, config)
	transformed["rollout_status"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoRolloutStatus(original["rolloutStatus"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoMetricName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoLimitName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoDimensions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoLimit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoFutureLimit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsQuotaInfoRolloutStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["links"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinks(original["links"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinksDescription(original["description"], d, config)
	transformed["url"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinksUrl(original["url"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsHelpLinksUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["locale"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessageLocale(original["locale"], d, config)
	transformed["message"] =
		flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessageMessage(original["message"], d, config)
	return []interface{}{transformed}
}
func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessageLocale(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeResizeRequestStatusLastAttemptErrorErrorsErrorDetailsLocalizedMessageMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandComputeResizeRequestName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeResizeRequestDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeResizeRequestResizeBy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeResizeRequestRequestedRunDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSeconds, err := expandComputeResizeRequestRequestedRunDurationSeconds(original["seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["seconds"] = transformedSeconds
	}

	transformedNanos, err := expandComputeResizeRequestRequestedRunDurationNanos(original["nanos"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNanos); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nanos"] = transformedNanos
	}

	return transformed, nil
}

func expandComputeResizeRequestRequestedRunDurationSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeResizeRequestRequestedRunDurationNanos(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
