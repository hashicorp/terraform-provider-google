// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/compute/data_source_google_compute_routers.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package compute

import (
	"fmt"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func DataSourceGoogleComputeRouters() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceGoogleComputeRoutersRead,
		Schema: map[string]*schema.Schema{
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"region": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"routers": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"network": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"description": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"creation_timestamp": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"self_link": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"bgp": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"asn": {
										Type:     schema.TypeInt,
										Computed: true,
									},
									"advertise_mode": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"advertised_groups": {
										Type:     schema.TypeList,
										Computed: true,
										Elem:     &schema.Schema{Type: schema.TypeString},
									},
									"advertised_ip_ranges": {
										Type:     schema.TypeList,
										Computed: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"range": {
													Type:     schema.TypeString,
													Computed: true,
												},
												"description": {
													Type:     schema.TypeString,
													Computed: true,
												},
											},
										},
									},
									"keepalive_interval": {
										Type:     schema.TypeInt,
										Computed: true,
									},
								},
							},
						},
						"interfaces": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"linked_vpn_tunnel": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"linked_interconnect_attachment": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"ip_range": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"private_ip_address": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"redundant_interface": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"subnetwork": {
										Type:     schema.TypeString,
										Computed: true,
									},
								},
							},
						},
						"bgp_peers": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"interface_name": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"ip_address": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"peer_ip_address": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"peer_asn": {
										Type:     schema.TypeInt,
										Computed: true,
									},
									"advertised_route_priority": {
										Type:     schema.TypeInt,
										Computed: true,
									},
									"advertise_mode": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"management_type": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"enable": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"enable_ipv6": {
										Type:     schema.TypeBool,
										Computed: true,
									},
								},
							},
						},
						"nats": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"source_subnetwork_ip_ranges_to_nat": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"nat_ip_allocate_option": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"nat_ips": {
										Type:     schema.TypeList,
										Computed: true,
										Elem:     &schema.Schema{Type: schema.TypeString},
									},
									"min_ports_per_vm": {
										Type:     schema.TypeInt,
										Computed: true,
									},
									"udp_idle_timeout_sec": {
										Type:     schema.TypeInt,
										Computed: true,
									},
									"icmp_idle_timeout_sec": {
										Type:     schema.TypeInt,
										Computed: true,
									},
									"tcp_established_idle_timeout_sec": {
										Type:     schema.TypeInt,
										Computed: true,
									},
									"tcp_transitory_idle_timeout_sec": {
										Type:     schema.TypeInt,
										Computed: true,
									},
									"enable_endpoint_independent_mapping": {
										Type:     schema.TypeBool,
										Computed: true,
									},
								},
							},
						},
						"encrypted_interconnect_router": {
							Type:     schema.TypeBool,
							Computed: true,
						},
						"md5_authentication_keys": {
							Type:     schema.TypeList,
							Computed: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:     schema.TypeString,
										Computed: true,
									},
									"key": {
										Type:      schema.TypeString,
										Computed:  true,
										Sensitive: true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func dataSourceGoogleComputeRoutersRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return err
	}

	region, err := tpgresource.GetRegion(d, config)
	if err != nil {
		return err
	}

	d.SetId(fmt.Sprintf("projects/%s/regions/%s", project, region))

	list, err := config.NewComputeClient(userAgent).Routers.List(project, region).Do()
	if err != nil {
		return fmt.Errorf("Error retrieving list of routers: %s", err)
	}

	var routers []map[string]interface{}
	for _, router := range list.Items {
		var bgpList []interface{}
		if router.Bgp != nil {
			var advertisedIpRanges []interface{}
			for _, ipRange := range router.Bgp.AdvertisedIpRanges {
				advertisedIpRanges = append(advertisedIpRanges, map[string]interface{}{
					"range":       ipRange.Range,
					"description": ipRange.Description,
				})
			}
			bgpList = []interface{}{
				map[string]interface{}{
					"asn":                  router.Bgp.Asn,
					"advertise_mode":       router.Bgp.AdvertiseMode,
					"advertised_groups":    router.Bgp.AdvertisedGroups,
					"advertised_ip_ranges": advertisedIpRanges,
					"keepalive_interval":   router.Bgp.KeepaliveInterval,
				},
			}
		}

		var interfaces []map[string]interface{}
		for _, iface := range router.Interfaces {
			interfaces = append(interfaces, map[string]interface{}{
				"name":                           iface.Name,
				"linked_vpn_tunnel":              iface.LinkedVpnTunnel,
				"linked_interconnect_attachment": iface.LinkedInterconnectAttachment,
				"ip_range":                       iface.IpRange,
				"private_ip_address":             iface.PrivateIpAddress,
				"redundant_interface":            iface.RedundantInterface,
				"subnetwork":                     iface.Subnetwork,
			})
		}

		var bgpPeers []map[string]interface{}
		for _, peer := range router.BgpPeers {
			bgpPeers = append(bgpPeers, map[string]interface{}{
				"name":                      peer.Name,
				"interface_name":            peer.InterfaceName,
				"ip_address":                peer.IpAddress,
				"peer_ip_address":           peer.PeerIpAddress,
				"peer_asn":                  peer.PeerAsn,
				"advertised_route_priority": peer.AdvertisedRoutePriority,
				"advertise_mode":            peer.AdvertiseMode,
				"management_type":           peer.ManagementType,
				"enable":                    peer.Enable,
				"enable_ipv6":               peer.EnableIpv6,
			})
		}

		var nats []map[string]interface{}
		for _, nat := range router.Nats {
			nats = append(nats, map[string]interface{}{
				"name":                                nat.Name,
				"source_subnetwork_ip_ranges_to_nat":  nat.SourceSubnetworkIpRangesToNat,
				"nat_ip_allocate_option":              nat.NatIpAllocateOption,
				"nat_ips":                             nat.NatIps,
				"min_ports_per_vm":                    nat.MinPortsPerVm,
				"udp_idle_timeout_sec":                nat.UdpIdleTimeoutSec,
				"icmp_idle_timeout_sec":               nat.IcmpIdleTimeoutSec,
				"tcp_established_idle_timeout_sec":    nat.TcpEstablishedIdleTimeoutSec,
				"tcp_transitory_idle_timeout_sec":     nat.TcpTransitoryIdleTimeoutSec,
				"enable_endpoint_independent_mapping": nat.EnableEndpointIndependentMapping,
			})
		}

		var md5AuthKeys []map[string]interface{}
		for _, key := range router.Md5AuthenticationKeys {
			md5AuthKeys = append(md5AuthKeys, map[string]interface{}{
				"name": key.Name,
				"key":  key.Key,
			})
		}

		routers = append(routers, map[string]interface{}{
			"name":                          router.Name,
			"network":                       router.Network,
			"description":                   router.Description,
			"creation_timestamp":            router.CreationTimestamp,
			"self_link":                     router.SelfLink,
			"bgp":                           bgpList,
			"interfaces":                    interfaces,
			"bgp_peers":                     bgpPeers,
			"nats":                          nats,
			"encrypted_interconnect_router": router.EncryptedInterconnectRouter,
			"md5_authentication_keys":       md5AuthKeys,
		})
	}

	if err := d.Set("routers", routers); err != nil {
		return fmt.Errorf("Error setting routers: %s", err)
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error setting project: %s", err)
	}

	if err := d.Set("region", region); err != nil {
		return fmt.Errorf("Error setting region: %s", err)
	}

	return nil
}
