// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/compute/InterconnectGroup.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package compute

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceComputeInterconnectGroup() *schema.Resource {
	return &schema.Resource{
		Create: resourceComputeInterconnectGroupCreate,
		Read:   resourceComputeInterconnectGroupRead,
		Update: resourceComputeInterconnectGroupUpdate,
		Delete: resourceComputeInterconnectGroupDelete,

		Importer: &schema.ResourceImporter{
			State: resourceComputeInterconnectGroupImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"intent": {
				Type:     schema.TypeList,
				Required: true,
				Description: `The user's intent for this group. This is the only required field besides
the name that must be specified on group creation.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"topology_capability": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"PRODUCTION_NON_CRITICAL", "PRODUCTION_CRITICAL", "NO_SLA", "AVAILABILITY_SLA_UNSPECIFIED", ""}),
							Description: `The reliability the user intends this group to be capable of, in terms
of the Interconnect product SLAs. Possible values: ["PRODUCTION_NON_CRITICAL", "PRODUCTION_CRITICAL", "NO_SLA", "AVAILABILITY_SLA_UNSPECIFIED"]`,
						},
					},
				},
			},
			"name": {
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateRegexp(`^[a-z]([-a-z0-9]*[a-z0-9])?$`),
				Description: `Name of the resource. Provided by the client when the resource is created. The name must be
1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters
long and match the regular expression '[a-z]([-a-z0-9]*[a-z0-9])?' which means the first
character must be a lowercase letter, and all following characters must be a dash,
lowercase letter, or digit, except the last character, which cannot be a dash.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An optional description of this resource. Provide this property when you create the resource.`,
			},
			"interconnects": {
				Type:     schema.TypeSet,
				Optional: true,
				Description: `Interconnects in the InterconnectGroup. Keys are arbitrary user-specified
strings. Users are encouraged, but not required, to use their preferred
format for resource links as keys.
Note that there are add-members and remove-members methods in gcloud.
The size of this map is limited by an "Interconnects per group" quota.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:     schema.TypeString,
							Required: true,
						},
						"interconnect": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The URL of an Interconnect in this group. All Interconnects in the group are unique.`,
						},
					},
				},
			},
			"configured": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `The status of the group as configured. This has the same
structure as the operational field reported by the OperationalStatus
method, but does not take into account the operational status of each
resource.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"topology_capability": {
							Type:     schema.TypeList,
							Computed: true,
							Description: `How reliable this topology is configured to be, and why
this group does or does not meet the requirements for the intended
capability.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"intended_capability_blockers": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Reasons why configuration.topologyCapability.sla differs
from intent.topologyCapability. This list is empty if and only if those
are the same.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"blocker_type": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The category of an unmet SLA requirement. The Intended
SLA Blockers section below explains this field and how it relates to
other fields in intendedCapabilityBlockers.`,
												},
												"documentation_link": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The url of Google Cloud public documentation explaining
this requirement. This is set for every type of requirement.`,
												},
												"explanation": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `A human-readable explanation of this requirement and
why it's not met. This is set for every type of requirement.`,
												},
												"facilities": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `Facilities used to explain this blocker in more detail.
Like physicalStructure.metros.facilities.facility, this is a numeric
string like "5467".`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"interconnects": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `Interconnects used to explain this blocker in more
detail.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"metros": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `Metros used to explain this blocker in more detail.
These are three-letter lowercase strings like "iad". A blocker like
INCOMPATIBLE_METROS will specify the problematic metros in this
field.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"zones": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `Zones used to explain this blocker in more detail.
Zone names are "zone1" and/or "zone2".`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"supported_sla": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Which level of reliability this group is configured to
support.`,
									},
								},
							},
						},
					},
				},
			},
			"creation_timestamp": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Creation timestamp in RFC3339 text format.`,
			},
			"physical_structure": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `An analysis of the physical layout of Interconnects in this
group. Every Interconnect in the group is shown once in this structure.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"metros": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The metros Interconnects in this group are in.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"facilities": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `The facilities Interconnects in this metro are present
in.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"facility": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The ID of this facility, as a numeric string like
"5467". This is the third component of the location of Interconnects
in this facility.`,
												},
												"zones": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `The zones that Interconnects in this facility are
present in.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"interconnects": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `URLs of Interconnects in this redundancy group in the
given metro, facility, and zone.`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"zone": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The name of the zone, either "zone1" or "zone2".
This is the second component of the location of Interconnects in
this facility.`,
															},
														},
													},
												},
											},
										},
									},
									"metro": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The name of the metro, as a three-letter lowercase string
like "iad". This is the first component of the location of
Interconnects underneath this.`,
									},
								},
							},
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceComputeInterconnectGroupCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandComputeInterconnectGroupDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	nameProp, err := expandComputeInterconnectGroupName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	interconnectsProp, err := expandComputeInterconnectGroupInterconnects(d.Get("interconnects"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("interconnects"); !tpgresource.IsEmptyValue(reflect.ValueOf(interconnectsProp)) && (ok || !reflect.DeepEqual(v, interconnectsProp)) {
		obj["interconnects"] = interconnectsProp
	}
	intentProp, err := expandComputeInterconnectGroupIntent(d.Get("intent"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("intent"); !tpgresource.IsEmptyValue(reflect.ValueOf(intentProp)) && (ok || !reflect.DeepEqual(v, intentProp)) {
		obj["intent"] = intentProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/interconnectGroups")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new InterconnectGroup: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InterconnectGroup: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating InterconnectGroup: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/global/interconnectGroups/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = ComputeOperationWaitTime(
		config, res, project, "Creating InterconnectGroup", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create InterconnectGroup: %s", err)
	}

	log.Printf("[DEBUG] Finished creating InterconnectGroup %q: %#v", d.Id(), res)

	return resourceComputeInterconnectGroupRead(d, meta)
}

func resourceComputeInterconnectGroupRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/interconnectGroups/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InterconnectGroup: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ComputeInterconnectGroup %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading InterconnectGroup: %s", err)
	}

	if err := d.Set("description", flattenComputeInterconnectGroupDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading InterconnectGroup: %s", err)
	}
	if err := d.Set("creation_timestamp", flattenComputeInterconnectGroupCreationTimestamp(res["creationTimestamp"], d, config)); err != nil {
		return fmt.Errorf("Error reading InterconnectGroup: %s", err)
	}
	if err := d.Set("name", flattenComputeInterconnectGroupName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading InterconnectGroup: %s", err)
	}
	if err := d.Set("interconnects", flattenComputeInterconnectGroupInterconnects(res["interconnects"], d, config)); err != nil {
		return fmt.Errorf("Error reading InterconnectGroup: %s", err)
	}
	if err := d.Set("intent", flattenComputeInterconnectGroupIntent(res["intent"], d, config)); err != nil {
		return fmt.Errorf("Error reading InterconnectGroup: %s", err)
	}
	if err := d.Set("physical_structure", flattenComputeInterconnectGroupPhysicalStructure(res["physicalStructure"], d, config)); err != nil {
		return fmt.Errorf("Error reading InterconnectGroup: %s", err)
	}
	if err := d.Set("configured", flattenComputeInterconnectGroupConfigured(res["configured"], d, config)); err != nil {
		return fmt.Errorf("Error reading InterconnectGroup: %s", err)
	}

	return nil
}

func resourceComputeInterconnectGroupUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InterconnectGroup: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandComputeInterconnectGroupDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	interconnectsProp, err := expandComputeInterconnectGroupInterconnects(d.Get("interconnects"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("interconnects"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, interconnectsProp)) {
		obj["interconnects"] = interconnectsProp
	}
	intentProp, err := expandComputeInterconnectGroupIntent(d.Get("intent"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("intent"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, intentProp)) {
		obj["intent"] = intentProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/interconnectGroups/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating InterconnectGroup %q: %#v", d.Id(), obj)
	headers := make(http.Header)

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "PATCH",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutUpdate),
		Headers:   headers,
	})

	if err != nil {
		return fmt.Errorf("Error updating InterconnectGroup %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating InterconnectGroup %q: %#v", d.Id(), res)
	}

	err = ComputeOperationWaitTime(
		config, res, project, "Updating InterconnectGroup", userAgent,
		d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return err
	}

	return resourceComputeInterconnectGroupRead(d, meta)
}

func resourceComputeInterconnectGroupDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InterconnectGroup: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/interconnectGroups/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting InterconnectGroup %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "InterconnectGroup")
	}

	err = ComputeOperationWaitTime(
		config, res, project, "Deleting InterconnectGroup", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting InterconnectGroup %q: %#v", d.Id(), res)
	return nil
}

func resourceComputeInterconnectGroupImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/global/interconnectGroups/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/global/interconnectGroups/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenComputeInterconnectGroupDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupCreationTimestamp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupInterconnects(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"name":         k,
			"interconnect": flattenComputeInterconnectGroupInterconnectsInterconnect(original["interconnect"], d, config),
		})
	}
	return transformed
}
func flattenComputeInterconnectGroupInterconnectsInterconnect(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupIntent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["topology_capability"] =
		flattenComputeInterconnectGroupIntentTopologyCapability(original["topologyCapability"], d, config)
	return []interface{}{transformed}
}
func flattenComputeInterconnectGroupIntentTopologyCapability(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupPhysicalStructure(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["metros"] =
		flattenComputeInterconnectGroupPhysicalStructureMetros(original["metros"], d, config)
	return []interface{}{transformed}
}
func flattenComputeInterconnectGroupPhysicalStructureMetros(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"metro":      flattenComputeInterconnectGroupPhysicalStructureMetrosMetro(original["metro"], d, config),
			"facilities": flattenComputeInterconnectGroupPhysicalStructureMetrosFacilities(original["facilities"], d, config),
		})
	}
	return transformed
}
func flattenComputeInterconnectGroupPhysicalStructureMetrosMetro(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupPhysicalStructureMetrosFacilities(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"facility": flattenComputeInterconnectGroupPhysicalStructureMetrosFacilitiesFacility(original["facility"], d, config),
			"zones":    flattenComputeInterconnectGroupPhysicalStructureMetrosFacilitiesZones(original["zones"], d, config),
		})
	}
	return transformed
}
func flattenComputeInterconnectGroupPhysicalStructureMetrosFacilitiesFacility(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupPhysicalStructureMetrosFacilitiesZones(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"zone":          flattenComputeInterconnectGroupPhysicalStructureMetrosFacilitiesZonesZone(original["zone"], d, config),
			"interconnects": flattenComputeInterconnectGroupPhysicalStructureMetrosFacilitiesZonesInterconnects(original["interconnects"], d, config),
		})
	}
	return transformed
}
func flattenComputeInterconnectGroupPhysicalStructureMetrosFacilitiesZonesZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupPhysicalStructureMetrosFacilitiesZonesInterconnects(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupConfigured(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["topology_capability"] =
		flattenComputeInterconnectGroupConfiguredTopologyCapability(original["topologyCapability"], d, config)
	return []interface{}{transformed}
}
func flattenComputeInterconnectGroupConfiguredTopologyCapability(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["supported_sla"] =
		flattenComputeInterconnectGroupConfiguredTopologyCapabilitySupportedSla(original["supportedSla"], d, config)
	transformed["intended_capability_blockers"] =
		flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockers(original["intendedCapabilityBlockers"], d, config)
	return []interface{}{transformed}
}
func flattenComputeInterconnectGroupConfiguredTopologyCapabilitySupportedSla(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"blocker_type":       flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersBlockerType(original["blockerType"], d, config),
			"explanation":        flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersExplanation(original["explanation"], d, config),
			"documentation_link": flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersDocumentationLink(original["documentationLink"], d, config),
			"metros":             flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersMetros(original["metros"], d, config),
			"facilities":         flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersFacilities(original["facilities"], d, config),
			"zones":              flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersZones(original["zones"], d, config),
			"interconnects":      flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersInterconnects(original["interconnects"], d, config),
		})
	}
	return transformed
}
func flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersBlockerType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersExplanation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersDocumentationLink(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersMetros(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersFacilities(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersZones(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenComputeInterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockersInterconnects(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandComputeInterconnectGroupDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeInterconnectGroupName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeInterconnectGroupInterconnects(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedInterconnect, err := expandComputeInterconnectGroupInterconnectsInterconnect(original["interconnect"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInterconnect); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["interconnect"] = transformedInterconnect
		}

		transformedName, err := tpgresource.ExpandString(original["name"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedName] = transformed
	}
	return m, nil
}

func expandComputeInterconnectGroupInterconnectsInterconnect(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandComputeInterconnectGroupIntent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTopologyCapability, err := expandComputeInterconnectGroupIntentTopologyCapability(original["topology_capability"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTopologyCapability); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["topologyCapability"] = transformedTopologyCapability
	}

	return transformed, nil
}

func expandComputeInterconnectGroupIntentTopologyCapability(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
