// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/storage/data_source_storage_bucket_object_contents.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package storage

import (
	"context"
	"crypto/sha512"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"io"
	"net/http"
	"sort"
	"time"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"google.golang.org/api/storage/v1"
)

func DataSourceGoogleStorageBucketObjectContents() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceGoogleStorageBucketObjectContentsRead,
		Schema: map[string]*schema.Schema{
			"bucket": {
				Type:     schema.TypeString,
				Required: true,
			},
			"match_glob": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"prefix": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"bucket_objects": {
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"content": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"content_base64": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"content_base64sha512": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"content_hexsha512": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"content_type": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"media_link": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"name": {
							Type:     schema.TypeString,
							Computed: true,
						},
						"self_link": {
							Type:     schema.TypeString,
							Computed: true,
						},
					},
				},
			},
		},
	}
}

func dataSourceGoogleStorageBucketObjectContentsRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	// Init result
	bucketObjects := make([]map[string]interface{}, 0)

	// Init ID
	var dataSourceId string

	// Get bucket name
	bucket := d.Get("bucket").(string)
	dataSourceId = fmt.Sprintf("bucket/%s", bucket)

	// Get optional parameters
	var matchGlob string
	if v, ok := d.GetOk("match_glob"); ok {
		matchGlob = v.(string)
		dataSourceId += fmt.Sprintf("/glob/%s", matchGlob)
	}
	var prefix string
	if v, ok := d.GetOk("prefix"); ok {
		prefix = v.(string)
		dataSourceId += fmt.Sprintf("/prefix/%s", prefix)
	}

	// Prepare API call
	objectsService := storage.NewObjectsService(config.NewStorageClient(userAgent))
	getObjectsCall := objectsService.List(bucket).Prefix(prefix).MatchGlob(matchGlob)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	// Request and paginate through results
	err = getObjectsCall.Pages(ctx, func(objectList *storage.Objects) error {
		for _, obj := range objectList.Items {
			// Get object metadata
			objectName := obj.Name
			objectContentType := obj.ContentType
			objectMediaLink := obj.MediaLink
			objectSelfLink := obj.SelfLink

			// Download object content
			getCall := objectsService.Get(bucket, objectName)
			res, err := getCall.Download()
			if err != nil {
				return fmt.Errorf("Error downloading storage bucket object: %s", err)
			}

			// Read object content
			var objectBytes []byte
			if res.StatusCode != http.StatusOK {
				res.Body.Close()
				return fmt.Errorf(
					"Error downloading storage bucket object %s: HTTP %d",
					objectName,
					res.StatusCode,
				)
			}

			bodyBytes, err := io.ReadAll(res.Body)
			res.Body.Close()
			if err != nil {
				return fmt.Errorf("Error reading storage bucket object %s: %s", objectName, err)
			}

			objectBytes = bodyBytes

			// Convert content
			content := string(objectBytes)
			contentBase64 := base64.StdEncoding.EncodeToString(objectBytes)
			sha512Sum := sha512.Sum512(objectBytes)
			contentBase64Sha512 := base64.StdEncoding.EncodeToString(sha512Sum[:])
			contentHexSha512 := hex.EncodeToString(sha512Sum[:])

			// Append to results
			bucketObjects = append(bucketObjects, map[string]interface{}{
				"content":              content,
				"content_base64":       contentBase64,
				"content_base64sha512": contentBase64Sha512,
				"content_hexsha512":    contentHexSha512,
				"content_type":         objectContentType,
				"media_link":           objectMediaLink,
				"name":                 objectName,
				"self_link":            objectSelfLink,
			})
		}
		return nil
	})

	if err != nil {
		return fmt.Errorf("Error retrieving bucket objects: %s", err)
	}

	// Sort bucket objects by name for consistent ordering and preventing noisy diffs
	sort.Slice(bucketObjects, func(i, j int) bool {
		return bucketObjects[i]["name"].(string) < bucketObjects[j]["name"].(string)
	})

	if err := d.Set("bucket_objects", bucketObjects); err != nil {
		return fmt.Errorf("Error setting bucket objects: %s", err)
	}

	d.SetId(dataSourceId)
	return nil
}
