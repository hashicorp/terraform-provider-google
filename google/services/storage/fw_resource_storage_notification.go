// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/storage/fw_resource_storage_notification.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package storage

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"google.golang.org/api/googleapi"
	"google.golang.org/api/storage/v1"

	"github.com/hashicorp/terraform-provider-google/google/fwmodels"
	"github.com/hashicorp/terraform-provider-google/google/fwresource"
	"github.com/hashicorp/terraform-provider-google/google/fwtransport"
	"github.com/hashicorp/terraform-provider-google/google/fwvalidators"
	"github.com/hashicorp/terraform-provider-google/google/services/pubsub"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

var (
	_ resource.Resource                 = &storageNotificationResource{}
	_ resource.ResourceWithConfigure    = &storageNotificationResource{}
	_ resource.ResourceWithImportState  = &storageNotificationResource{}
	_ resource.ResourceWithUpgradeState = &storageNotificationResource{}
)

func NewStorageNotificationResource() resource.Resource {
	return &storageNotificationResource{}
}

type storageNotificationResource struct {
	config *transport_tpg.Config
}

type storageNotificationModel struct {
	Bucket           types.String `tfsdk:"bucket"`
	PayloadFormat    types.String `tfsdk:"payload_format"`
	Topic            types.String `tfsdk:"topic"`
	CustomAttributes types.Map    `tfsdk:"custom_attributes"`
	EventTypes       types.Set    `tfsdk:"event_types"`
	ObjectNamePrefix types.String `tfsdk:"object_name_prefix"`
	NotificationID   types.String `tfsdk:"notification_id"`
	SelfLink         types.String `tfsdk:"self_link"`
	Id               types.String `tfsdk:"id"`
}

func (r *storageNotificationResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_storage_notification"
}

func (r *storageNotificationResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	config, ok := req.ProviderData.(*transport_tpg.Config)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *transport_tpg.Config, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.config = config
}

func (r *storageNotificationResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Creates a new notification configuration on a specified bucket, establishing a flow of event notifications from GCS to a Cloud Pub/Sub topic.",
		Version:     1,
		Attributes: map[string]schema.Attribute{
			"bucket": schema.StringAttribute{
				Required:    true,
				Description: "The name of the bucket.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"payload_format": schema.StringAttribute{
				Required:    true,
				Description: `The desired content of the Payload. One of "JSON_API_V1" or "NONE".`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("JSON_API_V1", "NONE"),
				},
			},
			"topic": schema.StringAttribute{
				Required:    true,
				Description: "The Cloud Pub/Sub topic to which this subscription publishes.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					fwvalidators.NewTopicPrefixValidator(),
				},
			},
			"custom_attributes": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Description: "A set of key/value attribute pairs to attach to each Cloud Pub/Sub message published for this notification subscription.",
				PlanModifiers: []planmodifier.Map{
					mapplanmodifier.RequiresReplace(),
				},
			},
			"event_types": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Description: `List of event type filters for this notification config. If not specified, Cloud Storage will send notifications for all event types. The valid types are: "OBJECT_FINALIZE", "OBJECT_METADATA_UPDATE", "OBJECT_DELETE", "OBJECT_ARCHIVE"`,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.RequiresReplace(),
				},
				Validators: []validator.Set{
					fwvalidators.StringValuesInSet(
						"OBJECT_FINALIZE",
						"OBJECT_METADATA_UPDATE",
						"OBJECT_DELETE",
						"OBJECT_ARCHIVE",
					),
				},
			},
			"object_name_prefix": schema.StringAttribute{
				Optional:    true,
				Description: "Specifies a prefix path filter for this notification config. Cloud Storage will only send notifications for objects in this bucket whose names begin with the specified prefix.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"notification_id": schema.StringAttribute{
				Computed:    true,
				Description: "The ID of the created notification.",
			},
			"self_link": schema.StringAttribute{
				Computed:    true,
				Description: "The URI of the created resource.",
			},
			"id": schema.StringAttribute{
				Computed: true,
			},
		},
	}
}

func (r *storageNotificationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan storageNotificationModel
	var metaData *fwmodels.ProviderMetaModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.ProviderMeta.Get(ctx, &metaData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	computedTopicName := pubsub.GetComputedTopicName("", plan.Topic.ValueString())

	var customAttrs map[string]string
	if !plan.CustomAttributes.IsNull() && !plan.CustomAttributes.IsUnknown() {
		resp.Diagnostics.Append(plan.CustomAttributes.ElementsAs(ctx, &customAttrs, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
	}

	var eventTypes []string
	if !plan.EventTypes.IsNull() && !plan.EventTypes.IsUnknown() {
		resp.Diagnostics.Append(plan.EventTypes.ElementsAs(ctx, &eventTypes, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
	}

	storageNotification := &storage.Notification{
		CustomAttributes: customAttrs,
		EventTypes:       eventTypes,
		ObjectNamePrefix: plan.ObjectNamePrefix.ValueString(),
		PayloadFormat:    plan.PayloadFormat.ValueString(),
		Topic:            computedTopicName,
	}

	userAgent := fwtransport.GenerateFrameworkUserAgentString(metaData, r.config.UserAgent)
	bucket := plan.Bucket.ValueString()

	res, err := r.config.NewStorageClient(userAgent).Notifications.Insert(bucket, storageNotification).Do()
	if err != nil {
		resp.Diagnostics.AddError(fmt.Sprintf("Error creating notification config for bucket %s", bucket), err.Error())
		return
	}

	plan.Id = types.StringValue(fmt.Sprintf("%s/notificationConfigs/%s", bucket, res.Id))
	tflog.Info(ctx, "Created Storage Notification", map[string]interface{}{"id": plan.Id.ValueString()})

	found := r.refresh(ctx, &plan, metaData, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}
	if !found {
		resp.Diagnostics.AddError("Newly created resource not found", "The Storage Notification was not found immediately after creation.")
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

func (r *storageNotificationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state storageNotificationModel
	var metaData *fwmodels.ProviderMetaModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.ProviderMeta.Get(ctx, &metaData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	found := r.refresh(ctx, &state, metaData, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	if !found {
		tflog.Warn(ctx, "Storage Notification not found, removing from state.", map[string]interface{}{"id": state.Id.ValueString()})
		resp.State.RemoveResource(ctx)
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update is not supported for this resource.
func (r *storageNotificationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	// This resource is immutable and all configurable attributes are marked with `RequiresReplace`.
	// This function should not get called.
}

func (r *storageNotificationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state storageNotificationModel
	var metaData *fwmodels.ProviderMetaModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.ProviderMeta.Get(ctx, &metaData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	bucket, notificationID, err := ParseStorageNotificationID(state.Id.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Invalid resource ID", err.Error())
		return
	}

	userAgent := fwtransport.GenerateFrameworkUserAgentString(metaData, r.config.UserAgent)

	err = r.config.NewStorageClient(userAgent).Notifications.Delete(bucket, notificationID).Do()
	if err != nil {
		if gerr, ok := err.(*googleapi.Error); ok && gerr.Code == 404 {
			// Resource is gone. This is a successful deletion.
			return
		}
		resp.Diagnostics.AddError(fmt.Sprintf("Error deleting notification configuration %s for bucket %s", notificationID, bucket), err.Error())
		return
	}
}

func (r *storageNotificationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}

func (r *storageNotificationResource) refresh(ctx context.Context, model *storageNotificationModel, metaData *fwmodels.ProviderMetaModel, diags *diag.Diagnostics) bool {
	bucket, notificationID, err := ParseStorageNotificationID(model.Id.ValueString())
	if err != nil {
		diags.AddError("Invalid resource ID", err.Error())
		return false
	}

	userAgent := fwtransport.GenerateFrameworkUserAgentString(metaData, r.config.UserAgent)

	res, err := r.config.NewStorageClient(userAgent).Notifications.Get(bucket, notificationID).Do()
	if err != nil {
		if gerr, ok := err.(*googleapi.Error); ok && gerr.Code == 404 {
			return false
		}
		diags.AddError("Error reading Storage Notification", err.Error())
		return false
	}

	model.Bucket = types.StringValue(bucket)
	model.NotificationID = types.StringValue(notificationID)
	model.SelfLink = types.StringValue(res.SelfLink)
	model.PayloadFormat = types.StringValue(res.PayloadFormat)

	configuredObjectNamePrefix := model.ObjectNamePrefix
	apiObjectNamePrefix := res.ObjectNamePrefix
	model.ObjectNamePrefix = fwresource.FlattenStringEmptyToNull(configuredObjectNamePrefix, apiObjectNamePrefix)

	// trim the fully qualified prefix
	apiValue := res.Topic
	model.Topic = types.StringValue(strings.TrimPrefix(apiValue, "//pubsub.googleapis.com/"))

	var eventTypesDiags diag.Diagnostics
	model.EventTypes, eventTypesDiags = types.SetValueFrom(ctx, types.StringType, res.EventTypes)
	diags.Append(eventTypesDiags...)

	var customAttrsDiags diag.Diagnostics
	model.CustomAttributes, customAttrsDiags = types.MapValueFrom(ctx, types.StringType, res.CustomAttributes)
	diags.Append(customAttrsDiags...)

	return !diags.HasError()
}

// ParseStorageNotificationID replicates the logic from the SDKv2 helper.
func ParseStorageNotificationID(id string) (bucket string, notificationID string, err error) {
	parts := strings.Split(id, "/")
	if len(parts) != 3 || parts[1] != "notificationConfigs" {
		return "", "", fmt.Errorf("invalid storage notification ID format, expected '{bucket}/notificationConfigs/{notification_id}', got '%s'", id)
	}
	return parts[0], parts[2], nil
}
