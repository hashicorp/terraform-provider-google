// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/beyondcorp/SecurityGatewayApplication.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package beyondcorp

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceBeyondcorpSecurityGatewayApplication() *schema.Resource {
	return &schema.Resource{
		Create: resourceBeyondcorpSecurityGatewayApplicationCreate,
		Read:   resourceBeyondcorpSecurityGatewayApplicationRead,
		Update: resourceBeyondcorpSecurityGatewayApplicationUpdate,
		Delete: resourceBeyondcorpSecurityGatewayApplicationDelete,

		Importer: &schema.ResourceImporter{
			State: resourceBeyondcorpSecurityGatewayApplicationImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"application_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `User-settable Application resource ID.
* Must start with a letter.
* Must contain between 4-63 characters from '/a-z-/'.
* Must end with a number or letter.`,
			},
			"endpoint_matchers": {
				Type:     schema.TypeList,
				Required: true,
				Description: `Required. Endpoint matchers associated with an application.
A combination of hostname and ports as endpoint matcher is used to match
the application.
Match conditions for OR logic.
An array of match conditions to allow for multiple matching criteria.
The rule is considered a match if one the conditions are met.
The conditions can be one of the following combination
(Hostname), (Hostname & Ports)

EXAMPLES:
Hostname - ("*.abc.com"), ("xyz.abc.com")
Hostname and Ports - ("abc.com" and "22"), ("abc.com" and "22,33") etc`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Required. Hostname of the application.`,
						},
						"ports": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Optional. Ports of the application.`,
							Elem: &schema.Schema{
								Type: schema.TypeInt,
							},
						},
					},
				},
			},
			"security_gateway_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `ID of the Security Gateway resource this belongs to.`,
			},
			"display_name": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Optional. An arbitrary user-provided name for the Application resource.
Cannot exceed 64 characters.`,
			},
			"upstreams": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Optional. List of which upstream resource(s) to forward traffic to.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_policy": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Optional. Routing policy information.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"regions": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `Required. List of regions where the application sends traffic to.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"network": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Network to forward traffic to.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:     schema.TypeString,
										Required: true,
										Description: `Required. Network name is of the format:
'projects/{project}/global/networks/{network}'`,
									},
								},
							},
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Timestamp when the resource was created.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Identifier. Name of the resource.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Timestamp when the resource was last modified.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceBeyondcorpSecurityGatewayApplicationCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandBeyondcorpSecurityGatewayApplicationDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	endpointMatchersProp, err := expandBeyondcorpSecurityGatewayApplicationEndpointMatchers(d.Get("endpoint_matchers"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("endpoint_matchers"); !tpgresource.IsEmptyValue(reflect.ValueOf(endpointMatchersProp)) && (ok || !reflect.DeepEqual(v, endpointMatchersProp)) {
		obj["endpointMatchers"] = endpointMatchersProp
	}
	upstreamsProp, err := expandBeyondcorpSecurityGatewayApplicationUpstreams(d.Get("upstreams"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("upstreams"); !tpgresource.IsEmptyValue(reflect.ValueOf(upstreamsProp)) && (ok || !reflect.DeepEqual(v, upstreamsProp)) {
		obj["upstreams"] = upstreamsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BeyondcorpBasePath}}projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications?applicationId={{application_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new SecurityGatewayApplication: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SecurityGatewayApplication: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating SecurityGatewayApplication: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications/{{application_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = BeyondcorpOperationWaitTime(
		config, res, project, "Creating SecurityGatewayApplication", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create SecurityGatewayApplication: %s", err)
	}

	log.Printf("[DEBUG] Finished creating SecurityGatewayApplication %q: %#v", d.Id(), res)

	return resourceBeyondcorpSecurityGatewayApplicationRead(d, meta)
}

func resourceBeyondcorpSecurityGatewayApplicationRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BeyondcorpBasePath}}projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications/{{application_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SecurityGatewayApplication: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("BeyondcorpSecurityGatewayApplication %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}

	if err := d.Set("create_time", flattenBeyondcorpSecurityGatewayApplicationCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}
	if err := d.Set("display_name", flattenBeyondcorpSecurityGatewayApplicationDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}
	if err := d.Set("endpoint_matchers", flattenBeyondcorpSecurityGatewayApplicationEndpointMatchers(res["endpointMatchers"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}
	if err := d.Set("upstreams", flattenBeyondcorpSecurityGatewayApplicationUpstreams(res["upstreams"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}
	if err := d.Set("name", flattenBeyondcorpSecurityGatewayApplicationName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}
	if err := d.Set("update_time", flattenBeyondcorpSecurityGatewayApplicationUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}

	return nil
}

func resourceBeyondcorpSecurityGatewayApplicationUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SecurityGatewayApplication: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	displayNameProp, err := expandBeyondcorpSecurityGatewayApplicationDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	endpointMatchersProp, err := expandBeyondcorpSecurityGatewayApplicationEndpointMatchers(d.Get("endpoint_matchers"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("endpoint_matchers"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, endpointMatchersProp)) {
		obj["endpointMatchers"] = endpointMatchersProp
	}
	upstreamsProp, err := expandBeyondcorpSecurityGatewayApplicationUpstreams(d.Get("upstreams"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("upstreams"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, upstreamsProp)) {
		obj["upstreams"] = upstreamsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BeyondcorpBasePath}}projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications/{{application_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating SecurityGatewayApplication %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("endpoint_matchers") {
		updateMask = append(updateMask, "endpointMatchers")
	}

	if d.HasChange("upstreams") {
		updateMask = append(updateMask, "upstreams")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating SecurityGatewayApplication %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating SecurityGatewayApplication %q: %#v", d.Id(), res)
		}

		err = BeyondcorpOperationWaitTime(
			config, res, project, "Updating SecurityGatewayApplication", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceBeyondcorpSecurityGatewayApplicationRead(d, meta)
}

func resourceBeyondcorpSecurityGatewayApplicationDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SecurityGatewayApplication: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{BeyondcorpBasePath}}projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications/{{application_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting SecurityGatewayApplication %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "SecurityGatewayApplication")
	}

	err = BeyondcorpOperationWaitTime(
		config, res, project, "Deleting SecurityGatewayApplication", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting SecurityGatewayApplication %q: %#v", d.Id(), res)
	return nil
}

func resourceBeyondcorpSecurityGatewayApplicationImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/global/securityGateways/(?P<security_gateway_id>[^/]+)/applications/(?P<application_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<security_gateway_id>[^/]+)/(?P<application_id>[^/]+)$",
		"^(?P<security_gateway_id>[^/]+)/(?P<application_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications/{{application_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenBeyondcorpSecurityGatewayApplicationCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationEndpointMatchers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"hostname": flattenBeyondcorpSecurityGatewayApplicationEndpointMatchersHostname(original["hostname"], d, config),
			"ports":    flattenBeyondcorpSecurityGatewayApplicationEndpointMatchersPorts(original["ports"], d, config),
		})
	}
	return transformed
}
func flattenBeyondcorpSecurityGatewayApplicationEndpointMatchersHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationEndpointMatchersPorts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"egress_policy": flattenBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicy(original["egressPolicy"], d, config),
			"network":       flattenBeyondcorpSecurityGatewayApplicationUpstreamsNetwork(original["network"], d, config),
		})
	}
	return transformed
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["regions"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicyRegions(original["regions"], d, config)
	return []interface{}{transformed}
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicyRegions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsNetworkName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsNetworkName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandBeyondcorpSecurityGatewayApplicationDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationEndpointMatchers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedHostname, err := expandBeyondcorpSecurityGatewayApplicationEndpointMatchersHostname(original["hostname"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hostname"] = transformedHostname
		}

		transformedPorts, err := expandBeyondcorpSecurityGatewayApplicationEndpointMatchersPorts(original["ports"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPorts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ports"] = transformedPorts
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBeyondcorpSecurityGatewayApplicationEndpointMatchersHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationEndpointMatchersPorts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedEgressPolicy, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicy(original["egress_policy"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEgressPolicy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["egressPolicy"] = transformedEgressPolicy
		}

		transformedNetwork, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsNetwork(original["network"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["network"] = transformedNetwork
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRegions, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicyRegions(original["regions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRegions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["regions"] = transformedRegions
	}

	return transformed, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicyRegions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsNetworkName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	return transformed, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsNetworkName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
