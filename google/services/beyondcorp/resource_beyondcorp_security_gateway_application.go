// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/beyondcorp/SecurityGatewayApplication.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package beyondcorp

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceBeyondcorpSecurityGatewayApplication() *schema.Resource {
	return &schema.Resource{
		Create: resourceBeyondcorpSecurityGatewayApplicationCreate,
		Read:   resourceBeyondcorpSecurityGatewayApplicationRead,
		Update: resourceBeyondcorpSecurityGatewayApplicationUpdate,
		Delete: resourceBeyondcorpSecurityGatewayApplicationDelete,

		Importer: &schema.ResourceImporter{
			State: resourceBeyondcorpSecurityGatewayApplicationImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"security_gateway_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"application_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"application_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `User-settable Application resource ID.
* Must start with a letter.
* Must contain between 4-63 characters from '/a-z-/'.
* Must end with a number or letter.`,
			},
			"security_gateway_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `ID of the Security Gateway resource this belongs to.`,
			},
			"display_name": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Optional. An arbitrary user-provided name for the Application resource.
Cannot exceed 64 characters.`,
			},
			"endpoint_matchers": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Required. Endpoint matchers associated with an application.
A combination of hostname and ports as endpoint matcher is used to match
the application.
Match conditions for OR logic.
An array of match conditions to allow for multiple matching criteria.
The rule is considered a match if one the conditions are met.
The conditions can be one of the following combination
(Hostname), (Hostname & Ports)

EXAMPLES:
Hostname - ("*.abc.com"), ("xyz.abc.com")
Hostname and Ports - ("abc.com" and "22"), ("abc.com" and "22,33") etc`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Required. Hostname of the application.`,
						},
						"ports": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Optional. Ports of the application.`,
							Elem: &schema.Schema{
								Type: schema.TypeInt,
							},
						},
					},
				},
			},
			"schema": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"PROXY_GATEWAY", "API_GATEWAY", ""}),
				Description:  `Type of the external application. Possible values: ["PROXY_GATEWAY", "API_GATEWAY"]`,
			},
			"upstreams": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Optional. List of which upstream resource(s) to forward traffic to.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"egress_policy": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Optional. Routing policy information.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"regions": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `Required. List of regions where the application sends traffic to.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"external": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `List of the external endpoints to forward traffic to.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"endpoints": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `List of the endpoints to forward traffic to.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"hostname": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `Hostname of the endpoint.`,
												},
												"port": {
													Type:        schema.TypeInt,
													Required:    true,
													Description: `Port of the endpoint.`,
												},
											},
										},
									},
								},
							},
						},
						"network": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Network to forward traffic to.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:     schema.TypeString,
										Required: true,
										Description: `Required. Network name is of the format:
'projects/{project}/global/networks/{network}'`,
									},
								},
							},
						},
						"proxy_protocol": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Shared proxy configuration for all apps.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"allowed_client_headers": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `The configuration for the proxy.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"client_ip": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Client IP configuration. The client IP address is included if true.`,
									},
									"contextual_headers": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Configuration for the contextual headers.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"device_info": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Device info configuration.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"output_type": {
																Type:         schema.TypeString,
																Optional:     true,
																ValidateFunc: verify.ValidateEnum([]string{"PROTOBUF", "JSON", "NONE", ""}),
																Description:  `The output type of the delegated device info. Possible values: ["PROTOBUF", "JSON", "NONE"]`,
															},
														},
													},
												},
												"group_info": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Group info configuration.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"output_type": {
																Type:         schema.TypeString,
																Optional:     true,
																ValidateFunc: verify.ValidateEnum([]string{"PROTOBUF", "JSON", "NONE", ""}),
																Description:  `The output type of the delegated group info. Possible values: ["PROTOBUF", "JSON", "NONE"]`,
															},
														},
													},
												},
												"output_type": {
													Type:         schema.TypeString,
													Optional:     true,
													ValidateFunc: verify.ValidateEnum([]string{"PROTOBUF", "JSON", "NONE", ""}),
													Description:  `Default output type for all enabled headers. Possible values: ["PROTOBUF", "JSON", "NONE"]`,
												},
												"user_info": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `User info configuration.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"output_type": {
																Type:         schema.TypeString,
																Optional:     true,
																ValidateFunc: verify.ValidateEnum([]string{"PROTOBUF", "JSON", "NONE", ""}),
																Description:  `The output type of the delegated user info. Possible values: ["PROTOBUF", "JSON", "NONE"]`,
															},
														},
													},
												},
											},
										},
									},
									"gateway_identity": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"RESOURCE_NAME", ""}),
										Description:  `Gateway identity configuration. Possible values: ["RESOURCE_NAME"]`,
									},
									"metadata_headers": {
										Type:     schema.TypeMap,
										Optional: true,
										Description: `Custom resource specific headers along with the values.
The names should conform to RFC 9110:
> Field names SHOULD constrain themselves to alphanumeric characters, "-",
  and ".", and SHOULD begin with a letter.
> Field values SHOULD contain only ASCII printable characters and tab.`,
										Elem: &schema.Schema{Type: schema.TypeString},
									},
								},
							},
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Timestamp when the resource was created.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Identifier. Name of the resource.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Timestamp when the resource was last modified.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceBeyondcorpSecurityGatewayApplicationCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandBeyondcorpSecurityGatewayApplicationDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	endpointMatchersProp, err := expandBeyondcorpSecurityGatewayApplicationEndpointMatchers(d.Get("endpoint_matchers"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("endpoint_matchers"); !tpgresource.IsEmptyValue(reflect.ValueOf(endpointMatchersProp)) && (ok || !reflect.DeepEqual(v, endpointMatchersProp)) {
		obj["endpointMatchers"] = endpointMatchersProp
	}
	upstreamsProp, err := expandBeyondcorpSecurityGatewayApplicationUpstreams(d.Get("upstreams"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("upstreams"); !tpgresource.IsEmptyValue(reflect.ValueOf(upstreamsProp)) && (ok || !reflect.DeepEqual(v, upstreamsProp)) {
		obj["upstreams"] = upstreamsProp
	}
	schemaProp, err := expandBeyondcorpSecurityGatewayApplicationSchema(d.Get("schema"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("schema"); !tpgresource.IsEmptyValue(reflect.ValueOf(schemaProp)) && (ok || !reflect.DeepEqual(v, schemaProp)) {
		obj["schema"] = schemaProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BeyondcorpBasePath}}projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications?applicationId={{application_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new SecurityGatewayApplication: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SecurityGatewayApplication: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating SecurityGatewayApplication: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications/{{application_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if securityGatewayIdValue, ok := d.GetOk("security_gateway_id"); ok && securityGatewayIdValue.(string) != "" {
			if err = identity.Set("security_gateway_id", securityGatewayIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting security_gateway_id: %s", err)
			}
		}
		if applicationIdValue, ok := d.GetOk("application_id"); ok && applicationIdValue.(string) != "" {
			if err = identity.Set("application_id", applicationIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting application_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = BeyondcorpOperationWaitTime(
		config, res, project, "Creating SecurityGatewayApplication", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create SecurityGatewayApplication: %s", err)
	}

	log.Printf("[DEBUG] Finished creating SecurityGatewayApplication %q: %#v", d.Id(), res)

	return resourceBeyondcorpSecurityGatewayApplicationRead(d, meta)
}

func resourceBeyondcorpSecurityGatewayApplicationRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BeyondcorpBasePath}}projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications/{{application_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SecurityGatewayApplication: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("BeyondcorpSecurityGatewayApplication %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}

	if err := d.Set("create_time", flattenBeyondcorpSecurityGatewayApplicationCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}
	if err := d.Set("display_name", flattenBeyondcorpSecurityGatewayApplicationDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}
	if err := d.Set("endpoint_matchers", flattenBeyondcorpSecurityGatewayApplicationEndpointMatchers(res["endpointMatchers"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}
	if err := d.Set("upstreams", flattenBeyondcorpSecurityGatewayApplicationUpstreams(res["upstreams"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}
	if err := d.Set("schema", flattenBeyondcorpSecurityGatewayApplicationSchema(res["schema"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}
	if err := d.Set("name", flattenBeyondcorpSecurityGatewayApplicationName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}
	if err := d.Set("update_time", flattenBeyondcorpSecurityGatewayApplicationUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading SecurityGatewayApplication: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("security_gateway_id"); !ok && v == "" {
			err = identity.Set("security_gateway_id", d.Get("security_gateway_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting security_gateway_id: %s", err)
			}
		}
		if v, ok := identity.GetOk("application_id"); !ok && v == "" {
			err = identity.Set("application_id", d.Get("application_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting application_id: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceBeyondcorpSecurityGatewayApplicationUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if securityGatewayIdValue, ok := d.GetOk("security_gateway_id"); ok && securityGatewayIdValue.(string) != "" {
			if err = identity.Set("security_gateway_id", securityGatewayIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting security_gateway_id: %s", err)
			}
		}
		if applicationIdValue, ok := d.GetOk("application_id"); ok && applicationIdValue.(string) != "" {
			if err = identity.Set("application_id", applicationIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting application_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SecurityGatewayApplication: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	displayNameProp, err := expandBeyondcorpSecurityGatewayApplicationDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	endpointMatchersProp, err := expandBeyondcorpSecurityGatewayApplicationEndpointMatchers(d.Get("endpoint_matchers"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("endpoint_matchers"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, endpointMatchersProp)) {
		obj["endpointMatchers"] = endpointMatchersProp
	}
	upstreamsProp, err := expandBeyondcorpSecurityGatewayApplicationUpstreams(d.Get("upstreams"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("upstreams"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, upstreamsProp)) {
		obj["upstreams"] = upstreamsProp
	}
	schemaProp, err := expandBeyondcorpSecurityGatewayApplicationSchema(d.Get("schema"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("schema"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, schemaProp)) {
		obj["schema"] = schemaProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BeyondcorpBasePath}}projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications/{{application_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating SecurityGatewayApplication %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("endpoint_matchers") {
		updateMask = append(updateMask, "endpointMatchers")
	}

	if d.HasChange("upstreams") {
		updateMask = append(updateMask, "upstreams")
	}

	if d.HasChange("schema") {
		updateMask = append(updateMask, "schema")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating SecurityGatewayApplication %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating SecurityGatewayApplication %q: %#v", d.Id(), res)
		}

		err = BeyondcorpOperationWaitTime(
			config, res, project, "Updating SecurityGatewayApplication", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceBeyondcorpSecurityGatewayApplicationRead(d, meta)
}

func resourceBeyondcorpSecurityGatewayApplicationDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SecurityGatewayApplication: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{BeyondcorpBasePath}}projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications/{{application_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting SecurityGatewayApplication %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "SecurityGatewayApplication")
	}

	err = BeyondcorpOperationWaitTime(
		config, res, project, "Deleting SecurityGatewayApplication", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting SecurityGatewayApplication %q: %#v", d.Id(), res)
	return nil
}

func resourceBeyondcorpSecurityGatewayApplicationImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/global/securityGateways/(?P<security_gateway_id>[^/]+)/applications/(?P<application_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<security_gateway_id>[^/]+)/(?P<application_id>[^/]+)$",
		"^(?P<security_gateway_id>[^/]+)/(?P<application_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/global/securityGateways/{{security_gateway_id}}/applications/{{application_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenBeyondcorpSecurityGatewayApplicationCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationEndpointMatchers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"hostname": flattenBeyondcorpSecurityGatewayApplicationEndpointMatchersHostname(original["hostname"], d, config),
			"ports":    flattenBeyondcorpSecurityGatewayApplicationEndpointMatchersPorts(original["ports"], d, config),
		})
	}
	return transformed
}
func flattenBeyondcorpSecurityGatewayApplicationEndpointMatchersHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationEndpointMatchersPorts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"egress_policy":  flattenBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicy(original["egressPolicy"], d, config),
			"network":        flattenBeyondcorpSecurityGatewayApplicationUpstreamsNetwork(original["network"], d, config),
			"external":       flattenBeyondcorpSecurityGatewayApplicationUpstreamsExternal(original["external"], d, config),
			"proxy_protocol": flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocol(original["proxyProtocol"], d, config),
		})
	}
	return transformed
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["regions"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicyRegions(original["regions"], d, config)
	return []interface{}{transformed}
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicyRegions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsNetworkName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsNetworkName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsExternal(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["endpoints"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpoints(original["endpoints"], d, config)
	return []interface{}{transformed}
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"hostname": flattenBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpointsHostname(original["hostname"], d, config),
			"port":     flattenBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpointsPort(original["port"], d, config),
		})
	}
	return transformed
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpointsHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpointsPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocol(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["allowed_client_headers"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolAllowedClientHeaders(original["allowedClientHeaders"], d, config)
	transformed["contextual_headers"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeaders(original["contextualHeaders"], d, config)
	transformed["metadata_headers"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolMetadataHeaders(original["metadataHeaders"], d, config)
	transformed["gateway_identity"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolGatewayIdentity(original["gatewayIdentity"], d, config)
	transformed["client_ip"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolClientIp(original["clientIp"], d, config)
	return []interface{}{transformed}
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolAllowedClientHeaders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeaders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["user_info"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersUserInfo(original["userInfo"], d, config)
	transformed["group_info"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersGroupInfo(original["groupInfo"], d, config)
	transformed["device_info"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersDeviceInfo(original["deviceInfo"], d, config)
	transformed["output_type"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersOutputType(original["outputType"], d, config)
	return []interface{}{transformed}
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersUserInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["output_type"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersUserInfoOutputType(original["outputType"], d, config)
	return []interface{}{transformed}
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersUserInfoOutputType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersGroupInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["output_type"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersGroupInfoOutputType(original["outputType"], d, config)
	return []interface{}{transformed}
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersGroupInfoOutputType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersDeviceInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["output_type"] =
		flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersDeviceInfoOutputType(original["outputType"], d, config)
	return []interface{}{transformed}
}
func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersDeviceInfoOutputType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersOutputType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolMetadataHeaders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolGatewayIdentity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolClientIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBeyondcorpSecurityGatewayApplicationUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandBeyondcorpSecurityGatewayApplicationDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationEndpointMatchers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedHostname, err := expandBeyondcorpSecurityGatewayApplicationEndpointMatchersHostname(original["hostname"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hostname"] = transformedHostname
		}

		transformedPorts, err := expandBeyondcorpSecurityGatewayApplicationEndpointMatchersPorts(original["ports"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPorts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ports"] = transformedPorts
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBeyondcorpSecurityGatewayApplicationEndpointMatchersHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationEndpointMatchersPorts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreams(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedEgressPolicy, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicy(original["egress_policy"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEgressPolicy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["egressPolicy"] = transformedEgressPolicy
		}

		transformedNetwork, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsNetwork(original["network"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["network"] = transformedNetwork
		}

		transformedExternal, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsExternal(original["external"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedExternal); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["external"] = transformedExternal
		}

		transformedProxyProtocol, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocol(original["proxy_protocol"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedProxyProtocol); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["proxyProtocol"] = transformedProxyProtocol
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRegions, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicyRegions(original["regions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRegions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["regions"] = transformedRegions
	}

	return transformed, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsEgressPolicyRegions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsNetworkName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	return transformed, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsNetworkName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsExternal(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEndpoints, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpoints(original["endpoints"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEndpoints); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["endpoints"] = transformedEndpoints
	}

	return transformed, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpoints(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedHostname, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpointsHostname(original["hostname"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hostname"] = transformedHostname
		}

		transformedPort, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpointsPort(original["port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["port"] = transformedPort
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpointsHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsExternalEndpointsPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocol(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAllowedClientHeaders, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolAllowedClientHeaders(original["allowed_client_headers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowedClientHeaders); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allowedClientHeaders"] = transformedAllowedClientHeaders
	}

	transformedContextualHeaders, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeaders(original["contextual_headers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContextualHeaders); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["contextualHeaders"] = transformedContextualHeaders
	}

	transformedMetadataHeaders, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolMetadataHeaders(original["metadata_headers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMetadataHeaders); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["metadataHeaders"] = transformedMetadataHeaders
	}

	transformedGatewayIdentity, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolGatewayIdentity(original["gateway_identity"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGatewayIdentity); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gatewayIdentity"] = transformedGatewayIdentity
	}

	transformedClientIp, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolClientIp(original["client_ip"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientIp); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientIp"] = transformedClientIp
	}

	return transformed, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolAllowedClientHeaders(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeaders(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUserInfo, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersUserInfo(original["user_info"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["userInfo"] = transformedUserInfo
	}

	transformedGroupInfo, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersGroupInfo(original["group_info"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["groupInfo"] = transformedGroupInfo
	}

	transformedDeviceInfo, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersDeviceInfo(original["device_info"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["deviceInfo"] = transformedDeviceInfo
	}

	transformedOutputType, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersOutputType(original["output_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputType"] = transformedOutputType
	}

	return transformed, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersUserInfo(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOutputType, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersUserInfoOutputType(original["output_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputType"] = transformedOutputType
	}

	return transformed, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersUserInfoOutputType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersGroupInfo(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOutputType, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersGroupInfoOutputType(original["output_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputType"] = transformedOutputType
	}

	return transformed, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersGroupInfoOutputType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersDeviceInfo(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOutputType, err := expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersDeviceInfoOutputType(original["output_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputType"] = transformedOutputType
	}

	return transformed, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersDeviceInfoOutputType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolContextualHeadersOutputType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolMetadataHeaders(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolGatewayIdentity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationUpstreamsProxyProtocolClientIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBeyondcorpSecurityGatewayApplicationSchema(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
