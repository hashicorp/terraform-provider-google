// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/datastream/ConnectionProfile.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package datastream

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

func resourceDataStreamStreamCreateWithoutValidationDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// If the old value was "false" and the new value is now unset (empty string),
	// return true to suppress the diff.
	if (old == "" && new == "false") || (old == "false" && new == "") {
		return true
	}

	// Otherwise, do not suppress the diff.
	return false
}

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceDatastreamConnectionProfile() *schema.Resource {
	return &schema.Resource{
		Create: resourceDatastreamConnectionProfileCreate,
		Read:   resourceDatastreamConnectionProfileRead,
		Update: resourceDatastreamConnectionProfileUpdate,
		Delete: resourceDatastreamConnectionProfileDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDatastreamConnectionProfileImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"connection_profile_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"connection_profile_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The connection profile identifier.`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Display name.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of the location this connection profile is located in.`,
			},
			"bigquery_profile": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `BigQuery warehouse profile.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{},
				},
				ExactlyOneOf: []string{"bigquery_profile", "gcs_profile", "mongodb_profile", "mysql_profile", "oracle_profile", "postgresql_profile", "sql_server_profile"},
			},
			"create_without_validation": {
				Type:             schema.TypeBool,
				Optional:         true,
				ForceNew:         true,
				DiffSuppressFunc: resourceDataStreamStreamCreateWithoutValidationDiffSuppress,
				Description:      `Create the connection profile without validating it.`,
				Default:          false,
			},
			"forward_ssh_connectivity": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Forward SSH tunnel connectivity.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Hostname for the SSH tunnel.`,
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Username for the SSH tunnel.`,
						},
						"password": {
							Type:          schema.TypeString,
							Optional:      true,
							ForceNew:      true,
							Description:   `SSH password.`,
							Sensitive:     true,
							ConflictsWith: []string{"forward_ssh_connectivity.0.private_key"},
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `Port for the SSH tunnel.`,
							Default:     22,
						},
						"private_key": {
							Type:          schema.TypeString,
							Optional:      true,
							Description:   `SSH private key.`,
							Sensitive:     true,
							ConflictsWith: []string{"forward_ssh_connectivity.0.password"},
						},
					},
				},
				ConflictsWith: []string{"private_connectivity"},
			},
			"gcs_profile": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Cloud Storage bucket profile.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"bucket": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The Cloud Storage bucket name.`,
						},
						"root_path": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The root path inside the Cloud Storage bucket.`,
						},
					},
				},
				ExactlyOneOf: []string{"bigquery_profile", "gcs_profile", "mongodb_profile", "mysql_profile", "oracle_profile", "postgresql_profile", "sql_server_profile"},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"mongodb_profile": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configuration for connecting to a MongoDB database.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"host_addresses": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `List of host addresses for a MongoDB cluster.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"hostname": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Hostname for the connection.`,
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Port for the connection.`,
									},
								},
							},
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Username for the MongoDB connection.`,
						},
						"password": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `Password for the MongoDB connection. Mutually exclusive with
secretManagerStoredPassword.`,
							Sensitive: true,
						},
						"replica_set": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Name of the replica set.`,
						},
						"secret_manager_stored_password": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `A reference to a Secret Manager resource name storing the MongoDB
connection password. Mutually exclusive with password.`,
						},
						"srv_connection_format": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Srv connection format. Mutually exclusive with
standard_connection_Format.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
							AtLeastOneOf: []string{"mongodb_profile.0.srv_connection_format", "mongodb_profile.0.standard_connection_format"},
						},
						"ssl_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `SSL configuration for the MongoDB connection.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_certificate": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `PEM-encoded certificate of the CA that signed the source database
server's certificate.`,
										Sensitive: true,
									},
									"client_certificate": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `PEM-encoded certificate that will be used by the replica to
authenticate against the source database server. If this field
is used then the 'clientKey' and the 'caCertificate' fields are
mandatory.`,
										Sensitive: true,
									},
									"client_key": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `PEM-encoded private key associated with the Client Certificate.
If this field is used then the 'client_certificate' and the
'ca_certificate' fields are mandatory.`,
										Sensitive:    true,
										ExactlyOneOf: []string{"mongodb_profile.0.ssl_config.0.client_key", "mongodb_profile.0.ssl_config.0.secret_manager_stored_client_key"},
									},
									"secret_manager_stored_client_key": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `A reference to a Secret Manager resource name storing the
PEM-encoded private key. Mutually exclusive with clientKey.`,
										Sensitive:    true,
										ExactlyOneOf: []string{"mongodb_profile.0.ssl_config.0.client_key", "mongodb_profile.0.ssl_config.0.secret_manager_stored_client_key"},
									},
									"ca_certificate_set": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether the clientKey field is set.`,
									},
									"client_certificate_set": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether the clientCertificate field is set.`,
									},
									"client_key_set": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether the clientKey field is set.`,
									},
								},
							},
						},
						"standard_connection_format": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Standard connection format. Mutually exclusive with
srv_connection_format.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"direct_connection": {
										Type:     schema.TypeBool,
										Optional: true,
										Description: `Specifies whether the client connects directly to the
host[:port] in the connection URI.`,
									},
								},
							},
							AtLeastOneOf: []string{"mongodb_profile.0.srv_connection_format", "mongodb_profile.0.standard_connection_format"},
						},
					},
				},
				ExactlyOneOf: []string{"bigquery_profile", "gcs_profile", "mongodb_profile", "mysql_profile", "oracle_profile", "postgresql_profile", "sql_server_profile"},
			},
			"mysql_profile": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `MySQL database profile.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Hostname for the MySQL connection.`,
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Username for the MySQL connection.`,
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Password for the MySQL connection.`,
							Sensitive:   true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `Port for the MySQL connection.`,
							Default:     3306,
						},
						"secret_manager_stored_password": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `A reference to a Secret Manager resource name storing the user's password.`,
						},
						"ssl_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `SSL configuration for the MySQL connection.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_certificate": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `PEM-encoded certificate of the CA that signed the source database
server's certificate.`,
										Sensitive: true,
									},
									"client_certificate": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `PEM-encoded certificate that will be used by the replica to
authenticate against the source database server. If this field
is used then the 'clientKey' and the 'caCertificate' fields are
mandatory.`,
										Sensitive: true,
									},
									"client_key": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `PEM-encoded private key associated with the Client Certificate.
If this field is used then the 'client_certificate' and the
'ca_certificate' fields are mandatory.`,
										Sensitive: true,
									},
									"ca_certificate_set": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether the clientKey field is set.`,
									},
									"client_certificate_set": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether the clientCertificate field is set.`,
									},
									"client_key_set": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether the clientKey field is set.`,
									},
								},
							},
						},
					},
				},
				ExactlyOneOf: []string{"bigquery_profile", "gcs_profile", "mongodb_profile", "mysql_profile", "oracle_profile", "postgresql_profile", "sql_server_profile"},
			},
			"oracle_profile": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Oracle database profile.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database_service": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Database for the Oracle connection.`,
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Hostname for the Oracle connection.`,
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Username for the Oracle connection.`,
						},
						"connection_attributes": {
							Type:        schema.TypeMap,
							Optional:    true,
							Description: `Connection string attributes`,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Password for the Oracle connection.`,
							Sensitive:   true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `Port for the Oracle connection.`,
							Default:     1521,
						},
						"secret_manager_stored_password": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `A reference to a Secret Manager resource name storing the user's password.`,
						},
					},
				},
				ExactlyOneOf: []string{"bigquery_profile", "gcs_profile", "mongodb_profile", "mysql_profile", "oracle_profile", "postgresql_profile", "sql_server_profile"},
			},
			"postgresql_profile": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `PostgreSQL database profile.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Database for the PostgreSQL connection.`,
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Hostname for the PostgreSQL connection.`,
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Username for the PostgreSQL connection.`,
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Password for the PostgreSQL connection.`,
							Sensitive:   true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `Port for the PostgreSQL connection.`,
							Default:     5432,
						},
						"secret_manager_stored_password": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `A reference to a Secret Manager resource name storing the user's password.`,
						},
						"ssl_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `SSL configuration for the PostgreSQL connection.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"server_and_client_verification": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `If this field is set, the communication will be encrypted with TLS encryption
and both the server identity and the client identity will be authenticated.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"ca_certificate": {
													Type:        schema.TypeString,
													Required:    true,
													ForceNew:    true,
													Description: `PEM-encoded server root CA certificate.`,
													Sensitive:   true,
												},
												"client_certificate": {
													Type:     schema.TypeString,
													Required: true,
													ForceNew: true,
													Description: `PEM-encoded certificate used by the source database to authenticate the
client identity (i.e., the Datastream's identity). This certificate is
signed by either a root certificate trusted by the server or one or more
intermediate certificates (which is stored with the leaf certificate) to
link to this certificate to the trusted root certificate.`,
													Sensitive: true,
												},
												"client_key": {
													Type:     schema.TypeString,
													Required: true,
													ForceNew: true,
													Description: `PEM-encoded private key associated with the client certificate.
This value will be used during the SSL/TLS handshake, allowing
the PostgreSQL server to authenticate the client's identity,
i.e. identity of the stream.`,
													Sensitive: true,
												},
											},
										},
										ExactlyOneOf: []string{},
									},
									"server_verification": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `If this field is set, the communication will be encrypted with TLS encryption
and the server identity will be authenticated.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"ca_certificate": {
													Type:        schema.TypeString,
													Required:    true,
													ForceNew:    true,
													Description: `PEM-encoded server root CA certificate.`,
													Sensitive:   true,
												},
											},
										},
										ExactlyOneOf: []string{},
									},
								},
							},
						},
					},
				},
				ExactlyOneOf: []string{"bigquery_profile", "gcs_profile", "mongodb_profile", "mysql_profile", "oracle_profile", "postgresql_profile", "sql_server_profile"},
			},
			"private_connectivity": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Private connectivity.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"private_connection": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `A reference to a private connection resource. Format: 'projects/{project}/locations/{location}/privateConnections/{name}'`,
						},
					},
				},
				ConflictsWith: []string{"forward_ssh_connectivity"},
			},
			"sql_server_profile": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `SQL Server database profile.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"database": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Database for the SQL Server connection.`,
						},
						"hostname": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Hostname for the SQL Server connection.`,
						},
						"username": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Username for the SQL Server connection.`,
						},
						"password": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Password for the SQL Server connection.`,
							Sensitive:   true,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `Port for the SQL Server connection.`,
							Default:     1433,
						},
						"secret_manager_stored_password": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `A reference to a Secret Manager resource name storing the user's password.`,
						},
					},
				},
				ExactlyOneOf: []string{"bigquery_profile", "gcs_profile", "mongodb_profile", "mysql_profile", "oracle_profile", "postgresql_profile", "sql_server_profile"},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The resource's name.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDatastreamConnectionProfileCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandDatastreamConnectionProfileDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	oracleProfileProp, err := expandDatastreamConnectionProfileOracleProfile(d.Get("oracle_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("oracle_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(oracleProfileProp)) && (ok || !reflect.DeepEqual(v, oracleProfileProp)) {
		obj["oracleProfile"] = oracleProfileProp
	}
	gcsProfileProp, err := expandDatastreamConnectionProfileGcsProfile(d.Get("gcs_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("gcs_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(gcsProfileProp)) && (ok || !reflect.DeepEqual(v, gcsProfileProp)) {
		obj["gcsProfile"] = gcsProfileProp
	}
	mysqlProfileProp, err := expandDatastreamConnectionProfileMysqlProfile(d.Get("mysql_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("mysql_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(mysqlProfileProp)) && (ok || !reflect.DeepEqual(v, mysqlProfileProp)) {
		obj["mysqlProfile"] = mysqlProfileProp
	}
	bigqueryProfileProp, err := expandDatastreamConnectionProfileBigqueryProfile(d.Get("bigquery_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("bigquery_profile"); ok || !reflect.DeepEqual(v, bigqueryProfileProp) {
		obj["bigqueryProfile"] = bigqueryProfileProp
	}
	postgresqlProfileProp, err := expandDatastreamConnectionProfilePostgresqlProfile(d.Get("postgresql_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("postgresql_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(postgresqlProfileProp)) && (ok || !reflect.DeepEqual(v, postgresqlProfileProp)) {
		obj["postgresqlProfile"] = postgresqlProfileProp
	}
	sqlServerProfileProp, err := expandDatastreamConnectionProfileSqlServerProfile(d.Get("sql_server_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("sql_server_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(sqlServerProfileProp)) && (ok || !reflect.DeepEqual(v, sqlServerProfileProp)) {
		obj["sqlServerProfile"] = sqlServerProfileProp
	}
	mongodbProfileProp, err := expandDatastreamConnectionProfileMongodbProfile(d.Get("mongodb_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("mongodb_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(mongodbProfileProp)) && (ok || !reflect.DeepEqual(v, mongodbProfileProp)) {
		obj["mongodbProfile"] = mongodbProfileProp
	}
	forwardSshConnectivityProp, err := expandDatastreamConnectionProfileForwardSshConnectivity(d.Get("forward_ssh_connectivity"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("forward_ssh_connectivity"); !tpgresource.IsEmptyValue(reflect.ValueOf(forwardSshConnectivityProp)) && (ok || !reflect.DeepEqual(v, forwardSshConnectivityProp)) {
		obj["forwardSshConnectivity"] = forwardSshConnectivityProp
	}
	privateConnectivityProp, err := expandDatastreamConnectionProfilePrivateConnectivity(d.Get("private_connectivity"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("private_connectivity"); !tpgresource.IsEmptyValue(reflect.ValueOf(privateConnectivityProp)) && (ok || !reflect.DeepEqual(v, privateConnectivityProp)) {
		obj["privateConnectivity"] = privateConnectivityProp
	}
	effectiveLabelsProp, err := expandDatastreamConnectionProfileEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DatastreamBasePath}}projects/{{project}}/locations/{{location}}/connectionProfiles?connectionProfileId={{connection_profile_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new ConnectionProfile: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ConnectionProfile: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	if d.Get("create_without_validation").(bool) {
		url, err = transport_tpg.AddQueryParams(url, map[string]string{"force": "true"})
	} else {
		url, err = transport_tpg.AddQueryParams(url, map[string]string{"force": "false"})
	}
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating ConnectionProfile: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/connectionProfiles/{{connection_profile_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if connectionProfileIdValue, ok := d.GetOk("connection_profile_id"); ok && connectionProfileIdValue.(string) != "" {
			if err = identity.Set("connection_profile_id", connectionProfileIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting connection_profile_id: %s", err)
			}
		}
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = DatastreamOperationWaitTime(
		config, res, project, "Creating ConnectionProfile", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create ConnectionProfile: %s", err)
	}

	log.Printf("[DEBUG] Finished creating ConnectionProfile %q: %#v", d.Id(), res)

	return resourceDatastreamConnectionProfileRead(d, meta)
}

func resourceDatastreamConnectionProfileRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DatastreamBasePath}}projects/{{project}}/locations/{{location}}/connectionProfiles/{{connection_profile_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ConnectionProfile: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DatastreamConnectionProfile %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}

	if err := d.Set("name", flattenDatastreamConnectionProfileName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("labels", flattenDatastreamConnectionProfileLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("display_name", flattenDatastreamConnectionProfileDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("oracle_profile", flattenDatastreamConnectionProfileOracleProfile(res["oracleProfile"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("gcs_profile", flattenDatastreamConnectionProfileGcsProfile(res["gcsProfile"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("mysql_profile", flattenDatastreamConnectionProfileMysqlProfile(res["mysqlProfile"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("bigquery_profile", flattenDatastreamConnectionProfileBigqueryProfile(res["bigqueryProfile"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("postgresql_profile", flattenDatastreamConnectionProfilePostgresqlProfile(res["postgresqlProfile"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("sql_server_profile", flattenDatastreamConnectionProfileSqlServerProfile(res["sqlServerProfile"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("mongodb_profile", flattenDatastreamConnectionProfileMongodbProfile(res["mongodbProfile"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("forward_ssh_connectivity", flattenDatastreamConnectionProfileForwardSshConnectivity(res["forwardSshConnectivity"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("private_connectivity", flattenDatastreamConnectionProfilePrivateConnectivity(res["privateConnectivity"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("terraform_labels", flattenDatastreamConnectionProfileTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}
	if err := d.Set("effective_labels", flattenDatastreamConnectionProfileEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading ConnectionProfile: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("connection_profile_id"); !ok && v == "" {
			err = identity.Set("connection_profile_id", d.Get("connection_profile_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting connection_profile_id: %s", err)
			}
		}
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceDatastreamConnectionProfileUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if connectionProfileIdValue, ok := d.GetOk("connection_profile_id"); ok && connectionProfileIdValue.(string) != "" {
			if err = identity.Set("connection_profile_id", connectionProfileIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting connection_profile_id: %s", err)
			}
		}
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ConnectionProfile: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	displayNameProp, err := expandDatastreamConnectionProfileDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	oracleProfileProp, err := expandDatastreamConnectionProfileOracleProfile(d.Get("oracle_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("oracle_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, oracleProfileProp)) {
		obj["oracleProfile"] = oracleProfileProp
	}
	gcsProfileProp, err := expandDatastreamConnectionProfileGcsProfile(d.Get("gcs_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("gcs_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, gcsProfileProp)) {
		obj["gcsProfile"] = gcsProfileProp
	}
	mysqlProfileProp, err := expandDatastreamConnectionProfileMysqlProfile(d.Get("mysql_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("mysql_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, mysqlProfileProp)) {
		obj["mysqlProfile"] = mysqlProfileProp
	}
	bigqueryProfileProp, err := expandDatastreamConnectionProfileBigqueryProfile(d.Get("bigquery_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("bigquery_profile"); ok || !reflect.DeepEqual(v, bigqueryProfileProp) {
		obj["bigqueryProfile"] = bigqueryProfileProp
	}
	postgresqlProfileProp, err := expandDatastreamConnectionProfilePostgresqlProfile(d.Get("postgresql_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("postgresql_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, postgresqlProfileProp)) {
		obj["postgresqlProfile"] = postgresqlProfileProp
	}
	sqlServerProfileProp, err := expandDatastreamConnectionProfileSqlServerProfile(d.Get("sql_server_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("sql_server_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, sqlServerProfileProp)) {
		obj["sqlServerProfile"] = sqlServerProfileProp
	}
	mongodbProfileProp, err := expandDatastreamConnectionProfileMongodbProfile(d.Get("mongodb_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("mongodb_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, mongodbProfileProp)) {
		obj["mongodbProfile"] = mongodbProfileProp
	}
	forwardSshConnectivityProp, err := expandDatastreamConnectionProfileForwardSshConnectivity(d.Get("forward_ssh_connectivity"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("forward_ssh_connectivity"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, forwardSshConnectivityProp)) {
		obj["forwardSshConnectivity"] = forwardSshConnectivityProp
	}
	privateConnectivityProp, err := expandDatastreamConnectionProfilePrivateConnectivity(d.Get("private_connectivity"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("private_connectivity"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, privateConnectivityProp)) {
		obj["privateConnectivity"] = privateConnectivityProp
	}
	effectiveLabelsProp, err := expandDatastreamConnectionProfileEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DatastreamBasePath}}projects/{{project}}/locations/{{location}}/connectionProfiles/{{connection_profile_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating ConnectionProfile %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("oracle_profile") {
		updateMask = append(updateMask, "oracleProfile")
	}

	if d.HasChange("gcs_profile") {
		updateMask = append(updateMask, "gcsProfile")
	}

	if d.HasChange("mysql_profile") {
		updateMask = append(updateMask, "mysqlProfile")
	}

	if d.HasChange("bigquery_profile") {
		updateMask = append(updateMask, "bigqueryProfile")
	}

	if d.HasChange("postgresql_profile") {
		updateMask = append(updateMask, "postgresqlProfile")
	}

	if d.HasChange("sql_server_profile") {
		updateMask = append(updateMask, "sqlServerProfile")
	}

	if d.HasChange("mongodb_profile") {
		updateMask = append(updateMask, "mongodbProfile")
	}

	if d.HasChange("forward_ssh_connectivity") {
		updateMask = append(updateMask, "forwardSshConnectivity")
	}

	if d.HasChange("private_connectivity") {
		updateMask = append(updateMask, "privateConnectivity")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	if d.HasChange("mongodb_profile.0.username") {
		updateMask = append(updateMask, "mongodbProfile.username")
	}
	if d.HasChange("mongodb_profile.0.password") {
		// Note: Password updates might require special handling
		updateMask = append(updateMask, "mongodbProfile.password")
	}
	if d.HasChange("mongodb_profile.0.replica_set") {
		updateMask = append(updateMask, "mongodbProfile.replicaSet")
	}
	if d.HasChange("mongodb_profile.0.host_addresses") {
		updateMask = append(updateMask, "mongodbProfile.hostAddresses")
	}

	// Override the previous setting of updateMask to include state.
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	if d.Get("create_without_validation").(bool) {
		url, err = transport_tpg.AddQueryParams(url, map[string]string{"force": "true"})
	} else {
		url, err = transport_tpg.AddQueryParams(url, map[string]string{"force": "false"})
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating ConnectionProfile %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating ConnectionProfile %q: %#v", d.Id(), res)
		}

		err = DatastreamOperationWaitTime(
			config, res, project, "Updating ConnectionProfile", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceDatastreamConnectionProfileRead(d, meta)
}

func resourceDatastreamConnectionProfileDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ConnectionProfile: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{DatastreamBasePath}}projects/{{project}}/locations/{{location}}/connectionProfiles/{{connection_profile_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting ConnectionProfile %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "ConnectionProfile")
	}

	err = DatastreamOperationWaitTime(
		config, res, project, "Deleting ConnectionProfile", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting ConnectionProfile %q: %#v", d.Id(), res)
	return nil
}

func resourceDatastreamConnectionProfileImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/connectionProfiles/(?P<connection_profile_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<connection_profile_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<connection_profile_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/connectionProfiles/{{connection_profile_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenDatastreamConnectionProfileName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDatastreamConnectionProfileDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileOracleProfile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["hostname"] =
		flattenDatastreamConnectionProfileOracleProfileHostname(original["hostname"], d, config)
	transformed["port"] =
		flattenDatastreamConnectionProfileOracleProfilePort(original["port"], d, config)
	transformed["username"] =
		flattenDatastreamConnectionProfileOracleProfileUsername(original["username"], d, config)
	transformed["password"] =
		flattenDatastreamConnectionProfileOracleProfilePassword(original["password"], d, config)
	transformed["secret_manager_stored_password"] =
		flattenDatastreamConnectionProfileOracleProfileSecretManagerStoredPassword(original["secretManagerStoredPassword"], d, config)
	transformed["database_service"] =
		flattenDatastreamConnectionProfileOracleProfileDatabaseService(original["databaseService"], d, config)
	transformed["connection_attributes"] =
		flattenDatastreamConnectionProfileOracleProfileConnectionAttributes(original["connectionAttributes"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfileOracleProfileHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileOracleProfilePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDatastreamConnectionProfileOracleProfileUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileOracleProfilePassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("oracle_profile.0.password")
}

func flattenDatastreamConnectionProfileOracleProfileSecretManagerStoredPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileOracleProfileDatabaseService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileOracleProfileConnectionAttributes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileGcsProfile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["bucket"] =
		flattenDatastreamConnectionProfileGcsProfileBucket(original["bucket"], d, config)
	transformed["root_path"] =
		flattenDatastreamConnectionProfileGcsProfileRootPath(original["rootPath"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfileGcsProfileBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileGcsProfileRootPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMysqlProfile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["hostname"] =
		flattenDatastreamConnectionProfileMysqlProfileHostname(original["hostname"], d, config)
	transformed["port"] =
		flattenDatastreamConnectionProfileMysqlProfilePort(original["port"], d, config)
	transformed["username"] =
		flattenDatastreamConnectionProfileMysqlProfileUsername(original["username"], d, config)
	transformed["password"] =
		flattenDatastreamConnectionProfileMysqlProfilePassword(original["password"], d, config)
	transformed["secret_manager_stored_password"] =
		flattenDatastreamConnectionProfileMysqlProfileSecretManagerStoredPassword(original["secretManagerStoredPassword"], d, config)
	transformed["ssl_config"] =
		flattenDatastreamConnectionProfileMysqlProfileSslConfig(original["sslConfig"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfileMysqlProfileHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMysqlProfilePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDatastreamConnectionProfileMysqlProfileUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMysqlProfilePassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("mysql_profile.0.password")
}

func flattenDatastreamConnectionProfileMysqlProfileSecretManagerStoredPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMysqlProfileSslConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["client_key"] =
		flattenDatastreamConnectionProfileMysqlProfileSslConfigClientKey(original["clientKey"], d, config)
	transformed["client_key_set"] =
		flattenDatastreamConnectionProfileMysqlProfileSslConfigClientKeySet(original["clientKeySet"], d, config)
	transformed["client_certificate"] =
		flattenDatastreamConnectionProfileMysqlProfileSslConfigClientCertificate(original["clientCertificate"], d, config)
	transformed["client_certificate_set"] =
		flattenDatastreamConnectionProfileMysqlProfileSslConfigClientCertificateSet(original["clientCertificateSet"], d, config)
	transformed["ca_certificate"] =
		flattenDatastreamConnectionProfileMysqlProfileSslConfigCaCertificate(original["caCertificate"], d, config)
	transformed["ca_certificate_set"] =
		flattenDatastreamConnectionProfileMysqlProfileSslConfigCaCertificateSet(original["caCertificateSet"], d, config)
	return []interface{}{transformed}
}

func flattenDatastreamConnectionProfileMysqlProfileSslConfigClientKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("mysql_profile.0.ssl_config.0.client_key")
}

func flattenDatastreamConnectionProfileMysqlProfileSslConfigClientKeySet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMysqlProfileSslConfigClientCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("mysql_profile.0.ssl_config.0.client_certificate")
}

func flattenDatastreamConnectionProfileMysqlProfileSslConfigClientCertificateSet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMysqlProfileSslConfigCaCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("mysql_profile.0.ssl_config.0.ca_certificate")
}

func flattenDatastreamConnectionProfileMysqlProfileSslConfigCaCertificateSet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileBigqueryProfile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDatastreamConnectionProfilePostgresqlProfile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["hostname"] =
		flattenDatastreamConnectionProfilePostgresqlProfileHostname(original["hostname"], d, config)
	transformed["port"] =
		flattenDatastreamConnectionProfilePostgresqlProfilePort(original["port"], d, config)
	transformed["username"] =
		flattenDatastreamConnectionProfilePostgresqlProfileUsername(original["username"], d, config)
	transformed["password"] =
		flattenDatastreamConnectionProfilePostgresqlProfilePassword(original["password"], d, config)
	transformed["secret_manager_stored_password"] =
		flattenDatastreamConnectionProfilePostgresqlProfileSecretManagerStoredPassword(original["secretManagerStoredPassword"], d, config)
	transformed["database"] =
		flattenDatastreamConnectionProfilePostgresqlProfileDatabase(original["database"], d, config)
	transformed["ssl_config"] =
		flattenDatastreamConnectionProfilePostgresqlProfileSslConfig(original["sslConfig"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfilePostgresqlProfileHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfilePostgresqlProfilePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDatastreamConnectionProfilePostgresqlProfileUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfilePostgresqlProfilePassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("postgresql_profile.0.password")
}

func flattenDatastreamConnectionProfilePostgresqlProfileSecretManagerStoredPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfilePostgresqlProfileDatabase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfilePostgresqlProfileSslConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["server_verification"] =
		flattenDatastreamConnectionProfilePostgresqlProfileSslConfigServerVerification(original["serverVerification"], d, config)
	transformed["server_and_client_verification"] =
		flattenDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerification(original["serverAndClientVerification"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfilePostgresqlProfileSslConfigServerVerification(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ca_certificate"] =
		flattenDatastreamConnectionProfilePostgresqlProfileSslConfigServerVerificationCaCertificate(original["caCertificate"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfilePostgresqlProfileSslConfigServerVerificationCaCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("postgresql_profile.0.ssl_config.0.server_verification.0.ca_certificate")
}

func flattenDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerification(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("postgresql_profile.0.ssl_config.0.server_and_client_verification")
}
func flattenDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerificationClientCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("postgresql_profile.0.ssl_config.0.server_and_client_verification.0.client_certificate")
}

func flattenDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerificationClientKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("postgresql_profile.0.ssl_config.0.server_and_client_verification.0.client_key")
}

func flattenDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerificationCaCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("postgresql_profile.0.ssl_config.0.server_and_client_verification.0.ca_certificate")
}

func flattenDatastreamConnectionProfileSqlServerProfile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["hostname"] =
		flattenDatastreamConnectionProfileSqlServerProfileHostname(original["hostname"], d, config)
	transformed["port"] =
		flattenDatastreamConnectionProfileSqlServerProfilePort(original["port"], d, config)
	transformed["username"] =
		flattenDatastreamConnectionProfileSqlServerProfileUsername(original["username"], d, config)
	transformed["password"] =
		flattenDatastreamConnectionProfileSqlServerProfilePassword(original["password"], d, config)
	transformed["secret_manager_stored_password"] =
		flattenDatastreamConnectionProfileSqlServerProfileSecretManagerStoredPassword(original["secretManagerStoredPassword"], d, config)
	transformed["database"] =
		flattenDatastreamConnectionProfileSqlServerProfileDatabase(original["database"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfileSqlServerProfileHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileSqlServerProfilePort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDatastreamConnectionProfileSqlServerProfileUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileSqlServerProfilePassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("sql_server_profile.0.password")
}

func flattenDatastreamConnectionProfileSqlServerProfileSecretManagerStoredPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileSqlServerProfileDatabase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMongodbProfile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["host_addresses"] =
		flattenDatastreamConnectionProfileMongodbProfileHostAddresses(original["hostAddresses"], d, config)
	transformed["replica_set"] =
		flattenDatastreamConnectionProfileMongodbProfileReplicaSet(original["replicaSet"], d, config)
	transformed["username"] =
		flattenDatastreamConnectionProfileMongodbProfileUsername(original["username"], d, config)
	transformed["password"] =
		flattenDatastreamConnectionProfileMongodbProfilePassword(original["password"], d, config)
	transformed["secret_manager_stored_password"] =
		flattenDatastreamConnectionProfileMongodbProfileSecretManagerStoredPassword(original["secretManagerStoredPassword"], d, config)
	transformed["ssl_config"] =
		flattenDatastreamConnectionProfileMongodbProfileSslConfig(original["sslConfig"], d, config)
	transformed["srv_connection_format"] =
		flattenDatastreamConnectionProfileMongodbProfileSrvConnectionFormat(original["srvConnectionFormat"], d, config)
	transformed["standard_connection_format"] =
		flattenDatastreamConnectionProfileMongodbProfileStandardConnectionFormat(original["standardConnectionFormat"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfileMongodbProfileHostAddresses(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"hostname": flattenDatastreamConnectionProfileMongodbProfileHostAddressesHostname(original["hostname"], d, config),
			"port":     flattenDatastreamConnectionProfileMongodbProfileHostAddressesPort(original["port"], d, config),
		})
	}
	return transformed
}
func flattenDatastreamConnectionProfileMongodbProfileHostAddressesHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMongodbProfileHostAddressesPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDatastreamConnectionProfileMongodbProfileReplicaSet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMongodbProfileUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMongodbProfilePassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMongodbProfileSecretManagerStoredPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMongodbProfileSslConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["client_key"] =
		flattenDatastreamConnectionProfileMongodbProfileSslConfigClientKey(original["clientKey"], d, config)
	transformed["client_key_set"] =
		flattenDatastreamConnectionProfileMongodbProfileSslConfigClientKeySet(original["clientKeySet"], d, config)
	transformed["client_certificate"] =
		flattenDatastreamConnectionProfileMongodbProfileSslConfigClientCertificate(original["clientCertificate"], d, config)
	transformed["client_certificate_set"] =
		flattenDatastreamConnectionProfileMongodbProfileSslConfigClientCertificateSet(original["clientCertificateSet"], d, config)
	transformed["ca_certificate"] =
		flattenDatastreamConnectionProfileMongodbProfileSslConfigCaCertificate(original["caCertificate"], d, config)
	transformed["ca_certificate_set"] =
		flattenDatastreamConnectionProfileMongodbProfileSslConfigCaCertificateSet(original["caCertificateSet"], d, config)
	transformed["secret_manager_stored_client_key"] =
		flattenDatastreamConnectionProfileMongodbProfileSslConfigSecretManagerStoredClientKey(original["secretManagerStoredClientKey"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfileMongodbProfileSslConfigClientKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("mongodb_profile.0.ssl_config.0.client_key")
}

func flattenDatastreamConnectionProfileMongodbProfileSslConfigClientKeySet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMongodbProfileSslConfigClientCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("mongodb_profile.0.ssl_config.0.client_certificate")
}

func flattenDatastreamConnectionProfileMongodbProfileSslConfigClientCertificateSet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMongodbProfileSslConfigCaCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("mongodb_profile.0.ssl_config.0.ca_certificate")
}

func flattenDatastreamConnectionProfileMongodbProfileSslConfigCaCertificateSet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileMongodbProfileSslConfigSecretManagerStoredClientKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("mongodb_profile.0.ssl_config.0.secret_manager_stored_client_key")
}

func flattenDatastreamConnectionProfileMongodbProfileSrvConnectionFormat(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDatastreamConnectionProfileMongodbProfileStandardConnectionFormat(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["direct_connection"] =
		flattenDatastreamConnectionProfileMongodbProfileStandardConnectionFormatDirectConnection(original["directConnection"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfileMongodbProfileStandardConnectionFormatDirectConnection(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileForwardSshConnectivity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["hostname"] =
		flattenDatastreamConnectionProfileForwardSshConnectivityHostname(original["hostname"], d, config)
	transformed["username"] =
		flattenDatastreamConnectionProfileForwardSshConnectivityUsername(original["username"], d, config)
	transformed["port"] =
		flattenDatastreamConnectionProfileForwardSshConnectivityPort(original["port"], d, config)
	transformed["password"] =
		flattenDatastreamConnectionProfileForwardSshConnectivityPassword(original["password"], d, config)
	transformed["private_key"] =
		flattenDatastreamConnectionProfileForwardSshConnectivityPrivateKey(original["privateKey"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfileForwardSshConnectivityHostname(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileForwardSshConnectivityUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileForwardSshConnectivityPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDatastreamConnectionProfileForwardSshConnectivityPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("forward_ssh_connectivity.0.password")
}

func flattenDatastreamConnectionProfileForwardSshConnectivityPrivateKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return d.Get("forward_ssh_connectivity.0.private_key")
}

func flattenDatastreamConnectionProfilePrivateConnectivity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["private_connection"] =
		flattenDatastreamConnectionProfilePrivateConnectivityPrivateConnection(original["privateConnection"], d, config)
	return []interface{}{transformed}
}
func flattenDatastreamConnectionProfilePrivateConnectivityPrivateConnection(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDatastreamConnectionProfileTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDatastreamConnectionProfileEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandDatastreamConnectionProfileDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileOracleProfile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHostname, err := expandDatastreamConnectionProfileOracleProfileHostname(original["hostname"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostname"] = transformedHostname
	}

	transformedPort, err := expandDatastreamConnectionProfileOracleProfilePort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	transformedUsername, err := expandDatastreamConnectionProfileOracleProfileUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	transformedPassword, err := expandDatastreamConnectionProfileOracleProfilePassword(original["password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["password"] = transformedPassword
	}

	transformedSecretManagerStoredPassword, err := expandDatastreamConnectionProfileOracleProfileSecretManagerStoredPassword(original["secret_manager_stored_password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretManagerStoredPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretManagerStoredPassword"] = transformedSecretManagerStoredPassword
	}

	transformedDatabaseService, err := expandDatastreamConnectionProfileOracleProfileDatabaseService(original["database_service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatabaseService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["databaseService"] = transformedDatabaseService
	}

	transformedConnectionAttributes, err := expandDatastreamConnectionProfileOracleProfileConnectionAttributes(original["connection_attributes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConnectionAttributes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["connectionAttributes"] = transformedConnectionAttributes
	}

	return transformed, nil
}

func expandDatastreamConnectionProfileOracleProfileHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileOracleProfilePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileOracleProfileUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileOracleProfilePassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileOracleProfileSecretManagerStoredPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileOracleProfileDatabaseService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileOracleProfileConnectionAttributes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandDatastreamConnectionProfileGcsProfile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBucket, err := expandDatastreamConnectionProfileGcsProfileBucket(original["bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bucket"] = transformedBucket
	}

	transformedRootPath, err := expandDatastreamConnectionProfileGcsProfileRootPath(original["root_path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRootPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rootPath"] = transformedRootPath
	}

	return transformed, nil
}

func expandDatastreamConnectionProfileGcsProfileBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileGcsProfileRootPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMysqlProfile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHostname, err := expandDatastreamConnectionProfileMysqlProfileHostname(original["hostname"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostname"] = transformedHostname
	}

	transformedPort, err := expandDatastreamConnectionProfileMysqlProfilePort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	transformedUsername, err := expandDatastreamConnectionProfileMysqlProfileUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	transformedPassword, err := expandDatastreamConnectionProfileMysqlProfilePassword(original["password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["password"] = transformedPassword
	}

	transformedSecretManagerStoredPassword, err := expandDatastreamConnectionProfileMysqlProfileSecretManagerStoredPassword(original["secret_manager_stored_password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretManagerStoredPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretManagerStoredPassword"] = transformedSecretManagerStoredPassword
	}

	transformedSslConfig, err := expandDatastreamConnectionProfileMysqlProfileSslConfig(original["ssl_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSslConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sslConfig"] = transformedSslConfig
	}

	return transformed, nil
}

func expandDatastreamConnectionProfileMysqlProfileHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMysqlProfilePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMysqlProfileUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMysqlProfilePassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMysqlProfileSecretManagerStoredPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMysqlProfileSslConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedClientKey, err := expandDatastreamConnectionProfileMysqlProfileSslConfigClientKey(original["client_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientKey"] = transformedClientKey
	}

	transformedClientKeySet, err := expandDatastreamConnectionProfileMysqlProfileSslConfigClientKeySet(original["client_key_set"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientKeySet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientKeySet"] = transformedClientKeySet
	}

	transformedClientCertificate, err := expandDatastreamConnectionProfileMysqlProfileSslConfigClientCertificate(original["client_certificate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientCertificate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientCertificate"] = transformedClientCertificate
	}

	transformedClientCertificateSet, err := expandDatastreamConnectionProfileMysqlProfileSslConfigClientCertificateSet(original["client_certificate_set"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientCertificateSet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientCertificateSet"] = transformedClientCertificateSet
	}

	transformedCaCertificate, err := expandDatastreamConnectionProfileMysqlProfileSslConfigCaCertificate(original["ca_certificate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCertificate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCertificate"] = transformedCaCertificate
	}

	transformedCaCertificateSet, err := expandDatastreamConnectionProfileMysqlProfileSslConfigCaCertificateSet(original["ca_certificate_set"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCertificateSet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCertificateSet"] = transformedCaCertificateSet
	}

	return transformed, nil
}

func expandDatastreamConnectionProfileMysqlProfileSslConfigClientKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMysqlProfileSslConfigClientKeySet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMysqlProfileSslConfigClientCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMysqlProfileSslConfigClientCertificateSet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMysqlProfileSslConfigCaCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMysqlProfileSslConfigCaCertificateSet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileBigqueryProfile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDatastreamConnectionProfilePostgresqlProfile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHostname, err := expandDatastreamConnectionProfilePostgresqlProfileHostname(original["hostname"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostname"] = transformedHostname
	}

	transformedPort, err := expandDatastreamConnectionProfilePostgresqlProfilePort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	transformedUsername, err := expandDatastreamConnectionProfilePostgresqlProfileUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	transformedPassword, err := expandDatastreamConnectionProfilePostgresqlProfilePassword(original["password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["password"] = transformedPassword
	}

	transformedSecretManagerStoredPassword, err := expandDatastreamConnectionProfilePostgresqlProfileSecretManagerStoredPassword(original["secret_manager_stored_password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretManagerStoredPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretManagerStoredPassword"] = transformedSecretManagerStoredPassword
	}

	transformedDatabase, err := expandDatastreamConnectionProfilePostgresqlProfileDatabase(original["database"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatabase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["database"] = transformedDatabase
	}

	transformedSslConfig, err := expandDatastreamConnectionProfilePostgresqlProfileSslConfig(original["ssl_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSslConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sslConfig"] = transformedSslConfig
	}

	return transformed, nil
}

func expandDatastreamConnectionProfilePostgresqlProfileHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfilePostgresqlProfilePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfilePostgresqlProfileUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfilePostgresqlProfilePassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfilePostgresqlProfileSecretManagerStoredPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfilePostgresqlProfileDatabase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfilePostgresqlProfileSslConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServerVerification, err := expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerVerification(original["server_verification"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServerVerification); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serverVerification"] = transformedServerVerification
	}

	transformedServerAndClientVerification, err := expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerification(original["server_and_client_verification"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServerAndClientVerification); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serverAndClientVerification"] = transformedServerAndClientVerification
	}

	return transformed, nil
}

func expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerVerification(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCaCertificate, err := expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerVerificationCaCertificate(original["ca_certificate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCertificate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCertificate"] = transformedCaCertificate
	}

	return transformed, nil
}

func expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerVerificationCaCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerification(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedClientCertificate, err := expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerificationClientCertificate(original["client_certificate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientCertificate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientCertificate"] = transformedClientCertificate
	}

	transformedClientKey, err := expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerificationClientKey(original["client_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientKey"] = transformedClientKey
	}

	transformedCaCertificate, err := expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerificationCaCertificate(original["ca_certificate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCertificate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCertificate"] = transformedCaCertificate
	}

	return transformed, nil
}

func expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerificationClientCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerificationClientKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfilePostgresqlProfileSslConfigServerAndClientVerificationCaCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileSqlServerProfile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHostname, err := expandDatastreamConnectionProfileSqlServerProfileHostname(original["hostname"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostname"] = transformedHostname
	}

	transformedPort, err := expandDatastreamConnectionProfileSqlServerProfilePort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	transformedUsername, err := expandDatastreamConnectionProfileSqlServerProfileUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	transformedPassword, err := expandDatastreamConnectionProfileSqlServerProfilePassword(original["password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["password"] = transformedPassword
	}

	transformedSecretManagerStoredPassword, err := expandDatastreamConnectionProfileSqlServerProfileSecretManagerStoredPassword(original["secret_manager_stored_password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretManagerStoredPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretManagerStoredPassword"] = transformedSecretManagerStoredPassword
	}

	transformedDatabase, err := expandDatastreamConnectionProfileSqlServerProfileDatabase(original["database"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatabase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["database"] = transformedDatabase
	}

	return transformed, nil
}

func expandDatastreamConnectionProfileSqlServerProfileHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileSqlServerProfilePort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileSqlServerProfileUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileSqlServerProfilePassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileSqlServerProfileSecretManagerStoredPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileSqlServerProfileDatabase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHostAddresses, err := expandDatastreamConnectionProfileMongodbProfileHostAddresses(original["host_addresses"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostAddresses); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostAddresses"] = transformedHostAddresses
	}

	transformedReplicaSet, err := expandDatastreamConnectionProfileMongodbProfileReplicaSet(original["replica_set"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReplicaSet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["replicaSet"] = transformedReplicaSet
	}

	transformedUsername, err := expandDatastreamConnectionProfileMongodbProfileUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	transformedPassword, err := expandDatastreamConnectionProfileMongodbProfilePassword(original["password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["password"] = transformedPassword
	}

	transformedSecretManagerStoredPassword, err := expandDatastreamConnectionProfileMongodbProfileSecretManagerStoredPassword(original["secret_manager_stored_password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretManagerStoredPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretManagerStoredPassword"] = transformedSecretManagerStoredPassword
	}

	transformedSslConfig, err := expandDatastreamConnectionProfileMongodbProfileSslConfig(original["ssl_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSslConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sslConfig"] = transformedSslConfig
	}

	transformedSrvConnectionFormat, err := expandDatastreamConnectionProfileMongodbProfileSrvConnectionFormat(original["srv_connection_format"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["srvConnectionFormat"] = transformedSrvConnectionFormat
	}

	transformedStandardConnectionFormat, err := expandDatastreamConnectionProfileMongodbProfileStandardConnectionFormat(original["standard_connection_format"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["standardConnectionFormat"] = transformedStandardConnectionFormat
	}

	return transformed, nil
}

func expandDatastreamConnectionProfileMongodbProfileHostAddresses(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedHostname, err := expandDatastreamConnectionProfileMongodbProfileHostAddressesHostname(original["hostname"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["hostname"] = transformedHostname
		}

		transformedPort, err := expandDatastreamConnectionProfileMongodbProfileHostAddressesPort(original["port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["port"] = transformedPort
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDatastreamConnectionProfileMongodbProfileHostAddressesHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileHostAddressesPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileReplicaSet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfilePassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileSecretManagerStoredPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileSslConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedClientKey, err := expandDatastreamConnectionProfileMongodbProfileSslConfigClientKey(original["client_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientKey"] = transformedClientKey
	}

	transformedClientKeySet, err := expandDatastreamConnectionProfileMongodbProfileSslConfigClientKeySet(original["client_key_set"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientKeySet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientKeySet"] = transformedClientKeySet
	}

	transformedClientCertificate, err := expandDatastreamConnectionProfileMongodbProfileSslConfigClientCertificate(original["client_certificate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientCertificate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientCertificate"] = transformedClientCertificate
	}

	transformedClientCertificateSet, err := expandDatastreamConnectionProfileMongodbProfileSslConfigClientCertificateSet(original["client_certificate_set"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientCertificateSet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientCertificateSet"] = transformedClientCertificateSet
	}

	transformedCaCertificate, err := expandDatastreamConnectionProfileMongodbProfileSslConfigCaCertificate(original["ca_certificate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCertificate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCertificate"] = transformedCaCertificate
	}

	transformedCaCertificateSet, err := expandDatastreamConnectionProfileMongodbProfileSslConfigCaCertificateSet(original["ca_certificate_set"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCertificateSet); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCertificateSet"] = transformedCaCertificateSet
	}

	transformedSecretManagerStoredClientKey, err := expandDatastreamConnectionProfileMongodbProfileSslConfigSecretManagerStoredClientKey(original["secret_manager_stored_client_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretManagerStoredClientKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretManagerStoredClientKey"] = transformedSecretManagerStoredClientKey
	}

	return transformed, nil
}

func expandDatastreamConnectionProfileMongodbProfileSslConfigClientKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileSslConfigClientKeySet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileSslConfigClientCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileSslConfigClientCertificateSet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileSslConfigCaCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileSslConfigCaCertificateSet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileSslConfigSecretManagerStoredClientKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileMongodbProfileSrvConnectionFormat(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDatastreamConnectionProfileMongodbProfileStandardConnectionFormat(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDirectConnection, err := expandDatastreamConnectionProfileMongodbProfileStandardConnectionFormatDirectConnection(original["direct_connection"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDirectConnection); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["directConnection"] = transformedDirectConnection
	}

	return transformed, nil
}

func expandDatastreamConnectionProfileMongodbProfileStandardConnectionFormatDirectConnection(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileForwardSshConnectivity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHostname, err := expandDatastreamConnectionProfileForwardSshConnectivityHostname(original["hostname"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostname); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hostname"] = transformedHostname
	}

	transformedUsername, err := expandDatastreamConnectionProfileForwardSshConnectivityUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	transformedPort, err := expandDatastreamConnectionProfileForwardSshConnectivityPort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	transformedPassword, err := expandDatastreamConnectionProfileForwardSshConnectivityPassword(original["password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["password"] = transformedPassword
	}

	transformedPrivateKey, err := expandDatastreamConnectionProfileForwardSshConnectivityPrivateKey(original["private_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrivateKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["privateKey"] = transformedPrivateKey
	}

	return transformed, nil
}

func expandDatastreamConnectionProfileForwardSshConnectivityHostname(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileForwardSshConnectivityUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileForwardSshConnectivityPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileForwardSshConnectivityPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileForwardSshConnectivityPrivateKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfilePrivateConnectivity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPrivateConnection, err := expandDatastreamConnectionProfilePrivateConnectivityPrivateConnection(original["private_connection"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrivateConnection); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["privateConnection"] = transformedPrivateConnection
	}

	return transformed, nil
}

func expandDatastreamConnectionProfilePrivateConnectivityPrivateConnection(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamConnectionProfileEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
