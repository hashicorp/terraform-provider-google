// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/ces/Guardrail.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package ces

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceCESGuardrail() *schema.Resource {
	return &schema.Resource{
		Create: resourceCESGuardrailCreate,
		Read:   resourceCESGuardrailRead,
		Update: resourceCESGuardrailUpdate,
		Delete: resourceCESGuardrailDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCESGuardrailImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"app": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"app": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Display name of the guardrail.`,
			},
			"guardrail_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The ID to use for the guardrail, which will become the final component of
the guardrail's resource name. If not provided, a unique ID will be
automatically assigned for the guardrail.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"action": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Action that is taken when a certain precondition is met.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"generative_answer": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The agent will immediately respond with a generative answer.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"prompt": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The prompt to use for the generative answer.`,
									},
								},
							},
						},
						"respond_immediately": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The agent will immediately respond with a preconfigured response.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"responses": {
										Type:     schema.TypeList,
										Required: true,
										Description: `The canned responses for the agent to choose from. The response is chosen
randomly.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"text": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `Text for the agent to respond with.`,
												},
												"disabled": {
													Type:     schema.TypeBool,
													Optional: true,
													Description: `Whether the response is disabled. Disabled responses are not used by the
agent.`,
												},
											},
										},
									},
								},
							},
						},
						"transfer_agent": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The agent will transfer the conversation to a different agent.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"agent": {
										Type:     schema.TypeString,
										Required: true,
										Description: `The name of the agent to transfer the conversation to. The agent must be
in the same app as the current agent.
Format:
'projects/{project}/locations/{location}/apps/{app}/agents/{agent}'`,
									},
								},
							},
						},
					},
				},
			},
			"code_callback": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Guardrail that blocks the conversation based on the code callbacks
provided.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"after_agent_callback": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `A callback defines the custom logic to be executed at various stages of
agent interaction.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"python_code": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The python code to execute for the callback.`,
									},
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Human-readable description of the callback.`,
									},
									"disabled": {
										Type:     schema.TypeBool,
										Optional: true,
										Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
									},
								},
							},
						},
						"after_model_callback": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `A callback defines the custom logic to be executed at various stages of
agent interaction.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"python_code": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The python code to execute for the callback.`,
									},
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Human-readable description of the callback.`,
									},
									"disabled": {
										Type:     schema.TypeBool,
										Optional: true,
										Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
									},
								},
							},
						},
						"before_agent_callback": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `A callback defines the custom logic to be executed at various stages of
agent interaction.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"python_code": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The python code to execute for the callback.`,
									},
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Human-readable description of the callback.`,
									},
									"disabled": {
										Type:     schema.TypeBool,
										Optional: true,
										Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
									},
								},
							},
						},
						"before_model_callback": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `A callback defines the custom logic to be executed at various stages of
agent interaction.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"python_code": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The python code to execute for the callback.`,
									},
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Human-readable description of the callback.`,
									},
									"disabled": {
										Type:     schema.TypeBool,
										Optional: true,
										Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
									},
								},
							},
						},
					},
				},
			},
			"content_filter": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Guardrail that bans certain content from being used in the conversation.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"match_type": {
							Type:     schema.TypeString,
							Required: true,
							Description: `Match type for the content filter.
Possible values:
SIMPLE_STRING_MATCH
WORD_BOUNDARY_STRING_MATCH
REGEXP_MATCH`,
						},
						"banned_contents": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `List of banned phrases. Applies to both user inputs and agent responses.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"banned_contents_in_agent_response": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `List of banned phrases. Applies only to agent responses.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"banned_contents_in_user_input": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `List of banned phrases. Applies only to user inputs.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"disregard_diacritics": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `If true, diacritics are ignored during matching.`,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Description of the guardrail.`,
			},
			"enabled": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Whether the guardrail is enabled.`,
			},
			"llm_policy": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Guardrail that blocks the conversation if the LLM response is considered
violating the policy based on the LLM classification.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"policy_scope": {
							Type:         schema.TypeString,
							Required:     true,
							ValidateFunc: verify.ValidateEnum([]string{"USER_QUERY", "AGENT_RESPONSE", "USER_QUERY_AND_AGENT_RESPONSE"}),
							Description: `Defines when to apply the policy check during the conversation. If set to
'POLICY_SCOPE_UNSPECIFIED', the policy will be applied to the user input.
When applying the policy to the agent response, additional latency will
be introduced before the agent can respond.
Possible values:
USER_QUERY
AGENT_RESPONSE
USER_QUERY_AND_AGENT_RESPONSE Possible values: ["USER_QUERY", "AGENT_RESPONSE", "USER_QUERY_AND_AGENT_RESPONSE"]`,
						},
						"prompt": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Policy prompt.`,
						},
						"allow_short_utterance": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `By default, the LLM policy check is bypassed for short utterances.
Enabling this setting applies the policy check to all utterances,
including those that would normally be skipped.`,
						},
						"fail_open": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `If an error occurs during the policy check, fail open and do not trigger
the guardrail.`,
						},
						"max_conversation_messages": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `When checking this policy, consider the last 'n' messages in the
conversation.
When not set a default value of 10 will be used.`,
						},
						"model_settings": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Model settings contains various configurations for the LLM model.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"model": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
									},
									"temperature": {
										Type:     schema.TypeFloat,
										Optional: true,
										Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
									},
								},
							},
						},
					},
				},
			},
			"llm_prompt_security": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Guardrail that blocks the conversation if the input is considered unsafe
based on the LLM classification.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"custom_policy": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Guardrail that blocks the conversation if the LLM response is considered
violating the policy based on the LLM classification.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"policy_scope": {
										Type:     schema.TypeString,
										Required: true,
										Description: `Defines when to apply the policy check during the conversation. If set to
'POLICY_SCOPE_UNSPECIFIED', the policy will be applied to the user input.
When applying the policy to the agent response, additional latency will
be introduced before the agent can respond.
Possible values:
USER_QUERY
AGENT_RESPONSE
USER_QUERY_AND_AGENT_RESPONSE`,
									},
									"prompt": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Policy prompt.`,
									},
									"allow_short_utterance": {
										Type:     schema.TypeBool,
										Optional: true,
										Description: `By default, the LLM policy check is bypassed for short utterances.
Enabling this setting applies the policy check to all utterances,
including those that would normally be skipped.`,
									},
									"fail_open": {
										Type:     schema.TypeBool,
										Optional: true,
										Description: `If an error occurs during the policy check, fail open and do not trigger
the guardrail.`,
									},
									"max_conversation_messages": {
										Type:     schema.TypeInt,
										Optional: true,
										Description: `When checking this policy, consider the last 'n' messages in the
conversation.
When not set a default value of 10 will be used.`,
									},
									"model_settings": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Model settings contains various configurations for the LLM model.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"model": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
												},
												"temperature": {
													Type:     schema.TypeFloat,
													Optional: true,
													Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
												},
											},
										},
									},
								},
							},
						},
						"default_settings": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for default system security settings.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"default_prompt_template": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The default prompt template used by the system.
This field is for display purposes to show the user what prompt
the system uses by default. It is OUTPUT_ONLY.`,
									},
								},
							},
						},
					},
				},
			},
			"model_safety": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Model safety settings overrides. When this is set, it will override the
default settings and trigger the guardrail if the response is considered
unsafe.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"safety_settings": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `List of safety settings.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"category": {
										Type:         schema.TypeString,
										Required:     true,
										ValidateFunc: verify.ValidateEnum([]string{"HARM_CATEGORY_HATE_SPEECH", "HARM_CATEGORY_DANGEROUS_CONTENT", "HARM_CATEGORY_HARASSMENT", "HARM_CATEGORY_SEXUALLY_EXPLICIT"}),
										Description: `The harm category.
Possible values:
HARM_CATEGORY_HATE_SPEECH
HARM_CATEGORY_DANGEROUS_CONTENT
HARM_CATEGORY_HARASSMENT
HARM_CATEGORY_SEXUALLY_EXPLICIT Possible values: ["HARM_CATEGORY_HATE_SPEECH", "HARM_CATEGORY_DANGEROUS_CONTENT", "HARM_CATEGORY_HARASSMENT", "HARM_CATEGORY_SEXUALLY_EXPLICIT"]`,
									},
									"threshold": {
										Type:         schema.TypeString,
										Required:     true,
										ValidateFunc: verify.ValidateEnum([]string{"BLOCK_LOW_AND_ABOVE", "BLOCK_MEDIUM_AND_ABOVE", "BLOCK_ONLY_HIGH", "BLOCK_NONE", "OFF"}),
										Description: `The harm block threshold.
Possible values:
BLOCK_LOW_AND_ABOVE
BLOCK_MEDIUM_AND_ABOVE
BLOCK_ONLY_HIGH
BLOCK_NONE
OFF Possible values: ["BLOCK_LOW_AND_ABOVE", "BLOCK_MEDIUM_AND_ABOVE", "BLOCK_ONLY_HIGH", "BLOCK_NONE", "OFF"]`,
									},
								},
							},
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp when the guardrail was created.`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Etag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The unique identifier of the guardrail.
Format:
'projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}'`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp when the guardrail was last updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCESGuardrailCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	actionProp, err := expandCESGuardrailAction(d.Get("action"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("action"); !tpgresource.IsEmptyValue(reflect.ValueOf(actionProp)) && (ok || !reflect.DeepEqual(v, actionProp)) {
		obj["action"] = actionProp
	}
	codeCallbackProp, err := expandCESGuardrailCodeCallback(d.Get("code_callback"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("code_callback"); !tpgresource.IsEmptyValue(reflect.ValueOf(codeCallbackProp)) && (ok || !reflect.DeepEqual(v, codeCallbackProp)) {
		obj["codeCallback"] = codeCallbackProp
	}
	contentFilterProp, err := expandCESGuardrailContentFilter(d.Get("content_filter"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("content_filter"); !tpgresource.IsEmptyValue(reflect.ValueOf(contentFilterProp)) && (ok || !reflect.DeepEqual(v, contentFilterProp)) {
		obj["contentFilter"] = contentFilterProp
	}
	descriptionProp, err := expandCESGuardrailDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	displayNameProp, err := expandCESGuardrailDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	enabledProp, err := expandCESGuardrailEnabled(d.Get("enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("enabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(enabledProp)) && (ok || !reflect.DeepEqual(v, enabledProp)) {
		obj["enabled"] = enabledProp
	}
	llmPolicyProp, err := expandCESGuardrailLlmPolicy(d.Get("llm_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("llm_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(llmPolicyProp)) && (ok || !reflect.DeepEqual(v, llmPolicyProp)) {
		obj["llmPolicy"] = llmPolicyProp
	}
	llmPromptSecurityProp, err := expandCESGuardrailLlmPromptSecurity(d.Get("llm_prompt_security"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("llm_prompt_security"); !tpgresource.IsEmptyValue(reflect.ValueOf(llmPromptSecurityProp)) && (ok || !reflect.DeepEqual(v, llmPromptSecurityProp)) {
		obj["llmPromptSecurity"] = llmPromptSecurityProp
	}
	modelSafetyProp, err := expandCESGuardrailModelSafety(d.Get("model_safety"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("model_safety"); !tpgresource.IsEmptyValue(reflect.ValueOf(modelSafetyProp)) && (ok || !reflect.DeepEqual(v, modelSafetyProp)) {
		obj["modelSafety"] = modelSafetyProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/guardrails?guardrailId={{guardrail_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Guardrail: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Guardrail: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Guardrail: %s", err)
	}
	// Set computed resource properties from create API response so that they're available on the subsequent Read
	// call.
	err = resourceCESGuardrailPostCreateSetComputedFields(d, meta, res)
	if err != nil {
		return fmt.Errorf("setting computed ID format fields: %w", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{app}}/guardrails/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Guardrail %q: %#v", d.Id(), res)

	return resourceCESGuardrailRead(d, meta)
}

func resourceCESGuardrailRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/guardrails/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Guardrail: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("CESGuardrail %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}

	if err := d.Set("action", flattenCESGuardrailAction(res["action"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("code_callback", flattenCESGuardrailCodeCallback(res["codeCallback"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("content_filter", flattenCESGuardrailContentFilter(res["contentFilter"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("create_time", flattenCESGuardrailCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("description", flattenCESGuardrailDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("display_name", flattenCESGuardrailDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("enabled", flattenCESGuardrailEnabled(res["enabled"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("etag", flattenCESGuardrailEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("llm_policy", flattenCESGuardrailLlmPolicy(res["llmPolicy"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("llm_prompt_security", flattenCESGuardrailLlmPromptSecurity(res["llmPromptSecurity"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("model_safety", flattenCESGuardrailModelSafety(res["modelSafety"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("name", flattenCESGuardrailName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}
	if err := d.Set("update_time", flattenCESGuardrailUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Guardrail: %s", err)
	}

	identity, err := d.Identity()
	if err != nil && identity != nil {
		if v, ok := identity.GetOk("name"); ok && v != "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("location"); ok && v != "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("app"); ok && v != "" {
			err = identity.Set("app", d.Get("app").(string))
			if err != nil {
				return fmt.Errorf("Error setting app: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); ok && v != "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] identity not set: %s", err)
	}
	return nil
}

func resourceCESGuardrailUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Guardrail: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	actionProp, err := expandCESGuardrailAction(d.Get("action"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("action"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, actionProp)) {
		obj["action"] = actionProp
	}
	codeCallbackProp, err := expandCESGuardrailCodeCallback(d.Get("code_callback"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("code_callback"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, codeCallbackProp)) {
		obj["codeCallback"] = codeCallbackProp
	}
	contentFilterProp, err := expandCESGuardrailContentFilter(d.Get("content_filter"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("content_filter"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, contentFilterProp)) {
		obj["contentFilter"] = contentFilterProp
	}
	descriptionProp, err := expandCESGuardrailDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	displayNameProp, err := expandCESGuardrailDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	enabledProp, err := expandCESGuardrailEnabled(d.Get("enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("enabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, enabledProp)) {
		obj["enabled"] = enabledProp
	}
	llmPolicyProp, err := expandCESGuardrailLlmPolicy(d.Get("llm_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("llm_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, llmPolicyProp)) {
		obj["llmPolicy"] = llmPolicyProp
	}
	llmPromptSecurityProp, err := expandCESGuardrailLlmPromptSecurity(d.Get("llm_prompt_security"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("llm_prompt_security"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, llmPromptSecurityProp)) {
		obj["llmPromptSecurity"] = llmPromptSecurityProp
	}
	modelSafetyProp, err := expandCESGuardrailModelSafety(d.Get("model_safety"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("model_safety"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, modelSafetyProp)) {
		obj["modelSafety"] = modelSafetyProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/guardrails/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Guardrail %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("action") {
		updateMask = append(updateMask, "action")
	}

	if d.HasChange("code_callback") {
		updateMask = append(updateMask, "codeCallback")
	}

	if d.HasChange("content_filter") {
		updateMask = append(updateMask, "contentFilter")
	}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("enabled") {
		updateMask = append(updateMask, "enabled")
	}

	if d.HasChange("llm_policy") {
		updateMask = append(updateMask, "llmPolicy")
	}

	if d.HasChange("llm_prompt_security") {
		updateMask = append(updateMask, "llmPromptSecurity")
	}

	if d.HasChange("model_safety") {
		updateMask = append(updateMask, "modelSafety")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Guardrail %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Guardrail %q: %#v", d.Id(), res)
		}

	}

	return resourceCESGuardrailRead(d, meta)
}

func resourceCESGuardrailDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Guardrail: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/guardrails/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Guardrail %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Guardrail")
	}

	log.Printf("[DEBUG] Finished deleting Guardrail %q: %#v", d.Id(), res)
	return nil
}

func resourceCESGuardrailImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/apps/(?P<app>[^/]+)/guardrails/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<app>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<app>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{app}}/guardrails/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCESGuardrailAction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["generative_answer"] =
		flattenCESGuardrailActionGenerativeAnswer(original["generativeAnswer"], d, config)
	transformed["respond_immediately"] =
		flattenCESGuardrailActionRespondImmediately(original["respondImmediately"], d, config)
	transformed["transfer_agent"] =
		flattenCESGuardrailActionTransferAgent(original["transferAgent"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailActionGenerativeAnswer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["prompt"] =
		flattenCESGuardrailActionGenerativeAnswerPrompt(original["prompt"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailActionGenerativeAnswerPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailActionRespondImmediately(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["responses"] =
		flattenCESGuardrailActionRespondImmediatelyResponses(original["responses"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailActionRespondImmediatelyResponses(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"disabled": flattenCESGuardrailActionRespondImmediatelyResponsesDisabled(original["disabled"], d, config),
			"text":     flattenCESGuardrailActionRespondImmediatelyResponsesText(original["text"], d, config),
		})
	}
	return transformed
}
func flattenCESGuardrailActionRespondImmediatelyResponsesDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailActionRespondImmediatelyResponsesText(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailActionTransferAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["agent"] =
		flattenCESGuardrailActionTransferAgentAgent(original["agent"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailActionTransferAgentAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallback(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["after_agent_callback"] =
		flattenCESGuardrailCodeCallbackAfterAgentCallback(original["afterAgentCallback"], d, config)
	transformed["after_model_callback"] =
		flattenCESGuardrailCodeCallbackAfterModelCallback(original["afterModelCallback"], d, config)
	transformed["before_agent_callback"] =
		flattenCESGuardrailCodeCallbackBeforeAgentCallback(original["beforeAgentCallback"], d, config)
	transformed["before_model_callback"] =
		flattenCESGuardrailCodeCallbackBeforeModelCallback(original["beforeModelCallback"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailCodeCallbackAfterAgentCallback(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESGuardrailCodeCallbackAfterAgentCallbackDescription(original["description"], d, config)
	transformed["disabled"] =
		flattenCESGuardrailCodeCallbackAfterAgentCallbackDisabled(original["disabled"], d, config)
	transformed["python_code"] =
		flattenCESGuardrailCodeCallbackAfterAgentCallbackPythonCode(original["pythonCode"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailCodeCallbackAfterAgentCallbackDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallbackAfterAgentCallbackDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallbackAfterAgentCallbackPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallbackAfterModelCallback(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESGuardrailCodeCallbackAfterModelCallbackDescription(original["description"], d, config)
	transformed["disabled"] =
		flattenCESGuardrailCodeCallbackAfterModelCallbackDisabled(original["disabled"], d, config)
	transformed["python_code"] =
		flattenCESGuardrailCodeCallbackAfterModelCallbackPythonCode(original["pythonCode"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailCodeCallbackAfterModelCallbackDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallbackAfterModelCallbackDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallbackAfterModelCallbackPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallbackBeforeAgentCallback(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESGuardrailCodeCallbackBeforeAgentCallbackDescription(original["description"], d, config)
	transformed["disabled"] =
		flattenCESGuardrailCodeCallbackBeforeAgentCallbackDisabled(original["disabled"], d, config)
	transformed["python_code"] =
		flattenCESGuardrailCodeCallbackBeforeAgentCallbackPythonCode(original["pythonCode"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailCodeCallbackBeforeAgentCallbackDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallbackBeforeAgentCallbackDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallbackBeforeAgentCallbackPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallbackBeforeModelCallback(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESGuardrailCodeCallbackBeforeModelCallbackDescription(original["description"], d, config)
	transformed["disabled"] =
		flattenCESGuardrailCodeCallbackBeforeModelCallbackDisabled(original["disabled"], d, config)
	transformed["python_code"] =
		flattenCESGuardrailCodeCallbackBeforeModelCallbackPythonCode(original["pythonCode"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailCodeCallbackBeforeModelCallbackDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallbackBeforeModelCallbackDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCodeCallbackBeforeModelCallbackPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailContentFilter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["banned_contents"] =
		flattenCESGuardrailContentFilterBannedContents(original["bannedContents"], d, config)
	transformed["banned_contents_in_agent_response"] =
		flattenCESGuardrailContentFilterBannedContentsInAgentResponse(original["bannedContentsInAgentResponse"], d, config)
	transformed["banned_contents_in_user_input"] =
		flattenCESGuardrailContentFilterBannedContentsInUserInput(original["bannedContentsInUserInput"], d, config)
	transformed["disregard_diacritics"] =
		flattenCESGuardrailContentFilterDisregardDiacritics(original["disregardDiacritics"], d, config)
	transformed["match_type"] =
		flattenCESGuardrailContentFilterMatchType(original["matchType"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailContentFilterBannedContents(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailContentFilterBannedContentsInAgentResponse(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailContentFilterBannedContentsInUserInput(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailContentFilterDisregardDiacritics(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailContentFilterMatchType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["fail_open"] =
		flattenCESGuardrailLlmPolicyFailOpen(original["failOpen"], d, config)
	transformed["max_conversation_messages"] =
		flattenCESGuardrailLlmPolicyMaxConversationMessages(original["maxConversationMessages"], d, config)
	transformed["model_settings"] =
		flattenCESGuardrailLlmPolicyModelSettings(original["modelSettings"], d, config)
	transformed["policy_scope"] =
		flattenCESGuardrailLlmPolicyPolicyScope(original["policyScope"], d, config)
	transformed["prompt"] =
		flattenCESGuardrailLlmPolicyPrompt(original["prompt"], d, config)
	transformed["allow_short_utterance"] =
		flattenCESGuardrailLlmPolicyAllowShortUtterance(original["allowShortUtterance"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailLlmPolicyFailOpen(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPolicyMaxConversationMessages(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESGuardrailLlmPolicyModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESGuardrailLlmPolicyModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESGuardrailLlmPolicyModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailLlmPolicyModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPolicyModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPolicyPolicyScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPolicyPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPolicyAllowShortUtterance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPromptSecurity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["custom_policy"] =
		flattenCESGuardrailLlmPromptSecurityCustomPolicy(original["customPolicy"], d, config)
	transformed["default_settings"] =
		flattenCESGuardrailLlmPromptSecurityDefaultSettings(original["defaultSettings"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailLlmPromptSecurityCustomPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["fail_open"] =
		flattenCESGuardrailLlmPromptSecurityCustomPolicyFailOpen(original["failOpen"], d, config)
	transformed["max_conversation_messages"] =
		flattenCESGuardrailLlmPromptSecurityCustomPolicyMaxConversationMessages(original["maxConversationMessages"], d, config)
	transformed["model_settings"] =
		flattenCESGuardrailLlmPromptSecurityCustomPolicyModelSettings(original["modelSettings"], d, config)
	transformed["policy_scope"] =
		flattenCESGuardrailLlmPromptSecurityCustomPolicyPolicyScope(original["policyScope"], d, config)
	transformed["prompt"] =
		flattenCESGuardrailLlmPromptSecurityCustomPolicyPrompt(original["prompt"], d, config)
	transformed["allow_short_utterance"] =
		flattenCESGuardrailLlmPromptSecurityCustomPolicyAllowShortUtterance(original["allowShortUtterance"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailLlmPromptSecurityCustomPolicyFailOpen(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPromptSecurityCustomPolicyMaxConversationMessages(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESGuardrailLlmPromptSecurityCustomPolicyModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESGuardrailLlmPromptSecurityCustomPolicyModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESGuardrailLlmPromptSecurityCustomPolicyModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailLlmPromptSecurityCustomPolicyModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPromptSecurityCustomPolicyModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPromptSecurityCustomPolicyPolicyScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPromptSecurityCustomPolicyPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPromptSecurityCustomPolicyAllowShortUtterance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailLlmPromptSecurityDefaultSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["default_prompt_template"] =
		flattenCESGuardrailLlmPromptSecurityDefaultSettingsDefaultPromptTemplate(original["defaultPromptTemplate"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailLlmPromptSecurityDefaultSettingsDefaultPromptTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailModelSafety(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["safety_settings"] =
		flattenCESGuardrailModelSafetySafetySettings(original["safetySettings"], d, config)
	return []interface{}{transformed}
}
func flattenCESGuardrailModelSafetySafetySettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"category":  flattenCESGuardrailModelSafetySafetySettingsCategory(original["category"], d, config),
			"threshold": flattenCESGuardrailModelSafetySafetySettingsThreshold(original["threshold"], d, config),
		})
	}
	return transformed
}
func flattenCESGuardrailModelSafetySafetySettingsCategory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailModelSafetySafetySettingsThreshold(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESGuardrailName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenCESGuardrailUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandCESGuardrailAction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGenerativeAnswer, err := expandCESGuardrailActionGenerativeAnswer(original["generative_answer"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGenerativeAnswer); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["generativeAnswer"] = transformedGenerativeAnswer
	}

	transformedRespondImmediately, err := expandCESGuardrailActionRespondImmediately(original["respond_immediately"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRespondImmediately); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["respondImmediately"] = transformedRespondImmediately
	}

	transformedTransferAgent, err := expandCESGuardrailActionTransferAgent(original["transfer_agent"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTransferAgent); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["transferAgent"] = transformedTransferAgent
	}

	return transformed, nil
}

func expandCESGuardrailActionGenerativeAnswer(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPrompt, err := expandCESGuardrailActionGenerativeAnswerPrompt(original["prompt"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrompt); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prompt"] = transformedPrompt
	}

	return transformed, nil
}

func expandCESGuardrailActionGenerativeAnswerPrompt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailActionRespondImmediately(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedResponses, err := expandCESGuardrailActionRespondImmediatelyResponses(original["responses"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResponses); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["responses"] = transformedResponses
	}

	return transformed, nil
}

func expandCESGuardrailActionRespondImmediatelyResponses(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDisabled, err := expandCESGuardrailActionRespondImmediatelyResponsesDisabled(original["disabled"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["disabled"] = transformedDisabled
		}

		transformedText, err := expandCESGuardrailActionRespondImmediatelyResponsesText(original["text"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedText); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["text"] = transformedText
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESGuardrailActionRespondImmediatelyResponsesDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailActionRespondImmediatelyResponsesText(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailActionTransferAgent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAgent, err := expandCESGuardrailActionTransferAgentAgent(original["agent"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAgent); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["agent"] = transformedAgent
	}

	return transformed, nil
}

func expandCESGuardrailActionTransferAgentAgent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallback(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAfterAgentCallback, err := expandCESGuardrailCodeCallbackAfterAgentCallback(original["after_agent_callback"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAfterAgentCallback); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["afterAgentCallback"] = transformedAfterAgentCallback
	}

	transformedAfterModelCallback, err := expandCESGuardrailCodeCallbackAfterModelCallback(original["after_model_callback"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAfterModelCallback); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["afterModelCallback"] = transformedAfterModelCallback
	}

	transformedBeforeAgentCallback, err := expandCESGuardrailCodeCallbackBeforeAgentCallback(original["before_agent_callback"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBeforeAgentCallback); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["beforeAgentCallback"] = transformedBeforeAgentCallback
	}

	transformedBeforeModelCallback, err := expandCESGuardrailCodeCallbackBeforeModelCallback(original["before_model_callback"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBeforeModelCallback); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["beforeModelCallback"] = transformedBeforeModelCallback
	}

	return transformed, nil
}

func expandCESGuardrailCodeCallbackAfterAgentCallback(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDescription, err := expandCESGuardrailCodeCallbackAfterAgentCallbackDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedDisabled, err := expandCESGuardrailCodeCallbackAfterAgentCallbackDisabled(original["disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disabled"] = transformedDisabled
	}

	transformedPythonCode, err := expandCESGuardrailCodeCallbackAfterAgentCallbackPythonCode(original["python_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPythonCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pythonCode"] = transformedPythonCode
	}

	return transformed, nil
}

func expandCESGuardrailCodeCallbackAfterAgentCallbackDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallbackAfterAgentCallbackDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallbackAfterAgentCallbackPythonCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallbackAfterModelCallback(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDescription, err := expandCESGuardrailCodeCallbackAfterModelCallbackDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedDisabled, err := expandCESGuardrailCodeCallbackAfterModelCallbackDisabled(original["disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disabled"] = transformedDisabled
	}

	transformedPythonCode, err := expandCESGuardrailCodeCallbackAfterModelCallbackPythonCode(original["python_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPythonCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pythonCode"] = transformedPythonCode
	}

	return transformed, nil
}

func expandCESGuardrailCodeCallbackAfterModelCallbackDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallbackAfterModelCallbackDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallbackAfterModelCallbackPythonCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallbackBeforeAgentCallback(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDescription, err := expandCESGuardrailCodeCallbackBeforeAgentCallbackDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedDisabled, err := expandCESGuardrailCodeCallbackBeforeAgentCallbackDisabled(original["disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disabled"] = transformedDisabled
	}

	transformedPythonCode, err := expandCESGuardrailCodeCallbackBeforeAgentCallbackPythonCode(original["python_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPythonCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pythonCode"] = transformedPythonCode
	}

	return transformed, nil
}

func expandCESGuardrailCodeCallbackBeforeAgentCallbackDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallbackBeforeAgentCallbackDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallbackBeforeAgentCallbackPythonCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallbackBeforeModelCallback(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDescription, err := expandCESGuardrailCodeCallbackBeforeModelCallbackDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedDisabled, err := expandCESGuardrailCodeCallbackBeforeModelCallbackDisabled(original["disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disabled"] = transformedDisabled
	}

	transformedPythonCode, err := expandCESGuardrailCodeCallbackBeforeModelCallbackPythonCode(original["python_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPythonCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pythonCode"] = transformedPythonCode
	}

	return transformed, nil
}

func expandCESGuardrailCodeCallbackBeforeModelCallbackDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallbackBeforeModelCallbackDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailCodeCallbackBeforeModelCallbackPythonCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailContentFilter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBannedContents, err := expandCESGuardrailContentFilterBannedContents(original["banned_contents"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBannedContents); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bannedContents"] = transformedBannedContents
	}

	transformedBannedContentsInAgentResponse, err := expandCESGuardrailContentFilterBannedContentsInAgentResponse(original["banned_contents_in_agent_response"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBannedContentsInAgentResponse); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bannedContentsInAgentResponse"] = transformedBannedContentsInAgentResponse
	}

	transformedBannedContentsInUserInput, err := expandCESGuardrailContentFilterBannedContentsInUserInput(original["banned_contents_in_user_input"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBannedContentsInUserInput); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bannedContentsInUserInput"] = transformedBannedContentsInUserInput
	}

	transformedDisregardDiacritics, err := expandCESGuardrailContentFilterDisregardDiacritics(original["disregard_diacritics"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisregardDiacritics); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disregardDiacritics"] = transformedDisregardDiacritics
	}

	transformedMatchType, err := expandCESGuardrailContentFilterMatchType(original["match_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMatchType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["matchType"] = transformedMatchType
	}

	return transformed, nil
}

func expandCESGuardrailContentFilterBannedContents(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailContentFilterBannedContentsInAgentResponse(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailContentFilterBannedContentsInUserInput(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailContentFilterDisregardDiacritics(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailContentFilterMatchType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFailOpen, err := expandCESGuardrailLlmPolicyFailOpen(original["fail_open"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFailOpen); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["failOpen"] = transformedFailOpen
	}

	transformedMaxConversationMessages, err := expandCESGuardrailLlmPolicyMaxConversationMessages(original["max_conversation_messages"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxConversationMessages); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxConversationMessages"] = transformedMaxConversationMessages
	}

	transformedModelSettings, err := expandCESGuardrailLlmPolicyModelSettings(original["model_settings"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModelSettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["modelSettings"] = transformedModelSettings
	}

	transformedPolicyScope, err := expandCESGuardrailLlmPolicyPolicyScope(original["policy_scope"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPolicyScope); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["policyScope"] = transformedPolicyScope
	}

	transformedPrompt, err := expandCESGuardrailLlmPolicyPrompt(original["prompt"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrompt); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prompt"] = transformedPrompt
	}

	transformedAllowShortUtterance, err := expandCESGuardrailLlmPolicyAllowShortUtterance(original["allow_short_utterance"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowShortUtterance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allowShortUtterance"] = transformedAllowShortUtterance
	}

	return transformed, nil
}

func expandCESGuardrailLlmPolicyFailOpen(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPolicyMaxConversationMessages(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPolicyModelSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedModel, err := expandCESGuardrailLlmPolicyModelSettingsModel(original["model"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["model"] = transformedModel
	}

	transformedTemperature, err := expandCESGuardrailLlmPolicyModelSettingsTemperature(original["temperature"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTemperature); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["temperature"] = transformedTemperature
	}

	return transformed, nil
}

func expandCESGuardrailLlmPolicyModelSettingsModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPolicyModelSettingsTemperature(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPolicyPolicyScope(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPolicyPrompt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPolicyAllowShortUtterance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPromptSecurity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCustomPolicy, err := expandCESGuardrailLlmPromptSecurityCustomPolicy(original["custom_policy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCustomPolicy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["customPolicy"] = transformedCustomPolicy
	}

	transformedDefaultSettings, err := expandCESGuardrailLlmPromptSecurityDefaultSettings(original["default_settings"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefaultSettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["defaultSettings"] = transformedDefaultSettings
	}

	return transformed, nil
}

func expandCESGuardrailLlmPromptSecurityCustomPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFailOpen, err := expandCESGuardrailLlmPromptSecurityCustomPolicyFailOpen(original["fail_open"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFailOpen); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["failOpen"] = transformedFailOpen
	}

	transformedMaxConversationMessages, err := expandCESGuardrailLlmPromptSecurityCustomPolicyMaxConversationMessages(original["max_conversation_messages"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxConversationMessages); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxConversationMessages"] = transformedMaxConversationMessages
	}

	transformedModelSettings, err := expandCESGuardrailLlmPromptSecurityCustomPolicyModelSettings(original["model_settings"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModelSettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["modelSettings"] = transformedModelSettings
	}

	transformedPolicyScope, err := expandCESGuardrailLlmPromptSecurityCustomPolicyPolicyScope(original["policy_scope"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPolicyScope); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["policyScope"] = transformedPolicyScope
	}

	transformedPrompt, err := expandCESGuardrailLlmPromptSecurityCustomPolicyPrompt(original["prompt"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrompt); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prompt"] = transformedPrompt
	}

	transformedAllowShortUtterance, err := expandCESGuardrailLlmPromptSecurityCustomPolicyAllowShortUtterance(original["allow_short_utterance"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowShortUtterance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allowShortUtterance"] = transformedAllowShortUtterance
	}

	return transformed, nil
}

func expandCESGuardrailLlmPromptSecurityCustomPolicyFailOpen(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPromptSecurityCustomPolicyMaxConversationMessages(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPromptSecurityCustomPolicyModelSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedModel, err := expandCESGuardrailLlmPromptSecurityCustomPolicyModelSettingsModel(original["model"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["model"] = transformedModel
	}

	transformedTemperature, err := expandCESGuardrailLlmPromptSecurityCustomPolicyModelSettingsTemperature(original["temperature"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTemperature); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["temperature"] = transformedTemperature
	}

	return transformed, nil
}

func expandCESGuardrailLlmPromptSecurityCustomPolicyModelSettingsModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPromptSecurityCustomPolicyModelSettingsTemperature(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPromptSecurityCustomPolicyPolicyScope(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPromptSecurityCustomPolicyPrompt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPromptSecurityCustomPolicyAllowShortUtterance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailLlmPromptSecurityDefaultSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDefaultPromptTemplate, err := expandCESGuardrailLlmPromptSecurityDefaultSettingsDefaultPromptTemplate(original["default_prompt_template"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefaultPromptTemplate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["defaultPromptTemplate"] = transformedDefaultPromptTemplate
	}

	return transformed, nil
}

func expandCESGuardrailLlmPromptSecurityDefaultSettingsDefaultPromptTemplate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailModelSafety(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSafetySettings, err := expandCESGuardrailModelSafetySafetySettings(original["safety_settings"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSafetySettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["safetySettings"] = transformedSafetySettings
	}

	return transformed, nil
}

func expandCESGuardrailModelSafetySafetySettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedCategory, err := expandCESGuardrailModelSafetySafetySettingsCategory(original["category"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCategory); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["category"] = transformedCategory
		}

		transformedThreshold, err := expandCESGuardrailModelSafetySafetySettingsThreshold(original["threshold"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedThreshold); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["threshold"] = transformedThreshold
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESGuardrailModelSafetySafetySettingsCategory(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESGuardrailModelSafetySafetySettingsThreshold(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceCESGuardrailPostCreateSetComputedFields(d *schema.ResourceData, meta interface{}, res map[string]interface{}) error {
	config := meta.(*transport_tpg.Config)
	if err := d.Set("name", flattenCESGuardrailName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}
	return nil
}
