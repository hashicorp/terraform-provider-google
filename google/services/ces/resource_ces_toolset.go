// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/ces/Toolset.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package ces

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceCESToolset() *schema.Resource {
	return &schema.Resource{
		Create: resourceCESToolsetCreate,
		Read:   resourceCESToolsetRead,
		Update: resourceCESToolsetUpdate,
		Delete: resourceCESToolsetDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCESToolsetImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"app": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"toolset_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"app": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"toolset_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The ID to use for the toolset, which will become the final component of
the toolset's resource name. If not provided, a unique ID will be
automatically assigned for the toolset.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The description of the toolset.`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The display name of the toolset. Must be unique within the same app.`,
			},
			"execution_type": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Possible values:
SYNCHRONOUS
ASYNCHRONOUS`,
			},
			"open_api_toolset": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `A toolset that contains a list of tools that are defined by an OpenAPI
schema.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"open_api_schema": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The OpenAPI schema of the toolset.`,
						},
						"api_authentication": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Authentication information required for API calls.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"api_key_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Configurations for authentication with API key.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"api_key_secret_version": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The name of the SecretManager secret version resource storing the API key.
Format: 'projects/{project}/secrets/{secret}/versions/{version}'
Note: You should grant 'roles/secretmanager.secretAccessor' role to the CES
service agent
'service-@gcp-sa-ces.iam.gserviceaccount.com'.`,
												},
												"key_name": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The parameter name or the header name of the API key.
E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.`,
												},
												"request_location": {
													Type:     schema.TypeString,
													Required: true,
													Description: `Key location in the request.
Possible values:
HEADER
QUERY_STRING`,
												},
											},
										},
									},
									"bearer_token_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Configurations for authentication with a bearer token.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"token": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: ``,
												},
											},
										},
									},
									"oauth_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Configurations for authentication with OAuth.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"client_id": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The client ID from the OAuth provider.`,
												},
												"client_secret_version": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The name of the SecretManager secret version resource storing the
client secret.
Format: 'projects/{project}/secrets/{secret}/versions/{version}'

Note: You should grant 'roles/secretmanager.secretAccessor' role to the CES
service agent
'service-@gcp-sa-ces.iam.gserviceaccount.com'.`,
												},
												"oauth_grant_type": {
													Type:     schema.TypeString,
													Required: true,
													Description: `OAuth grant types.
Possible values:
CLIENT_CREDENTIAL`,
												},
												"token_endpoint": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The token endpoint in the OAuth provider to exchange for an access token.`,
												},
												"scopes": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `The OAuth scopes to grant.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"service_account_auth_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Configurations for authentication using a custom service account.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"service_account": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The email address of the service account used for authenticatation. CES
uses this service account to exchange an access token and the access token
is then sent in the 'Authorization' header of the request.

The service account must have the
'roles/iam.serviceAccountTokenCreator' role granted to the
CES service agent
'service-@gcp-sa-ces.iam.gserviceaccount.com'.`,
												},
											},
										},
									},
									"service_agent_id_token_auth_config": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Configurations for authentication with [ID
token](https://cloud.google.com/docs/authentication/token-types#id) generated
from service agent.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},
								},
							},
						},
						"ignore_unknown_fields": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `If true, the agent will ignore unknown fields in the API response for all
operations defined in the OpenAPI schema.`,
						},
						"service_directory_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for tools using Service Directory.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"service": {
										Type:     schema.TypeString,
										Required: true,
										Description: `The name of [Service
Directory](https://cloud.google.com/service-directory) service.
Format:
'projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}'.
Location of the service directory must be the same as the location of the
app.`,
									},
								},
							},
						},
						"tls_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The TLS configuration.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_certs": {
										Type:     schema.TypeList,
										Required: true,
										Description: `Specifies a list of allowed custom CA certificates for HTTPS
verification.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"cert": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The allowed custom CA certificates (in DER format) for
HTTPS verification. This overrides the default SSL trust store. If this
is empty or unspecified, CES will use Google's default trust
store to verify certificates. N.B. Make sure the HTTPS server
certificates are signed with "subject alt name". For instance a
certificate can be self-signed using the following command,
openssl x509 -req -days 200 -in example.com.csr \
-signkey example.com.key \
-out example.com.crt \
-extfile <(printf "\nsubjectAltName='DNS:www.example.com'")`,
												},
												"display_name": {
													Type:     schema.TypeString,
													Required: true,
													Description: `The name of the allowed custom CA certificates. This
can be used to disambiguate the custom CA certificates.`,
												},
											},
										},
									},
								},
							},
						},
						"url": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The server URL of the Open API schema.
This field is only set in toolsets in the environment dependencies
during the export process if the schema contains a server url.
During the import process, if this url is present in the environment dependencies
and the schema has the $env_var placeholder,
it will replace the placeholder in the schema.`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp when the toolset was created.`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `ETag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The unique identifier of the toolset.
Format:
'projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}'`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp when the toolset was last updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCESToolsetCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandCESToolsetDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	displayNameProp, err := expandCESToolsetDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	executionTypeProp, err := expandCESToolsetExecutionType(d.Get("execution_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("execution_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(executionTypeProp)) && (ok || !reflect.DeepEqual(v, executionTypeProp)) {
		obj["executionType"] = executionTypeProp
	}
	openApiToolsetProp, err := expandCESToolsetOpenApiToolset(d.Get("open_api_toolset"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("open_api_toolset"); !tpgresource.IsEmptyValue(reflect.ValueOf(openApiToolsetProp)) && (ok || !reflect.DeepEqual(v, openApiToolsetProp)) {
		obj["openApiToolset"] = openApiToolsetProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/toolsets?toolsetId={{toolset_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Toolset: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Toolset: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Toolset: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{app}}/toolsets/{{toolset_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if appValue, ok := d.GetOk("app"); ok && appValue.(string) != "" {
			if err = identity.Set("app", appValue.(string)); err != nil {
				return fmt.Errorf("Error setting app: %s", err)
			}
		}
		if toolsetIdValue, ok := d.GetOk("toolset_id"); ok && toolsetIdValue.(string) != "" {
			if err = identity.Set("toolset_id", toolsetIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting toolset_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Toolset %q: %#v", d.Id(), res)

	return resourceCESToolsetRead(d, meta)
}

func resourceCESToolsetRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/toolsets/{{toolset_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Toolset: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("CESToolset %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Toolset: %s", err)
	}

	if err := d.Set("create_time", flattenCESToolsetCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Toolset: %s", err)
	}
	if err := d.Set("description", flattenCESToolsetDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Toolset: %s", err)
	}
	if err := d.Set("display_name", flattenCESToolsetDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Toolset: %s", err)
	}
	if err := d.Set("etag", flattenCESToolsetEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Toolset: %s", err)
	}
	if err := d.Set("execution_type", flattenCESToolsetExecutionType(res["executionType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Toolset: %s", err)
	}
	if err := d.Set("name", flattenCESToolsetName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Toolset: %s", err)
	}
	if err := d.Set("open_api_toolset", flattenCESToolsetOpenApiToolset(res["openApiToolset"], d, config)); err != nil {
		return fmt.Errorf("Error reading Toolset: %s", err)
	}
	if err := d.Set("update_time", flattenCESToolsetUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Toolset: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("app"); !ok && v == "" {
			err = identity.Set("app", d.Get("app").(string))
			if err != nil {
				return fmt.Errorf("Error setting app: %s", err)
			}
		}
		if v, ok := identity.GetOk("toolset_id"); !ok && v == "" {
			err = identity.Set("toolset_id", d.Get("toolset_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting toolset_id: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceCESToolsetUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if appValue, ok := d.GetOk("app"); ok && appValue.(string) != "" {
			if err = identity.Set("app", appValue.(string)); err != nil {
				return fmt.Errorf("Error setting app: %s", err)
			}
		}
		if toolsetIdValue, ok := d.GetOk("toolset_id"); ok && toolsetIdValue.(string) != "" {
			if err = identity.Set("toolset_id", toolsetIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting toolset_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Toolset: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandCESToolsetDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	displayNameProp, err := expandCESToolsetDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	executionTypeProp, err := expandCESToolsetExecutionType(d.Get("execution_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("execution_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, executionTypeProp)) {
		obj["executionType"] = executionTypeProp
	}
	openApiToolsetProp, err := expandCESToolsetOpenApiToolset(d.Get("open_api_toolset"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("open_api_toolset"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, openApiToolsetProp)) {
		obj["openApiToolset"] = openApiToolsetProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/toolsets/{{toolset_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Toolset %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("execution_type") {
		updateMask = append(updateMask, "executionType")
	}

	if d.HasChange("open_api_toolset") {
		updateMask = append(updateMask, "openApiToolset")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Toolset %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Toolset %q: %#v", d.Id(), res)
		}

	}

	return resourceCESToolsetRead(d, meta)
}

func resourceCESToolsetDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Toolset: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/toolsets/{{toolset_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Toolset %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Toolset")
	}

	log.Printf("[DEBUG] Finished deleting Toolset %q: %#v", d.Id(), res)
	return nil
}

func resourceCESToolsetImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/apps/(?P<app>[^/]+)/toolsets/(?P<toolset_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<app>[^/]+)/(?P<toolset_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<app>[^/]+)/(?P<toolset_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{app}}/toolsets/{{toolset_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCESToolsetCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetExecutionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_authentication"] =
		flattenCESToolsetOpenApiToolsetApiAuthentication(original["apiAuthentication"], d, config)
	transformed["ignore_unknown_fields"] =
		flattenCESToolsetOpenApiToolsetIgnoreUnknownFields(original["ignoreUnknownFields"], d, config)
	transformed["open_api_schema"] =
		flattenCESToolsetOpenApiToolsetOpenApiSchema(original["openApiSchema"], d, config)
	transformed["service_directory_config"] =
		flattenCESToolsetOpenApiToolsetServiceDirectoryConfig(original["serviceDirectoryConfig"], d, config)
	transformed["tls_config"] =
		flattenCESToolsetOpenApiToolsetTlsConfig(original["tlsConfig"], d, config)
	transformed["url"] =
		flattenCESToolsetOpenApiToolsetUrl(original["url"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolsetOpenApiToolsetApiAuthentication(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_key_config"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfig(original["apiKeyConfig"], d, config)
	transformed["oauth_config"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfig(original["oauthConfig"], d, config)
	transformed["service_account_auth_config"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig(original["serviceAccountAuthConfig"], d, config)
	transformed["service_agent_id_token_auth_config"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig(original["serviceAgentIdTokenAuthConfig"], d, config)
	transformed["bearer_token_config"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig(original["bearerTokenConfig"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_key_secret_version"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigApiKeySecretVersion(original["apiKeySecretVersion"], d, config)
	transformed["key_name"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigKeyName(original["keyName"], d, config)
	transformed["request_location"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigRequestLocation(original["requestLocation"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigApiKeySecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigRequestLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["client_id"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfigClientId(original["clientId"], d, config)
	transformed["client_secret_version"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfigClientSecretVersion(original["clientSecretVersion"], d, config)
	transformed["oauth_grant_type"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfigOauthGrantType(original["oauthGrantType"], d, config)
	transformed["scopes"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfigScopes(original["scopes"], d, config)
	transformed["token_endpoint"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfigTokenEndpoint(original["tokenEndpoint"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfigClientId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfigClientSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfigOauthGrantType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfigScopes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetApiAuthenticationOauthConfigTokenEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_account"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigServiceAccount(original["serviceAccount"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenCESToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["token"] =
		flattenCESToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigToken(original["token"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetIgnoreUnknownFields(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetOpenApiSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetServiceDirectoryConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service"] =
		flattenCESToolsetOpenApiToolsetServiceDirectoryConfigService(original["service"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolsetOpenApiToolsetServiceDirectoryConfigService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetTlsConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ca_certs"] =
		flattenCESToolsetOpenApiToolsetTlsConfigCaCerts(original["caCerts"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolsetOpenApiToolsetTlsConfigCaCerts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"cert":         flattenCESToolsetOpenApiToolsetTlsConfigCaCertsCert(original["cert"], d, config),
			"display_name": flattenCESToolsetOpenApiToolsetTlsConfigCaCertsDisplayName(original["displayName"], d, config),
		})
	}
	return transformed
}
func flattenCESToolsetOpenApiToolsetTlsConfigCaCertsCert(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetTlsConfigCaCertsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetOpenApiToolsetUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolsetUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandCESToolsetDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetExecutionType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedApiAuthentication, err := expandCESToolsetOpenApiToolsetApiAuthentication(original["api_authentication"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApiAuthentication); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["apiAuthentication"] = transformedApiAuthentication
	}

	transformedIgnoreUnknownFields, err := expandCESToolsetOpenApiToolsetIgnoreUnknownFields(original["ignore_unknown_fields"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIgnoreUnknownFields); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ignoreUnknownFields"] = transformedIgnoreUnknownFields
	}

	transformedOpenApiSchema, err := expandCESToolsetOpenApiToolsetOpenApiSchema(original["open_api_schema"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOpenApiSchema); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["openApiSchema"] = transformedOpenApiSchema
	}

	transformedServiceDirectoryConfig, err := expandCESToolsetOpenApiToolsetServiceDirectoryConfig(original["service_directory_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceDirectoryConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceDirectoryConfig"] = transformedServiceDirectoryConfig
	}

	transformedTlsConfig, err := expandCESToolsetOpenApiToolsetTlsConfig(original["tls_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTlsConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tlsConfig"] = transformedTlsConfig
	}

	transformedUrl, err := expandCESToolsetOpenApiToolsetUrl(original["url"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUrl); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["url"] = transformedUrl
	}

	return transformed, nil
}

func expandCESToolsetOpenApiToolsetApiAuthentication(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedApiKeyConfig, err := expandCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfig(original["api_key_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApiKeyConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["apiKeyConfig"] = transformedApiKeyConfig
	}

	transformedOauthConfig, err := expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfig(original["oauth_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauthConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauthConfig"] = transformedOauthConfig
	}

	transformedServiceAccountAuthConfig, err := expandCESToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig(original["service_account_auth_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccountAuthConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccountAuthConfig"] = transformedServiceAccountAuthConfig
	}

	transformedServiceAgentIdTokenAuthConfig, err := expandCESToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig(original["service_agent_id_token_auth_config"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["serviceAgentIdTokenAuthConfig"] = transformedServiceAgentIdTokenAuthConfig
	}

	transformedBearerTokenConfig, err := expandCESToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig(original["bearer_token_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBearerTokenConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bearerTokenConfig"] = transformedBearerTokenConfig
	}

	return transformed, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedApiKeySecretVersion, err := expandCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigApiKeySecretVersion(original["api_key_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApiKeySecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["apiKeySecretVersion"] = transformedApiKeySecretVersion
	}

	transformedKeyName, err := expandCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigKeyName(original["key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["keyName"] = transformedKeyName
	}

	transformedRequestLocation, err := expandCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigRequestLocation(original["request_location"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRequestLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["requestLocation"] = transformedRequestLocation
	}

	return transformed, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigApiKeySecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationApiKeyConfigRequestLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedClientId, err := expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfigClientId(original["client_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientId"] = transformedClientId
	}

	transformedClientSecretVersion, err := expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfigClientSecretVersion(original["client_secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClientSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clientSecretVersion"] = transformedClientSecretVersion
	}

	transformedOauthGrantType, err := expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfigOauthGrantType(original["oauth_grant_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauthGrantType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["oauthGrantType"] = transformedOauthGrantType
	}

	transformedScopes, err := expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfigScopes(original["scopes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScopes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scopes"] = transformedScopes
	}

	transformedTokenEndpoint, err := expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfigTokenEndpoint(original["token_endpoint"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTokenEndpoint); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tokenEndpoint"] = transformedTokenEndpoint
	}

	return transformed, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfigClientId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfigClientSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfigOauthGrantType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfigScopes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationOauthConfigTokenEndpoint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServiceAccount, err := expandCESToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigServiceAccount(original["service_account"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccount"] = transformedServiceAccount
	}

	return transformed, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedToken, err := expandCESToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigToken(original["token"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedToken); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["token"] = transformedToken
	}

	return transformed, nil
}

func expandCESToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigToken(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetIgnoreUnknownFields(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetOpenApiSchema(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetServiceDirectoryConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedService, err := expandCESToolsetOpenApiToolsetServiceDirectoryConfigService(original["service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["service"] = transformedService
	}

	return transformed, nil
}

func expandCESToolsetOpenApiToolsetServiceDirectoryConfigService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetTlsConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCaCerts, err := expandCESToolsetOpenApiToolsetTlsConfigCaCerts(original["ca_certs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCaCerts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["caCerts"] = transformedCaCerts
	}

	return transformed, nil
}

func expandCESToolsetOpenApiToolsetTlsConfigCaCerts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedCert, err := expandCESToolsetOpenApiToolsetTlsConfigCaCertsCert(original["cert"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCert); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["cert"] = transformedCert
		}

		transformedDisplayName, err := expandCESToolsetOpenApiToolsetTlsConfigCaCertsDisplayName(original["display_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["displayName"] = transformedDisplayName
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESToolsetOpenApiToolsetTlsConfigCaCertsCert(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetTlsConfigCaCertsDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolsetOpenApiToolsetUrl(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
