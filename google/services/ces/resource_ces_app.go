// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/ces/App.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package ces

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceCESApp() *schema.Resource {
	return &schema.Resource{
		Create: resourceCESAppCreate,
		Read:   resourceCESAppRead,
		Update: resourceCESAppUpdate,
		Delete: resourceCESAppDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCESAppImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"app_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The ID to use for the app, which will become the final component of
the app's resource name. If not provided, a unique ID will be
automatically assigned for the app.`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Display name of the app.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"audio_processing_config": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Configuration for how the input and output audio should be processed and
delivered.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ambient_sound_config": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Configuration for the ambient sound to be played with the synthesized agent
response, to enhance the naturalness of the conversation.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"gcs_uri": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
Storage](https://cloud.google.com/storage).
Note: Please make sure the CES service agent
'service-@gcp-sa-ces.iam.gserviceaccount.com' has
'storage.objects.get' permission to the Cloud Storage object.`,
									},
									"prebuilt_ambient_sound": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Name of the prebuilt ambient sound.
Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
-"office_1" - "office_2" - "office_3"
-"room_1" - "room_2" - "room_3"
-"room_4" - "room_5" - "air_conditioner"`,
									},
									"volume_gain_db": {
										Type:     schema.TypeFloat,
										Optional: true,
										Description: `Volume gain (in dB) of the normal native volume supported by
ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
will play at approximately half the amplitude of the normal native signal
amplitude. A value of +6.0 (dB) will play at approximately twice the
amplitude of the normal native signal amplitude. We strongly recommend not
to exceed +10 (dB) as there's usually no effective increase in loudness for
any value greater than that.`,
									},
								},
							},
						},
						"barge_in_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for how the user barge-in activities should be handled.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"barge_in_awareness": {
										Type:     schema.TypeBool,
										Optional: true,
										Description: `If enabled, the agent will adapt its next response based on the assumption
that the user hasn't heard the full preceding agent message.
This should not be used in scenarios where agent responses are displayed
visually.`,
									},
								},
							},
						},
						"inactivity_timeout": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The duration of user inactivity (no speech or interaction) before the agent
prompts the user for reengagement. If not set, the agent will not prompt
the user for reengagement.`,
						},
						"synthesize_speech_configs": {
							Type:     schema.TypeSet,
							Optional: true,
							Description: `Configuration of how the agent response should be synthesized, mapping from
the language code to SynthesizeSpeechConfig.
If the configuration for the specified language code is not found, the
configuration for the root language code will be used. For example, if the
map contains "en-us" and "en", and the specified language code is "en-gb",
then "en" configuration will be used.
Note: Language code is case-insensitive.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"language_code": {
										Type:     schema.TypeString,
										Required: true,
									},
									"speaking_rate": {
										Type:     schema.TypeFloat,
										Optional: true,
										Description: `The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
half as fast. Values outside of the range [0.25, 2.0] will return an error.`,
									},
									"voice": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The name of the voice. If not set, the service will choose a
voice based on the other parameters such as language_code.
For the list of available voices, please refer to Supported voices and
languages from Cloud Text-to-Speech.`,
									},
								},
							},
						},
					},
				},
			},
			"client_certificate_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The default client certificate settings for the app.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"private_key": {
							Type:     schema.TypeString,
							Required: true,
							Description: `The name of the SecretManager secret version resource
storing the private key encoded in PEM format.
Format: projects/{project}/secrets/{secret}/versions/{version}`,
						},
						"tls_certificate": {
							Type:     schema.TypeString,
							Required: true,
							Description: `The TLS certificate encoded in PEM format.
This string must include the begin header and end footer lines.`,
						},
						"passphrase": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The passphrase to decrypt the private key.
Should be left unset if the private key is not encrypted.`,
						},
					},
				},
			},
			"data_store_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Data store related settings for the app.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"engines": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The engines for the app.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The resource name of the engine.
Format:
'projects/{project}/locations/{location}/collections/{collection}/engines/{engine}'`,
									},
									"type": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The type of the engine.
Possible values:
ENGINE_TYPE_SEARCH
ENGINE_TYPE_CHAT`,
									},
								},
							},
						},
					},
				},
			},
			"default_channel_profile": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `A ChannelProfile configures the agent's behavior for a specific communication
channel, such as web UI or telephony.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"channel_type": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The type of the channel profile.
Possible values:
UNKNOWN
WEB_UI
API
TWILIO
GOOGLE_TELEPHONY_PLATFORM
CONTACT_CENTER_AS_A_SERVICE`,
						},
						"disable_barge_in_control": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Whether to disable user barge-in in the conversation.
- true: User interruptions are disabled while the agent is speaking.
- false: The agent retains automatic control over when the user can interrupt.`,
						},
						"disable_dtmf": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Whether to disable DTMF (dual-tone multi-frequency).`,
						},
						"persona_property": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Represents the persona property of a channel.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"persona": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The persona of the channel.
Possible values:
UNKNOWN
CONCISE
CHATTY`,
									},
								},
							},
						},
						"profile_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The unique identifier of the channel profile.`,
						},
						"web_widget_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Message for configuration for the web widget.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"modality": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The modality of the web widget.
Possible values:
UNKNOWN_MODALITY
CHAT_AND_VOICE
VOICE_ONLY
CHAT_ONLY`,
									},
									"theme": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The theme of the web widget.
Possible values:
UNKNOWN_THEME
LIGHT
DARK`,
									},
									"web_widget_title": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The title of the web widget.`,
									},
								},
							},
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Human-readable description of the app.`,
			},
			"evaluation_metrics_thresholds": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Threshold settings for metrics in an Evaluation.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"golden_evaluation_metrics_thresholds": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Settings for golden evaluations.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"expectation_level_metrics_thresholds": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Expectation level metrics thresholds.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"tool_invocation_parameter_correctness_threshold": {
													Type:     schema.TypeFloat,
													Optional: true,
													Description: `The success threshold for individual tool invocation parameter
correctness. Must be a float between 0 and 1. Default is 1.0.`,
												},
											},
										},
									},
									"turn_level_metrics_thresholds": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Turn level metrics thresholds.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"overall_tool_invocation_correctness_threshold": {
													Type:     schema.TypeFloat,
													Optional: true,
													Description: `The success threshold for overall tool invocation correctness. Must be
a float between 0 and 1. Default is 1.0.`,
												},
												"semantic_similarity_success_threshold": {
													Type:     schema.TypeInt,
													Optional: true,
													Description: `The success threshold for semantic similarity. Must be an integer
between 0 and 4. Default is >= 3.`,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"global_instruction": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Instructions for all the agents in the app.
You can use this instruction to set up a stable identity or personality
across all the agents.`,
			},
			"guardrails": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `List of guardrails for the app.
Format:
'projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}'`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"language_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Language settings of the app.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"default_language_code": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The default language code of the app.`,
						},
						"enable_multilingual_support": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Enables multilingual support. If true, agents in the app will use pre-built
instructions to improve handling of multilingual input.`,
						},
						"fallback_action": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The action to perform when an agent receives input in an unsupported
language.
This can be a predefined action or a custom tool call.
Valid values are:
- A tool's full resource name, which triggers a specific tool execution.
- A predefined system action, such as "escalate" or "exit", which triggers
an EndSession signal with corresponding metadata
to terminate the conversation.`,
						},
						"supported_language_codes": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `List of languages codes supported by the app, in addition to the
'default_language_code'.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},
			"logging_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Settings to describe the logging behaviors for the app.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"audio_recording_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration for how the audio interactions should be recorded.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"gcs_bucket": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
session audio recordings. The URI must start with "gs://".
Note: If the Cloud Storage bucket is in a different project from the app,
you should grant 'storage.objects.create' permission to the CES service
agent 'service-@gcp-sa-ces.iam.gserviceaccount.com'.`,
									},
									"gcs_path_prefix": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The Cloud Storage path prefix for audio recordings.
This prefix can include the following placeholders, which will be
dynamically substituted at serving time:
- $project:   project ID
- $location:  app location
- $app:       app ID
- $date:      session date in YYYY-MM-DD format
- $session:   session ID
If the path prefix is not specified, the default prefix
'$project/$location/$app/$date/$session/' will be used.`,
									},
								},
							},
						},
						"bigquery_export_settings": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Settings to describe the BigQuery export behaviors for the app.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"dataset": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The BigQuery dataset to export the data to.`,
									},
									"enabled": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Indicates whether the BigQuery export is enabled.`,
									},
									"project": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The project ID of the BigQuery dataset to export the data to.
Note: If the BigQuery dataset is in a different project from the app, you should grant
roles/bigquery.admin role to the CES service agent service-<PROJECT-
NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.`,
									},
								},
							},
						},
						"cloud_logging_settings": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Settings to describe the Cloud Logging behaviors for the app.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enable_cloud_logging": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Whether to enable Cloud Logging for the sessions.`,
									},
								},
							},
						},
						"conversation_logging_settings": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Settings to describe the conversation logging behaviors for the app.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"disable_conversation_logging": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Whether to disable conversation logging for the sessions.`,
									},
								},
							},
						},
						"redaction_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Configuration to instruct how sensitive data should be handled.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"deidentify_template": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `[DLP](https://cloud.google.com/dlp/docs) deidentify template name to
instruct on how to de-identify content.
Format:
'projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}'`,
									},
									"enable_redaction": {
										Type:     schema.TypeBool,
										Optional: true,
										Description: `If true, redaction will be applied in various logging scenarios, including
conversation history, Cloud Logging and audio recording.`,
									},
									"inspect_template": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `[DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
detection of sensitive data types.
Format:
'projects/{project}/locations/{location}/inspectTemplates/{inspect_template}'`,
									},
								},
							},
						},
					},
				},
			},
			"metadata": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Metadata about the app. This field can be used to store additional
information relevant to the app's details or intended usages.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"model_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Model settings contains various configurations for the LLM model.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"model": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
						},
						"temperature": {
							Type:     schema.TypeFloat,
							Optional: true,
							Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
						},
					},
				},
			},
			"pinned": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Whether the app is pinned in the app list.`,
			},
			"root_agent": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `The root agent is the entry point of the app.
Format: 'projects/{project}/locations/{location}/apps/{app}/agents/{agent}'`,
			},
			"time_zone_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `TimeZone settings of the app.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"time_zone": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.`,
						},
					},
				},
			},
			"variable_declarations": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The declarations of the variables.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"description": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The description of the variable.`,
						},
						"name": {
							Type:     schema.TypeString,
							Required: true,
							Description: `The name of the variable. The name must start with a letter or underscore
and contain only letters, numbers, or underscores.`,
						},
						"schema": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Represents a select subset of an OpenAPI 3.0 schema object.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"type": {
										Type:     schema.TypeString,
										Required: true,
										Description: `The type of the data.
Possible values:
STRING
INTEGER
NUMBER
BOOLEAN
OBJECT
ARRAY`,
									},
									"additional_properties": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description: `Optional. Defines the schema for additional properties allowed in an object.
The value must be a valid JSON string representing the Schema object.
(Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).`,
									},
									"any_of": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `Optional. The instance value should be valid against at least one of the schemas in this list.`,
									},
									"default": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Optional. Default value of the data. Represents a dynamically typed value
which can be either null, a number, a string, a boolean, a struct,
or a list of values. The provided default value must be compatible
with the defined 'type' and other schema constraints.`,
									},
									"defs": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `A map of definitions for use by ref. Only allowed at the root of the schema.`,
									},
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The description of the data.`,
									},
									"enum": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Possible values of the element of primitive type with enum format.
Examples:
1. We can define direction as :
{type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
2. We can define apartment number as :
{type:INTEGER, format:enum, enum:["101", "201", "301"]}`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"items": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `Schema of the elements of Type.ARRAY.`,
									},
									"nullable": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Indicates if the value may be null.`,
									},
									"prefix_items": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `Optional. Schemas of initial elements of Type.ARRAY.`,
									},
									"properties": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `Properties of Type.OBJECT.`,
									},
									"ref": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Allows indirect references between schema nodes. The value should be a
valid reference to a child of the root 'defs'.
For example, the following schema defines a reference to a schema node
named "Pet":
type: object
properties:
  pet:
    ref: #/defs/Pet
defs:
  Pet:
    type: object
    properties:
      name:
        type: string
The value of the "pet" property is a reference to the schema node
named "Pet".
See details in
https://json-schema.org/understanding-json-schema/structuring.`,
									},
									"required": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Required properties of Type.OBJECT.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"title": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The title of the schema.`,
									},
									"unique_items": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.`,
									},
								},
							},
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp when the app was created.`,
			},
			"deployment_count": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `Number of deployments in the app.`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Etag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The unique identifier of the app.
Format: 'projects/{project}/locations/{location}/apps/{app}'`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp when the app was last updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCESAppCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	audioProcessingConfigProp, err := expandCESAppAudioProcessingConfig(d.Get("audio_processing_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("audio_processing_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(audioProcessingConfigProp)) && (ok || !reflect.DeepEqual(v, audioProcessingConfigProp)) {
		obj["audioProcessingConfig"] = audioProcessingConfigProp
	}
	pinnedProp, err := expandCESAppPinned(d.Get("pinned"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("pinned"); !tpgresource.IsEmptyValue(reflect.ValueOf(pinnedProp)) && (ok || !reflect.DeepEqual(v, pinnedProp)) {
		obj["pinned"] = pinnedProp
	}
	dataStoreSettingsProp, err := expandCESAppDataStoreSettings(d.Get("data_store_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_store_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(dataStoreSettingsProp)) && (ok || !reflect.DeepEqual(v, dataStoreSettingsProp)) {
		obj["dataStoreSettings"] = dataStoreSettingsProp
	}
	defaultChannelProfileProp, err := expandCESAppDefaultChannelProfile(d.Get("default_channel_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("default_channel_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(defaultChannelProfileProp)) && (ok || !reflect.DeepEqual(v, defaultChannelProfileProp)) {
		obj["defaultChannelProfile"] = defaultChannelProfileProp
	}
	descriptionProp, err := expandCESAppDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	displayNameProp, err := expandCESAppDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	evaluationMetricsThresholdsProp, err := expandCESAppEvaluationMetricsThresholds(d.Get("evaluation_metrics_thresholds"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("evaluation_metrics_thresholds"); !tpgresource.IsEmptyValue(reflect.ValueOf(evaluationMetricsThresholdsProp)) && (ok || !reflect.DeepEqual(v, evaluationMetricsThresholdsProp)) {
		obj["evaluationMetricsThresholds"] = evaluationMetricsThresholdsProp
	}
	globalInstructionProp, err := expandCESAppGlobalInstruction(d.Get("global_instruction"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("global_instruction"); !tpgresource.IsEmptyValue(reflect.ValueOf(globalInstructionProp)) && (ok || !reflect.DeepEqual(v, globalInstructionProp)) {
		obj["globalInstruction"] = globalInstructionProp
	}
	guardrailsProp, err := expandCESAppGuardrails(d.Get("guardrails"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("guardrails"); !tpgresource.IsEmptyValue(reflect.ValueOf(guardrailsProp)) && (ok || !reflect.DeepEqual(v, guardrailsProp)) {
		obj["guardrails"] = guardrailsProp
	}
	languageSettingsProp, err := expandCESAppLanguageSettings(d.Get("language_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("language_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(languageSettingsProp)) && (ok || !reflect.DeepEqual(v, languageSettingsProp)) {
		obj["languageSettings"] = languageSettingsProp
	}
	loggingSettingsProp, err := expandCESAppLoggingSettings(d.Get("logging_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("logging_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(loggingSettingsProp)) && (ok || !reflect.DeepEqual(v, loggingSettingsProp)) {
		obj["loggingSettings"] = loggingSettingsProp
	}
	metadataProp, err := expandCESAppMetadata(d.Get("metadata"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("metadata"); !tpgresource.IsEmptyValue(reflect.ValueOf(metadataProp)) && (ok || !reflect.DeepEqual(v, metadataProp)) {
		obj["metadata"] = metadataProp
	}
	modelSettingsProp, err := expandCESAppModelSettings(d.Get("model_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("model_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(modelSettingsProp)) && (ok || !reflect.DeepEqual(v, modelSettingsProp)) {
		obj["modelSettings"] = modelSettingsProp
	}
	rootAgentProp, err := expandCESAppRootAgent(d.Get("root_agent"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("root_agent"); !tpgresource.IsEmptyValue(reflect.ValueOf(rootAgentProp)) && (ok || !reflect.DeepEqual(v, rootAgentProp)) {
		obj["rootAgent"] = rootAgentProp
	}
	timeZoneSettingsProp, err := expandCESAppTimeZoneSettings(d.Get("time_zone_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("time_zone_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(timeZoneSettingsProp)) && (ok || !reflect.DeepEqual(v, timeZoneSettingsProp)) {
		obj["timeZoneSettings"] = timeZoneSettingsProp
	}
	variableDeclarationsProp, err := expandCESAppVariableDeclarations(d.Get("variable_declarations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("variable_declarations"); !tpgresource.IsEmptyValue(reflect.ValueOf(variableDeclarationsProp)) && (ok || !reflect.DeepEqual(v, variableDeclarationsProp)) {
		obj["variableDeclarations"] = variableDeclarationsProp
	}
	clientCertificateSettingsProp, err := expandCESAppClientCertificateSettings(d.Get("client_certificate_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client_certificate_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(clientCertificateSettingsProp)) && (ok || !reflect.DeepEqual(v, clientCertificateSettingsProp)) {
		obj["clientCertificateSettings"] = clientCertificateSettingsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps?appId={{app_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new App: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for App: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating App: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = CESOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating App", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create App: %s", err)
	}

	if err := d.Set("name", flattenCESAppName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating App %q: %#v", d.Id(), res)

	return resourceCESAppRead(d, meta)
}

func resourceCESAppRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for App: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("CESApp %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}

	if err := d.Set("audio_processing_config", flattenCESAppAudioProcessingConfig(res["audioProcessingConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("create_time", flattenCESAppCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("pinned", flattenCESAppPinned(res["pinned"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("data_store_settings", flattenCESAppDataStoreSettings(res["dataStoreSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("default_channel_profile", flattenCESAppDefaultChannelProfile(res["defaultChannelProfile"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("deployment_count", flattenCESAppDeploymentCount(res["deploymentCount"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("description", flattenCESAppDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("display_name", flattenCESAppDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("etag", flattenCESAppEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("evaluation_metrics_thresholds", flattenCESAppEvaluationMetricsThresholds(res["evaluationMetricsThresholds"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("global_instruction", flattenCESAppGlobalInstruction(res["globalInstruction"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("guardrails", flattenCESAppGuardrails(res["guardrails"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("language_settings", flattenCESAppLanguageSettings(res["languageSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("logging_settings", flattenCESAppLoggingSettings(res["loggingSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("metadata", flattenCESAppMetadata(res["metadata"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("model_settings", flattenCESAppModelSettings(res["modelSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("name", flattenCESAppName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("root_agent", flattenCESAppRootAgent(res["rootAgent"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("time_zone_settings", flattenCESAppTimeZoneSettings(res["timeZoneSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("update_time", flattenCESAppUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("variable_declarations", flattenCESAppVariableDeclarations(res["variableDeclarations"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}
	if err := d.Set("client_certificate_settings", flattenCESAppClientCertificateSettings(res["clientCertificateSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading App: %s", err)
	}

	identity, err := d.Identity()
	if err != nil && identity != nil {
		if v, ok := identity.GetOk("name"); ok && v != "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("location"); ok && v != "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); ok && v != "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] identity not set: %s", err)
	}
	return nil
}

func resourceCESAppUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for App: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	audioProcessingConfigProp, err := expandCESAppAudioProcessingConfig(d.Get("audio_processing_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("audio_processing_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, audioProcessingConfigProp)) {
		obj["audioProcessingConfig"] = audioProcessingConfigProp
	}
	pinnedProp, err := expandCESAppPinned(d.Get("pinned"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("pinned"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, pinnedProp)) {
		obj["pinned"] = pinnedProp
	}
	dataStoreSettingsProp, err := expandCESAppDataStoreSettings(d.Get("data_store_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_store_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dataStoreSettingsProp)) {
		obj["dataStoreSettings"] = dataStoreSettingsProp
	}
	defaultChannelProfileProp, err := expandCESAppDefaultChannelProfile(d.Get("default_channel_profile"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("default_channel_profile"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, defaultChannelProfileProp)) {
		obj["defaultChannelProfile"] = defaultChannelProfileProp
	}
	descriptionProp, err := expandCESAppDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	displayNameProp, err := expandCESAppDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	evaluationMetricsThresholdsProp, err := expandCESAppEvaluationMetricsThresholds(d.Get("evaluation_metrics_thresholds"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("evaluation_metrics_thresholds"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, evaluationMetricsThresholdsProp)) {
		obj["evaluationMetricsThresholds"] = evaluationMetricsThresholdsProp
	}
	globalInstructionProp, err := expandCESAppGlobalInstruction(d.Get("global_instruction"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("global_instruction"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, globalInstructionProp)) {
		obj["globalInstruction"] = globalInstructionProp
	}
	guardrailsProp, err := expandCESAppGuardrails(d.Get("guardrails"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("guardrails"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, guardrailsProp)) {
		obj["guardrails"] = guardrailsProp
	}
	languageSettingsProp, err := expandCESAppLanguageSettings(d.Get("language_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("language_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, languageSettingsProp)) {
		obj["languageSettings"] = languageSettingsProp
	}
	loggingSettingsProp, err := expandCESAppLoggingSettings(d.Get("logging_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("logging_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, loggingSettingsProp)) {
		obj["loggingSettings"] = loggingSettingsProp
	}
	metadataProp, err := expandCESAppMetadata(d.Get("metadata"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("metadata"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, metadataProp)) {
		obj["metadata"] = metadataProp
	}
	modelSettingsProp, err := expandCESAppModelSettings(d.Get("model_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("model_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, modelSettingsProp)) {
		obj["modelSettings"] = modelSettingsProp
	}
	rootAgentProp, err := expandCESAppRootAgent(d.Get("root_agent"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("root_agent"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, rootAgentProp)) {
		obj["rootAgent"] = rootAgentProp
	}
	timeZoneSettingsProp, err := expandCESAppTimeZoneSettings(d.Get("time_zone_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("time_zone_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, timeZoneSettingsProp)) {
		obj["timeZoneSettings"] = timeZoneSettingsProp
	}
	variableDeclarationsProp, err := expandCESAppVariableDeclarations(d.Get("variable_declarations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("variable_declarations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, variableDeclarationsProp)) {
		obj["variableDeclarations"] = variableDeclarationsProp
	}
	clientCertificateSettingsProp, err := expandCESAppClientCertificateSettings(d.Get("client_certificate_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client_certificate_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, clientCertificateSettingsProp)) {
		obj["clientCertificateSettings"] = clientCertificateSettingsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating App %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("audio_processing_config") {
		updateMask = append(updateMask, "audioProcessingConfig")
	}

	if d.HasChange("pinned") {
		updateMask = append(updateMask, "pinned")
	}

	if d.HasChange("data_store_settings") {
		updateMask = append(updateMask, "dataStoreSettings")
	}

	if d.HasChange("default_channel_profile") {
		updateMask = append(updateMask, "defaultChannelProfile")
	}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("evaluation_metrics_thresholds") {
		updateMask = append(updateMask, "evaluationMetricsThresholds")
	}

	if d.HasChange("global_instruction") {
		updateMask = append(updateMask, "globalInstruction")
	}

	if d.HasChange("guardrails") {
		updateMask = append(updateMask, "guardrails")
	}

	if d.HasChange("language_settings") {
		updateMask = append(updateMask, "languageSettings")
	}

	if d.HasChange("logging_settings") {
		updateMask = append(updateMask, "loggingSettings")
	}

	if d.HasChange("metadata") {
		updateMask = append(updateMask, "metadata")
	}

	if d.HasChange("model_settings") {
		updateMask = append(updateMask, "modelSettings")
	}

	if d.HasChange("root_agent") {
		updateMask = append(updateMask, "rootAgent")
	}

	if d.HasChange("time_zone_settings") {
		updateMask = append(updateMask, "timeZoneSettings")
	}

	if d.HasChange("variable_declarations") {
		updateMask = append(updateMask, "variableDeclarations")
	}

	if d.HasChange("client_certificate_settings") {
		updateMask = append(updateMask, "clientCertificateSettings")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating App %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating App %q: %#v", d.Id(), res)
		}

	}

	return resourceCESAppRead(d, meta)
}

func resourceCESAppDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for App: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting App %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "App")
	}

	err = CESOperationWaitTime(
		config, res, project, "Deleting App", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting App %q: %#v", d.Id(), res)
	return nil
}

func resourceCESAppImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/apps/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCESAppAudioProcessingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ambient_sound_config"] =
		flattenCESAppAudioProcessingConfigAmbientSoundConfig(original["ambientSoundConfig"], d, config)
	transformed["barge_in_config"] =
		flattenCESAppAudioProcessingConfigBargeInConfig(original["bargeInConfig"], d, config)
	transformed["inactivity_timeout"] =
		flattenCESAppAudioProcessingConfigInactivityTimeout(original["inactivityTimeout"], d, config)
	transformed["synthesize_speech_configs"] =
		flattenCESAppAudioProcessingConfigSynthesizeSpeechConfigs(original["synthesizeSpeechConfigs"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppAudioProcessingConfigAmbientSoundConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["gcs_uri"] =
		flattenCESAppAudioProcessingConfigAmbientSoundConfigGcsUri(original["gcsUri"], d, config)
	transformed["prebuilt_ambient_sound"] =
		flattenCESAppAudioProcessingConfigAmbientSoundConfigPrebuiltAmbientSound(original["prebuiltAmbientSound"], d, config)
	transformed["volume_gain_db"] =
		flattenCESAppAudioProcessingConfigAmbientSoundConfigVolumeGainDb(original["volumeGainDb"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppAudioProcessingConfigAmbientSoundConfigGcsUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppAudioProcessingConfigAmbientSoundConfigPrebuiltAmbientSound(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppAudioProcessingConfigAmbientSoundConfigVolumeGainDb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppAudioProcessingConfigBargeInConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["barge_in_awareness"] =
		flattenCESAppAudioProcessingConfigBargeInConfigBargeInAwareness(original["bargeInAwareness"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppAudioProcessingConfigBargeInConfigBargeInAwareness(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppAudioProcessingConfigInactivityTimeout(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppAudioProcessingConfigSynthesizeSpeechConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"language_code": k,
			"voice":         flattenCESAppAudioProcessingConfigSynthesizeSpeechConfigsVoice(original["voice"], d, config),
			"speaking_rate": flattenCESAppAudioProcessingConfigSynthesizeSpeechConfigsSpeakingRate(original["speakingRate"], d, config),
		})
	}
	return transformed
}
func flattenCESAppAudioProcessingConfigSynthesizeSpeechConfigsVoice(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppAudioProcessingConfigSynthesizeSpeechConfigsSpeakingRate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppPinned(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDataStoreSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["engines"] =
		flattenCESAppDataStoreSettingsEngines(original["engines"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppDataStoreSettingsEngines(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name": flattenCESAppDataStoreSettingsEnginesName(original["name"], d, config),
			"type": flattenCESAppDataStoreSettingsEnginesType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenCESAppDataStoreSettingsEnginesName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDataStoreSettingsEnginesType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDefaultChannelProfile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["channel_type"] =
		flattenCESAppDefaultChannelProfileChannelType(original["channelType"], d, config)
	transformed["disable_barge_in_control"] =
		flattenCESAppDefaultChannelProfileDisableBargeInControl(original["disableBargeInControl"], d, config)
	transformed["disable_dtmf"] =
		flattenCESAppDefaultChannelProfileDisableDtmf(original["disableDtmf"], d, config)
	transformed["persona_property"] =
		flattenCESAppDefaultChannelProfilePersonaProperty(original["personaProperty"], d, config)
	transformed["profile_id"] =
		flattenCESAppDefaultChannelProfileProfileId(original["profileId"], d, config)
	transformed["web_widget_config"] =
		flattenCESAppDefaultChannelProfileWebWidgetConfig(original["webWidgetConfig"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppDefaultChannelProfileChannelType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDefaultChannelProfileDisableBargeInControl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDefaultChannelProfileDisableDtmf(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDefaultChannelProfilePersonaProperty(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["persona"] =
		flattenCESAppDefaultChannelProfilePersonaPropertyPersona(original["persona"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppDefaultChannelProfilePersonaPropertyPersona(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDefaultChannelProfileProfileId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDefaultChannelProfileWebWidgetConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["modality"] =
		flattenCESAppDefaultChannelProfileWebWidgetConfigModality(original["modality"], d, config)
	transformed["theme"] =
		flattenCESAppDefaultChannelProfileWebWidgetConfigTheme(original["theme"], d, config)
	transformed["web_widget_title"] =
		flattenCESAppDefaultChannelProfileWebWidgetConfigWebWidgetTitle(original["webWidgetTitle"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppDefaultChannelProfileWebWidgetConfigModality(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDefaultChannelProfileWebWidgetConfigTheme(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDefaultChannelProfileWebWidgetConfigWebWidgetTitle(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDeploymentCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESAppDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppEvaluationMetricsThresholds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["golden_evaluation_metrics_thresholds"] =
		flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds(original["goldenEvaluationMetricsThresholds"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["expectation_level_metrics_thresholds"] =
		flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds(original["expectationLevelMetricsThresholds"], d, config)
	transformed["turn_level_metrics_thresholds"] =
		flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds(original["turnLevelMetricsThresholds"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["tool_invocation_parameter_correctness_threshold"] =
		flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsToolInvocationParameterCorrectnessThreshold(original["toolInvocationParameterCorrectnessThreshold"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsToolInvocationParameterCorrectnessThreshold(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["overall_tool_invocation_correctness_threshold"] =
		flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsOverallToolInvocationCorrectnessThreshold(original["overallToolInvocationCorrectnessThreshold"], d, config)
	transformed["semantic_similarity_success_threshold"] =
		flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsSemanticSimilaritySuccessThreshold(original["semanticSimilaritySuccessThreshold"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsOverallToolInvocationCorrectnessThreshold(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsSemanticSimilaritySuccessThreshold(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESAppGlobalInstruction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppGuardrails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLanguageSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["default_language_code"] =
		flattenCESAppLanguageSettingsDefaultLanguageCode(original["defaultLanguageCode"], d, config)
	transformed["enable_multilingual_support"] =
		flattenCESAppLanguageSettingsEnableMultilingualSupport(original["enableMultilingualSupport"], d, config)
	transformed["fallback_action"] =
		flattenCESAppLanguageSettingsFallbackAction(original["fallbackAction"], d, config)
	transformed["supported_language_codes"] =
		flattenCESAppLanguageSettingsSupportedLanguageCodes(original["supportedLanguageCodes"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppLanguageSettingsDefaultLanguageCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLanguageSettingsEnableMultilingualSupport(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLanguageSettingsFallbackAction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLanguageSettingsSupportedLanguageCodes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLoggingSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["audio_recording_config"] =
		flattenCESAppLoggingSettingsAudioRecordingConfig(original["audioRecordingConfig"], d, config)
	transformed["bigquery_export_settings"] =
		flattenCESAppLoggingSettingsBigqueryExportSettings(original["bigqueryExportSettings"], d, config)
	transformed["cloud_logging_settings"] =
		flattenCESAppLoggingSettingsCloudLoggingSettings(original["cloudLoggingSettings"], d, config)
	transformed["conversation_logging_settings"] =
		flattenCESAppLoggingSettingsConversationLoggingSettings(original["conversationLoggingSettings"], d, config)
	transformed["redaction_config"] =
		flattenCESAppLoggingSettingsRedactionConfig(original["redactionConfig"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppLoggingSettingsAudioRecordingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["gcs_bucket"] =
		flattenCESAppLoggingSettingsAudioRecordingConfigGcsBucket(original["gcsBucket"], d, config)
	transformed["gcs_path_prefix"] =
		flattenCESAppLoggingSettingsAudioRecordingConfigGcsPathPrefix(original["gcsPathPrefix"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppLoggingSettingsAudioRecordingConfigGcsBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLoggingSettingsAudioRecordingConfigGcsPathPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLoggingSettingsBigqueryExportSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dataset"] =
		flattenCESAppLoggingSettingsBigqueryExportSettingsDataset(original["dataset"], d, config)
	transformed["enabled"] =
		flattenCESAppLoggingSettingsBigqueryExportSettingsEnabled(original["enabled"], d, config)
	transformed["project"] =
		flattenCESAppLoggingSettingsBigqueryExportSettingsProject(original["project"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppLoggingSettingsBigqueryExportSettingsDataset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLoggingSettingsBigqueryExportSettingsEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLoggingSettingsBigqueryExportSettingsProject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLoggingSettingsCloudLoggingSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enable_cloud_logging"] =
		flattenCESAppLoggingSettingsCloudLoggingSettingsEnableCloudLogging(original["enableCloudLogging"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppLoggingSettingsCloudLoggingSettingsEnableCloudLogging(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLoggingSettingsConversationLoggingSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disable_conversation_logging"] =
		flattenCESAppLoggingSettingsConversationLoggingSettingsDisableConversationLogging(original["disableConversationLogging"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppLoggingSettingsConversationLoggingSettingsDisableConversationLogging(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLoggingSettingsRedactionConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["deidentify_template"] =
		flattenCESAppLoggingSettingsRedactionConfigDeidentifyTemplate(original["deidentifyTemplate"], d, config)
	transformed["enable_redaction"] =
		flattenCESAppLoggingSettingsRedactionConfigEnableRedaction(original["enableRedaction"], d, config)
	transformed["inspect_template"] =
		flattenCESAppLoggingSettingsRedactionConfigInspectTemplate(original["inspectTemplate"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppLoggingSettingsRedactionConfigDeidentifyTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLoggingSettingsRedactionConfigEnableRedaction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppLoggingSettingsRedactionConfigInspectTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppMetadata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESAppModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESAppModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenCESAppRootAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppTimeZoneSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["time_zone"] =
		flattenCESAppTimeZoneSettingsTimeZone(original["timeZone"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppTimeZoneSettingsTimeZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAppVariableDeclarationsDescription(original["description"], d, config),
			"name":        flattenCESAppVariableDeclarationsName(original["name"], d, config),
			"schema":      flattenCESAppVariableDeclarationsSchema(original["schema"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVariableDeclarationsDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarationsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarationsSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["title"] =
		flattenCESAppVariableDeclarationsSchemaTitle(original["title"], d, config)
	transformed["description"] =
		flattenCESAppVariableDeclarationsSchemaDescription(original["description"], d, config)
	transformed["enum"] =
		flattenCESAppVariableDeclarationsSchemaEnum(original["enum"], d, config)
	transformed["nullable"] =
		flattenCESAppVariableDeclarationsSchemaNullable(original["nullable"], d, config)
	transformed["ref"] =
		flattenCESAppVariableDeclarationsSchemaRef(original["ref"], d, config)
	transformed["required"] =
		flattenCESAppVariableDeclarationsSchemaRequired(original["required"], d, config)
	transformed["type"] =
		flattenCESAppVariableDeclarationsSchemaType(original["type"], d, config)
	transformed["unique_items"] =
		flattenCESAppVariableDeclarationsSchemaUniqueItems(original["uniqueItems"], d, config)
	transformed["defs"] =
		flattenCESAppVariableDeclarationsSchemaDefs(original["defs"], d, config)
	transformed["default"] =
		flattenCESAppVariableDeclarationsSchemaDefault(original["default"], d, config)
	transformed["additional_properties"] =
		flattenCESAppVariableDeclarationsSchemaAdditionalProperties(original["additionalProperties"], d, config)
	transformed["any_of"] =
		flattenCESAppVariableDeclarationsSchemaAnyOf(original["anyOf"], d, config)
	transformed["prefix_items"] =
		flattenCESAppVariableDeclarationsSchemaPrefixItems(original["prefixItems"], d, config)
	transformed["properties"] =
		flattenCESAppVariableDeclarationsSchemaProperties(original["properties"], d, config)
	transformed["items"] =
		flattenCESAppVariableDeclarationsSchemaItems(original["items"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVariableDeclarationsSchemaTitle(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarationsSchemaDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarationsSchemaEnum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarationsSchemaNullable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarationsSchemaRef(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarationsSchemaRequired(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarationsSchemaType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarationsSchemaUniqueItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarationsSchemaDefs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVariableDeclarationsSchemaDefault(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVariableDeclarationsSchemaAdditionalProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVariableDeclarationsSchemaAnyOf(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVariableDeclarationsSchemaPrefixItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVariableDeclarationsSchemaProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVariableDeclarationsSchemaItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppClientCertificateSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["tls_certificate"] =
		flattenCESAppClientCertificateSettingsTlsCertificate(original["tlsCertificate"], d, config)
	transformed["private_key"] =
		flattenCESAppClientCertificateSettingsPrivateKey(original["privateKey"], d, config)
	transformed["passphrase"] =
		flattenCESAppClientCertificateSettingsPassphrase(original["passphrase"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppClientCertificateSettingsTlsCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppClientCertificateSettingsPrivateKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppClientCertificateSettingsPassphrase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandCESAppAudioProcessingConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAmbientSoundConfig, err := expandCESAppAudioProcessingConfigAmbientSoundConfig(original["ambient_sound_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAmbientSoundConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ambientSoundConfig"] = transformedAmbientSoundConfig
	}

	transformedBargeInConfig, err := expandCESAppAudioProcessingConfigBargeInConfig(original["barge_in_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBargeInConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bargeInConfig"] = transformedBargeInConfig
	}

	transformedInactivityTimeout, err := expandCESAppAudioProcessingConfigInactivityTimeout(original["inactivity_timeout"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInactivityTimeout); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inactivityTimeout"] = transformedInactivityTimeout
	}

	transformedSynthesizeSpeechConfigs, err := expandCESAppAudioProcessingConfigSynthesizeSpeechConfigs(original["synthesize_speech_configs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSynthesizeSpeechConfigs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["synthesizeSpeechConfigs"] = transformedSynthesizeSpeechConfigs
	}

	return transformed, nil
}

func expandCESAppAudioProcessingConfigAmbientSoundConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGcsUri, err := expandCESAppAudioProcessingConfigAmbientSoundConfigGcsUri(original["gcs_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcsUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcsUri"] = transformedGcsUri
	}

	transformedPrebuiltAmbientSound, err := expandCESAppAudioProcessingConfigAmbientSoundConfigPrebuiltAmbientSound(original["prebuilt_ambient_sound"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrebuiltAmbientSound); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prebuiltAmbientSound"] = transformedPrebuiltAmbientSound
	}

	transformedVolumeGainDb, err := expandCESAppAudioProcessingConfigAmbientSoundConfigVolumeGainDb(original["volume_gain_db"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVolumeGainDb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["volumeGainDb"] = transformedVolumeGainDb
	}

	return transformed, nil
}

func expandCESAppAudioProcessingConfigAmbientSoundConfigGcsUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppAudioProcessingConfigAmbientSoundConfigPrebuiltAmbientSound(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppAudioProcessingConfigAmbientSoundConfigVolumeGainDb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppAudioProcessingConfigBargeInConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBargeInAwareness, err := expandCESAppAudioProcessingConfigBargeInConfigBargeInAwareness(original["barge_in_awareness"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBargeInAwareness); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bargeInAwareness"] = transformedBargeInAwareness
	}

	return transformed, nil
}

func expandCESAppAudioProcessingConfigBargeInConfigBargeInAwareness(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppAudioProcessingConfigInactivityTimeout(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppAudioProcessingConfigSynthesizeSpeechConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedVoice, err := expandCESAppAudioProcessingConfigSynthesizeSpeechConfigsVoice(original["voice"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVoice); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["voice"] = transformedVoice
		}

		transformedSpeakingRate, err := expandCESAppAudioProcessingConfigSynthesizeSpeechConfigsSpeakingRate(original["speaking_rate"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSpeakingRate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["speakingRate"] = transformedSpeakingRate
		}

		transformedLanguageCode, err := tpgresource.ExpandString(original["language_code"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedLanguageCode] = transformed
	}
	return m, nil
}

func expandCESAppAudioProcessingConfigSynthesizeSpeechConfigsVoice(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppAudioProcessingConfigSynthesizeSpeechConfigsSpeakingRate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppPinned(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDataStoreSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEngines, err := expandCESAppDataStoreSettingsEngines(original["engines"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEngines); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["engines"] = transformedEngines
	}

	return transformed, nil
}

func expandCESAppDataStoreSettingsEngines(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCESAppDataStoreSettingsEnginesName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedType, err := expandCESAppDataStoreSettingsEnginesType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESAppDataStoreSettingsEnginesName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDataStoreSettingsEnginesType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDefaultChannelProfile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedChannelType, err := expandCESAppDefaultChannelProfileChannelType(original["channel_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedChannelType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["channelType"] = transformedChannelType
	}

	transformedDisableBargeInControl, err := expandCESAppDefaultChannelProfileDisableBargeInControl(original["disable_barge_in_control"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisableBargeInControl); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disableBargeInControl"] = transformedDisableBargeInControl
	}

	transformedDisableDtmf, err := expandCESAppDefaultChannelProfileDisableDtmf(original["disable_dtmf"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisableDtmf); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disableDtmf"] = transformedDisableDtmf
	}

	transformedPersonaProperty, err := expandCESAppDefaultChannelProfilePersonaProperty(original["persona_property"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPersonaProperty); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["personaProperty"] = transformedPersonaProperty
	}

	transformedProfileId, err := expandCESAppDefaultChannelProfileProfileId(original["profile_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProfileId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["profileId"] = transformedProfileId
	}

	transformedWebWidgetConfig, err := expandCESAppDefaultChannelProfileWebWidgetConfig(original["web_widget_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWebWidgetConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["webWidgetConfig"] = transformedWebWidgetConfig
	}

	return transformed, nil
}

func expandCESAppDefaultChannelProfileChannelType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDefaultChannelProfileDisableBargeInControl(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDefaultChannelProfileDisableDtmf(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDefaultChannelProfilePersonaProperty(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPersona, err := expandCESAppDefaultChannelProfilePersonaPropertyPersona(original["persona"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPersona); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["persona"] = transformedPersona
	}

	return transformed, nil
}

func expandCESAppDefaultChannelProfilePersonaPropertyPersona(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDefaultChannelProfileProfileId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDefaultChannelProfileWebWidgetConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedModality, err := expandCESAppDefaultChannelProfileWebWidgetConfigModality(original["modality"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModality); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["modality"] = transformedModality
	}

	transformedTheme, err := expandCESAppDefaultChannelProfileWebWidgetConfigTheme(original["theme"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTheme); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["theme"] = transformedTheme
	}

	transformedWebWidgetTitle, err := expandCESAppDefaultChannelProfileWebWidgetConfigWebWidgetTitle(original["web_widget_title"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWebWidgetTitle); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["webWidgetTitle"] = transformedWebWidgetTitle
	}

	return transformed, nil
}

func expandCESAppDefaultChannelProfileWebWidgetConfigModality(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDefaultChannelProfileWebWidgetConfigTheme(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDefaultChannelProfileWebWidgetConfigWebWidgetTitle(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppEvaluationMetricsThresholds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGoldenEvaluationMetricsThresholds, err := expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds(original["golden_evaluation_metrics_thresholds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGoldenEvaluationMetricsThresholds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["goldenEvaluationMetricsThresholds"] = transformedGoldenEvaluationMetricsThresholds
	}

	return transformed, nil
}

func expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedExpectationLevelMetricsThresholds, err := expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds(original["expectation_level_metrics_thresholds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExpectationLevelMetricsThresholds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["expectationLevelMetricsThresholds"] = transformedExpectationLevelMetricsThresholds
	}

	transformedTurnLevelMetricsThresholds, err := expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds(original["turn_level_metrics_thresholds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTurnLevelMetricsThresholds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["turnLevelMetricsThresholds"] = transformedTurnLevelMetricsThresholds
	}

	return transformed, nil
}

func expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedToolInvocationParameterCorrectnessThreshold, err := expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsToolInvocationParameterCorrectnessThreshold(original["tool_invocation_parameter_correctness_threshold"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedToolInvocationParameterCorrectnessThreshold); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["toolInvocationParameterCorrectnessThreshold"] = transformedToolInvocationParameterCorrectnessThreshold
	}

	return transformed, nil
}

func expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsToolInvocationParameterCorrectnessThreshold(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOverallToolInvocationCorrectnessThreshold, err := expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsOverallToolInvocationCorrectnessThreshold(original["overall_tool_invocation_correctness_threshold"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOverallToolInvocationCorrectnessThreshold); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["overallToolInvocationCorrectnessThreshold"] = transformedOverallToolInvocationCorrectnessThreshold
	}

	transformedSemanticSimilaritySuccessThreshold, err := expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsSemanticSimilaritySuccessThreshold(original["semantic_similarity_success_threshold"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSemanticSimilaritySuccessThreshold); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["semanticSimilaritySuccessThreshold"] = transformedSemanticSimilaritySuccessThreshold
	}

	return transformed, nil
}

func expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsOverallToolInvocationCorrectnessThreshold(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsSemanticSimilaritySuccessThreshold(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppGlobalInstruction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppGuardrails(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLanguageSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDefaultLanguageCode, err := expandCESAppLanguageSettingsDefaultLanguageCode(original["default_language_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefaultLanguageCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["defaultLanguageCode"] = transformedDefaultLanguageCode
	}

	transformedEnableMultilingualSupport, err := expandCESAppLanguageSettingsEnableMultilingualSupport(original["enable_multilingual_support"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableMultilingualSupport); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableMultilingualSupport"] = transformedEnableMultilingualSupport
	}

	transformedFallbackAction, err := expandCESAppLanguageSettingsFallbackAction(original["fallback_action"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFallbackAction); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fallbackAction"] = transformedFallbackAction
	}

	transformedSupportedLanguageCodes, err := expandCESAppLanguageSettingsSupportedLanguageCodes(original["supported_language_codes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSupportedLanguageCodes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["supportedLanguageCodes"] = transformedSupportedLanguageCodes
	}

	return transformed, nil
}

func expandCESAppLanguageSettingsDefaultLanguageCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLanguageSettingsEnableMultilingualSupport(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLanguageSettingsFallbackAction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLanguageSettingsSupportedLanguageCodes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLoggingSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAudioRecordingConfig, err := expandCESAppLoggingSettingsAudioRecordingConfig(original["audio_recording_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAudioRecordingConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["audioRecordingConfig"] = transformedAudioRecordingConfig
	}

	transformedBigqueryExportSettings, err := expandCESAppLoggingSettingsBigqueryExportSettings(original["bigquery_export_settings"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBigqueryExportSettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bigqueryExportSettings"] = transformedBigqueryExportSettings
	}

	transformedCloudLoggingSettings, err := expandCESAppLoggingSettingsCloudLoggingSettings(original["cloud_logging_settings"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCloudLoggingSettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cloudLoggingSettings"] = transformedCloudLoggingSettings
	}

	transformedConversationLoggingSettings, err := expandCESAppLoggingSettingsConversationLoggingSettings(original["conversation_logging_settings"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConversationLoggingSettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["conversationLoggingSettings"] = transformedConversationLoggingSettings
	}

	transformedRedactionConfig, err := expandCESAppLoggingSettingsRedactionConfig(original["redaction_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRedactionConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["redactionConfig"] = transformedRedactionConfig
	}

	return transformed, nil
}

func expandCESAppLoggingSettingsAudioRecordingConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGcsBucket, err := expandCESAppLoggingSettingsAudioRecordingConfigGcsBucket(original["gcs_bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcsBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcsBucket"] = transformedGcsBucket
	}

	transformedGcsPathPrefix, err := expandCESAppLoggingSettingsAudioRecordingConfigGcsPathPrefix(original["gcs_path_prefix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcsPathPrefix); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcsPathPrefix"] = transformedGcsPathPrefix
	}

	return transformed, nil
}

func expandCESAppLoggingSettingsAudioRecordingConfigGcsBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLoggingSettingsAudioRecordingConfigGcsPathPrefix(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLoggingSettingsBigqueryExportSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDataset, err := expandCESAppLoggingSettingsBigqueryExportSettingsDataset(original["dataset"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataset"] = transformedDataset
	}

	transformedEnabled, err := expandCESAppLoggingSettingsBigqueryExportSettingsEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	transformedProject, err := expandCESAppLoggingSettingsBigqueryExportSettingsProject(original["project"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["project"] = transformedProject
	}

	return transformed, nil
}

func expandCESAppLoggingSettingsBigqueryExportSettingsDataset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLoggingSettingsBigqueryExportSettingsEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLoggingSettingsBigqueryExportSettingsProject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLoggingSettingsCloudLoggingSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnableCloudLogging, err := expandCESAppLoggingSettingsCloudLoggingSettingsEnableCloudLogging(original["enable_cloud_logging"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableCloudLogging); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableCloudLogging"] = transformedEnableCloudLogging
	}

	return transformed, nil
}

func expandCESAppLoggingSettingsCloudLoggingSettingsEnableCloudLogging(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLoggingSettingsConversationLoggingSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDisableConversationLogging, err := expandCESAppLoggingSettingsConversationLoggingSettingsDisableConversationLogging(original["disable_conversation_logging"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisableConversationLogging); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disableConversationLogging"] = transformedDisableConversationLogging
	}

	return transformed, nil
}

func expandCESAppLoggingSettingsConversationLoggingSettingsDisableConversationLogging(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLoggingSettingsRedactionConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDeidentifyTemplate, err := expandCESAppLoggingSettingsRedactionConfigDeidentifyTemplate(original["deidentify_template"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDeidentifyTemplate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["deidentifyTemplate"] = transformedDeidentifyTemplate
	}

	transformedEnableRedaction, err := expandCESAppLoggingSettingsRedactionConfigEnableRedaction(original["enable_redaction"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableRedaction); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableRedaction"] = transformedEnableRedaction
	}

	transformedInspectTemplate, err := expandCESAppLoggingSettingsRedactionConfigInspectTemplate(original["inspect_template"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInspectTemplate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inspectTemplate"] = transformedInspectTemplate
	}

	return transformed, nil
}

func expandCESAppLoggingSettingsRedactionConfigDeidentifyTemplate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLoggingSettingsRedactionConfigEnableRedaction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppLoggingSettingsRedactionConfigInspectTemplate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppMetadata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCESAppModelSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedModel, err := expandCESAppModelSettingsModel(original["model"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["model"] = transformedModel
	}

	transformedTemperature, err := expandCESAppModelSettingsTemperature(original["temperature"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTemperature); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["temperature"] = transformedTemperature
	}

	return transformed, nil
}

func expandCESAppModelSettingsModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppModelSettingsTemperature(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppRootAgent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppTimeZoneSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTimeZone, err := expandCESAppTimeZoneSettingsTimeZone(original["time_zone"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeZone); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["timeZone"] = transformedTimeZone
	}

	return transformed, nil
}

func expandCESAppTimeZoneSettingsTimeZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDescription, err := expandCESAppVariableDeclarationsDescription(original["description"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["description"] = transformedDescription
		}

		transformedName, err := expandCESAppVariableDeclarationsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedSchema, err := expandCESAppVariableDeclarationsSchema(original["schema"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSchema); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["schema"] = transformedSchema
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESAppVariableDeclarationsDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarationsName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarationsSchema(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTitle, err := expandCESAppVariableDeclarationsSchemaTitle(original["title"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTitle); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["title"] = transformedTitle
	}

	transformedDescription, err := expandCESAppVariableDeclarationsSchemaDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedEnum, err := expandCESAppVariableDeclarationsSchemaEnum(original["enum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enum"] = transformedEnum
	}

	transformedNullable, err := expandCESAppVariableDeclarationsSchemaNullable(original["nullable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNullable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nullable"] = transformedNullable
	}

	transformedRef, err := expandCESAppVariableDeclarationsSchemaRef(original["ref"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRef); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ref"] = transformedRef
	}

	transformedRequired, err := expandCESAppVariableDeclarationsSchemaRequired(original["required"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRequired); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["required"] = transformedRequired
	}

	transformedType, err := expandCESAppVariableDeclarationsSchemaType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedUniqueItems, err := expandCESAppVariableDeclarationsSchemaUniqueItems(original["unique_items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUniqueItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uniqueItems"] = transformedUniqueItems
	}

	transformedDefs, err := expandCESAppVariableDeclarationsSchemaDefs(original["defs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["defs"] = transformedDefs
	}

	transformedDefault, err := expandCESAppVariableDeclarationsSchemaDefault(original["default"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefault); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["default"] = transformedDefault
	}

	transformedAdditionalProperties, err := expandCESAppVariableDeclarationsSchemaAdditionalProperties(original["additional_properties"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdditionalProperties); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["additionalProperties"] = transformedAdditionalProperties
	}

	transformedAnyOf, err := expandCESAppVariableDeclarationsSchemaAnyOf(original["any_of"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAnyOf); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["anyOf"] = transformedAnyOf
	}

	transformedPrefixItems, err := expandCESAppVariableDeclarationsSchemaPrefixItems(original["prefix_items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrefixItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prefixItems"] = transformedPrefixItems
	}

	transformedProperties, err := expandCESAppVariableDeclarationsSchemaProperties(original["properties"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProperties); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["properties"] = transformedProperties
	}

	transformedItems, err := expandCESAppVariableDeclarationsSchemaItems(original["items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["items"] = transformedItems
	}

	return transformed, nil
}

func expandCESAppVariableDeclarationsSchemaTitle(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarationsSchemaDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarationsSchemaEnum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarationsSchemaNullable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarationsSchemaRef(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarationsSchemaRequired(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarationsSchemaType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarationsSchemaUniqueItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarationsSchemaDefs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESAppVariableDeclarationsSchemaDefault(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVariableDeclarationsSchemaAdditionalProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESAppVariableDeclarationsSchemaAnyOf(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESAppVariableDeclarationsSchemaPrefixItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESAppVariableDeclarationsSchemaProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESAppVariableDeclarationsSchemaItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESAppClientCertificateSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTlsCertificate, err := expandCESAppClientCertificateSettingsTlsCertificate(original["tls_certificate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTlsCertificate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tlsCertificate"] = transformedTlsCertificate
	}

	transformedPrivateKey, err := expandCESAppClientCertificateSettingsPrivateKey(original["private_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrivateKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["privateKey"] = transformedPrivateKey
	}

	transformedPassphrase, err := expandCESAppClientCertificateSettingsPassphrase(original["passphrase"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassphrase); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["passphrase"] = transformedPassphrase
	}

	return transformed, nil
}

func expandCESAppClientCertificateSettingsTlsCertificate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppClientCertificateSettingsPrivateKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppClientCertificateSettingsPassphrase(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
