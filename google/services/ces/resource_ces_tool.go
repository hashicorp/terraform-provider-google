// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/ces/Tool.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package ces

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceCESTool() *schema.Resource {
	return &schema.Resource{
		Create: resourceCESToolCreate,
		Read:   resourceCESToolRead,
		Update: resourceCESToolUpdate,
		Delete: resourceCESToolDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCESToolImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"app": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"app": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"tool_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The ID to use for the tool, which will become the final component of
the tool's resource name. If not provided, a unique ID will be
automatically assigned for the tool.`,
			},
			"client_function": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Represents a client-side function that the agent can invoke. When the
tool is chosen by the agent, control is handed off to the client.
The client is responsible for executing the function and returning the result
as a ToolResponse to continue the interaction with the agent.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The function name.`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The function description.`,
						},
						"parameters": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Represents a select subset of an OpenAPI 3.0 schema object.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"type": {
										Type:     schema.TypeString,
										Required: true,
										Description: `The type of the data.
Possible values:
STRING
INTEGER
NUMBER
BOOLEAN
OBJECT
ARRAY`,
									},
									"additional_properties": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description: `Defines the schema for additional properties allowed in an object.
The value must be a valid JSON string representing the Schema object.
(Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).`,
									},
									"any_of": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `The instance value should be valid against at least one of the schemas in this list.`,
									},
									"default": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Default value of the data. Represents a dynamically typed value
which can be either null, a number, a string, a boolean, a struct,
or a list of values. The provided default value must be compatible
with the defined 'type' and other schema constraints.`,
									},
									"defs": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `A map of definitions for use by ref. Only allowed at the root of the schema.`,
									},
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The description of the data.`,
									},
									"enum": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Possible values of the element of primitive type with enum format.
Examples:
1. We can define direction as :
{type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
2. We can define apartment number as :
{type:INTEGER, format:enum, enum:["101", "201", "301"]}`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"items": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `Schema of the elements of Type.ARRAY.`,
									},
									"max_items": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Maximum number of the elements for Type.ARRAY. (int64 format)`,
									},
									"maximum": {
										Type:        schema.TypeFloat,
										Optional:    true,
										Description: `Maximum value for Type.INTEGER and Type.NUMBER.`,
									},
									"min_items": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Minimum number of the elements for Type.ARRAY. (int64 format)`,
									},
									"minimum": {
										Type:        schema.TypeFloat,
										Optional:    true,
										Description: `Minimum value for Type.INTEGER and Type.NUMBER.`,
									},
									"nullable": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Indicates if the value may be null.`,
									},
									"prefix_items": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `Schemas of initial elements of Type.ARRAY.`,
									},
									"properties": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `Properties of Type.OBJECT.`,
									},
									"ref": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Allows indirect references between schema nodes. The value should be a
valid reference to a child of the root 'defs'.
For example, the following schema defines a reference to a schema node
named "Pet":
type: object
properties:
  pet:
    ref: #/defs/Pet
defs:
  Pet:
    type: object
    properties:
      name:
        type: string
The value of the "pet" property is a reference to the schema node
named "Pet".
See details in
https://json-schema.org/understanding-json-schema/structuring.`,
									},
									"required": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Required properties of Type.OBJECT.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"title": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The title of the schema.`,
									},
									"unique_items": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.`,
									},
								},
							},
						},
						"response": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Represents a select subset of an OpenAPI 3.0 schema object.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"type": {
										Type:     schema.TypeString,
										Required: true,
										Description: `The type of the data.
Possible values:
STRING
INTEGER
NUMBER
BOOLEAN
OBJECT
ARRAY`,
									},
									"additional_properties": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description: `Defines the schema for additional properties allowed in an object.
The value must be a valid JSON string representing the Schema object.
(Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).`,
									},
									"any_of": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `The instance value should be valid against at least one of the schemas in this list.`,
									},
									"default": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Default value of the data. Represents a dynamically typed value
which can be either null, a number, a string, a boolean, a struct,
or a list of values. The provided default value must be compatible
with the defined 'type' and other schema constraints.`,
									},
									"defs": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `A map of definitions for use by ref. Only allowed at the root of the schema.`,
									},
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The description of the data.`,
									},
									"enum": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Possible values of the element of primitive type with enum format.
Examples:
1. We can define direction as :
{type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
2. We can define apartment number as :
{type:INTEGER, format:enum, enum:["101", "201", "301"]}`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"items": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `Schema of the elements of Type.ARRAY.`,
									},
									"max_items": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Maximum number of the elements for Type.ARRAY. (int64 format)`,
									},
									"maximum": {
										Type:        schema.TypeFloat,
										Optional:    true,
										Description: `Maximum value for Type.INTEGER and Type.NUMBER.`,
									},
									"min_items": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Minimum number of the elements for Type.ARRAY. (int64 format)`,
									},
									"minimum": {
										Type:        schema.TypeFloat,
										Optional:    true,
										Description: `Minimum value for Type.INTEGER and Type.NUMBER.`,
									},
									"nullable": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Indicates if the value may be null.`,
									},
									"prefix_items": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `Schemas of initial elements of Type.ARRAY.`,
									},
									"properties": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: validation.StringIsJSON,
										StateFunc:    func(v interface{}) string { s, _ := structure.NormalizeJsonString(v); return s },
										Description:  `Properties of Type.OBJECT.`,
									},
									"ref": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Allows indirect references between schema nodes. The value should be a
valid reference to a child of the root 'defs'.
For example, the following schema defines a reference to a schema node
named "Pet":
type: object
properties:
  pet:
    ref: #/defs/Pet
defs:
  Pet:
    type: object
    properties:
      name:
        type: string
The value of the "pet" property is a reference to the schema node
named "Pet".
See details in
https://json-schema.org/understanding-json-schema/structuring.`,
									},
									"required": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Required properties of Type.OBJECT.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"title": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The title of the schema.`,
									},
									"unique_items": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.`,
									},
								},
							},
						},
					},
				},
			},
			"data_store_tool": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Tool to retrieve from Vertex AI Search datastore or engine for grounding.
Accepts either a datastore or an engine, but not both.
See Vertex AI Search:
https://cloud.google.com/generative-ai-app-builder/docs/enterprise-search-introduction.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The data store tool name.`,
						},
						"boost_specs": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Boost specification to boost certain documents.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"data_stores": {
										Type:     schema.TypeList,
										Required: true,
										Description: `The Data Store where the boosting configuration is applied. Full resource
name of DataStore, such as
projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"spec": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `A list of boosting specifications.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"condition_boost_specs": {
													Type:        schema.TypeList,
													Required:    true,
													Description: `A list of boosting specifications.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"condition": {
																Type:     schema.TypeString,
																Required: true,
																Description: `An expression which specifies a boost condition. The syntax is the same
as filter expression syntax. Currently, the only supported condition is
a list of BCP-47 lang codes.
Example: To boost suggestions in languages en or fr:
(lang_code: ANY("en", "fr"))`,
															},
															"boost": {
																Type:     schema.TypeFloat,
																Optional: true,
																Description: `Strength of the boost, which should be in [-1, 1]. Negative boost means
demotion. Default is 0.0.
Setting to 1.0 gives the suggestions a big promotion. However, it does
not necessarily mean that the top result will be a boosted suggestion.
Setting to -1.0 gives the suggestions a big demotion. However, other
suggestions that are relevant might still be shown.
Setting to 0.0 means no boost applied. The boosting condition is
ignored.`,
															},
															"boost_control_spec": {
																Type:     schema.TypeList,
																Optional: true,
																Description: `Specification for custom ranking based on customer specified attribute
value. It provides more controls for customized ranking than the simple
(condition, boost) combination above.`,
																MaxItems: 1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"attribute_type": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The attribute type to be used to determine the boost amount. The
attribute value can be derived from the field value of the specified
field_name. In the case of numerical it is straightforward i.e.
attribute_value = numerical_field_value. In the case of freshness
however, attribute_value = (time.now() - datetime_field_value).
Possible values:
NUMERICAL
FRESHNESS`,
																		},
																		"control_points": {
																			Type:     schema.TypeList,
																			Optional: true,
																			Description: `The control points used to define the curve. The monotonic function
(defined through the interpolation_type above) passes through the
control points listed here.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"attribute_value": {
																						Type:     schema.TypeString,
																						Optional: true,
																						Description: `Can be one of:
1. The numerical field value.
2. The duration spec for freshness:
The value must be formatted as an XSD 'dayTimeDuration' value (a
restricted subset of an ISO 8601 duration value). The pattern for
this is: 'nDnM]'.`,
																					},
																					"boost_amount": {
																						Type:     schema.TypeFloat,
																						Optional: true,
																						Description: `The value between -1 to 1 by which to boost the score if the
attribute_value evaluates to the value specified above.`,
																					},
																				},
																			},
																		},
																		"field_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The name of the field whose value will be used to determine the
boost amount.`,
																		},
																		"interpolation_type": {
																			Type:     schema.TypeString,
																			Optional: true,
																			Description: `The interpolation type to be applied to connect the control points
listed below.
Possible values:
LINEAR`,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The tool description.`,
						},
						"engine_source": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Configuration for searching within an Engine, potentially targeting
specific DataStores.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"engine": {
										Type:     schema.TypeString,
										Required: true,
										Description: `Full resource name of the Engine.
Format:
'projects/{project}/locations/{location}/collections/{collection}/engines/{engine}'`,
									},
									"data_store_sources": {
										Type:     schema.TypeList,
										Optional: true,
										Description: `Use to target specific DataStores within the Engine.
If empty, the search applies to all DataStores associated with the
Engine.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"data_store": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `A DataStore resource in Vertex AI Search.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"name": {
																Type:     schema.TypeString,
																Required: true,
																Description: `Full resource name of the DataStore.
Format:
'projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}'`,
															},
															"connector_config": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `The connector config for the data store connection.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"collection": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `Resource name of the collection the data store belongs to.`,
																		},
																		"collection_display_name": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `Display name of the collection the data store belongs to.`,
																		},
																		"data_source": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The name of the data source.
Example: 'salesforce', 'jira', 'confluence', 'bigquery'.`,
																		},
																	},
																},
															},
															"create_time": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Timestamp when the data store was created.`,
															},
															"display_name": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The display name of the data store.`,
															},
															"document_processing_mode": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The document processing mode for the data store connection.
Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
Possible values:
DOCUMENTS
CHUNKS`,
															},
															"type": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The type of the data store. This field is readonly and populated by the
server.
Possible values:
PUBLIC_WEB
UNSTRUCTURED
FAQ
CONNECTOR`,
															},
														},
													},
												},
												"filter": {
													Type:     schema.TypeString,
													Optional: true,
													Description: `Filter specification for the DataStore.
See:
https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata`,
												},
											},
										},
									},
									"filter": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `A filter applied to the search across the Engine. Not relevant and not
used if 'data_store_sources' is provided.
See:
https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata`,
									},
								},
							},
						},
						"max_results": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `Number of search results to return per query.
The default value is 10. The maximum allowed value is 10.`,
						},
						"modality_configs": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The modality configs for the data store.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"modality_type": {
										Type:     schema.TypeString,
										Required: true,
										Description: `The modality type.
Possible values:
TEXT
AUDIO`,
									},
									"grounding_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Grounding configuration.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"disabled": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: `Whether grounding is disabled.`,
												},
												"grounding_level": {
													Type:     schema.TypeFloat,
													Optional: true,
													Description: `The groundedness threshold of the answer based on the retrieved sources.
The value has a configurable range of [1, 5]. The level is used to
threshold the groundedness of the answer, meaning that all responses with
a groundedness score below the threshold will fall back to returning
relevant snippets only.
For example, a level of 3 means that the groundedness score must be
3 or higher for the response to be returned.`,
												},
											},
										},
									},
									"rewriter_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Rewriter configuration.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"model_settings": {
													Type:        schema.TypeList,
													Required:    true,
													Description: `Model settings contains various configurations for the LLM model.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"model": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
															},
															"temperature": {
																Type:     schema.TypeFloat,
																Optional: true,
																Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
															},
														},
													},
												},
												"disabled": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: `Whether the rewriter is disabled.`,
												},
												"prompt": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The prompt definition. If not set, default prompt will be used.`,
												},
											},
										},
									},
									"summarization_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Summarization configuration.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"disabled": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: `Whether summarization is disabled.`,
												},
												"model_settings": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Model settings contains various configurations for the LLM model.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"model": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
															},
															"temperature": {
																Type:     schema.TypeFloat,
																Optional: true,
																Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
															},
														},
													},
												},
												"prompt": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The prompt definition. If not set, default prompt will be used.`,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"execution_type": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Possible values:
SYNCHRONOUS
ASYNCHRONOUS`,
			},
			"google_search_tool": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Represents a tool to perform Google web searches for grounding.
See
https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/grounding-with-google-search.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The name of the tool.`,
						},
						"context_urls": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Content will be fetched directly from these URLs for context and grounding.
More details: https://cloud.google.com/vertex-ai/generative-ai/docs/url-context.
Example: "https://example.com/path.html". A maximum of 20 URLs are allowed.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Description of the tool's purpose.`,
						},
						"exclude_domains": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `List of domains to be excluded from the search results.
Example: "example.com".
A maximum of 2000 domains can be excluded.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"preferred_domains": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Specifies domain names to guide the search.
The model will be instructed to prioritize these domains
when formulating queries for google search.
This is a best-effort hint and these domains may or may
not be exclusively reflected in the final search results.
Example: "example.com", "another.site".
A maximum of 20 domains can be specified.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},
			"python_function": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `A Python function tool.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The name of the Python function to execute. Must match a Python function
name defined in the python code. Case sensitive. If the name is not
provided, the first function defined in the python code will be used.`,
						},
						"python_code": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The Python code to execute for the tool.`,
						},
						"description": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The description of the Python function, parsed from the python code's
docstring.`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp when the tool was created.`,
			},
			"display_name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The display name of the tool, derived based on the tool's type. For
example, display name of a ClientFunction is derived
from its 'name' property.`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Etag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
			},
			"generated_summary": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `If the tool is generated by the LLM assistant, this field contains a
descriptive summary of the generation.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The unique identifier of the tool.
Format:
'projects/{project}/locations/{location}/apps/{app}/tools/{tool}'`,
			},
			"open_api_tool": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `A remote API tool defined by an OpenAPI schema.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"api_authentication": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Authentication information required for API calls.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"api_key_config": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Configurations for authentication with API key.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"api_key_secret_version": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The name of the SecretManager secret version resource storing the API key.
Format: 'projects/{project}/secrets/{secret}/versions/{version}'
Note: You should grant 'roles/secretmanager.secretAccessor' role to the CES
service agent
'service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com'.`,
												},
												"key_name": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The parameter name or the header name of the API key.
E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.`,
												},
												"request_location": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `Key location in the request.
Possible values:
HEADER
QUERY_STRING`,
												},
											},
										},
									},
									"bearer_token_config": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Configurations for authentication with a bearer token.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"token": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The bearer token. Must be in the format $context.variables.<name_of_variable>.`,
												},
											},
										},
									},
									"oauth_config": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Configurations for authentication with OAuth.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"client_id": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The client ID from the OAuth provider.`,
												},
												"client_secret_version": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The name of the SecretManager secret version resource storing the
client secret.
Format: 'projects/{project}/secrets/{secret}/versions/{version}'
Note: You should grant 'roles/secretmanager.secretAccessor' role to the CES
service agent
'service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com'.`,
												},
												"oauth_grant_type": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `OAuth grant types.
Possible values:
CLIENT_CREDENTIAL`,
												},
												"scopes": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `The OAuth scopes to grant.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"token_endpoint": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The token endpoint in the OAuth provider to exchange for an access token.`,
												},
											},
										},
									},
									"service_account_auth_config": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Configurations for authentication using a custom service account.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"service_account": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The email address of the service account used for authenticatation. CES
uses this service account to exchange an access token and the access token
is then sent in the 'Authorization' header of the request.
The service account must have the
'roles/iam.serviceAccountTokenCreator' role granted to the
CES service agent
'service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com'.`,
												},
											},
										},
									},
									"service_agent_id_token_auth_config": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Configurations for authentication with [ID
token](https://cloud.google.com/docs/authentication/token-types#id) generated
from service agent.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},
								},
							},
						},
						"description": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The description of the tool. If not provided, the description of the tool
will be derived from the OpenAPI schema, from 'operation.description' or
'operation.summary'.`,
						},
						"ignore_unknown_fields": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `If true, the agent will ignore unknown fields in the API response.`,
						},
						"name": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The name of the tool. If not provided, the name of the tool will be
derived from the OpenAPI schema, from 'operation.operationId'.`,
						},
						"open_api_schema": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The OpenAPI schema in JSON or YAML format.`,
						},
						"service_directory_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Configuration for tools using Service Directory.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"service": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The name of [Service
Directory](https://cloud.google.com/service-directory) service.
Format:
'projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}'.
Location of the service directory must be the same as the location of the
app.`,
									},
								},
							},
						},
						"tls_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The TLS configuration.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ca_certs": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Specifies a list of allowed custom CA certificates for HTTPS
verification.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"cert": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The allowed custom CA certificates (in DER format) for
HTTPS verification. This overrides the default SSL trust store. If this
is empty or unspecified, CES will use Google's default trust
store to verify certificates. N.B. Make sure the HTTPS server
certificates are signed with "subject alt name". For instance a
certificate can be self-signed using the following command,
openssl x509 -req -days 200 -in example.com.csr \
-signkey example.com.key \
-out example.com.crt \
-extfile <(printf "\nsubjectAltName='DNS:www.example.com'")

A base64-encoded string.`,
												},
												"display_name": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The name of the allowed custom CA certificates. This
can be used to disambiguate the custom CA certificates.`,
												},
											},
										},
									},
								},
							},
						},
						"url": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The server URL of the Open API schema. This field is only set in tools in the
environment dependencies during the export process if the schema contains a
server url. During the import process, if this url is present in the environment
dependencies and the schema has the $env_var placeholder, it will replace the
placeholder in the schema.`,
						},
					},
				},
			},
			"system_tool": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The system tool.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"description": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The description of the system tool.`,
						},
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The name of the system tool.`,
						},
					},
				},
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp when the tool was last updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCESToolCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	clientFunctionProp, err := expandCESToolClientFunction(d.Get("client_function"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client_function"); !tpgresource.IsEmptyValue(reflect.ValueOf(clientFunctionProp)) && (ok || !reflect.DeepEqual(v, clientFunctionProp)) {
		obj["clientFunction"] = clientFunctionProp
	}
	dataStoreToolProp, err := expandCESToolDataStoreTool(d.Get("data_store_tool"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_store_tool"); !tpgresource.IsEmptyValue(reflect.ValueOf(dataStoreToolProp)) && (ok || !reflect.DeepEqual(v, dataStoreToolProp)) {
		obj["dataStoreTool"] = dataStoreToolProp
	}
	executionTypeProp, err := expandCESToolExecutionType(d.Get("execution_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("execution_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(executionTypeProp)) && (ok || !reflect.DeepEqual(v, executionTypeProp)) {
		obj["executionType"] = executionTypeProp
	}
	googleSearchToolProp, err := expandCESToolGoogleSearchTool(d.Get("google_search_tool"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("google_search_tool"); !tpgresource.IsEmptyValue(reflect.ValueOf(googleSearchToolProp)) && (ok || !reflect.DeepEqual(v, googleSearchToolProp)) {
		obj["googleSearchTool"] = googleSearchToolProp
	}
	pythonFunctionProp, err := expandCESToolPythonFunction(d.Get("python_function"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("python_function"); !tpgresource.IsEmptyValue(reflect.ValueOf(pythonFunctionProp)) && (ok || !reflect.DeepEqual(v, pythonFunctionProp)) {
		obj["pythonFunction"] = pythonFunctionProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/tools?toolId={{tool_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Tool: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Tool: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Tool: %s", err)
	}
	// Set computed resource properties from create API response so that they're available on the subsequent Read
	// call.
	err = resourceCESToolPostCreateSetComputedFields(d, meta, res)
	if err != nil {
		return fmt.Errorf("setting computed ID format fields: %w", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{app}}/tools/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Tool %q: %#v", d.Id(), res)

	return resourceCESToolRead(d, meta)
}

func resourceCESToolRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/tools/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Tool: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("CESTool %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}

	if err := d.Set("client_function", flattenCESToolClientFunction(res["clientFunction"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("create_time", flattenCESToolCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("data_store_tool", flattenCESToolDataStoreTool(res["dataStoreTool"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("display_name", flattenCESToolDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("etag", flattenCESToolEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("execution_type", flattenCESToolExecutionType(res["executionType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("generated_summary", flattenCESToolGeneratedSummary(res["generatedSummary"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("google_search_tool", flattenCESToolGoogleSearchTool(res["googleSearchTool"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("name", flattenCESToolName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("open_api_tool", flattenCESToolOpenApiTool(res["openApiTool"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("python_function", flattenCESToolPythonFunction(res["pythonFunction"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("update_time", flattenCESToolUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}
	if err := d.Set("system_tool", flattenCESToolSystemTool(res["systemTool"], d, config)); err != nil {
		return fmt.Errorf("Error reading Tool: %s", err)
	}

	identity, err := d.Identity()
	if err != nil && identity != nil {
		if v, ok := identity.GetOk("name"); ok && v != "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("location"); ok && v != "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("app"); ok && v != "" {
			err = identity.Set("app", d.Get("app").(string))
			if err != nil {
				return fmt.Errorf("Error setting app: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); ok && v != "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] identity not set: %s", err)
	}
	return nil
}

func resourceCESToolUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Tool: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	clientFunctionProp, err := expandCESToolClientFunction(d.Get("client_function"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client_function"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, clientFunctionProp)) {
		obj["clientFunction"] = clientFunctionProp
	}
	dataStoreToolProp, err := expandCESToolDataStoreTool(d.Get("data_store_tool"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("data_store_tool"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, dataStoreToolProp)) {
		obj["dataStoreTool"] = dataStoreToolProp
	}
	executionTypeProp, err := expandCESToolExecutionType(d.Get("execution_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("execution_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, executionTypeProp)) {
		obj["executionType"] = executionTypeProp
	}
	googleSearchToolProp, err := expandCESToolGoogleSearchTool(d.Get("google_search_tool"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("google_search_tool"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, googleSearchToolProp)) {
		obj["googleSearchTool"] = googleSearchToolProp
	}
	pythonFunctionProp, err := expandCESToolPythonFunction(d.Get("python_function"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("python_function"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, pythonFunctionProp)) {
		obj["pythonFunction"] = pythonFunctionProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/tools/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Tool %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("client_function") {
		updateMask = append(updateMask, "clientFunction")
	}

	if d.HasChange("data_store_tool") {
		updateMask = append(updateMask, "dataStoreTool")
	}

	if d.HasChange("execution_type") {
		updateMask = append(updateMask, "executionType")
	}

	if d.HasChange("google_search_tool") {
		updateMask = append(updateMask, "googleSearchTool")
	}

	if d.HasChange("python_function") {
		updateMask = append(updateMask, "pythonFunction")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Tool %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Tool %q: %#v", d.Id(), res)
		}

	}

	return resourceCESToolRead(d, meta)
}

func resourceCESToolDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Tool: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/tools/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Tool %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Tool")
	}

	log.Printf("[DEBUG] Finished deleting Tool %q: %#v", d.Id(), res)
	return nil
}

func resourceCESToolImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/apps/(?P<app>[^/]+)/tools/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<app>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<app>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{app}}/tools/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCESToolClientFunction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESToolClientFunctionDescription(original["description"], d, config)
	transformed["name"] =
		flattenCESToolClientFunctionName(original["name"], d, config)
	transformed["parameters"] =
		flattenCESToolClientFunctionParameters(original["parameters"], d, config)
	transformed["response"] =
		flattenCESToolClientFunctionResponse(original["response"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolClientFunctionDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionParameters(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["additional_properties"] =
		flattenCESToolClientFunctionParametersAdditionalProperties(original["additionalProperties"], d, config)
	transformed["any_of"] =
		flattenCESToolClientFunctionParametersAnyOf(original["anyOf"], d, config)
	transformed["default"] =
		flattenCESToolClientFunctionParametersDefault(original["default"], d, config)
	transformed["defs"] =
		flattenCESToolClientFunctionParametersDefs(original["defs"], d, config)
	transformed["description"] =
		flattenCESToolClientFunctionParametersDescription(original["description"], d, config)
	transformed["enum"] =
		flattenCESToolClientFunctionParametersEnum(original["enum"], d, config)
	transformed["items"] =
		flattenCESToolClientFunctionParametersItems(original["items"], d, config)
	transformed["max_items"] =
		flattenCESToolClientFunctionParametersMaxItems(original["maxItems"], d, config)
	transformed["maximum"] =
		flattenCESToolClientFunctionParametersMaximum(original["maximum"], d, config)
	transformed["min_items"] =
		flattenCESToolClientFunctionParametersMinItems(original["minItems"], d, config)
	transformed["minimum"] =
		flattenCESToolClientFunctionParametersMinimum(original["minimum"], d, config)
	transformed["nullable"] =
		flattenCESToolClientFunctionParametersNullable(original["nullable"], d, config)
	transformed["prefix_items"] =
		flattenCESToolClientFunctionParametersPrefixItems(original["prefixItems"], d, config)
	transformed["properties"] =
		flattenCESToolClientFunctionParametersProperties(original["properties"], d, config)
	transformed["ref"] =
		flattenCESToolClientFunctionParametersRef(original["ref"], d, config)
	transformed["required"] =
		flattenCESToolClientFunctionParametersRequired(original["required"], d, config)
	transformed["title"] =
		flattenCESToolClientFunctionParametersTitle(original["title"], d, config)
	transformed["type"] =
		flattenCESToolClientFunctionParametersType(original["type"], d, config)
	transformed["unique_items"] =
		flattenCESToolClientFunctionParametersUniqueItems(original["uniqueItems"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolClientFunctionParametersAdditionalProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionParametersAnyOf(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionParametersDefault(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionParametersDefs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionParametersDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionParametersEnum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionParametersItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionParametersMaxItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESToolClientFunctionParametersMaximum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionParametersMinItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESToolClientFunctionParametersMinimum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionParametersNullable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionParametersPrefixItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionParametersProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionParametersRef(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionParametersRequired(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionParametersTitle(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionParametersType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionParametersUniqueItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionResponse(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["additional_properties"] =
		flattenCESToolClientFunctionResponseAdditionalProperties(original["additionalProperties"], d, config)
	transformed["any_of"] =
		flattenCESToolClientFunctionResponseAnyOf(original["anyOf"], d, config)
	transformed["default"] =
		flattenCESToolClientFunctionResponseDefault(original["default"], d, config)
	transformed["defs"] =
		flattenCESToolClientFunctionResponseDefs(original["defs"], d, config)
	transformed["description"] =
		flattenCESToolClientFunctionResponseDescription(original["description"], d, config)
	transformed["enum"] =
		flattenCESToolClientFunctionResponseEnum(original["enum"], d, config)
	transformed["items"] =
		flattenCESToolClientFunctionResponseItems(original["items"], d, config)
	transformed["max_items"] =
		flattenCESToolClientFunctionResponseMaxItems(original["maxItems"], d, config)
	transformed["maximum"] =
		flattenCESToolClientFunctionResponseMaximum(original["maximum"], d, config)
	transformed["min_items"] =
		flattenCESToolClientFunctionResponseMinItems(original["minItems"], d, config)
	transformed["minimum"] =
		flattenCESToolClientFunctionResponseMinimum(original["minimum"], d, config)
	transformed["nullable"] =
		flattenCESToolClientFunctionResponseNullable(original["nullable"], d, config)
	transformed["prefix_items"] =
		flattenCESToolClientFunctionResponsePrefixItems(original["prefixItems"], d, config)
	transformed["properties"] =
		flattenCESToolClientFunctionResponseProperties(original["properties"], d, config)
	transformed["ref"] =
		flattenCESToolClientFunctionResponseRef(original["ref"], d, config)
	transformed["required"] =
		flattenCESToolClientFunctionResponseRequired(original["required"], d, config)
	transformed["title"] =
		flattenCESToolClientFunctionResponseTitle(original["title"], d, config)
	transformed["type"] =
		flattenCESToolClientFunctionResponseType(original["type"], d, config)
	transformed["unique_items"] =
		flattenCESToolClientFunctionResponseUniqueItems(original["uniqueItems"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolClientFunctionResponseAdditionalProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionResponseAnyOf(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionResponseDefault(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionResponseDefs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionResponseDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionResponseEnum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionResponseItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionResponseMaxItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESToolClientFunctionResponseMaximum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionResponseMinItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESToolClientFunctionResponseMinimum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionResponseNullable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionResponsePrefixItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionResponseProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESToolClientFunctionResponseRef(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionResponseRequired(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionResponseTitle(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionResponseType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolClientFunctionResponseUniqueItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["boost_specs"] =
		flattenCESToolDataStoreToolBoostSpecs(original["boostSpecs"], d, config)
	transformed["description"] =
		flattenCESToolDataStoreToolDescription(original["description"], d, config)
	transformed["engine_source"] =
		flattenCESToolDataStoreToolEngineSource(original["engineSource"], d, config)
	transformed["max_results"] =
		flattenCESToolDataStoreToolMaxResults(original["maxResults"], d, config)
	transformed["modality_configs"] =
		flattenCESToolDataStoreToolModalityConfigs(original["modalityConfigs"], d, config)
	transformed["name"] =
		flattenCESToolDataStoreToolName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolDataStoreToolBoostSpecs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"data_stores": flattenCESToolDataStoreToolBoostSpecsDataStores(original["dataStores"], d, config),
			"spec":        flattenCESToolDataStoreToolBoostSpecsSpec(original["spec"], d, config),
		})
	}
	return transformed
}
func flattenCESToolDataStoreToolBoostSpecsDataStores(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolBoostSpecsSpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"condition_boost_specs": flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecs(original["conditionBoostSpecs"], d, config),
		})
	}
	return transformed
}
func flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"boost":              flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoost(original["boost"], d, config),
			"boost_control_spec": flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpec(original["boostControlSpec"], d, config),
			"condition":          flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsCondition(original["condition"], d, config),
		})
	}
	return transformed
}
func flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoost(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["attribute_type"] =
		flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecAttributeType(original["attributeType"], d, config)
	transformed["control_points"] =
		flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPoints(original["controlPoints"], d, config)
	transformed["field_name"] =
		flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecFieldName(original["fieldName"], d, config)
	transformed["interpolation_type"] =
		flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecInterpolationType(original["interpolationType"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecAttributeType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"attribute_value": flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsAttributeValue(original["attributeValue"], d, config),
			"boost_amount":    flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsBoostAmount(original["boostAmount"], d, config),
		})
	}
	return transformed
}
func flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsAttributeValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsBoostAmount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecFieldName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecInterpolationType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsCondition(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolEngineSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["data_store_sources"] =
		flattenCESToolDataStoreToolEngineSourceDataStoreSources(original["dataStoreSources"], d, config)
	transformed["engine"] =
		flattenCESToolDataStoreToolEngineSourceEngine(original["engine"], d, config)
	transformed["filter"] =
		flattenCESToolDataStoreToolEngineSourceFilter(original["filter"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolDataStoreToolEngineSourceDataStoreSources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"data_store": flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStore(original["dataStore"], d, config),
			"filter":     flattenCESToolDataStoreToolEngineSourceDataStoreSourcesFilter(original["filter"], d, config),
		})
	}
	return transformed
}
func flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStore(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["connector_config"] =
		flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfig(original["connectorConfig"], d, config)
	transformed["create_time"] =
		flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreCreateTime(original["createTime"], d, config)
	transformed["display_name"] =
		flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreDisplayName(original["displayName"], d, config)
	transformed["document_processing_mode"] =
		flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreDocumentProcessingMode(original["documentProcessingMode"], d, config)
	transformed["name"] =
		flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreName(original["name"], d, config)
	transformed["type"] =
		flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreType(original["type"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["collection"] =
		flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollection(original["collection"], d, config)
	transformed["collection_display_name"] =
		flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollectionDisplayName(original["collectionDisplayName"], d, config)
	transformed["data_source"] =
		flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigDataSource(original["dataSource"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollection(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollectionDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigDataSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreDocumentProcessingMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolEngineSourceDataStoreSourcesFilter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolEngineSourceEngine(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolEngineSourceFilter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolMaxResults(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESToolDataStoreToolModalityConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"grounding_config":     flattenCESToolDataStoreToolModalityConfigsGroundingConfig(original["groundingConfig"], d, config),
			"modality_type":        flattenCESToolDataStoreToolModalityConfigsModalityType(original["modalityType"], d, config),
			"rewriter_config":      flattenCESToolDataStoreToolModalityConfigsRewriterConfig(original["rewriterConfig"], d, config),
			"summarization_config": flattenCESToolDataStoreToolModalityConfigsSummarizationConfig(original["summarizationConfig"], d, config),
		})
	}
	return transformed
}
func flattenCESToolDataStoreToolModalityConfigsGroundingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disabled"] =
		flattenCESToolDataStoreToolModalityConfigsGroundingConfigDisabled(original["disabled"], d, config)
	transformed["grounding_level"] =
		flattenCESToolDataStoreToolModalityConfigsGroundingConfigGroundingLevel(original["groundingLevel"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolDataStoreToolModalityConfigsGroundingConfigDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolModalityConfigsGroundingConfigGroundingLevel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolModalityConfigsModalityType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolModalityConfigsRewriterConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disabled"] =
		flattenCESToolDataStoreToolModalityConfigsRewriterConfigDisabled(original["disabled"], d, config)
	transformed["model_settings"] =
		flattenCESToolDataStoreToolModalityConfigsRewriterConfigModelSettings(original["modelSettings"], d, config)
	transformed["prompt"] =
		flattenCESToolDataStoreToolModalityConfigsRewriterConfigPrompt(original["prompt"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolDataStoreToolModalityConfigsRewriterConfigDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolModalityConfigsRewriterConfigModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESToolDataStoreToolModalityConfigsRewriterConfigModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESToolDataStoreToolModalityConfigsRewriterConfigModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolDataStoreToolModalityConfigsRewriterConfigModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolModalityConfigsRewriterConfigModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolModalityConfigsRewriterConfigPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolModalityConfigsSummarizationConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disabled"] =
		flattenCESToolDataStoreToolModalityConfigsSummarizationConfigDisabled(original["disabled"], d, config)
	transformed["model_settings"] =
		flattenCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettings(original["modelSettings"], d, config)
	transformed["prompt"] =
		flattenCESToolDataStoreToolModalityConfigsSummarizationConfigPrompt(original["prompt"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolDataStoreToolModalityConfigsSummarizationConfigDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolModalityConfigsSummarizationConfigPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDataStoreToolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolExecutionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolGeneratedSummary(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolGoogleSearchTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["context_urls"] =
		flattenCESToolGoogleSearchToolContextUrls(original["contextUrls"], d, config)
	transformed["description"] =
		flattenCESToolGoogleSearchToolDescription(original["description"], d, config)
	transformed["exclude_domains"] =
		flattenCESToolGoogleSearchToolExcludeDomains(original["excludeDomains"], d, config)
	transformed["name"] =
		flattenCESToolGoogleSearchToolName(original["name"], d, config)
	transformed["preferred_domains"] =
		flattenCESToolGoogleSearchToolPreferredDomains(original["preferredDomains"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolGoogleSearchToolContextUrls(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolGoogleSearchToolDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolGoogleSearchToolExcludeDomains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolGoogleSearchToolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolGoogleSearchToolPreferredDomains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenCESToolOpenApiTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_authentication"] =
		flattenCESToolOpenApiToolApiAuthentication(original["apiAuthentication"], d, config)
	transformed["description"] =
		flattenCESToolOpenApiToolDescription(original["description"], d, config)
	transformed["ignore_unknown_fields"] =
		flattenCESToolOpenApiToolIgnoreUnknownFields(original["ignoreUnknownFields"], d, config)
	transformed["name"] =
		flattenCESToolOpenApiToolName(original["name"], d, config)
	transformed["open_api_schema"] =
		flattenCESToolOpenApiToolOpenApiSchema(original["openApiSchema"], d, config)
	transformed["service_directory_config"] =
		flattenCESToolOpenApiToolServiceDirectoryConfig(original["serviceDirectoryConfig"], d, config)
	transformed["tls_config"] =
		flattenCESToolOpenApiToolTlsConfig(original["tlsConfig"], d, config)
	transformed["url"] =
		flattenCESToolOpenApiToolUrl(original["url"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolOpenApiToolApiAuthentication(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_key_config"] =
		flattenCESToolOpenApiToolApiAuthenticationApiKeyConfig(original["apiKeyConfig"], d, config)
	transformed["bearer_token_config"] =
		flattenCESToolOpenApiToolApiAuthenticationBearerTokenConfig(original["bearerTokenConfig"], d, config)
	transformed["oauth_config"] =
		flattenCESToolOpenApiToolApiAuthenticationOauthConfig(original["oauthConfig"], d, config)
	transformed["service_account_auth_config"] =
		flattenCESToolOpenApiToolApiAuthenticationServiceAccountAuthConfig(original["serviceAccountAuthConfig"], d, config)
	transformed["service_agent_id_token_auth_config"] =
		flattenCESToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig(original["serviceAgentIdTokenAuthConfig"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolOpenApiToolApiAuthenticationApiKeyConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_key_secret_version"] =
		flattenCESToolOpenApiToolApiAuthenticationApiKeyConfigApiKeySecretVersion(original["apiKeySecretVersion"], d, config)
	transformed["key_name"] =
		flattenCESToolOpenApiToolApiAuthenticationApiKeyConfigKeyName(original["keyName"], d, config)
	transformed["request_location"] =
		flattenCESToolOpenApiToolApiAuthenticationApiKeyConfigRequestLocation(original["requestLocation"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolOpenApiToolApiAuthenticationApiKeyConfigApiKeySecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolApiAuthenticationApiKeyConfigKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolApiAuthenticationApiKeyConfigRequestLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolApiAuthenticationBearerTokenConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["token"] =
		flattenCESToolOpenApiToolApiAuthenticationBearerTokenConfigToken(original["token"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolOpenApiToolApiAuthenticationBearerTokenConfigToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolApiAuthenticationOauthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["client_id"] =
		flattenCESToolOpenApiToolApiAuthenticationOauthConfigClientId(original["clientId"], d, config)
	transformed["client_secret_version"] =
		flattenCESToolOpenApiToolApiAuthenticationOauthConfigClientSecretVersion(original["clientSecretVersion"], d, config)
	transformed["oauth_grant_type"] =
		flattenCESToolOpenApiToolApiAuthenticationOauthConfigOauthGrantType(original["oauthGrantType"], d, config)
	transformed["scopes"] =
		flattenCESToolOpenApiToolApiAuthenticationOauthConfigScopes(original["scopes"], d, config)
	transformed["token_endpoint"] =
		flattenCESToolOpenApiToolApiAuthenticationOauthConfigTokenEndpoint(original["tokenEndpoint"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolOpenApiToolApiAuthenticationOauthConfigClientId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolApiAuthenticationOauthConfigClientSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolApiAuthenticationOauthConfigOauthGrantType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolApiAuthenticationOauthConfigScopes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolApiAuthenticationOauthConfigTokenEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolApiAuthenticationServiceAccountAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_account"] =
		flattenCESToolOpenApiToolApiAuthenticationServiceAccountAuthConfigServiceAccount(original["serviceAccount"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolOpenApiToolApiAuthenticationServiceAccountAuthConfigServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenCESToolOpenApiToolDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolIgnoreUnknownFields(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolOpenApiSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolServiceDirectoryConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service"] =
		flattenCESToolOpenApiToolServiceDirectoryConfigService(original["service"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolOpenApiToolServiceDirectoryConfigService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolTlsConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ca_certs"] =
		flattenCESToolOpenApiToolTlsConfigCaCerts(original["caCerts"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolOpenApiToolTlsConfigCaCerts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"cert":         flattenCESToolOpenApiToolTlsConfigCaCertsCert(original["cert"], d, config),
			"display_name": flattenCESToolOpenApiToolTlsConfigCaCertsDisplayName(original["displayName"], d, config),
		})
	}
	return transformed
}
func flattenCESToolOpenApiToolTlsConfigCaCertsCert(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolTlsConfigCaCertsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolOpenApiToolUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolPythonFunction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESToolPythonFunctionDescription(original["description"], d, config)
	transformed["name"] =
		flattenCESToolPythonFunctionName(original["name"], d, config)
	transformed["python_code"] =
		flattenCESToolPythonFunctionPythonCode(original["pythonCode"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolPythonFunctionDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolPythonFunctionName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolPythonFunctionPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolSystemTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESToolSystemToolDescription(original["description"], d, config)
	transformed["name"] =
		flattenCESToolSystemToolName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenCESToolSystemToolDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESToolSystemToolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandCESToolClientFunction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDescription, err := expandCESToolClientFunctionDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedName, err := expandCESToolClientFunctionName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedParameters, err := expandCESToolClientFunctionParameters(original["parameters"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedParameters); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["parameters"] = transformedParameters
	}

	transformedResponse, err := expandCESToolClientFunctionResponse(original["response"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResponse); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["response"] = transformedResponse
	}

	return transformed, nil
}

func expandCESToolClientFunctionDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParameters(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAdditionalProperties, err := expandCESToolClientFunctionParametersAdditionalProperties(original["additional_properties"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdditionalProperties); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["additionalProperties"] = transformedAdditionalProperties
	}

	transformedAnyOf, err := expandCESToolClientFunctionParametersAnyOf(original["any_of"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAnyOf); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["anyOf"] = transformedAnyOf
	}

	transformedDefault, err := expandCESToolClientFunctionParametersDefault(original["default"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefault); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["default"] = transformedDefault
	}

	transformedDefs, err := expandCESToolClientFunctionParametersDefs(original["defs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["defs"] = transformedDefs
	}

	transformedDescription, err := expandCESToolClientFunctionParametersDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedEnum, err := expandCESToolClientFunctionParametersEnum(original["enum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enum"] = transformedEnum
	}

	transformedItems, err := expandCESToolClientFunctionParametersItems(original["items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["items"] = transformedItems
	}

	transformedMaxItems, err := expandCESToolClientFunctionParametersMaxItems(original["max_items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxItems"] = transformedMaxItems
	}

	transformedMaximum, err := expandCESToolClientFunctionParametersMaximum(original["maximum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaximum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maximum"] = transformedMaximum
	}

	transformedMinItems, err := expandCESToolClientFunctionParametersMinItems(original["min_items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minItems"] = transformedMinItems
	}

	transformedMinimum, err := expandCESToolClientFunctionParametersMinimum(original["minimum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinimum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minimum"] = transformedMinimum
	}

	transformedNullable, err := expandCESToolClientFunctionParametersNullable(original["nullable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNullable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nullable"] = transformedNullable
	}

	transformedPrefixItems, err := expandCESToolClientFunctionParametersPrefixItems(original["prefix_items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrefixItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prefixItems"] = transformedPrefixItems
	}

	transformedProperties, err := expandCESToolClientFunctionParametersProperties(original["properties"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProperties); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["properties"] = transformedProperties
	}

	transformedRef, err := expandCESToolClientFunctionParametersRef(original["ref"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRef); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ref"] = transformedRef
	}

	transformedRequired, err := expandCESToolClientFunctionParametersRequired(original["required"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRequired); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["required"] = transformedRequired
	}

	transformedTitle, err := expandCESToolClientFunctionParametersTitle(original["title"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTitle); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["title"] = transformedTitle
	}

	transformedType, err := expandCESToolClientFunctionParametersType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedUniqueItems, err := expandCESToolClientFunctionParametersUniqueItems(original["unique_items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUniqueItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uniqueItems"] = transformedUniqueItems
	}

	return transformed, nil
}

func expandCESToolClientFunctionParametersAdditionalProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionParametersAnyOf(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionParametersDefault(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersDefs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionParametersDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersEnum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionParametersMaxItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersMaximum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersMinItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersMinimum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersNullable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersPrefixItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionParametersProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionParametersRef(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersRequired(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersTitle(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionParametersUniqueItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponse(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAdditionalProperties, err := expandCESToolClientFunctionResponseAdditionalProperties(original["additional_properties"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAdditionalProperties); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["additionalProperties"] = transformedAdditionalProperties
	}

	transformedAnyOf, err := expandCESToolClientFunctionResponseAnyOf(original["any_of"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAnyOf); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["anyOf"] = transformedAnyOf
	}

	transformedDefault, err := expandCESToolClientFunctionResponseDefault(original["default"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefault); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["default"] = transformedDefault
	}

	transformedDefs, err := expandCESToolClientFunctionResponseDefs(original["defs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["defs"] = transformedDefs
	}

	transformedDescription, err := expandCESToolClientFunctionResponseDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedEnum, err := expandCESToolClientFunctionResponseEnum(original["enum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enum"] = transformedEnum
	}

	transformedItems, err := expandCESToolClientFunctionResponseItems(original["items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["items"] = transformedItems
	}

	transformedMaxItems, err := expandCESToolClientFunctionResponseMaxItems(original["max_items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxItems"] = transformedMaxItems
	}

	transformedMaximum, err := expandCESToolClientFunctionResponseMaximum(original["maximum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaximum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maximum"] = transformedMaximum
	}

	transformedMinItems, err := expandCESToolClientFunctionResponseMinItems(original["min_items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minItems"] = transformedMinItems
	}

	transformedMinimum, err := expandCESToolClientFunctionResponseMinimum(original["minimum"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinimum); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minimum"] = transformedMinimum
	}

	transformedNullable, err := expandCESToolClientFunctionResponseNullable(original["nullable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNullable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nullable"] = transformedNullable
	}

	transformedPrefixItems, err := expandCESToolClientFunctionResponsePrefixItems(original["prefix_items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrefixItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prefixItems"] = transformedPrefixItems
	}

	transformedProperties, err := expandCESToolClientFunctionResponseProperties(original["properties"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProperties); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["properties"] = transformedProperties
	}

	transformedRef, err := expandCESToolClientFunctionResponseRef(original["ref"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRef); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ref"] = transformedRef
	}

	transformedRequired, err := expandCESToolClientFunctionResponseRequired(original["required"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRequired); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["required"] = transformedRequired
	}

	transformedTitle, err := expandCESToolClientFunctionResponseTitle(original["title"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTitle); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["title"] = transformedTitle
	}

	transformedType, err := expandCESToolClientFunctionResponseType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedUniqueItems, err := expandCESToolClientFunctionResponseUniqueItems(original["unique_items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUniqueItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uniqueItems"] = transformedUniqueItems
	}

	return transformed, nil
}

func expandCESToolClientFunctionResponseAdditionalProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionResponseAnyOf(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionResponseDefault(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponseDefs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionResponseDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponseEnum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponseItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionResponseMaxItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponseMaximum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponseMinItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponseMinimum(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponseNullable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponsePrefixItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionResponseProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	var j interface{}
	if err := json.Unmarshal(b, &j); err != nil {
		return nil, err
	}
	return j, nil
}

func expandCESToolClientFunctionResponseRef(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponseRequired(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponseTitle(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponseType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolClientFunctionResponseUniqueItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreTool(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBoostSpecs, err := expandCESToolDataStoreToolBoostSpecs(original["boost_specs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBoostSpecs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["boostSpecs"] = transformedBoostSpecs
	}

	transformedDescription, err := expandCESToolDataStoreToolDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedEngineSource, err := expandCESToolDataStoreToolEngineSource(original["engine_source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEngineSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["engineSource"] = transformedEngineSource
	}

	transformedMaxResults, err := expandCESToolDataStoreToolMaxResults(original["max_results"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxResults); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxResults"] = transformedMaxResults
	}

	transformedModalityConfigs, err := expandCESToolDataStoreToolModalityConfigs(original["modality_configs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModalityConfigs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["modalityConfigs"] = transformedModalityConfigs
	}

	transformedName, err := expandCESToolDataStoreToolName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	return transformed, nil
}

func expandCESToolDataStoreToolBoostSpecs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDataStores, err := expandCESToolDataStoreToolBoostSpecsDataStores(original["data_stores"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDataStores); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["dataStores"] = transformedDataStores
		}

		transformedSpec, err := expandCESToolDataStoreToolBoostSpecsSpec(original["spec"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSpec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["spec"] = transformedSpec
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESToolDataStoreToolBoostSpecsDataStores(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolBoostSpecsSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedConditionBoostSpecs, err := expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecs(original["condition_boost_specs"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedConditionBoostSpecs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["conditionBoostSpecs"] = transformedConditionBoostSpecs
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedBoost, err := expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoost(original["boost"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedBoost); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["boost"] = transformedBoost
		}

		transformedBoostControlSpec, err := expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpec(original["boost_control_spec"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedBoostControlSpec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["boostControlSpec"] = transformedBoostControlSpec
		}

		transformedCondition, err := expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsCondition(original["condition"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCondition); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["condition"] = transformedCondition
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoost(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAttributeType, err := expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecAttributeType(original["attribute_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAttributeType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["attributeType"] = transformedAttributeType
	}

	transformedControlPoints, err := expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPoints(original["control_points"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedControlPoints); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["controlPoints"] = transformedControlPoints
	}

	transformedFieldName, err := expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecFieldName(original["field_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFieldName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fieldName"] = transformedFieldName
	}

	transformedInterpolationType, err := expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecInterpolationType(original["interpolation_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInterpolationType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["interpolationType"] = transformedInterpolationType
	}

	return transformed, nil
}

func expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecAttributeType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPoints(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAttributeValue, err := expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsAttributeValue(original["attribute_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAttributeValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["attributeValue"] = transformedAttributeValue
		}

		transformedBoostAmount, err := expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsBoostAmount(original["boost_amount"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedBoostAmount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["boostAmount"] = transformedBoostAmount
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsAttributeValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsBoostAmount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecFieldName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecInterpolationType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolBoostSpecsSpecConditionBoostSpecsCondition(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolEngineSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDataStoreSources, err := expandCESToolDataStoreToolEngineSourceDataStoreSources(original["data_store_sources"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataStoreSources); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataStoreSources"] = transformedDataStoreSources
	}

	transformedEngine, err := expandCESToolDataStoreToolEngineSourceEngine(original["engine"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEngine); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["engine"] = transformedEngine
	}

	transformedFilter, err := expandCESToolDataStoreToolEngineSourceFilter(original["filter"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFilter); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["filter"] = transformedFilter
	}

	return transformed, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDataStore, err := expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStore(original["data_store"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDataStore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["dataStore"] = transformedDataStore
		}

		transformedFilter, err := expandCESToolDataStoreToolEngineSourceDataStoreSourcesFilter(original["filter"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFilter); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["filter"] = transformedFilter
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedConnectorConfig, err := expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfig(original["connector_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConnectorConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["connectorConfig"] = transformedConnectorConfig
	}

	transformedCreateTime, err := expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreCreateTime(original["create_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCreateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["createTime"] = transformedCreateTime
	}

	transformedDisplayName, err := expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreDisplayName(original["display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayName"] = transformedDisplayName
	}

	transformedDocumentProcessingMode, err := expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreDocumentProcessingMode(original["document_processing_mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDocumentProcessingMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["documentProcessingMode"] = transformedDocumentProcessingMode
	}

	transformedName, err := expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedType, err := expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	return transformed, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCollection, err := expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollection(original["collection"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCollection); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["collection"] = transformedCollection
	}

	transformedCollectionDisplayName, err := expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollectionDisplayName(original["collection_display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCollectionDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["collectionDisplayName"] = transformedCollectionDisplayName
	}

	transformedDataSource, err := expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigDataSource(original["data_source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataSource"] = transformedDataSource
	}

	return transformed, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollection(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollectionDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigDataSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreCreateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreDocumentProcessingMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSourcesDataStoreType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolEngineSourceDataStoreSourcesFilter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolEngineSourceEngine(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolEngineSourceFilter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolMaxResults(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolModalityConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedGroundingConfig, err := expandCESToolDataStoreToolModalityConfigsGroundingConfig(original["grounding_config"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedGroundingConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["groundingConfig"] = transformedGroundingConfig
		}

		transformedModalityType, err := expandCESToolDataStoreToolModalityConfigsModalityType(original["modality_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedModalityType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["modalityType"] = transformedModalityType
		}

		transformedRewriterConfig, err := expandCESToolDataStoreToolModalityConfigsRewriterConfig(original["rewriter_config"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedRewriterConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["rewriterConfig"] = transformedRewriterConfig
		}

		transformedSummarizationConfig, err := expandCESToolDataStoreToolModalityConfigsSummarizationConfig(original["summarization_config"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSummarizationConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["summarizationConfig"] = transformedSummarizationConfig
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESToolDataStoreToolModalityConfigsGroundingConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDisabled, err := expandCESToolDataStoreToolModalityConfigsGroundingConfigDisabled(original["disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disabled"] = transformedDisabled
	}

	transformedGroundingLevel, err := expandCESToolDataStoreToolModalityConfigsGroundingConfigGroundingLevel(original["grounding_level"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGroundingLevel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["groundingLevel"] = transformedGroundingLevel
	}

	return transformed, nil
}

func expandCESToolDataStoreToolModalityConfigsGroundingConfigDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolModalityConfigsGroundingConfigGroundingLevel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolModalityConfigsModalityType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolModalityConfigsRewriterConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDisabled, err := expandCESToolDataStoreToolModalityConfigsRewriterConfigDisabled(original["disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disabled"] = transformedDisabled
	}

	transformedModelSettings, err := expandCESToolDataStoreToolModalityConfigsRewriterConfigModelSettings(original["model_settings"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModelSettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["modelSettings"] = transformedModelSettings
	}

	transformedPrompt, err := expandCESToolDataStoreToolModalityConfigsRewriterConfigPrompt(original["prompt"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrompt); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prompt"] = transformedPrompt
	}

	return transformed, nil
}

func expandCESToolDataStoreToolModalityConfigsRewriterConfigDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolModalityConfigsRewriterConfigModelSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedModel, err := expandCESToolDataStoreToolModalityConfigsRewriterConfigModelSettingsModel(original["model"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["model"] = transformedModel
	}

	transformedTemperature, err := expandCESToolDataStoreToolModalityConfigsRewriterConfigModelSettingsTemperature(original["temperature"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTemperature); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["temperature"] = transformedTemperature
	}

	return transformed, nil
}

func expandCESToolDataStoreToolModalityConfigsRewriterConfigModelSettingsModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolModalityConfigsRewriterConfigModelSettingsTemperature(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolModalityConfigsRewriterConfigPrompt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolModalityConfigsSummarizationConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDisabled, err := expandCESToolDataStoreToolModalityConfigsSummarizationConfigDisabled(original["disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["disabled"] = transformedDisabled
	}

	transformedModelSettings, err := expandCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettings(original["model_settings"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModelSettings); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["modelSettings"] = transformedModelSettings
	}

	transformedPrompt, err := expandCESToolDataStoreToolModalityConfigsSummarizationConfigPrompt(original["prompt"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrompt); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prompt"] = transformedPrompt
	}

	return transformed, nil
}

func expandCESToolDataStoreToolModalityConfigsSummarizationConfigDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedModel, err := expandCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettingsModel(original["model"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["model"] = transformedModel
	}

	transformedTemperature, err := expandCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettingsTemperature(original["temperature"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTemperature); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["temperature"] = transformedTemperature
	}

	return transformed, nil
}

func expandCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettingsModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolModalityConfigsSummarizationConfigModelSettingsTemperature(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolModalityConfigsSummarizationConfigPrompt(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolDataStoreToolName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolExecutionType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolGoogleSearchTool(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedContextUrls, err := expandCESToolGoogleSearchToolContextUrls(original["context_urls"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContextUrls); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["contextUrls"] = transformedContextUrls
	}

	transformedDescription, err := expandCESToolGoogleSearchToolDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedExcludeDomains, err := expandCESToolGoogleSearchToolExcludeDomains(original["exclude_domains"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExcludeDomains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["excludeDomains"] = transformedExcludeDomains
	}

	transformedName, err := expandCESToolGoogleSearchToolName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedPreferredDomains, err := expandCESToolGoogleSearchToolPreferredDomains(original["preferred_domains"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPreferredDomains); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["preferredDomains"] = transformedPreferredDomains
	}

	return transformed, nil
}

func expandCESToolGoogleSearchToolContextUrls(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolGoogleSearchToolDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolGoogleSearchToolExcludeDomains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolGoogleSearchToolName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolGoogleSearchToolPreferredDomains(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolPythonFunction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDescription, err := expandCESToolPythonFunctionDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedName, err := expandCESToolPythonFunctionName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedPythonCode, err := expandCESToolPythonFunctionPythonCode(original["python_code"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPythonCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pythonCode"] = transformedPythonCode
	}

	return transformed, nil
}

func expandCESToolPythonFunctionDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolPythonFunctionName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESToolPythonFunctionPythonCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceCESToolPostCreateSetComputedFields(d *schema.ResourceData, meta interface{}, res map[string]interface{}) error {
	config := meta.(*transport_tpg.Config)
	if err := d.Set("name", flattenCESToolName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}
	return nil
}
