// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/ces/AppVersion.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package ces

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceCESAppVersion() *schema.Resource {
	return &schema.Resource{
		Create: resourceCESAppVersionCreate,
		Read:   resourceCESAppVersionRead,
		Delete: resourceCESAppVersionDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCESAppVersionImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"app": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"app": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"app_version_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The ID to use for the app version, which will become the final component
of the app version's resource name. If not provided, a unique ID will be
automatically assigned for the app version.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The description of the app version.`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The display name of the app version.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp when the app version was created.`,
			},
			"creator": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Email of the user who created the app version.`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Etag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The unique identifier of the app version.
Format:
'projects/{project}/locations/{location}/apps/{app}/versions/{version}'`,
			},
			"snapshot": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `A snapshot of the app.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"agents": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `List of agents in the app.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"after_agent_callbacks": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `The callbacks to execute after the agent is called.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Human-readable description of the callback.`,
												},
												"disabled": {
													Type:     schema.TypeBool,
													Computed: true,
													Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
												},
												"python_code": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The python code to execute for the callback.`,
												},
											},
										},
									},
									"after_model_callbacks": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `The callbacks to execute after the model is called. If there are multiple
calls to the model, the callback will be executed multiple times.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Human-readable description of the callback.`,
												},
												"disabled": {
													Type:     schema.TypeBool,
													Computed: true,
													Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
												},
												"python_code": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The python code to execute for the callback.`,
												},
											},
										},
									},
									"after_tool_callbacks": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `The callbacks to execute after the tool is invoked. If there are multiple
tool invocations, the callback will be executed multiple times.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Human-readable description of the callback.`,
												},
												"disabled": {
													Type:     schema.TypeBool,
													Computed: true,
													Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
												},
												"python_code": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The python code to execute for the callback.`,
												},
											},
										},
									},
									"before_agent_callbacks": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `The callbacks to execute before the agent is called.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Human-readable description of the callback.`,
												},
												"disabled": {
													Type:     schema.TypeBool,
													Computed: true,
													Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
												},
												"python_code": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The python code to execute for the callback.`,
												},
											},
										},
									},
									"before_model_callbacks": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `The callbacks to execute before the model is called. If there are multiple
calls to the model, the callback will be executed multiple times.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Human-readable description of the callback.`,
												},
												"disabled": {
													Type:     schema.TypeBool,
													Computed: true,
													Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
												},
												"python_code": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The python code to execute for the callback.`,
												},
											},
										},
									},
									"before_tool_callbacks": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `The callbacks to execute before the tool is invoked. If there are multiple
tool invocations, the callback will be executed multiple times.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Human-readable description of the callback.`,
												},
												"disabled": {
													Type:     schema.TypeBool,
													Computed: true,
													Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
												},
												"python_code": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The python code to execute for the callback.`,
												},
											},
										},
									},
									"child_agents": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `List of child agents in the agent tree.
Format: 'projects/{project}/locations/{location}/apps/{app}/agents/{agent}'`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"create_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the agent was created.`,
									},
									"description": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Human-readable description of the agent.`,
									},
									"display_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Display name of the agent.`,
									},
									"etag": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Etag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
									},
									"generated_summary": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `If the agent is generated by the LLM assistant, this field contains a
descriptive summary of the generation.`,
									},
									"guardrails": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `List of guardrails for the agent.
Format:
'projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}'`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"instruction": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Instructions for the LLM model to guide the agent's behavior.`,
									},
									"llm_agent": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Default agent type. The agent uses instructions and callbacks specified in
the agent to perform the task using a large language model.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},
									"model_settings": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Model settings contains various configurations for the LLM model.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"model": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
												},
												"temperature": {
													Type:     schema.TypeFloat,
													Computed: true,
													Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
												},
											},
										},
									},
									"name": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Identifier. The unique identifier of the agent.
Format: 'projects/{project}/locations/{location}/apps/{app}/agents/{agent}'`,
									},
									"remote_dialogflow_agent": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `The agent which will transfer execution to an existing remote
[Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents)
agent flow. The corresponding Dialogflow agent will process subsequent user
queries until the session ends or flow ends and the control is transferred
back to the parent CES agent.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"agent": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The
[Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents
agent resource name.
Format: 'projects/{project}/locations/{location}/agents/{agent}'`,
												},
												"environment_id": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The environment ID of the Dialogflow agent be used for the agent
execution. If not specified, the draft environment will be used.`,
												},
												"flow_id": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The flow ID of the flow in the Dialogflow agent.`,
												},
												"input_variable_mapping": {
													Type:     schema.TypeMap,
													Computed: true,
													Description: `The mapping of the app variables names to the Dialogflow session
parameters names to be sent to the Dialogflow agent as input.`,
													Elem: &schema.Schema{Type: schema.TypeString},
												},
												"output_variable_mapping": {
													Type:     schema.TypeMap,
													Computed: true,
													Description: `The mapping of the Dialogflow session parameters names to the app
variables names to be sent back to the CES agent after the Dialogflow
agent execution ends.`,
													Elem: &schema.Schema{Type: schema.TypeString},
												},
											},
										},
									},
									"tools": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `List of available tools for the agent.
Format: 'projects/{project}/locations/{location}/apps/{app}/tools/{tool}'`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"toolsets": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `List of toolsets for the agent.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"tool_ids": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `The tools IDs to filter the toolset.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"toolset": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The resource name of the toolset.
Format:
'projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}'`,
												},
											},
										},
									},
									"update_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the agent was last updated.`,
									},
								},
							},
						},
						"app": {
							Type:     schema.TypeList,
							Computed: true,
							Description: `In Customer Engagement Suite (CES), an app serves as a top-level container
for a group of agents, including the root agent and its sub-agents, along
with their associated configurations. These agents work together to achieve
specific goals within the app's context.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"audio_processing_config": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Configuration for how the input and output audio should be processed and
delivered.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"ambient_sound_config": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `Configuration for the ambient sound to be played with the synthesized agent
response, to enhance the naturalness of the conversation.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"gcs_uri": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
Storage](https://cloud.google.com/storage).
Note: Please make sure the CES service agent
'service-@gcp-sa-ces.iam.gserviceaccount.com' has
'storage.objects.get' permission to the Cloud Storage object.`,
															},
															"prebuilt_ambient_sound": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Name of the prebuilt ambient sound.
Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
-"office_1" - "office_2" - "office_3"
-"room_1" - "room_2" - "room_3"
-"room_4" - "room_5" - "air_conditioner"`,
															},
															"volume_gain_db": {
																Type:     schema.TypeFloat,
																Computed: true,
																Description: `Volume gain (in dB) of the normal native volume supported by
ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
will play at approximately half the amplitude of the normal native signal
amplitude. A value of +6.0 (dB) will play at approximately twice the
amplitude of the normal native signal amplitude. We strongly recommend not
to exceed +10 (dB) as there's usually no effective increase in loudness for
any value greater than that.`,
															},
														},
													},
												},
												"barge_in_config": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Configuration for how the user barge-in activities should be handled.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"barge_in_awareness": {
																Type:     schema.TypeBool,
																Computed: true,
																Description: `If enabled, the agent will adapt its next response based on the assumption
that the user hasn't heard the full preceding agent message.
This should not be used in scenarios where agent responses are displayed
visually.`,
															},
														},
													},
												},
												"inactivity_timeout": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The duration of user inactivity (no speech or interaction) before the agent
prompts the user for reengagement. If not set, the agent will not prompt
the user for reengagement.`,
												},
												"synthesize_speech_configs": {
													Type:     schema.TypeSet,
													Computed: true,
													Description: `Configuration of how the agent response should be synthesized, mapping from
the language code to SynthesizeSpeechConfig.
If the configuration for the specified language code is not found, the
configuration for the root language code will be used. For example, if the
map contains "en-us" and "en", and the specified language code is "en-gb",
then "en" configuration will be used.
Note: Language code is case-insensitive.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"language_code": {
																Type:     schema.TypeString,
																Required: true,
															},
															"speaking_rate": {
																Type:     schema.TypeFloat,
																Computed: true,
																Description: `The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
half as fast. Values outside of the range [0.25, 2.0] will return an error.`,
															},
															"voice": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The name of the voice. If not set, the service will choose a
voice based on the other parameters such as language_code.
For the list of available voices, please refer to Supported voices and
languages from Cloud Text-to-Speech.`,
															},
														},
													},
												},
											},
										},
									},
									"client_certificate_settings": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The default client certificate settings for the app.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"passphrase": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The passphrase to decrypt the private key.
Should be left unset if the private key is not encrypted.`,
												},
												"private_key": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The name of the SecretManager secret version resource
storing the private key encoded in PEM format.
Format: projects/{project}/secrets/{secret}/versions/{version}`,
												},
												"tls_certificate": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The TLS certificate encoded in PEM format.
This string must include the begin header and end footer lines.`,
												},
											},
										},
									},
									"create_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the app was created.`,
									},
									"data_store_settings": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Data store related settings for the app.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"engines": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `The engines for the app.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"name": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The resource name of the engine.
Format:
'projects/{project}/locations/{location}/collections/{collection}/engines/{engine}'`,
															},
															"type": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The type of the engine.
Possible values:
ENGINE_TYPE_SEARCH
ENGINE_TYPE_CHAT`,
															},
														},
													},
												},
											},
										},
									},
									"default_channel_profile": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `A ChannelProfile configures the agent's behavior for a specific communication
channel, such as web UI or telephony.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"channel_type": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The type of the channel profile.
Possible values:
UNKNOWN
WEB_UI
API
TWILIO
GOOGLE_TELEPHONY_PLATFORM
CONTACT_CENTER_AS_A_SERVICE`,
												},
												"disable_barge_in_control": {
													Type:     schema.TypeBool,
													Computed: true,
													Description: `Whether to disable user barge-in in the conversation.
- true: User interruptions are disabled while the agent is speaking.
- false: The agent retains automatic control over when the user can interrupt.`,
												},
												"disable_dtmf": {
													Type:        schema.TypeBool,
													Computed:    true,
													Description: `Whether to disable DTMF (dual-tone multi-frequency).`,
												},
												"persona_property": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Represents the persona property of a channel.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"persona": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The persona of the channel.
Possible values:
UNKNOWN
CONCISE
CHATTY`,
															},
														},
													},
												},
												"profile_id": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The unique identifier of the channel profile.`,
												},
												"web_widget_config": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Message for configuration for the web widget.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"modality": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The modality of the web widget.
Possible values:
UNKNOWN_MODALITY
CHAT_AND_VOICE
VOICE_ONLY
CHAT_ONLY`,
															},
															"theme": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The theme of the web widget.
Possible values:
UNKNOWN_THEME
LIGHT
DARK`,
															},
															"web_widget_title": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The title of the web widget.`,
															},
														},
													},
												},
											},
										},
									},
									"deployment_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Number of deployments in the app.`,
									},
									"description": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Human-readable description of the app.`,
									},
									"display_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Display name of the app.`,
									},
									"etag": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Etag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
									},
									"evaluation_metrics_thresholds": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Threshold settings for metrics in an Evaluation.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"golden_evaluation_metrics_thresholds": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Settings for golden evaluations.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"expectation_level_metrics_thresholds": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Expectation level metrics thresholds.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"tool_invocation_parameter_correctness_threshold": {
																			Type:     schema.TypeFloat,
																			Computed: true,
																			Description: `The success threshold for individual tool invocation parameter
correctness. Must be a float between 0 and 1. Default is 1.0.`,
																		},
																	},
																},
															},
															"turn_level_metrics_thresholds": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Turn level metrics thresholds.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"overall_tool_invocation_correctness_threshold": {
																			Type:     schema.TypeFloat,
																			Computed: true,
																			Description: `The success threshold for overall tool invocation correctness. Must be
a float between 0 and 1. Default is 1.0.`,
																		},
																		"semantic_similarity_success_threshold": {
																			Type:     schema.TypeInt,
																			Computed: true,
																			Description: `The success threshold for semantic similarity. Must be an integer
between 0 and 4. Default is >= 3.`,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"global_instruction": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Instructions for all the agents in the app.
You can use this instruction to set up a stable identity or personality
across all the agents.`,
									},
									"guardrails": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `List of guardrails for the app.
Format:
'projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}'`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"language_settings": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Language settings of the app.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"default_language_code": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The default language code of the app.`,
												},
												"enable_multilingual_support": {
													Type:     schema.TypeBool,
													Computed: true,
													Description: `Enables multilingual support. If true, agents in the app will use pre-built
instructions to improve handling of multilingual input.`,
												},
												"fallback_action": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The action to perform when an agent receives input in an unsupported
language.
This can be a predefined action or a custom tool call.
Valid values are:
- A tool's full resource name, which triggers a specific tool execution.
- A predefined system action, such as "escalate" or "exit", which triggers
an EndSession signal with corresponding metadata
to terminate the conversation.`,
												},
												"supported_language_codes": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `List of languages codes supported by the app, in addition to the
'default_language_code'.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"logging_settings": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Settings to describe the logging behaviors for the app.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"audio_recording_config": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Configuration for how the audio interactions should be recorded.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"gcs_bucket": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
session audio recordings. The URI must start with "gs://".
Note: If the Cloud Storage bucket is in a different project from the app,
you should grant 'storage.objects.create' permission to the CES service
agent 'service-@gcp-sa-ces.iam.gserviceaccount.com'.`,
															},
															"gcs_path_prefix": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The Cloud Storage path prefix for audio recordings.
This prefix can include the following placeholders, which will be
dynamically substituted at serving time:
- $project:   project ID
- $location:  app location
- $app:       app ID
- $date:      session date in YYYY-MM-DD format
- $session:   session ID
If the path prefix is not specified, the default prefix
'$project/$location/$app/$date/$session/' will be used.`,
															},
														},
													},
												},
												"bigquery_export_settings": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Settings to describe the BigQuery export behaviors for the app.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"dataset": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The BigQuery dataset to export the data to.`,
															},
															"enabled": {
																Type:        schema.TypeBool,
																Computed:    true,
																Description: `Indicates whether the BigQuery export is enabled.`,
															},
															"project": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The project ID of the BigQuery dataset to export the data to.
Note: If the BigQuery dataset is in a different project from the app, you should grant
roles/bigquery.admin role to the CES service agent service-<PROJECT-
NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.`,
															},
														},
													},
												},
												"cloud_logging_settings": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Settings to describe the Cloud Logging behaviors for the app.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"enable_cloud_logging": {
																Type:        schema.TypeBool,
																Computed:    true,
																Description: `Whether to enable Cloud Logging for the sessions.`,
															},
														},
													},
												},
												"conversation_logging_settings": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Settings to describe the conversation logging behaviors for the app.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"disable_conversation_logging": {
																Type:        schema.TypeBool,
																Computed:    true,
																Description: `Whether to disable conversation logging for the sessions.`,
															},
														},
													},
												},
												"redaction_config": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Configuration to instruct how sensitive data should be handled.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"deidentify_template": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `[DLP](https://cloud.google.com/dlp/docs) deidentify template name to
instruct on how to de-identify content.
Format:
'projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}'`,
															},
															"enable_redaction": {
																Type:     schema.TypeBool,
																Computed: true,
																Description: `If true, redaction will be applied in various logging scenarios, including
conversation history, Cloud Logging and audio recording.`,
															},
															"inspect_template": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `[DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
detection of sensitive data types.
Format:
'projects/{project}/locations/{location}/inspectTemplates/{inspect_template}'`,
															},
														},
													},
												},
											},
										},
									},
									"metadata": {
										Type:     schema.TypeMap,
										Computed: true,
										Description: `Metadata about the app. This field can be used to store additional
information relevant to the app's details or intended usages.`,
										Elem: &schema.Schema{Type: schema.TypeString},
									},
									"model_settings": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Model settings contains various configurations for the LLM model.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"model": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
												},
												"temperature": {
													Type:     schema.TypeFloat,
													Computed: true,
													Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
												},
											},
										},
									},
									"name": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Identifier. The unique identifier of the app.
Format: 'projects/{project}/locations/{location}/apps/{app}'`,
									},
									"root_agent": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The root agent is the entry point of the app.
Format: 'projects/{project}/locations/{location}/apps/{app}/agents/{agent}'`,
									},
									"time_zone_settings": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `TimeZone settings of the app.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"time_zone": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.`,
												},
											},
										},
									},
									"update_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the app was last updated.`,
									},
									"variable_declarations": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The declarations of the variables.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The description of the variable.`,
												},
												"name": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The name of the variable. The name must start with a letter or underscore
and contain only letters, numbers, or underscores.`,
												},
												"schema": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Represents a select subset of an OpenAPI 3.0 schema object.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"additional_properties": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Optional. Defines the schema for additional properties allowed in an object.
The value must be a valid JSON string representing the Schema object.
(Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).`,
															},
															"any_of": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Optional. The instance value should be valid against at least one of the schemas in this list.`,
															},
															"default": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Optional. Default value of the data. Represents a dynamically typed value
which can be either null, a number, a string, a boolean, a struct,
or a list of values. The provided default value must be compatible
with the defined 'type' and other schema constraints.`,
															},
															"defs": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `A map of definitions for use by ref. Only allowed at the root of the schema.`,
															},
															"description": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The description of the data.`,
															},
															"enum": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `Possible values of the element of primitive type with enum format.
Examples:
1. We can define direction as :
{type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
2. We can define apartment number as :
{type:INTEGER, format:enum, enum:["101", "201", "301"]}`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"items": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Schema of the elements of Type.ARRAY.`,
															},
															"nullable": {
																Type:        schema.TypeBool,
																Computed:    true,
																Description: `Indicates if the value may be null.`,
															},
															"prefix_items": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Optional. Schemas of initial elements of Type.ARRAY.`,
															},
															"properties": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Properties of Type.OBJECT.`,
															},
															"ref": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Allows indirect references between schema nodes. The value should be a
valid reference to a child of the root 'defs'.
For example, the following schema defines a reference to a schema node
named "Pet":
type: object
properties:
  pet:
    ref: #/defs/Pet
defs:
  Pet:
    type: object
    properties:
      name:
        type: string
The value of the "pet" property is a reference to the schema node
named "Pet".
See details in
https://json-schema.org/understanding-json-schema/structuring.`,
															},
															"required": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Required properties of Type.OBJECT.`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"type": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The type of the data.
Possible values:
STRING
INTEGER
NUMBER
BOOLEAN
OBJECT
ARRAY`,
															},
															"unique_items": {
																Type:        schema.TypeBool,
																Computed:    true,
																Description: `Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.`,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"examples": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `List of examples in the app.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"create_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the example was created.`,
									},
									"description": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Human-readable description of the example.`,
									},
									"display_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Display name of the example.`,
									},
									"entry_agent": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The agent that initially handles the conversation. If not specified, the
example represents a conversation that is handled by the root agent.
Format: 'projects/{project}/locations/{location}/apps/{app}/agents/{agent}'`,
									},
									"etag": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Etag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
									},
									"invalid": {
										Type:     schema.TypeBool,
										Computed: true,
										Description: `The example may become invalid if referencing resources are deleted.
Invalid examples will not be used as few-shot examples.`,
									},
									"messages": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The collection of messages that make up the conversation.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"chunks": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Content of the message as a series of chunks.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"agent_transfer": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `Represents an event indicating the transfer of a conversation to a different
agent.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"display_name": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `Display name of the agent.`,
																		},
																		"target_agent": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The agent to which the conversation is being transferred. The agent will
handle the conversation from this point forward.
Format: 'projects/{project}/locations/{location}/apps/{app}/agents/{agent}'`,
																		},
																	},
																},
															},
															"image": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Represents an image input or output in the conversation.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"data": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `Raw bytes of the image.`,
																		},
																		"mime_type": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The IANA standard MIME type of the source data.
Supported image types includes:
* image/png
* image/jpeg
* image/webp`,
																		},
																	},
																},
															},
															"text": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Text data.`,
															},
															"tool_call": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Request for the client or the agent to execute the specified tool.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"args": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The input parameters and values for the tool in JSON object format.`,
																		},
																		"display_name": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `Display name of the tool.`,
																		},
																		"id": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The unique identifier of the tool call. If populated, the client should
return the execution result with the matching ID in
ToolResponse.`,
																		},
																		"tool": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The name of the tool to execute.
Format: 'projects/{project}/locations/{location}/apps/{app}/tools/{tool}'`,
																		},
																		"toolset_tool": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `A tool that is created from a toolset.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"tool_id": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The tool ID to filter the tools to retrieve the schema for.`,
																					},
																					"toolset": {
																						Type:     schema.TypeString,
																						Computed: true,
																						Description: `The resource name of the Toolset from which this tool is derived.
Format:
'projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}'`,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"tool_response": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `The execution result of a specific tool from the client or the agent.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"display_name": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `Display name of the tool.`,
																		},
																		"id": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The matching ID of the tool call the response is for.`,
																		},
																		"response": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The tool execution result in JSON object format.
Use "output" key to specify tool response and "error" key to specify
error details (if any). If "output" and "error" keys are not specified,
then whole "response" is treated as tool execution result.`,
																		},
																		"tool": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The name of the tool to execute.
Format: 'projects/{project}/locations/{location}/apps/{app}/tools/{tool}'`,
																		},
																		"toolset_tool": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `A tool that is created from a toolset.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"tool_id": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The tool ID to filter the tools to retrieve the schema for.`,
																					},
																					"toolset": {
																						Type:     schema.TypeString,
																						Computed: true,
																						Description: `The resource name of the Toolset from which this tool is derived.
Format:
'projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}'`,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"updated_variables": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `A struct represents variables that were updated in the conversation,
keyed by variable names.`,
															},
														},
													},
												},
												"role": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The role within the conversation, e.g., user, agent.`,
												},
											},
										},
									},
									"name": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Identifier. The unique identifier of the example.
Format:
'projects/{project}/locations/{location}/apps/{app}/examples/{example}'`,
									},
									"update_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the example was last updated.`,
									},
								},
							},
						},
						"guardrails": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `List of guardrails in the app.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"action": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Action that is taken when a certain precondition is met.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"generative_answer": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `The agent will immediately respond with a generative answer.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"prompt": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The prompt to use for the generative answer.`,
															},
														},
													},
												},
												"respond_immediately": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `The agent will immediately respond with a preconfigured response.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"responses": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `The canned responses for the agent to choose from. The response is chosen
randomly.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"disabled": {
																			Type:     schema.TypeBool,
																			Computed: true,
																			Description: `Whether the response is disabled. Disabled responses are not used by the
agent.`,
																		},
																		"text": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `Text for the agent to respond with.`,
																		},
																	},
																},
															},
														},
													},
												},
												"transfer_agent": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `The agent will transfer the conversation to a different agent.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"agent": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The name of the agent to transfer the conversation to. The agent must be
in the same app as the current agent.
Format:
'projects/{project}/locations/{location}/apps/{app}/agents/{agent}'`,
															},
														},
													},
												},
											},
										},
									},
									"code_callback": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Guardrail that blocks the conversation based on the code callbacks
provided.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"after_agent_callback": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `A callback defines the custom logic to be executed at various stages of
agent interaction.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"description": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Human-readable description of the callback.`,
															},
															"disabled": {
																Type:     schema.TypeBool,
																Computed: true,
																Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
															},
															"python_code": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The python code to execute for the callback.`,
															},
														},
													},
												},
												"after_model_callback": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `A callback defines the custom logic to be executed at various stages of
agent interaction.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"description": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Human-readable description of the callback.`,
															},
															"disabled": {
																Type:     schema.TypeBool,
																Computed: true,
																Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
															},
															"python_code": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The python code to execute for the callback.`,
															},
														},
													},
												},
												"before_agent_callback": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `A callback defines the custom logic to be executed at various stages of
agent interaction.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"description": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Human-readable description of the callback.`,
															},
															"disabled": {
																Type:     schema.TypeBool,
																Computed: true,
																Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
															},
															"python_code": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The python code to execute for the callback.`,
															},
														},
													},
												},
												"before_model_callback": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `A callback defines the custom logic to be executed at various stages of
agent interaction.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"description": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Human-readable description of the callback.`,
															},
															"disabled": {
																Type:     schema.TypeBool,
																Computed: true,
																Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
															},
															"python_code": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The python code to execute for the callback.`,
															},
														},
													},
												},
											},
										},
									},
									"content_filter": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Guardrail that bans certain content from being used in the conversation.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"banned_contents": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `List of banned phrases. Applies to both user inputs and agent responses.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"banned_contents_in_agent_response": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `List of banned phrases. Applies only to agent responses.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"banned_contents_in_user_input": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `List of banned phrases. Applies only to user inputs.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"disregard_diacritics": {
													Type:        schema.TypeBool,
													Computed:    true,
													Description: `If true, diacritics are ignored during matching.`,
												},
												"match_type": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `Match type for the content filter.
Possible values:
SIMPLE_STRING_MATCH
WORD_BOUNDARY_STRING_MATCH
REGEXP_MATCH`,
												},
											},
										},
									},
									"create_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the guardrail was created.`,
									},
									"description": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Description of the guardrail.`,
									},
									"display_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Display name of the guardrail.`,
									},
									"enabled": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Whether the guardrail is enabled.`,
									},
									"etag": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Etag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
									},
									"llm_policy": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Guardrail that blocks the conversation if the LLM response is considered
violating the policy based on the LLM classification.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"fail_open": {
													Type:     schema.TypeBool,
													Computed: true,
													Description: `If an error occurs during the policy check, fail open and do not trigger
the guardrail.`,
												},
												"max_conversation_messages": {
													Type:     schema.TypeInt,
													Computed: true,
													Description: `When checking this policy, consider the last 'n' messages in the
conversation.
When not set a default value of 10 will be used.`,
												},
												"model_settings": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Model settings contains various configurations for the LLM model.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"model": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
															},
															"temperature": {
																Type:     schema.TypeFloat,
																Computed: true,
																Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
															},
														},
													},
												},
												"policy_scope": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `Defines when to apply the policy check during the conversation. If set to
'POLICY_SCOPE_UNSPECIFIED', the policy will be applied to the user input.
When applying the policy to the agent response, additional latency will
be introduced before the agent can respond.
Possible values:
USER_QUERY
AGENT_RESPONSE
USER_QUERY_AND_AGENT_RESPONSE`,
												},
												"prompt": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Policy prompt.`,
												},
											},
										},
									},
									"llm_prompt_security": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Guardrail that blocks the conversation if the input is considered unsafe
based on the LLM classification.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"custom_policy": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `Guardrail that blocks the conversation if the LLM response is considered
violating the policy based on the LLM classification.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"fail_open": {
																Type:     schema.TypeBool,
																Computed: true,
																Description: `If an error occurs during the policy check, fail open and do not trigger
the guardrail.`,
															},
															"max_conversation_messages": {
																Type:     schema.TypeInt,
																Computed: true,
																Description: `When checking this policy, consider the last 'n' messages in the
conversation.
When not set a default value of 10 will be used.`,
															},
															"model_settings": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Model settings contains various configurations for the LLM model.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"model": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
																		},
																		"temperature": {
																			Type:     schema.TypeFloat,
																			Computed: true,
																			Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
																		},
																	},
																},
															},
															"policy_scope": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Defines when to apply the policy check during the conversation. If set to
'POLICY_SCOPE_UNSPECIFIED', the policy will be applied to the user input.
When applying the policy to the agent response, additional latency will
be introduced before the agent can respond.
Possible values:
USER_QUERY
AGENT_RESPONSE
USER_QUERY_AND_AGENT_RESPONSE`,
															},
															"prompt": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Policy prompt.`,
															},
														},
													},
												},
												"default_settings": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Configuration for default system security settings.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"default_prompt_template": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The default prompt template used by the system.
This field is for display purposes to show the user what prompt
the system uses by default. It is OUTPUT_ONLY.`,
															},
														},
													},
												},
											},
										},
									},
									"model_safety": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Model safety settings overrides. When this is set, it will override the
default settings and trigger the guardrail if the response is considered
unsafe.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"safety_settings": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `List of safety settings.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"category": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The harm category.
Possible values:
HARM_CATEGORY_HATE_SPEECH
HARM_CATEGORY_DANGEROUS_CONTENT
HARM_CATEGORY_HARASSMENT
HARM_CATEGORY_SEXUALLY_EXPLICIT`,
															},
															"threshold": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The harm block threshold.
Possible values:
BLOCK_LOW_AND_ABOVE
BLOCK_MEDIUM_AND_ABOVE
BLOCK_ONLY_HIGH
BLOCK_NONE
OFF`,
															},
														},
													},
												},
											},
										},
									},
									"name": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Identifier. The unique identifier of the guardrail.
Format:
'projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}'`,
									},
									"update_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the guardrail was last updated.`,
									},
								},
							},
						},
						"tools": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `List of tools in the app.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"client_function": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Represents a client-side function that the agent can invoke. When the
tool is chosen by the agent, control is handed off to the client.
The client is responsible for executing the function and returning the result
as a ToolResponse to continue the interaction with the agent.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The function description.`,
												},
												"name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The function name.`,
												},
												"parameters": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Represents a select subset of an OpenAPI 3.0 schema object.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"additional_properties": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Optional. Defines the schema for additional properties allowed in an object.
The value must be a valid JSON string representing the Schema object.
(Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).`,
															},
															"any_of": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Optional. The instance value should be valid against at least one of the schemas in this list.`,
															},
															"default": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Optional. Default value of the data. Represents a dynamically typed value
which can be either null, a number, a string, a boolean, a struct,
or a list of values. The provided default value must be compatible
with the defined 'type' and other schema constraints.`,
															},
															"defs": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `A map of definitions for use by ref. Only allowed at the root of the schema.`,
															},
															"description": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The description of the data.`,
															},
															"enum": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `Possible values of the element of primitive type with enum format.
Examples:
1. We can define direction as :
{type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
2. We can define apartment number as :
{type:INTEGER, format:enum, enum:["101", "201", "301"]}`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"items": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Schema of the elements of Type.ARRAY.`,
															},
															"nullable": {
																Type:        schema.TypeBool,
																Computed:    true,
																Description: `Indicates if the value may be null.`,
															},
															"prefix_items": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Optional. Schemas of initial elements of Type.ARRAY.`,
															},
															"properties": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Properties of Type.OBJECT.`,
															},
															"ref": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Allows indirect references between schema nodes. The value should be a
valid reference to a child of the root 'defs'.
For example, the following schema defines a reference to a schema node
named "Pet":
type: object
properties:
  pet:
    ref: #/defs/Pet
defs:
  Pet:
    type: object
    properties:
      name:
        type: string
The value of the "pet" property is a reference to the schema node
named "Pet".
See details in
https://json-schema.org/understanding-json-schema/structuring.`,
															},
															"required": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Required properties of Type.OBJECT.`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"type": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The type of the data.
Possible values:
STRING
INTEGER
NUMBER
BOOLEAN
OBJECT
ARRAY`,
															},
															"unique_items": {
																Type:        schema.TypeBool,
																Computed:    true,
																Description: `Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.`,
															},
														},
													},
												},
												"response": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Represents a select subset of an OpenAPI 3.0 schema object.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"additional_properties": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Optional. Defines the schema for additional properties allowed in an object.
The value must be a valid JSON string representing the Schema object.
(Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).`,
															},
															"any_of": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Optional. The instance value should be valid against at least one of the schemas in this list.`,
															},
															"default": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Optional. Default value of the data. Represents a dynamically typed value
which can be either null, a number, a string, a boolean, a struct,
or a list of values. The provided default value must be compatible
with the defined 'type' and other schema constraints.`,
															},
															"defs": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `A map of definitions for use by ref. Only allowed at the root of the schema.`,
															},
															"description": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `The description of the data.`,
															},
															"enum": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `Possible values of the element of primitive type with enum format.
Examples:
1. We can define direction as :
{type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
2. We can define apartment number as :
{type:INTEGER, format:enum, enum:["101", "201", "301"]}`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"items": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Schema of the elements of Type.ARRAY.`,
															},
															"nullable": {
																Type:        schema.TypeBool,
																Computed:    true,
																Description: `Indicates if the value may be null.`,
															},
															"prefix_items": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Optional. Schemas of initial elements of Type.ARRAY.`,
															},
															"properties": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: `Properties of Type.OBJECT.`,
															},
															"ref": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Allows indirect references between schema nodes. The value should be a
valid reference to a child of the root 'defs'.
For example, the following schema defines a reference to a schema node
named "Pet":
type: object
properties:
  pet:
    ref: #/defs/Pet
defs:
  Pet:
    type: object
    properties:
      name:
        type: string
The value of the "pet" property is a reference to the schema node
named "Pet".
See details in
https://json-schema.org/understanding-json-schema/structuring.`,
															},
															"required": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Required properties of Type.OBJECT.`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"type": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The type of the data.
Possible values:
STRING
INTEGER
NUMBER
BOOLEAN
OBJECT
ARRAY`,
															},
															"unique_items": {
																Type:        schema.TypeBool,
																Computed:    true,
																Description: `Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.`,
															},
														},
													},
												},
											},
										},
									},
									"create_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the tool was created.`,
									},
									"data_store_tool": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Tool to retrieve from Vertex AI Search datastore or engine for grounding.
Accepts either a datastore or an engine, but not both.
See Vertex AI Search:
https://cloud.google.com/generative-ai-app-builder/docs/enterprise-search-introduction.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"boost_specs": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Boost specification to boost certain documents.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"data_stores": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `The Data Store where the boosting configuration is applied. Full resource
name of DataStore, such as
projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"spec": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `A list of boosting specifications.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"condition_boost_specs": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `A list of boosting specifications.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"boost": {
																						Type:     schema.TypeFloat,
																						Computed: true,
																						Description: `Strength of the boost, which should be in [-1, 1]. Negative boost means
demotion. Default is 0.0.
Setting to 1.0 gives the suggestions a big promotion. However, it does
not necessarily mean that the top result will be a boosted suggestion.
Setting to -1.0 gives the suggestions a big demotion. However, other
suggestions that are relevant might still be shown.
Setting to 0.0 means no boost applied. The boosting condition is
ignored.`,
																					},
																					"boost_control_spec": {
																						Type:     schema.TypeList,
																						Computed: true,
																						Description: `Specification for custom ranking based on customer specified attribute
value. It provides more controls for customized ranking than the simple
(condition, boost) combination above.`,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"attribute_type": {
																									Type:     schema.TypeString,
																									Computed: true,
																									Description: `The attribute type to be used to determine the boost amount. The
attribute value can be derived from the field value of the specified
field_name. In the case of numerical it is straightforward i.e.
attribute_value = numerical_field_value. In the case of freshness
however, attribute_value = (time.now() - datetime_field_value).
Possible values:
NUMERICAL
FRESHNESS`,
																								},
																								"control_points": {
																									Type:     schema.TypeList,
																									Computed: true,
																									Description: `The control points used to define the curve. The monotonic function
(defined through the interpolation_type above) passes through the
control points listed here.`,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"attribute_value": {
																												Type:     schema.TypeString,
																												Computed: true,
																												Description: `Can be one of:
1. The numerical field value.
2. The duration spec for freshness:
The value must be formatted as an XSD 'dayTimeDuration' value (a
restricted subset of an ISO 8601 duration value). The pattern for
this is: 'nDnM]'.`,
																											},
																											"boost_amount": {
																												Type:     schema.TypeFloat,
																												Computed: true,
																												Description: `The value between -1 to 1 by which to boost the score if the
attribute_value evaluates to the value specified above.`,
																											},
																										},
																									},
																								},
																								"field_name": {
																									Type:     schema.TypeString,
																									Computed: true,
																									Description: `The name of the field whose value will be used to determine the
boost amount.`,
																								},
																								"interpolation_type": {
																									Type:     schema.TypeString,
																									Computed: true,
																									Description: `The interpolation type to be applied to connect the control points
listed below.
Possible values:
LINEAR`,
																								},
																							},
																						},
																					},
																					"condition": {
																						Type:     schema.TypeString,
																						Computed: true,
																						Description: `An expression which specifies a boost condition. The syntax is the same
as filter expression syntax. Currently, the only supported condition is
a list of BCP-47 lang codes.
Example: To boost suggestions in languages en or fr:
(lang_code: ANY("en", "fr"))`,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The tool description.`,
												},
												"engine_source": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `Configuration for searching within an Engine, potentially targeting
specific DataStores.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"data_store_sources": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `Use to target specific DataStores within the Engine.
If empty, the search applies to all DataStores associated with the
Engine.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"data_store": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `A DataStore resource in Vertex AI Search.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"connector_config": {
																						Type:        schema.TypeList,
																						Computed:    true,
																						Description: `The connector config for the data store connection.`,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"collection": {
																									Type:        schema.TypeString,
																									Computed:    true,
																									Description: `Resource name of the collection the data store belongs to.`,
																								},
																								"collection_display_name": {
																									Type:        schema.TypeString,
																									Computed:    true,
																									Description: `Display name of the collection the data store belongs to.`,
																								},
																								"data_source": {
																									Type:     schema.TypeString,
																									Computed: true,
																									Description: `The name of the data source.
Example: 'salesforce', 'jira', 'confluence', 'bigquery'.`,
																								},
																							},
																						},
																					},
																					"create_time": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `Timestamp when the data store was created.`,
																					},
																					"display_name": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Description: `The display name of the data store.`,
																					},
																					"document_processing_mode": {
																						Type:     schema.TypeString,
																						Computed: true,
																						Description: `The document processing mode for the data store connection.
Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
Possible values:
DOCUMENTS
CHUNKS`,
																					},
																					"name": {
																						Type:     schema.TypeString,
																						Computed: true,
																						Description: `Full resource name of the DataStore.
Format:
'projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}'`,
																					},
																					"type": {
																						Type:     schema.TypeString,
																						Computed: true,
																						Description: `The type of the data store. This field is readonly and populated by the
server.
Possible values:
PUBLIC_WEB
UNSTRUCTURED
FAQ
CONNECTOR`,
																					},
																				},
																			},
																		},
																		"filter": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `Filter specification for the DataStore.
See:
https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata`,
																		},
																	},
																},
															},
															"engine": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `Full resource name of the Engine.
Format:
'projects/{project}/locations/{location}/collections/{collection}/engines/{engine}'`,
															},
															"filter": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `A filter applied to the search across the Engine. Not relevant and not
used if 'data_store_sources' is provided.
See:
https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata`,
															},
														},
													},
												},
												"max_results": {
													Type:     schema.TypeInt,
													Computed: true,
													Description: `Number of search results to return per query.
The default value is 10. The maximum allowed value is 10.`,
												},
												"modality_configs": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `The modality configs for the data store.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"grounding_config": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Grounding configuration.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"disabled": {
																			Type:        schema.TypeBool,
																			Computed:    true,
																			Description: `Whether grounding is disabled.`,
																		},
																		"grounding_level": {
																			Type:     schema.TypeFloat,
																			Computed: true,
																			Description: `The groundedness threshold of the answer based on the retrieved sources.
The value has a configurable range of [1, 5]. The level is used to
threshold the groundedness of the answer, meaning that all responses with
a groundedness score below the threshold will fall back to returning
relevant snippets only.
For example, a level of 3 means that the groundedness score must be
3 or higher for the response to be returned.`,
																		},
																	},
																},
															},
															"modality_type": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The modality type.
Possible values:
TEXT
AUDIO`,
															},
															"rewriter_config": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Rewriter configuration.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"disabled": {
																			Type:        schema.TypeBool,
																			Computed:    true,
																			Description: `Whether the rewriter is disabled.`,
																		},
																		"model_settings": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `Model settings contains various configurations for the LLM model.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"model": {
																						Type:     schema.TypeString,
																						Computed: true,
																						Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
																					},
																					"temperature": {
																						Type:     schema.TypeFloat,
																						Computed: true,
																						Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
																					},
																				},
																			},
																		},
																		"prompt": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The prompt definition. If not set, default prompt will be used.`,
																		},
																	},
																},
															},
															"summarization_config": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Summarization configuration.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"disabled": {
																			Type:        schema.TypeBool,
																			Computed:    true,
																			Description: `Whether summarization is disabled.`,
																		},
																		"model_settings": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `Model settings contains various configurations for the LLM model.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"model": {
																						Type:     schema.TypeString,
																						Computed: true,
																						Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
																					},
																					"temperature": {
																						Type:     schema.TypeFloat,
																						Computed: true,
																						Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
																					},
																				},
																			},
																		},
																		"prompt": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The prompt definition. If not set, default prompt will be used.`,
																		},
																	},
																},
															},
														},
													},
												},
												"name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The data store tool name.`,
												},
											},
										},
									},
									"display_name": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The display name of the tool, derived based on the tool's type. For
example, display name of a ClientFunction is derived
from its 'name' property.`,
									},
									"etag": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Etag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
									},
									"execution_type": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Possible values:
SYNCHRONOUS
ASYNCHRONOUS`,
									},
									"generated_summary": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `If the tool is generated by the LLM assistant, this field contains a
descriptive summary of the generation.`,
									},
									"google_search_tool": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `Represents a tool to perform Google web searches for grounding.
See
https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/grounding-with-google-search.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Description of the tool's purpose.`,
												},
												"exclude_domains": {
													Type:     schema.TypeList,
													Computed: true,
													Description: `List of domains to be excluded from the search results.
Example: "example.com".
A maximum of 2000 domains can be excluded.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The name of the tool.`,
												},
											},
										},
									},
									"name": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Identifier. The unique identifier of the tool.
Format:
'projects/{project}/locations/{location}/apps/{app}/tools/{tool}'`,
									},
									"open_api_tool": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `A remote API tool defined by an OpenAPI schema.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"api_authentication": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Authentication information required for API calls.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"api_key_config": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Configurations for authentication with API key.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"api_key_secret_version": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The name of the SecretManager secret version resource storing the API key.
Format: 'projects/{project}/secrets/{secret}/versions/{version}'
Note: You should grant 'roles/secretmanager.secretAccessor' role to the CES
service agent
'service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com'.`,
																		},
																		"key_name": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The parameter name or the header name of the API key.
E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.`,
																		},
																		"request_location": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `Key location in the request.
Possible values:
HEADER
QUERY_STRING`,
																		},
																	},
																},
															},
															"oauth_config": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Configurations for authentication with OAuth.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"client_id": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The client ID from the OAuth provider.`,
																		},
																		"client_secret_version": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The name of the SecretManager secret version resource storing the
client secret.
Format: 'projects/{project}/secrets/{secret}/versions/{version}'
Note: You should grant 'roles/secretmanager.secretAccessor' role to the CES
service agent
'service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com'.`,
																		},
																		"oauth_grant_type": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `OAuth grant types.
Possible values:
CLIENT_CREDENTIAL`,
																		},
																		"scopes": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `The OAuth scopes to grant.`,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},
																		"token_endpoint": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The token endpoint in the OAuth provider to exchange for an access token.`,
																		},
																	},
																},
															},
															"service_account_auth_config": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Configurations for authentication using a custom service account.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"service_account": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The email address of the service account used for authenticatation. CES
uses this service account to exchange an access token and the access token
is then sent in the 'Authorization' header of the request.
The service account must have the
'roles/iam.serviceAccountTokenCreator' role granted to the
CES service agent
'service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com'.`,
																		},
																	},
																},
															},
															"service_agent_id_token_auth_config": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `Configurations for authentication with [ID
token](https://cloud.google.com/docs/authentication/token-types#id) generated
from service agent.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},
														},
													},
												},
												"description": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The description of the tool. If not provided, the description of the tool
will be derived from the OpenAPI schema, from 'operation.description' or
'operation.summary'.`,
												},
												"ignore_unknown_fields": {
													Type:        schema.TypeBool,
													Computed:    true,
													Description: `If true, the agent will ignore unknown fields in the API response.`,
												},
												"name": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The name of the tool. If not provided, the name of the tool will be
derived from the OpenAPI schema, from 'operation.operationId'.`,
												},
												"open_api_schema": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The OpenAPI schema in JSON or YAML format.`,
												},
												"service_directory_config": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Configuration for tools using Service Directory.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"service": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The name of [Service
Directory](https://cloud.google.com/service-directory) service.
Format:
'projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}'.
Location of the service directory must be the same as the location of the
app.`,
															},
														},
													},
												},
												"tls_config": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `The TLS configuration.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"ca_certs": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `Specifies a list of allowed custom CA certificates for HTTPS
verification.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"cert": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The allowed custom CA certificates (in DER format) for
HTTPS verification. This overrides the default SSL trust store. If this
is empty or unspecified, CES will use Google's default trust
store to verify certificates. N.B. Make sure the HTTPS server
certificates are signed with "subject alt name". For instance a
certificate can be self-signed using the following command,
openssl x509 -req -days 200 -in example.com.csr \
-signkey example.com.key \
-out example.com.crt \
-extfile <(printf "\nsubjectAltName='DNS:www.example.com'")

A base64-encoded string.`,
																		},
																		"display_name": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The name of the allowed custom CA certificates. This
can be used to disambiguate the custom CA certificates.`,
																		},
																	},
																},
															},
														},
													},
												},
												"url": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The server URL of the Open API schema. This field is only set in tools in the
environment dependencies during the export process if the schema contains a
server url. During the import process, if this url is present in the environment
dependencies and the schema has the $env_var placeholder, it will replace the
placeholder in the schema.`,
												},
											},
										},
									},
									"python_function": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `A Python function tool.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"description": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The description of the Python function, parsed from the python code's
docstring.`,
												},
												"name": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The name of the Python function to execute. Must match a Python function
name defined in the python code. Case sensitive. If the name is not
provided, the first function defined in the python code will be used.`,
												},
												"python_code": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The Python code to execute for the tool.`,
												},
											},
										},
									},
									"system_tool": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The system tool.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"description": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The description of the system tool.`,
												},
												"name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The name of the system tool.`,
												},
											},
										},
									},
									"update_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the tool was last updated.`,
									},
								},
							},
						},
						"toolsets": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `List of toolsets in the app.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"create_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the toolset was created.`,
									},
									"description": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The description of the toolset.`,
									},
									"display_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The display name of the toolset. Must be unique within the same app.`,
									},
									"etag": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `ETag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
									},
									"execution_type": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Possible values:
SYNCHRONOUS
ASYNCHRONOUS`,
									},
									"name": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Identifier. The unique identifier of the toolset.
Format:
'projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}'`,
									},
									"open_api_toolset": {
										Type:     schema.TypeList,
										Computed: true,
										Description: `A toolset that contains a list of tools that are defined by an OpenAPI
schema.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"api_authentication": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Authentication information required for API calls.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"api_key_config": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Configurations for authentication with API key.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"api_key_secret_version": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The name of the SecretManager secret version resource storing the API key.
Format: 'projects/{project}/secrets/{secret}/versions/{version}'
Note: You should grant 'roles/secretmanager.secretAccessor' role to the CES
service agent
'service-@gcp-sa-ces.iam.gserviceaccount.com'.`,
																		},
																		"key_name": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The parameter name or the header name of the API key.
E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.`,
																		},
																		"request_location": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `Key location in the request.
Possible values:
HEADER
QUERY_STRING`,
																		},
																	},
																},
															},
															"bearer_token_config": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Configurations for authentication with a bearer token.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"token": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: ``,
																		},
																	},
																},
															},
															"oauth_config": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Configurations for authentication with OAuth.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"client_id": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The client ID from the OAuth provider.`,
																		},
																		"client_secret_version": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The name of the SecretManager secret version resource storing the
client secret.
Format: 'projects/{project}/secrets/{secret}/versions/{version}'

Note: You should grant 'roles/secretmanager.secretAccessor' role to the CES
service agent
'service-@gcp-sa-ces.iam.gserviceaccount.com'.`,
																		},
																		"oauth_grant_type": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `OAuth grant types.
Possible values:
CLIENT_CREDENTIAL`,
																		},
																		"scopes": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Description: `The OAuth scopes to grant.`,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},
																		"token_endpoint": {
																			Type:        schema.TypeString,
																			Computed:    true,
																			Description: `The token endpoint in the OAuth provider to exchange for an access token.`,
																		},
																	},
																},
															},
															"service_account_auth_config": {
																Type:        schema.TypeList,
																Computed:    true,
																Description: `Configurations for authentication using a custom service account.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"service_account": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The email address of the service account used for authenticatation. CES
uses this service account to exchange an access token and the access token
is then sent in the 'Authorization' header of the request.

The service account must have the
'roles/iam.serviceAccountTokenCreator' role granted to the
CES service agent
'service-@gcp-sa-ces.iam.gserviceaccount.com'.`,
																		},
																	},
																},
															},
															"service_agent_id_token_auth_config": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `Configurations for authentication with [ID
token](https://cloud.google.com/docs/authentication/token-types#id) generated
from service agent.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},
														},
													},
												},
												"ignore_unknown_fields": {
													Type:     schema.TypeBool,
													Computed: true,
													Description: `If true, the agent will ignore unknown fields in the API response for all
operations defined in the OpenAPI schema.`,
												},
												"open_api_schema": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The OpenAPI schema of the toolset.`,
												},
												"service_directory_config": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `Configuration for tools using Service Directory.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"service": {
																Type:     schema.TypeString,
																Computed: true,
																Description: `The name of [Service
Directory](https://cloud.google.com/service-directory) service.
Format:
'projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}'.
Location of the service directory must be the same as the location of the
app.`,
															},
														},
													},
												},
												"tls_config": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: `The TLS configuration.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"ca_certs": {
																Type:     schema.TypeList,
																Computed: true,
																Description: `Specifies a list of allowed custom CA certificates for HTTPS
verification.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"cert": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The allowed custom CA certificates (in DER format) for
HTTPS verification. This overrides the default SSL trust store. If this
is empty or unspecified, CES will use Google's default trust
store to verify certificates. N.B. Make sure the HTTPS server
certificates are signed with "subject alt name". For instance a
certificate can be self-signed using the following command,
openssl x509 -req -days 200 -in example.com.csr \
-signkey example.com.key \
-out example.com.crt \
-extfile <(printf "\nsubjectAltName='DNS:www.example.com'")`,
																		},
																		"display_name": {
																			Type:     schema.TypeString,
																			Computed: true,
																			Description: `The name of the allowed custom CA certificates. This
can be used to disambiguate the custom CA certificates.`,
																		},
																	},
																},
															},
														},
													},
												},
												"url": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `The server URL of the Open API schema.
This field is only set in toolsets in the environment dependencies
during the export process if the schema contains a server url.
During the import process, if this url is present in the environment dependencies
and the schema has the $env_var placeholder,
it will replace the placeholder in the schema.`,
												},
											},
										},
									},
									"update_time": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Timestamp when the toolset was last updated.`,
									},
								},
							},
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCESAppVersionCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandCESAppVersionDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	displayNameProp, err := expandCESAppVersionDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/versions?appVersionId={{app_version_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new AppVersion: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for AppVersion: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating AppVersion: %s", err)
	}
	// Set computed resource properties from create API response so that they're available on the subsequent Read
	// call.
	err = resourceCESAppVersionPostCreateSetComputedFields(d, meta, res)
	if err != nil {
		return fmt.Errorf("setting computed ID format fields: %w", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{app}}/versions/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if appValue, ok := d.GetOk("app"); ok && appValue.(string) != "" {
			if err = identity.Set("app", appValue.(string)); err != nil {
				return fmt.Errorf("Error setting app: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	log.Printf("[DEBUG] Finished creating AppVersion %q: %#v", d.Id(), res)

	return resourceCESAppVersionRead(d, meta)
}

func resourceCESAppVersionRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/versions/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for AppVersion: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("CESAppVersion %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading AppVersion: %s", err)
	}

	if err := d.Set("create_time", flattenCESAppVersionCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading AppVersion: %s", err)
	}
	if err := d.Set("creator", flattenCESAppVersionCreator(res["creator"], d, config)); err != nil {
		return fmt.Errorf("Error reading AppVersion: %s", err)
	}
	if err := d.Set("description", flattenCESAppVersionDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading AppVersion: %s", err)
	}
	if err := d.Set("display_name", flattenCESAppVersionDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading AppVersion: %s", err)
	}
	if err := d.Set("etag", flattenCESAppVersionEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading AppVersion: %s", err)
	}
	if err := d.Set("name", flattenCESAppVersionName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading AppVersion: %s", err)
	}
	if err := d.Set("snapshot", flattenCESAppVersionSnapshot(res["snapshot"], d, config)); err != nil {
		return fmt.Errorf("Error reading AppVersion: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("name"); !ok && v == "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("app"); !ok && v == "" {
			err = identity.Set("app", d.Get("app").(string))
			if err != nil {
				return fmt.Errorf("Error setting app: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceCESAppVersionDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for AppVersion: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/versions/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting AppVersion %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "AppVersion")
	}

	log.Printf("[DEBUG] Finished deleting AppVersion %q: %#v", d.Id(), res)
	return nil
}

func resourceCESAppVersionImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/apps/(?P<app>[^/]+)/versions/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<app>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<app>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{app}}/versions/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCESAppVersionCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionCreator(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenCESAppVersionSnapshot(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["agents"] =
		flattenCESAppVersionSnapshotAgents(original["agents"], d, config)
	transformed["app"] =
		flattenCESAppVersionSnapshotApp(original["app"], d, config)
	transformed["examples"] =
		flattenCESAppVersionSnapshotExamples(original["examples"], d, config)
	transformed["guardrails"] =
		flattenCESAppVersionSnapshotGuardrails(original["guardrails"], d, config)
	transformed["tools"] =
		flattenCESAppVersionSnapshotTools(original["tools"], d, config)
	transformed["toolsets"] =
		flattenCESAppVersionSnapshotToolsets(original["toolsets"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAgents(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"after_agent_callbacks":   flattenCESAppVersionSnapshotAgentsAfterAgentCallbacks(original["afterAgentCallbacks"], d, config),
			"after_model_callbacks":   flattenCESAppVersionSnapshotAgentsAfterModelCallbacks(original["afterModelCallbacks"], d, config),
			"after_tool_callbacks":    flattenCESAppVersionSnapshotAgentsAfterToolCallbacks(original["afterToolCallbacks"], d, config),
			"before_agent_callbacks":  flattenCESAppVersionSnapshotAgentsBeforeAgentCallbacks(original["beforeAgentCallbacks"], d, config),
			"before_model_callbacks":  flattenCESAppVersionSnapshotAgentsBeforeModelCallbacks(original["beforeModelCallbacks"], d, config),
			"before_tool_callbacks":   flattenCESAppVersionSnapshotAgentsBeforeToolCallbacks(original["beforeToolCallbacks"], d, config),
			"child_agents":            flattenCESAppVersionSnapshotAgentsChildAgents(original["childAgents"], d, config),
			"create_time":             flattenCESAppVersionSnapshotAgentsCreateTime(original["createTime"], d, config),
			"description":             flattenCESAppVersionSnapshotAgentsDescription(original["description"], d, config),
			"display_name":            flattenCESAppVersionSnapshotAgentsDisplayName(original["displayName"], d, config),
			"etag":                    flattenCESAppVersionSnapshotAgentsEtag(original["etag"], d, config),
			"generated_summary":       flattenCESAppVersionSnapshotAgentsGeneratedSummary(original["generatedSummary"], d, config),
			"guardrails":              flattenCESAppVersionSnapshotAgentsGuardrails(original["guardrails"], d, config),
			"instruction":             flattenCESAppVersionSnapshotAgentsInstruction(original["instruction"], d, config),
			"llm_agent":               flattenCESAppVersionSnapshotAgentsLlmAgent(original["llmAgent"], d, config),
			"model_settings":          flattenCESAppVersionSnapshotAgentsModelSettings(original["modelSettings"], d, config),
			"name":                    flattenCESAppVersionSnapshotAgentsName(original["name"], d, config),
			"remote_dialogflow_agent": flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgent(original["remoteDialogflowAgent"], d, config),
			"tools":                   flattenCESAppVersionSnapshotAgentsTools(original["tools"], d, config),
			"toolsets":                flattenCESAppVersionSnapshotAgentsToolsets(original["toolsets"], d, config),
			"update_time":             flattenCESAppVersionSnapshotAgentsUpdateTime(original["updateTime"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotAgentsAfterAgentCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAppVersionSnapshotAgentsAfterAgentCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAppVersionSnapshotAgentsAfterAgentCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAppVersionSnapshotAgentsAfterAgentCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotAgentsAfterAgentCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsAfterAgentCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsAfterAgentCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsAfterModelCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAppVersionSnapshotAgentsAfterModelCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAppVersionSnapshotAgentsAfterModelCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAppVersionSnapshotAgentsAfterModelCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotAgentsAfterModelCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsAfterModelCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsAfterModelCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsAfterToolCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAppVersionSnapshotAgentsAfterToolCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAppVersionSnapshotAgentsAfterToolCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAppVersionSnapshotAgentsAfterToolCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotAgentsAfterToolCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsAfterToolCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsAfterToolCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsBeforeAgentCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAppVersionSnapshotAgentsBeforeAgentCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAppVersionSnapshotAgentsBeforeAgentCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAppVersionSnapshotAgentsBeforeAgentCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotAgentsBeforeAgentCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsBeforeAgentCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsBeforeAgentCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsBeforeModelCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAppVersionSnapshotAgentsBeforeModelCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAppVersionSnapshotAgentsBeforeModelCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAppVersionSnapshotAgentsBeforeModelCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotAgentsBeforeModelCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsBeforeModelCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsBeforeModelCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsBeforeToolCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAppVersionSnapshotAgentsBeforeToolCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAppVersionSnapshotAgentsBeforeToolCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAppVersionSnapshotAgentsBeforeToolCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotAgentsBeforeToolCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsBeforeToolCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsBeforeToolCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsChildAgents(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsGeneratedSummary(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsGuardrails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsInstruction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsLlmAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenCESAppVersionSnapshotAgentsModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESAppVersionSnapshotAgentsModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESAppVersionSnapshotAgentsModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAgentsModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["agent"] =
		flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgentAgent(original["agent"], d, config)
	transformed["environment_id"] =
		flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgentEnvironmentId(original["environmentId"], d, config)
	transformed["flow_id"] =
		flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgentFlowId(original["flowId"], d, config)
	transformed["input_variable_mapping"] =
		flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgentInputVariableMapping(original["inputVariableMapping"], d, config)
	transformed["output_variable_mapping"] =
		flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgentOutputVariableMapping(original["outputVariableMapping"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgentAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgentEnvironmentId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgentFlowId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgentInputVariableMapping(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsRemoteDialogflowAgentOutputVariableMapping(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsTools(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsToolsets(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"toolset":  flattenCESAppVersionSnapshotAgentsToolsetsToolset(original["toolset"], d, config),
			"tool_ids": flattenCESAppVersionSnapshotAgentsToolsetsToolIds(original["toolIds"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotAgentsToolsetsToolset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsToolsetsToolIds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAgentsUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotApp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["audio_processing_config"] =
		flattenCESAppVersionSnapshotAppAudioProcessingConfig(original["audioProcessingConfig"], d, config)
	transformed["create_time"] =
		flattenCESAppVersionSnapshotAppCreateTime(original["createTime"], d, config)
	transformed["data_store_settings"] =
		flattenCESAppVersionSnapshotAppDataStoreSettings(original["dataStoreSettings"], d, config)
	transformed["default_channel_profile"] =
		flattenCESAppVersionSnapshotAppDefaultChannelProfile(original["defaultChannelProfile"], d, config)
	transformed["deployment_count"] =
		flattenCESAppVersionSnapshotAppDeploymentCount(original["deploymentCount"], d, config)
	transformed["description"] =
		flattenCESAppVersionSnapshotAppDescription(original["description"], d, config)
	transformed["display_name"] =
		flattenCESAppVersionSnapshotAppDisplayName(original["displayName"], d, config)
	transformed["etag"] =
		flattenCESAppVersionSnapshotAppEtag(original["etag"], d, config)
	transformed["evaluation_metrics_thresholds"] =
		flattenCESAppVersionSnapshotAppEvaluationMetricsThresholds(original["evaluationMetricsThresholds"], d, config)
	transformed["global_instruction"] =
		flattenCESAppVersionSnapshotAppGlobalInstruction(original["globalInstruction"], d, config)
	transformed["guardrails"] =
		flattenCESAppVersionSnapshotAppGuardrails(original["guardrails"], d, config)
	transformed["language_settings"] =
		flattenCESAppVersionSnapshotAppLanguageSettings(original["languageSettings"], d, config)
	transformed["logging_settings"] =
		flattenCESAppVersionSnapshotAppLoggingSettings(original["loggingSettings"], d, config)
	transformed["metadata"] =
		flattenCESAppVersionSnapshotAppMetadata(original["metadata"], d, config)
	transformed["model_settings"] =
		flattenCESAppVersionSnapshotAppModelSettings(original["modelSettings"], d, config)
	transformed["name"] =
		flattenCESAppVersionSnapshotAppName(original["name"], d, config)
	transformed["root_agent"] =
		flattenCESAppVersionSnapshotAppRootAgent(original["rootAgent"], d, config)
	transformed["time_zone_settings"] =
		flattenCESAppVersionSnapshotAppTimeZoneSettings(original["timeZoneSettings"], d, config)
	transformed["update_time"] =
		flattenCESAppVersionSnapshotAppUpdateTime(original["updateTime"], d, config)
	transformed["variable_declarations"] =
		flattenCESAppVersionSnapshotAppVariableDeclarations(original["variableDeclarations"], d, config)
	transformed["client_certificate_settings"] =
		flattenCESAppVersionSnapshotAppClientCertificateSettings(original["clientCertificateSettings"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppAudioProcessingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ambient_sound_config"] =
		flattenCESAppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfig(original["ambientSoundConfig"], d, config)
	transformed["barge_in_config"] =
		flattenCESAppVersionSnapshotAppAudioProcessingConfigBargeInConfig(original["bargeInConfig"], d, config)
	transformed["inactivity_timeout"] =
		flattenCESAppVersionSnapshotAppAudioProcessingConfigInactivityTimeout(original["inactivityTimeout"], d, config)
	transformed["synthesize_speech_configs"] =
		flattenCESAppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigs(original["synthesizeSpeechConfigs"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["gcs_uri"] =
		flattenCESAppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigGcsUri(original["gcsUri"], d, config)
	transformed["prebuilt_ambient_sound"] =
		flattenCESAppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigPrebuiltAmbientSound(original["prebuiltAmbientSound"], d, config)
	transformed["volume_gain_db"] =
		flattenCESAppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigVolumeGainDb(original["volumeGainDb"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigGcsUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigPrebuiltAmbientSound(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigVolumeGainDb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppAudioProcessingConfigBargeInConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["barge_in_awareness"] =
		flattenCESAppVersionSnapshotAppAudioProcessingConfigBargeInConfigBargeInAwareness(original["bargeInAwareness"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppAudioProcessingConfigBargeInConfigBargeInAwareness(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppAudioProcessingConfigInactivityTimeout(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"language_code": k,
			"voice":         flattenCESAppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigsVoice(original["voice"], d, config),
			"speaking_rate": flattenCESAppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigsSpeakingRate(original["speakingRate"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigsVoice(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigsSpeakingRate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDataStoreSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["engines"] =
		flattenCESAppVersionSnapshotAppDataStoreSettingsEngines(original["engines"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppDataStoreSettingsEngines(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name": flattenCESAppVersionSnapshotAppDataStoreSettingsEnginesName(original["name"], d, config),
			"type": flattenCESAppVersionSnapshotAppDataStoreSettingsEnginesType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotAppDataStoreSettingsEnginesName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDataStoreSettingsEnginesType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDefaultChannelProfile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["channel_type"] =
		flattenCESAppVersionSnapshotAppDefaultChannelProfileChannelType(original["channelType"], d, config)
	transformed["disable_barge_in_control"] =
		flattenCESAppVersionSnapshotAppDefaultChannelProfileDisableBargeInControl(original["disableBargeInControl"], d, config)
	transformed["disable_dtmf"] =
		flattenCESAppVersionSnapshotAppDefaultChannelProfileDisableDtmf(original["disableDtmf"], d, config)
	transformed["persona_property"] =
		flattenCESAppVersionSnapshotAppDefaultChannelProfilePersonaProperty(original["personaProperty"], d, config)
	transformed["profile_id"] =
		flattenCESAppVersionSnapshotAppDefaultChannelProfileProfileId(original["profileId"], d, config)
	transformed["web_widget_config"] =
		flattenCESAppVersionSnapshotAppDefaultChannelProfileWebWidgetConfig(original["webWidgetConfig"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppDefaultChannelProfileChannelType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDefaultChannelProfileDisableBargeInControl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDefaultChannelProfileDisableDtmf(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDefaultChannelProfilePersonaProperty(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["persona"] =
		flattenCESAppVersionSnapshotAppDefaultChannelProfilePersonaPropertyPersona(original["persona"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppDefaultChannelProfilePersonaPropertyPersona(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDefaultChannelProfileProfileId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDefaultChannelProfileWebWidgetConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["modality"] =
		flattenCESAppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigModality(original["modality"], d, config)
	transformed["theme"] =
		flattenCESAppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigTheme(original["theme"], d, config)
	transformed["web_widget_title"] =
		flattenCESAppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigWebWidgetTitle(original["webWidgetTitle"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigModality(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigTheme(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigWebWidgetTitle(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDeploymentCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESAppVersionSnapshotAppDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppEvaluationMetricsThresholds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["golden_evaluation_metrics_thresholds"] =
		flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds(original["goldenEvaluationMetricsThresholds"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["expectation_level_metrics_thresholds"] =
		flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds(original["expectationLevelMetricsThresholds"], d, config)
	transformed["turn_level_metrics_thresholds"] =
		flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds(original["turnLevelMetricsThresholds"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["tool_invocation_parameter_correctness_threshold"] =
		flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsToolInvocationParameterCorrectnessThreshold(original["toolInvocationParameterCorrectnessThreshold"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsToolInvocationParameterCorrectnessThreshold(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["overall_tool_invocation_correctness_threshold"] =
		flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsOverallToolInvocationCorrectnessThreshold(original["overallToolInvocationCorrectnessThreshold"], d, config)
	transformed["semantic_similarity_success_threshold"] =
		flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsSemanticSimilaritySuccessThreshold(original["semanticSimilaritySuccessThreshold"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsOverallToolInvocationCorrectnessThreshold(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsSemanticSimilaritySuccessThreshold(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESAppVersionSnapshotAppGlobalInstruction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppGuardrails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLanguageSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["default_language_code"] =
		flattenCESAppVersionSnapshotAppLanguageSettingsDefaultLanguageCode(original["defaultLanguageCode"], d, config)
	transformed["enable_multilingual_support"] =
		flattenCESAppVersionSnapshotAppLanguageSettingsEnableMultilingualSupport(original["enableMultilingualSupport"], d, config)
	transformed["fallback_action"] =
		flattenCESAppVersionSnapshotAppLanguageSettingsFallbackAction(original["fallbackAction"], d, config)
	transformed["supported_language_codes"] =
		flattenCESAppVersionSnapshotAppLanguageSettingsSupportedLanguageCodes(original["supportedLanguageCodes"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppLanguageSettingsDefaultLanguageCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLanguageSettingsEnableMultilingualSupport(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLanguageSettingsFallbackAction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLanguageSettingsSupportedLanguageCodes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLoggingSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["audio_recording_config"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsAudioRecordingConfig(original["audioRecordingConfig"], d, config)
	transformed["bigquery_export_settings"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsBigqueryExportSettings(original["bigqueryExportSettings"], d, config)
	transformed["cloud_logging_settings"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsCloudLoggingSettings(original["cloudLoggingSettings"], d, config)
	transformed["conversation_logging_settings"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsConversationLoggingSettings(original["conversationLoggingSettings"], d, config)
	transformed["redaction_config"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsRedactionConfig(original["redactionConfig"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppLoggingSettingsAudioRecordingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["gcs_bucket"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsAudioRecordingConfigGcsBucket(original["gcsBucket"], d, config)
	transformed["gcs_path_prefix"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsAudioRecordingConfigGcsPathPrefix(original["gcsPathPrefix"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppLoggingSettingsAudioRecordingConfigGcsBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLoggingSettingsAudioRecordingConfigGcsPathPrefix(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLoggingSettingsBigqueryExportSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dataset"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsBigqueryExportSettingsDataset(original["dataset"], d, config)
	transformed["enabled"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsBigqueryExportSettingsEnabled(original["enabled"], d, config)
	transformed["project"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsBigqueryExportSettingsProject(original["project"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppLoggingSettingsBigqueryExportSettingsDataset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLoggingSettingsBigqueryExportSettingsEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLoggingSettingsBigqueryExportSettingsProject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLoggingSettingsCloudLoggingSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enable_cloud_logging"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsCloudLoggingSettingsEnableCloudLogging(original["enableCloudLogging"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppLoggingSettingsCloudLoggingSettingsEnableCloudLogging(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLoggingSettingsConversationLoggingSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disable_conversation_logging"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsConversationLoggingSettingsDisableConversationLogging(original["disableConversationLogging"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppLoggingSettingsConversationLoggingSettingsDisableConversationLogging(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLoggingSettingsRedactionConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["deidentify_template"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsRedactionConfigDeidentifyTemplate(original["deidentifyTemplate"], d, config)
	transformed["enable_redaction"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsRedactionConfigEnableRedaction(original["enableRedaction"], d, config)
	transformed["inspect_template"] =
		flattenCESAppVersionSnapshotAppLoggingSettingsRedactionConfigInspectTemplate(original["inspectTemplate"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppLoggingSettingsRedactionConfigDeidentifyTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLoggingSettingsRedactionConfigEnableRedaction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppLoggingSettingsRedactionConfigInspectTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppMetadata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESAppVersionSnapshotAppModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESAppVersionSnapshotAppModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenCESAppVersionSnapshotAppRootAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppTimeZoneSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["time_zone"] =
		flattenCESAppVersionSnapshotAppTimeZoneSettingsTimeZone(original["timeZone"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppTimeZoneSettingsTimeZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppVariableDeclarations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAppVersionSnapshotAppVariableDeclarationsDescription(original["description"], d, config),
			"name":        flattenCESAppVersionSnapshotAppVariableDeclarationsName(original["name"], d, config),
			"schema":      flattenCESAppVersionSnapshotAppVariableDeclarationsSchema(original["schema"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotAppVariableDeclarationsDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaDescription(original["description"], d, config)
	transformed["enum"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaEnum(original["enum"], d, config)
	transformed["nullable"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaNullable(original["nullable"], d, config)
	transformed["ref"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaRef(original["ref"], d, config)
	transformed["required"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaRequired(original["required"], d, config)
	transformed["type"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaType(original["type"], d, config)
	transformed["unique_items"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaUniqueItems(original["uniqueItems"], d, config)
	transformed["defs"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaDefs(original["defs"], d, config)
	transformed["default"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaDefault(original["default"], d, config)
	transformed["additional_properties"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaAdditionalProperties(original["additionalProperties"], d, config)
	transformed["any_of"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaAnyOf(original["anyOf"], d, config)
	transformed["prefix_items"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaPrefixItems(original["prefixItems"], d, config)
	transformed["properties"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaProperties(original["properties"], d, config)
	transformed["items"] =
		flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaItems(original["items"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaEnum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaNullable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaRef(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaRequired(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaUniqueItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaDefs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaDefault(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaAdditionalProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaAnyOf(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaPrefixItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotAppVariableDeclarationsSchemaItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotAppClientCertificateSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["tls_certificate"] =
		flattenCESAppVersionSnapshotAppClientCertificateSettingsTlsCertificate(original["tlsCertificate"], d, config)
	transformed["private_key"] =
		flattenCESAppVersionSnapshotAppClientCertificateSettingsPrivateKey(original["privateKey"], d, config)
	transformed["passphrase"] =
		flattenCESAppVersionSnapshotAppClientCertificateSettingsPassphrase(original["passphrase"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotAppClientCertificateSettingsTlsCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppClientCertificateSettingsPrivateKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotAppClientCertificateSettingsPassphrase(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamples(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"create_time":  flattenCESAppVersionSnapshotExamplesCreateTime(original["createTime"], d, config),
			"description":  flattenCESAppVersionSnapshotExamplesDescription(original["description"], d, config),
			"display_name": flattenCESAppVersionSnapshotExamplesDisplayName(original["displayName"], d, config),
			"entry_agent":  flattenCESAppVersionSnapshotExamplesEntryAgent(original["entryAgent"], d, config),
			"etag":         flattenCESAppVersionSnapshotExamplesEtag(original["etag"], d, config),
			"invalid":      flattenCESAppVersionSnapshotExamplesInvalid(original["invalid"], d, config),
			"messages":     flattenCESAppVersionSnapshotExamplesMessages(original["messages"], d, config),
			"name":         flattenCESAppVersionSnapshotExamplesName(original["name"], d, config),
			"update_time":  flattenCESAppVersionSnapshotExamplesUpdateTime(original["updateTime"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotExamplesCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesEntryAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesInvalid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessages(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"chunks": flattenCESAppVersionSnapshotExamplesMessagesChunks(original["chunks"], d, config),
			"role":   flattenCESAppVersionSnapshotExamplesMessagesRole(original["role"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotExamplesMessagesChunks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"agent_transfer":    flattenCESAppVersionSnapshotExamplesMessagesChunksAgentTransfer(original["agentTransfer"], d, config),
			"image":             flattenCESAppVersionSnapshotExamplesMessagesChunksImage(original["image"], d, config),
			"text":              flattenCESAppVersionSnapshotExamplesMessagesChunksText(original["text"], d, config),
			"tool_call":         flattenCESAppVersionSnapshotExamplesMessagesChunksToolCall(original["toolCall"], d, config),
			"tool_response":     flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponse(original["toolResponse"], d, config),
			"updated_variables": flattenCESAppVersionSnapshotExamplesMessagesChunksUpdatedVariables(original["updatedVariables"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotExamplesMessagesChunksAgentTransfer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["display_name"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksAgentTransferDisplayName(original["displayName"], d, config)
	transformed["target_agent"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksAgentTransferTargetAgent(original["targetAgent"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotExamplesMessagesChunksAgentTransferDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksAgentTransferTargetAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["data"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksImageData(original["data"], d, config)
	transformed["mime_type"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksImageMimeType(original["mimeType"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotExamplesMessagesChunksImageData(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksImageMimeType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksText(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolCall(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["args"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallArgs(original["args"], d, config)
	transformed["display_name"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallDisplayName(original["displayName"], d, config)
	transformed["id"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallId(original["id"], d, config)
	transformed["tool"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallTool(original["tool"], d, config)
	transformed["toolset_tool"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallToolsetTool(original["toolsetTool"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallArgs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallToolsetTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["toolset"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallToolsetToolToolset(original["toolset"], d, config)
	transformed["tool_id"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallToolsetToolToolId(original["toolId"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallToolsetToolToolset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolCallToolsetToolToolId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponse(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["display_name"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseDisplayName(original["displayName"], d, config)
	transformed["id"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseId(original["id"], d, config)
	transformed["response"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseResponse(original["response"], d, config)
	transformed["tool"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseTool(original["tool"], d, config)
	transformed["toolset_tool"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseToolsetTool(original["toolsetTool"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseResponse(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseToolsetTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["toolset"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseToolsetToolToolset(original["toolset"], d, config)
	transformed["tool_id"] =
		flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseToolsetToolToolId(original["toolId"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseToolsetToolToolset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksToolResponseToolsetToolToolId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesMessagesChunksUpdatedVariables(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotExamplesMessagesRole(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotExamplesName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenCESAppVersionSnapshotExamplesUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"action":              flattenCESAppVersionSnapshotGuardrailsAction(original["action"], d, config),
			"code_callback":       flattenCESAppVersionSnapshotGuardrailsCodeCallback(original["codeCallback"], d, config),
			"content_filter":      flattenCESAppVersionSnapshotGuardrailsContentFilter(original["contentFilter"], d, config),
			"create_time":         flattenCESAppVersionSnapshotGuardrailsCreateTime(original["createTime"], d, config),
			"description":         flattenCESAppVersionSnapshotGuardrailsDescription(original["description"], d, config),
			"display_name":        flattenCESAppVersionSnapshotGuardrailsDisplayName(original["displayName"], d, config),
			"enabled":             flattenCESAppVersionSnapshotGuardrailsEnabled(original["enabled"], d, config),
			"etag":                flattenCESAppVersionSnapshotGuardrailsEtag(original["etag"], d, config),
			"llm_policy":          flattenCESAppVersionSnapshotGuardrailsLlmPolicy(original["llmPolicy"], d, config),
			"llm_prompt_security": flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurity(original["llmPromptSecurity"], d, config),
			"model_safety":        flattenCESAppVersionSnapshotGuardrailsModelSafety(original["modelSafety"], d, config),
			"name":                flattenCESAppVersionSnapshotGuardrailsName(original["name"], d, config),
			"update_time":         flattenCESAppVersionSnapshotGuardrailsUpdateTime(original["updateTime"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotGuardrailsAction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["generative_answer"] =
		flattenCESAppVersionSnapshotGuardrailsActionGenerativeAnswer(original["generativeAnswer"], d, config)
	transformed["respond_immediately"] =
		flattenCESAppVersionSnapshotGuardrailsActionRespondImmediately(original["respondImmediately"], d, config)
	transformed["transfer_agent"] =
		flattenCESAppVersionSnapshotGuardrailsActionTransferAgent(original["transferAgent"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsActionGenerativeAnswer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["prompt"] =
		flattenCESAppVersionSnapshotGuardrailsActionGenerativeAnswerPrompt(original["prompt"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsActionGenerativeAnswerPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsActionRespondImmediately(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["responses"] =
		flattenCESAppVersionSnapshotGuardrailsActionRespondImmediatelyResponses(original["responses"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsActionRespondImmediatelyResponses(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"disabled": flattenCESAppVersionSnapshotGuardrailsActionRespondImmediatelyResponsesDisabled(original["disabled"], d, config),
			"text":     flattenCESAppVersionSnapshotGuardrailsActionRespondImmediatelyResponsesText(original["text"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotGuardrailsActionRespondImmediatelyResponsesDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsActionRespondImmediatelyResponsesText(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsActionTransferAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["agent"] =
		flattenCESAppVersionSnapshotGuardrailsActionTransferAgentAgent(original["agent"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsActionTransferAgentAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallback(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["after_agent_callback"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterAgentCallback(original["afterAgentCallback"], d, config)
	transformed["after_model_callback"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterModelCallback(original["afterModelCallback"], d, config)
	transformed["before_agent_callback"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeAgentCallback(original["beforeAgentCallback"], d, config)
	transformed["before_model_callback"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeModelCallback(original["beforeModelCallback"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterAgentCallback(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterAgentCallbackDescription(original["description"], d, config)
	transformed["disabled"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterAgentCallbackDisabled(original["disabled"], d, config)
	transformed["python_code"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterAgentCallbackPythonCode(original["pythonCode"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterAgentCallbackDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterAgentCallbackDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterAgentCallbackPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterModelCallback(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterModelCallbackDescription(original["description"], d, config)
	transformed["disabled"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterModelCallbackDisabled(original["disabled"], d, config)
	transformed["python_code"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterModelCallbackPythonCode(original["pythonCode"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterModelCallbackDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterModelCallbackDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallbackAfterModelCallbackPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeAgentCallback(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeAgentCallbackDescription(original["description"], d, config)
	transformed["disabled"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeAgentCallbackDisabled(original["disabled"], d, config)
	transformed["python_code"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeAgentCallbackPythonCode(original["pythonCode"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeAgentCallbackDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeAgentCallbackDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeAgentCallbackPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeModelCallback(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeModelCallbackDescription(original["description"], d, config)
	transformed["disabled"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeModelCallbackDisabled(original["disabled"], d, config)
	transformed["python_code"] =
		flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeModelCallbackPythonCode(original["pythonCode"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeModelCallbackDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeModelCallbackDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCodeCallbackBeforeModelCallbackPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsContentFilter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["banned_contents"] =
		flattenCESAppVersionSnapshotGuardrailsContentFilterBannedContents(original["bannedContents"], d, config)
	transformed["banned_contents_in_agent_response"] =
		flattenCESAppVersionSnapshotGuardrailsContentFilterBannedContentsInAgentResponse(original["bannedContentsInAgentResponse"], d, config)
	transformed["banned_contents_in_user_input"] =
		flattenCESAppVersionSnapshotGuardrailsContentFilterBannedContentsInUserInput(original["bannedContentsInUserInput"], d, config)
	transformed["disregard_diacritics"] =
		flattenCESAppVersionSnapshotGuardrailsContentFilterDisregardDiacritics(original["disregardDiacritics"], d, config)
	transformed["match_type"] =
		flattenCESAppVersionSnapshotGuardrailsContentFilterMatchType(original["matchType"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsContentFilterBannedContents(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsContentFilterBannedContentsInAgentResponse(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsContentFilterBannedContentsInUserInput(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsContentFilterDisregardDiacritics(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsContentFilterMatchType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsLlmPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["fail_open"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPolicyFailOpen(original["failOpen"], d, config)
	transformed["max_conversation_messages"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPolicyMaxConversationMessages(original["maxConversationMessages"], d, config)
	transformed["model_settings"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPolicyModelSettings(original["modelSettings"], d, config)
	transformed["policy_scope"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPolicyPolicyScope(original["policyScope"], d, config)
	transformed["prompt"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPolicyPrompt(original["prompt"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsLlmPolicyFailOpen(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsLlmPolicyMaxConversationMessages(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESAppVersionSnapshotGuardrailsLlmPolicyModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPolicyModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPolicyModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsLlmPolicyModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsLlmPolicyModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsLlmPolicyPolicyScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsLlmPolicyPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["custom_policy"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicy(original["customPolicy"], d, config)
	transformed["default_settings"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityDefaultSettings(original["defaultSettings"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["fail_open"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyFailOpen(original["failOpen"], d, config)
	transformed["max_conversation_messages"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyMaxConversationMessages(original["maxConversationMessages"], d, config)
	transformed["model_settings"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyModelSettings(original["modelSettings"], d, config)
	transformed["policy_scope"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyPolicyScope(original["policyScope"], d, config)
	transformed["prompt"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyPrompt(original["prompt"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyFailOpen(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyMaxConversationMessages(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyPolicyScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityCustomPolicyPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityDefaultSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["default_prompt_template"] =
		flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityDefaultSettingsDefaultPromptTemplate(original["defaultPromptTemplate"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsLlmPromptSecurityDefaultSettingsDefaultPromptTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsModelSafety(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["safety_settings"] =
		flattenCESAppVersionSnapshotGuardrailsModelSafetySafetySettings(original["safetySettings"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotGuardrailsModelSafetySafetySettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"category":  flattenCESAppVersionSnapshotGuardrailsModelSafetySafetySettingsCategory(original["category"], d, config),
			"threshold": flattenCESAppVersionSnapshotGuardrailsModelSafetySafetySettingsThreshold(original["threshold"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotGuardrailsModelSafetySafetySettingsCategory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsModelSafetySafetySettingsThreshold(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotGuardrailsUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotTools(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"client_function":    flattenCESAppVersionSnapshotToolsClientFunction(original["clientFunction"], d, config),
			"create_time":        flattenCESAppVersionSnapshotToolsCreateTime(original["createTime"], d, config),
			"data_store_tool":    flattenCESAppVersionSnapshotToolsDataStoreTool(original["dataStoreTool"], d, config),
			"display_name":       flattenCESAppVersionSnapshotToolsDisplayName(original["displayName"], d, config),
			"etag":               flattenCESAppVersionSnapshotToolsEtag(original["etag"], d, config),
			"execution_type":     flattenCESAppVersionSnapshotToolsExecutionType(original["executionType"], d, config),
			"generated_summary":  flattenCESAppVersionSnapshotToolsGeneratedSummary(original["generatedSummary"], d, config),
			"google_search_tool": flattenCESAppVersionSnapshotToolsGoogleSearchTool(original["googleSearchTool"], d, config),
			"name":               flattenCESAppVersionSnapshotToolsName(original["name"], d, config),
			"open_api_tool":      flattenCESAppVersionSnapshotToolsOpenApiTool(original["openApiTool"], d, config),
			"python_function":    flattenCESAppVersionSnapshotToolsPythonFunction(original["pythonFunction"], d, config),
			"update_time":        flattenCESAppVersionSnapshotToolsUpdateTime(original["updateTime"], d, config),
			"system_tool":        flattenCESAppVersionSnapshotToolsSystemTool(original["systemTool"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotToolsClientFunction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESAppVersionSnapshotToolsClientFunctionDescription(original["description"], d, config)
	transformed["name"] =
		flattenCESAppVersionSnapshotToolsClientFunctionName(original["name"], d, config)
	transformed["parameters"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParameters(original["parameters"], d, config)
	transformed["response"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponse(original["response"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsClientFunctionDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionParameters(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersDescription(original["description"], d, config)
	transformed["enum"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersEnum(original["enum"], d, config)
	transformed["nullable"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersNullable(original["nullable"], d, config)
	transformed["ref"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersRef(original["ref"], d, config)
	transformed["required"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersRequired(original["required"], d, config)
	transformed["type"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersType(original["type"], d, config)
	transformed["unique_items"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersUniqueItems(original["uniqueItems"], d, config)
	transformed["defs"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersDefs(original["defs"], d, config)
	transformed["default"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersDefault(original["default"], d, config)
	transformed["additional_properties"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersAdditionalProperties(original["additionalProperties"], d, config)
	transformed["any_of"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersAnyOf(original["anyOf"], d, config)
	transformed["prefix_items"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersPrefixItems(original["prefixItems"], d, config)
	transformed["properties"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersProperties(original["properties"], d, config)
	transformed["items"] =
		flattenCESAppVersionSnapshotToolsClientFunctionParametersItems(original["items"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsClientFunctionParametersDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersEnum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersNullable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersRef(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersRequired(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersUniqueItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersDefs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersDefault(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersAdditionalProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersAnyOf(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersPrefixItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsClientFunctionParametersItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponse(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseDescription(original["description"], d, config)
	transformed["enum"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseEnum(original["enum"], d, config)
	transformed["nullable"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseNullable(original["nullable"], d, config)
	transformed["ref"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseRef(original["ref"], d, config)
	transformed["required"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseRequired(original["required"], d, config)
	transformed["type"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseType(original["type"], d, config)
	transformed["unique_items"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseUniqueItems(original["uniqueItems"], d, config)
	transformed["defs"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseDefs(original["defs"], d, config)
	transformed["default"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseDefault(original["default"], d, config)
	transformed["additional_properties"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseAdditionalProperties(original["additionalProperties"], d, config)
	transformed["any_of"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseAnyOf(original["anyOf"], d, config)
	transformed["prefix_items"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponsePrefixItems(original["prefixItems"], d, config)
	transformed["properties"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseProperties(original["properties"], d, config)
	transformed["items"] =
		flattenCESAppVersionSnapshotToolsClientFunctionResponseItems(original["items"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsClientFunctionResponseDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseEnum(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseNullable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseRef(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseRequired(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseUniqueItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseDefs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseDefault(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseAdditionalProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseAnyOf(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponsePrefixItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsClientFunctionResponseItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	b, err := json.Marshal(v)
	if err != nil {
		// TODO: return error once https://github.com/GoogleCloudPlatform/magic-modules/issues/3257 is fixed.
		log.Printf("[ERROR] failed to marshal schema to JSON: %v", err)
	}
	return string(b)
}

func flattenCESAppVersionSnapshotToolsCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["boost_specs"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecs(original["boostSpecs"], d, config)
	transformed["description"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolDescription(original["description"], d, config)
	transformed["engine_source"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSource(original["engineSource"], d, config)
	transformed["max_results"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolMaxResults(original["maxResults"], d, config)
	transformed["modality_configs"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigs(original["modalityConfigs"], d, config)
	transformed["name"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"data_stores": flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsDataStores(original["dataStores"], d, config),
			"spec":        flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpec(original["spec"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsDataStores(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"condition_boost_specs": flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecs(original["conditionBoostSpecs"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"boost":              flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoost(original["boost"], d, config),
			"boost_control_spec": flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpec(original["boostControlSpec"], d, config),
			"condition":          flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsCondition(original["condition"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoost(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["attribute_type"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecAttributeType(original["attributeType"], d, config)
	transformed["control_points"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPoints(original["controlPoints"], d, config)
	transformed["field_name"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecFieldName(original["fieldName"], d, config)
	transformed["interpolation_type"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecInterpolationType(original["interpolationType"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecAttributeType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"attribute_value": flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsAttributeValue(original["attributeValue"], d, config),
			"boost_amount":    flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsBoostAmount(original["boostAmount"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsAttributeValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecControlPointsBoostAmount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecFieldName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsBoostControlSpecInterpolationType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolBoostSpecsSpecConditionBoostSpecsCondition(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["data_store_sources"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSources(original["dataStoreSources"], d, config)
	transformed["engine"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceEngine(original["engine"], d, config)
	transformed["filter"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceFilter(original["filter"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"data_store": flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStore(original["dataStore"], d, config),
			"filter":     flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesFilter(original["filter"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStore(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["connector_config"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfig(original["connectorConfig"], d, config)
	transformed["create_time"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreCreateTime(original["createTime"], d, config)
	transformed["display_name"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreDisplayName(original["displayName"], d, config)
	transformed["document_processing_mode"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreDocumentProcessingMode(original["documentProcessingMode"], d, config)
	transformed["name"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreName(original["name"], d, config)
	transformed["type"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreType(original["type"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["collection"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollection(original["collection"], d, config)
	transformed["collection_display_name"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollectionDisplayName(original["collectionDisplayName"], d, config)
	transformed["data_source"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigDataSource(original["dataSource"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollection(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigCollectionDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreConnectorConfigDataSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreDocumentProcessingMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesDataStoreType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceDataStoreSourcesFilter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceEngine(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolEngineSourceFilter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolMaxResults(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"grounding_config":     flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsGroundingConfig(original["groundingConfig"], d, config),
			"modality_type":        flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsModalityType(original["modalityType"], d, config),
			"rewriter_config":      flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfig(original["rewriterConfig"], d, config),
			"summarization_config": flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfig(original["summarizationConfig"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsGroundingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disabled"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsGroundingConfigDisabled(original["disabled"], d, config)
	transformed["grounding_level"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsGroundingConfigGroundingLevel(original["groundingLevel"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsGroundingConfigDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsGroundingConfigGroundingLevel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsModalityType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disabled"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfigDisabled(original["disabled"], d, config)
	transformed["model_settings"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfigModelSettings(original["modelSettings"], d, config)
	transformed["prompt"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfigPrompt(original["prompt"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfigDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfigModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfigModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfigModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfigModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfigModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsRewriterConfigPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disabled"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfigDisabled(original["disabled"], d, config)
	transformed["model_settings"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfigModelSettings(original["modelSettings"], d, config)
	transformed["prompt"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfigPrompt(original["prompt"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfigDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfigModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfigModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfigModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfigModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfigModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolModalityConfigsSummarizationConfigPrompt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDataStoreToolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsExecutionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsGeneratedSummary(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsGoogleSearchTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESAppVersionSnapshotToolsGoogleSearchToolDescription(original["description"], d, config)
	transformed["exclude_domains"] =
		flattenCESAppVersionSnapshotToolsGoogleSearchToolExcludeDomains(original["excludeDomains"], d, config)
	transformed["name"] =
		flattenCESAppVersionSnapshotToolsGoogleSearchToolName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsGoogleSearchToolDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsGoogleSearchToolExcludeDomains(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsGoogleSearchToolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenCESAppVersionSnapshotToolsOpenApiTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_authentication"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthentication(original["apiAuthentication"], d, config)
	transformed["description"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolDescription(original["description"], d, config)
	transformed["ignore_unknown_fields"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolIgnoreUnknownFields(original["ignoreUnknownFields"], d, config)
	transformed["name"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolName(original["name"], d, config)
	transformed["open_api_schema"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolOpenApiSchema(original["openApiSchema"], d, config)
	transformed["service_directory_config"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolServiceDirectoryConfig(original["serviceDirectoryConfig"], d, config)
	transformed["tls_config"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolTlsConfig(original["tlsConfig"], d, config)
	transformed["url"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolUrl(original["url"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthentication(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_key_config"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationApiKeyConfig(original["apiKeyConfig"], d, config)
	transformed["oauth_config"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfig(original["oauthConfig"], d, config)
	transformed["service_account_auth_config"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationServiceAccountAuthConfig(original["serviceAccountAuthConfig"], d, config)
	transformed["service_agent_id_token_auth_config"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig(original["serviceAgentIdTokenAuthConfig"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationApiKeyConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_key_secret_version"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationApiKeyConfigApiKeySecretVersion(original["apiKeySecretVersion"], d, config)
	transformed["key_name"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationApiKeyConfigKeyName(original["keyName"], d, config)
	transformed["request_location"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationApiKeyConfigRequestLocation(original["requestLocation"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationApiKeyConfigApiKeySecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationApiKeyConfigKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationApiKeyConfigRequestLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["client_id"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfigClientId(original["clientId"], d, config)
	transformed["client_secret_version"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfigClientSecretVersion(original["clientSecretVersion"], d, config)
	transformed["oauth_grant_type"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfigOauthGrantType(original["oauthGrantType"], d, config)
	transformed["scopes"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfigScopes(original["scopes"], d, config)
	transformed["token_endpoint"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfigTokenEndpoint(original["tokenEndpoint"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfigClientId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfigClientSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfigOauthGrantType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfigScopes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationOauthConfigTokenEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationServiceAccountAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_account"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationServiceAccountAuthConfigServiceAccount(original["serviceAccount"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationServiceAccountAuthConfigServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenCESAppVersionSnapshotToolsOpenApiToolDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolIgnoreUnknownFields(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolOpenApiSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolServiceDirectoryConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolServiceDirectoryConfigService(original["service"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsOpenApiToolServiceDirectoryConfigService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolTlsConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ca_certs"] =
		flattenCESAppVersionSnapshotToolsOpenApiToolTlsConfigCaCerts(original["caCerts"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsOpenApiToolTlsConfigCaCerts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"cert":         flattenCESAppVersionSnapshotToolsOpenApiToolTlsConfigCaCertsCert(original["cert"], d, config),
			"display_name": flattenCESAppVersionSnapshotToolsOpenApiToolTlsConfigCaCertsDisplayName(original["displayName"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotToolsOpenApiToolTlsConfigCaCertsCert(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolTlsConfigCaCertsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsOpenApiToolUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsPythonFunction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESAppVersionSnapshotToolsPythonFunctionDescription(original["description"], d, config)
	transformed["name"] =
		flattenCESAppVersionSnapshotToolsPythonFunctionName(original["name"], d, config)
	transformed["python_code"] =
		flattenCESAppVersionSnapshotToolsPythonFunctionPythonCode(original["pythonCode"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsPythonFunctionDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsPythonFunctionName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsPythonFunctionPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsSystemTool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenCESAppVersionSnapshotToolsSystemToolDescription(original["description"], d, config)
	transformed["name"] =
		flattenCESAppVersionSnapshotToolsSystemToolName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsSystemToolDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsSystemToolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsets(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"create_time":      flattenCESAppVersionSnapshotToolsetsCreateTime(original["createTime"], d, config),
			"description":      flattenCESAppVersionSnapshotToolsetsDescription(original["description"], d, config),
			"display_name":     flattenCESAppVersionSnapshotToolsetsDisplayName(original["displayName"], d, config),
			"etag":             flattenCESAppVersionSnapshotToolsetsEtag(original["etag"], d, config),
			"execution_type":   flattenCESAppVersionSnapshotToolsetsExecutionType(original["executionType"], d, config),
			"name":             flattenCESAppVersionSnapshotToolsetsName(original["name"], d, config),
			"open_api_toolset": flattenCESAppVersionSnapshotToolsetsOpenApiToolset(original["openApiToolset"], d, config),
			"update_time":      flattenCESAppVersionSnapshotToolsetsUpdateTime(original["updateTime"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotToolsetsCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsExecutionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_authentication"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthentication(original["apiAuthentication"], d, config)
	transformed["ignore_unknown_fields"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetIgnoreUnknownFields(original["ignoreUnknownFields"], d, config)
	transformed["open_api_schema"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetOpenApiSchema(original["openApiSchema"], d, config)
	transformed["service_directory_config"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetServiceDirectoryConfig(original["serviceDirectoryConfig"], d, config)
	transformed["tls_config"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetTlsConfig(original["tlsConfig"], d, config)
	transformed["url"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetUrl(original["url"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthentication(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_key_config"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationApiKeyConfig(original["apiKeyConfig"], d, config)
	transformed["oauth_config"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfig(original["oauthConfig"], d, config)
	transformed["service_account_auth_config"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationServiceAccountAuthConfig(original["serviceAccountAuthConfig"], d, config)
	transformed["service_agent_id_token_auth_config"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig(original["serviceAgentIdTokenAuthConfig"], d, config)
	transformed["bearer_token_config"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationBearerTokenConfig(original["bearerTokenConfig"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationApiKeyConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["api_key_secret_version"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationApiKeyConfigApiKeySecretVersion(original["apiKeySecretVersion"], d, config)
	transformed["key_name"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationApiKeyConfigKeyName(original["keyName"], d, config)
	transformed["request_location"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationApiKeyConfigRequestLocation(original["requestLocation"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationApiKeyConfigApiKeySecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationApiKeyConfigKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationApiKeyConfigRequestLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["client_id"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfigClientId(original["clientId"], d, config)
	transformed["client_secret_version"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfigClientSecretVersion(original["clientSecretVersion"], d, config)
	transformed["oauth_grant_type"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfigOauthGrantType(original["oauthGrantType"], d, config)
	transformed["scopes"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfigScopes(original["scopes"], d, config)
	transformed["token_endpoint"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfigTokenEndpoint(original["tokenEndpoint"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfigClientId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfigClientSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfigOauthGrantType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfigScopes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationOauthConfigTokenEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationServiceAccountAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_account"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationServiceAccountAuthConfigServiceAccount(original["serviceAccount"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationServiceAccountAuthConfigServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationBearerTokenConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["token"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationBearerTokenConfigToken(original["token"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetApiAuthenticationBearerTokenConfigToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetIgnoreUnknownFields(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetOpenApiSchema(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetServiceDirectoryConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetServiceDirectoryConfigService(original["service"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetServiceDirectoryConfigService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetTlsConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ca_certs"] =
		flattenCESAppVersionSnapshotToolsetsOpenApiToolsetTlsConfigCaCerts(original["caCerts"], d, config)
	return []interface{}{transformed}
}
func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetTlsConfigCaCerts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"cert":         flattenCESAppVersionSnapshotToolsetsOpenApiToolsetTlsConfigCaCertsCert(original["cert"], d, config),
			"display_name": flattenCESAppVersionSnapshotToolsetsOpenApiToolsetTlsConfigCaCertsDisplayName(original["displayName"], d, config),
		})
	}
	return transformed
}
func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetTlsConfigCaCertsCert(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetTlsConfigCaCertsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsOpenApiToolsetUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAppVersionSnapshotToolsetsUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandCESAppVersionDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAppVersionDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceCESAppVersionPostCreateSetComputedFields(d *schema.ResourceData, meta interface{}, res map[string]interface{}) error {
	config := meta.(*transport_tpg.Config)
	if err := d.Set("name", flattenCESAppVersionName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}
	return nil
}
