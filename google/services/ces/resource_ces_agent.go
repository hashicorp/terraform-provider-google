// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/ces/Agent.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package ces

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceCESAgent() *schema.Resource {
	return &schema.Resource{
		Create: resourceCESAgentCreate,
		Read:   resourceCESAgentRead,
		Update: resourceCESAgentUpdate,
		Delete: resourceCESAgentDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCESAgentImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"app": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"app": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Display name of the agent.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"after_agent_callbacks": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `The callbacks to execute after the agent is called.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"python_code": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The python code to execute for the callback.`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Human-readable description of the callback.`,
						},
						"disabled": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
						},
					},
				},
			},
			"after_model_callbacks": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `The callbacks to execute after the model is called. If there are multiple
calls to the model, the callback will be executed multiple times.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"python_code": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The python code to execute for the callback.`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Human-readable description of the callback.`,
						},
						"disabled": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
						},
					},
				},
			},
			"after_tool_callbacks": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `The callbacks to execute after the tool is invoked. If there are multiple
tool invocations, the callback will be executed multiple times.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"python_code": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The python code to execute for the callback.`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Human-readable description of the callback.`,
						},
						"disabled": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
						},
					},
				},
			},
			"agent_id": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `The ID to use for the agent, which will become the final component of
the agent's resource name. If not provided, a unique ID will be
automatically assigned for the agent.`,
			},
			"before_agent_callbacks": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `The callbacks to execute before the agent is called.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"python_code": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The python code to execute for the callback.`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Human-readable description of the callback.`,
						},
						"disabled": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
						},
					},
				},
			},
			"before_model_callbacks": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `The callbacks to execute before the model is called. If there are multiple
calls to the model, the callback will be executed multiple times.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"python_code": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The python code to execute for the callback.`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Human-readable description of the callback.`,
						},
						"disabled": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
						},
					},
				},
			},
			"before_tool_callbacks": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `The callbacks to execute before the tool is invoked. If there are multiple
tool invocations, the callback will be executed multiple times.
The provided callbacks are executed sequentially in the exact order they
are given in the list. If a callback returns an overridden response,
execution stops and any remaining callbacks are skipped.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"python_code": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The python code to execute for the callback.`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Human-readable description of the callback.`,
						},
						"disabled": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Whether the callback is disabled. Disabled callbacks are ignored by the
agent.`,
						},
					},
				},
			},
			"child_agents": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `List of child agents in the agent tree.
Format: 'projects/{project}/locations/{location}/apps/{app}/agents/{agent}'`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Human-readable description of the agent.`,
			},
			"guardrails": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `List of guardrails for the agent.
Format:
'projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}'`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"instruction": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Instructions for the LLM model to guide the agent's behavior.`,
			},
			"llm_agent": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Default agent type. The agent uses instructions and callbacks specified in
the agent to perform the task using a large language model.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{},
				},
			},
			"model_settings": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Model settings contains various configurations for the LLM model.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"model": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The LLM model that the agent should use.
If not set, the agent will inherit the model from its parent agent.`,
						},
						"temperature": {
							Type:     schema.TypeFloat,
							Optional: true,
							Description: `If set, this temperature will be used for the LLM model. Temperature
controls the randomness of the model's responses. Lower temperatures
produce responses that are more predictable. Higher temperatures produce
responses that are more creative.`,
						},
					},
				},
			},
			"remote_dialogflow_agent": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `The agent which will transfer execution to an existing remote
[Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents)
agent flow. The corresponding Dialogflow agent will process subsequent user
queries until the session ends or flow ends and the control is transferred
back to the parent CES agent.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"agent": {
							Type:     schema.TypeString,
							Required: true,
							Description: `The
[Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents
agent resource name.
Format: 'projects/{project}/locations/{location}/agents/{agent}'`,
						},
						"flow_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The flow ID of the flow in the Dialogflow agent.`,
						},
						"environment_id": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The environment ID of the Dialogflow agent be used for the agent
execution. If not specified, the draft environment will be used.`,
						},
						"input_variable_mapping": {
							Type:     schema.TypeMap,
							Optional: true,
							Description: `The mapping of the app variables names to the Dialogflow session
parameters names to be sent to the Dialogflow agent as input.`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"output_variable_mapping": {
							Type:     schema.TypeMap,
							Optional: true,
							Description: `The mapping of the Dialogflow session parameters names to the app
variables names to be sent back to the CES agent after the Dialogflow
agent execution ends.`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			"tools": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `List of available tools for the agent.
Format: 'projects/{project}/locations/{location}/apps/{app}/tools/{tool}'`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"toolsets": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `List of toolsets for the agent.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"toolset": {
							Type:     schema.TypeString,
							Required: true,
							Description: `The resource name of the toolset.
Format:
'projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}'`,
						},
						"tool_ids": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `The tools IDs to filter the toolset.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp when the agent was created.`,
			},
			"etag": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Etag used to ensure the object hasn't changed during a read-modify-write
operation. If the etag is empty, the update will overwrite any concurrent
changes.`,
			},
			"generated_summary": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `If the agent is generated by the LLM assistant, this field contains a
descriptive summary of the generation.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The unique identifier of the agent.
Format: 'projects/{project}/locations/{location}/apps/{app}/agents/{agent}'`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Timestamp when the agent was last updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCESAgentCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	afterAgentCallbacksProp, err := expandCESAgentAfterAgentCallbacks(d.Get("after_agent_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("after_agent_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(afterAgentCallbacksProp)) && (ok || !reflect.DeepEqual(v, afterAgentCallbacksProp)) {
		obj["afterAgentCallbacks"] = afterAgentCallbacksProp
	}
	afterModelCallbacksProp, err := expandCESAgentAfterModelCallbacks(d.Get("after_model_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("after_model_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(afterModelCallbacksProp)) && (ok || !reflect.DeepEqual(v, afterModelCallbacksProp)) {
		obj["afterModelCallbacks"] = afterModelCallbacksProp
	}
	afterToolCallbacksProp, err := expandCESAgentAfterToolCallbacks(d.Get("after_tool_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("after_tool_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(afterToolCallbacksProp)) && (ok || !reflect.DeepEqual(v, afterToolCallbacksProp)) {
		obj["afterToolCallbacks"] = afterToolCallbacksProp
	}
	beforeAgentCallbacksProp, err := expandCESAgentBeforeAgentCallbacks(d.Get("before_agent_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("before_agent_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(beforeAgentCallbacksProp)) && (ok || !reflect.DeepEqual(v, beforeAgentCallbacksProp)) {
		obj["beforeAgentCallbacks"] = beforeAgentCallbacksProp
	}
	beforeModelCallbacksProp, err := expandCESAgentBeforeModelCallbacks(d.Get("before_model_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("before_model_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(beforeModelCallbacksProp)) && (ok || !reflect.DeepEqual(v, beforeModelCallbacksProp)) {
		obj["beforeModelCallbacks"] = beforeModelCallbacksProp
	}
	beforeToolCallbacksProp, err := expandCESAgentBeforeToolCallbacks(d.Get("before_tool_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("before_tool_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(beforeToolCallbacksProp)) && (ok || !reflect.DeepEqual(v, beforeToolCallbacksProp)) {
		obj["beforeToolCallbacks"] = beforeToolCallbacksProp
	}
	childAgentsProp, err := expandCESAgentChildAgents(d.Get("child_agents"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("child_agents"); !tpgresource.IsEmptyValue(reflect.ValueOf(childAgentsProp)) && (ok || !reflect.DeepEqual(v, childAgentsProp)) {
		obj["childAgents"] = childAgentsProp
	}
	descriptionProp, err := expandCESAgentDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	displayNameProp, err := expandCESAgentDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	guardrailsProp, err := expandCESAgentGuardrails(d.Get("guardrails"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("guardrails"); !tpgresource.IsEmptyValue(reflect.ValueOf(guardrailsProp)) && (ok || !reflect.DeepEqual(v, guardrailsProp)) {
		obj["guardrails"] = guardrailsProp
	}
	instructionProp, err := expandCESAgentInstruction(d.Get("instruction"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("instruction"); !tpgresource.IsEmptyValue(reflect.ValueOf(instructionProp)) && (ok || !reflect.DeepEqual(v, instructionProp)) {
		obj["instruction"] = instructionProp
	}
	modelSettingsProp, err := expandCESAgentModelSettings(d.Get("model_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("model_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(modelSettingsProp)) && (ok || !reflect.DeepEqual(v, modelSettingsProp)) {
		obj["modelSettings"] = modelSettingsProp
	}
	llmAgentProp, err := expandCESAgentLlmAgent(d.Get("llm_agent"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("llm_agent"); ok || !reflect.DeepEqual(v, llmAgentProp) {
		obj["llmAgent"] = llmAgentProp
	}
	remoteDialogflowAgentProp, err := expandCESAgentRemoteDialogflowAgent(d.Get("remote_dialogflow_agent"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("remote_dialogflow_agent"); !tpgresource.IsEmptyValue(reflect.ValueOf(remoteDialogflowAgentProp)) && (ok || !reflect.DeepEqual(v, remoteDialogflowAgentProp)) {
		obj["remoteDialogflowAgent"] = remoteDialogflowAgentProp
	}
	toolsProp, err := expandCESAgentTools(d.Get("tools"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("tools"); !tpgresource.IsEmptyValue(reflect.ValueOf(toolsProp)) && (ok || !reflect.DeepEqual(v, toolsProp)) {
		obj["tools"] = toolsProp
	}
	toolsetsProp, err := expandCESAgentToolsets(d.Get("toolsets"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("toolsets"); !tpgresource.IsEmptyValue(reflect.ValueOf(toolsetsProp)) && (ok || !reflect.DeepEqual(v, toolsetsProp)) {
		obj["toolsets"] = toolsetsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/agents?agentId={{agent_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Agent: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Agent: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Agent: %s", err)
	}
	// Set computed resource properties from create API response so that they're available on the subsequent Read
	// call.
	err = resourceCESAgentPostCreateSetComputedFields(d, meta, res)
	if err != nil {
		return fmt.Errorf("setting computed ID format fields: %w", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{app}}/agents/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Agent %q: %#v", d.Id(), res)

	return resourceCESAgentRead(d, meta)
}

func resourceCESAgentRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/agents/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Agent: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("CESAgent %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}

	if err := d.Set("after_agent_callbacks", flattenCESAgentAfterAgentCallbacks(res["afterAgentCallbacks"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("after_model_callbacks", flattenCESAgentAfterModelCallbacks(res["afterModelCallbacks"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("after_tool_callbacks", flattenCESAgentAfterToolCallbacks(res["afterToolCallbacks"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("before_agent_callbacks", flattenCESAgentBeforeAgentCallbacks(res["beforeAgentCallbacks"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("before_model_callbacks", flattenCESAgentBeforeModelCallbacks(res["beforeModelCallbacks"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("before_tool_callbacks", flattenCESAgentBeforeToolCallbacks(res["beforeToolCallbacks"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("child_agents", flattenCESAgentChildAgents(res["childAgents"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("create_time", flattenCESAgentCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("description", flattenCESAgentDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("display_name", flattenCESAgentDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("etag", flattenCESAgentEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("generated_summary", flattenCESAgentGeneratedSummary(res["generatedSummary"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("guardrails", flattenCESAgentGuardrails(res["guardrails"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("instruction", flattenCESAgentInstruction(res["instruction"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("model_settings", flattenCESAgentModelSettings(res["modelSettings"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("name", flattenCESAgentName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("llm_agent", flattenCESAgentLlmAgent(res["llmAgent"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("remote_dialogflow_agent", flattenCESAgentRemoteDialogflowAgent(res["remoteDialogflowAgent"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("tools", flattenCESAgentTools(res["tools"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("toolsets", flattenCESAgentToolsets(res["toolsets"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}
	if err := d.Set("update_time", flattenCESAgentUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Agent: %s", err)
	}

	identity, err := d.Identity()
	if err != nil && identity != nil {
		if v, ok := identity.GetOk("name"); ok && v != "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("location"); ok && v != "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("app"); ok && v != "" {
			err = identity.Set("app", d.Get("app").(string))
			if err != nil {
				return fmt.Errorf("Error setting app: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); ok && v != "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] identity not set: %s", err)
	}
	return nil
}

func resourceCESAgentUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Agent: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	afterAgentCallbacksProp, err := expandCESAgentAfterAgentCallbacks(d.Get("after_agent_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("after_agent_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, afterAgentCallbacksProp)) {
		obj["afterAgentCallbacks"] = afterAgentCallbacksProp
	}
	afterModelCallbacksProp, err := expandCESAgentAfterModelCallbacks(d.Get("after_model_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("after_model_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, afterModelCallbacksProp)) {
		obj["afterModelCallbacks"] = afterModelCallbacksProp
	}
	afterToolCallbacksProp, err := expandCESAgentAfterToolCallbacks(d.Get("after_tool_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("after_tool_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, afterToolCallbacksProp)) {
		obj["afterToolCallbacks"] = afterToolCallbacksProp
	}
	beforeAgentCallbacksProp, err := expandCESAgentBeforeAgentCallbacks(d.Get("before_agent_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("before_agent_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, beforeAgentCallbacksProp)) {
		obj["beforeAgentCallbacks"] = beforeAgentCallbacksProp
	}
	beforeModelCallbacksProp, err := expandCESAgentBeforeModelCallbacks(d.Get("before_model_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("before_model_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, beforeModelCallbacksProp)) {
		obj["beforeModelCallbacks"] = beforeModelCallbacksProp
	}
	beforeToolCallbacksProp, err := expandCESAgentBeforeToolCallbacks(d.Get("before_tool_callbacks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("before_tool_callbacks"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, beforeToolCallbacksProp)) {
		obj["beforeToolCallbacks"] = beforeToolCallbacksProp
	}
	childAgentsProp, err := expandCESAgentChildAgents(d.Get("child_agents"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("child_agents"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, childAgentsProp)) {
		obj["childAgents"] = childAgentsProp
	}
	descriptionProp, err := expandCESAgentDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	displayNameProp, err := expandCESAgentDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	guardrailsProp, err := expandCESAgentGuardrails(d.Get("guardrails"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("guardrails"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, guardrailsProp)) {
		obj["guardrails"] = guardrailsProp
	}
	instructionProp, err := expandCESAgentInstruction(d.Get("instruction"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("instruction"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, instructionProp)) {
		obj["instruction"] = instructionProp
	}
	modelSettingsProp, err := expandCESAgentModelSettings(d.Get("model_settings"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("model_settings"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, modelSettingsProp)) {
		obj["modelSettings"] = modelSettingsProp
	}
	llmAgentProp, err := expandCESAgentLlmAgent(d.Get("llm_agent"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("llm_agent"); ok || !reflect.DeepEqual(v, llmAgentProp) {
		obj["llmAgent"] = llmAgentProp
	}
	remoteDialogflowAgentProp, err := expandCESAgentRemoteDialogflowAgent(d.Get("remote_dialogflow_agent"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("remote_dialogflow_agent"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, remoteDialogflowAgentProp)) {
		obj["remoteDialogflowAgent"] = remoteDialogflowAgentProp
	}
	toolsProp, err := expandCESAgentTools(d.Get("tools"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("tools"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, toolsProp)) {
		obj["tools"] = toolsProp
	}
	toolsetsProp, err := expandCESAgentToolsets(d.Get("toolsets"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("toolsets"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, toolsetsProp)) {
		obj["toolsets"] = toolsetsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/agents/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Agent %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("after_agent_callbacks") {
		updateMask = append(updateMask, "afterAgentCallbacks")
	}

	if d.HasChange("after_model_callbacks") {
		updateMask = append(updateMask, "afterModelCallbacks")
	}

	if d.HasChange("after_tool_callbacks") {
		updateMask = append(updateMask, "afterToolCallbacks")
	}

	if d.HasChange("before_agent_callbacks") {
		updateMask = append(updateMask, "beforeAgentCallbacks")
	}

	if d.HasChange("before_model_callbacks") {
		updateMask = append(updateMask, "beforeModelCallbacks")
	}

	if d.HasChange("before_tool_callbacks") {
		updateMask = append(updateMask, "beforeToolCallbacks")
	}

	if d.HasChange("child_agents") {
		updateMask = append(updateMask, "childAgents")
	}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("display_name") {
		updateMask = append(updateMask, "displayName")
	}

	if d.HasChange("guardrails") {
		updateMask = append(updateMask, "guardrails")
	}

	if d.HasChange("instruction") {
		updateMask = append(updateMask, "instruction")
	}

	if d.HasChange("model_settings") {
		updateMask = append(updateMask, "modelSettings")
	}

	if d.HasChange("llm_agent") {
		updateMask = append(updateMask, "llmAgent")
	}

	if d.HasChange("remote_dialogflow_agent") {
		updateMask = append(updateMask, "remoteDialogflowAgent")
	}

	if d.HasChange("tools") {
		updateMask = append(updateMask, "tools")
	}

	if d.HasChange("toolsets") {
		updateMask = append(updateMask, "toolsets")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Agent %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Agent %q: %#v", d.Id(), res)
		}

	}

	return resourceCESAgentRead(d, meta)
}

func resourceCESAgentDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Agent: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{CESBasePath}}projects/{{project}}/locations/{{location}}/apps/{{app}}/agents/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Agent %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Agent")
	}

	log.Printf("[DEBUG] Finished deleting Agent %q: %#v", d.Id(), res)
	return nil
}

func resourceCESAgentImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/apps/(?P<app>[^/]+)/agents/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<app>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<app>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/apps/{{app}}/agents/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCESAgentAfterAgentCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAgentAfterAgentCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAgentAfterAgentCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAgentAfterAgentCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAgentAfterAgentCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentAfterAgentCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentAfterAgentCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentAfterModelCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAgentAfterModelCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAgentAfterModelCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAgentAfterModelCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAgentAfterModelCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentAfterModelCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentAfterModelCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentAfterToolCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAgentAfterToolCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAgentAfterToolCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAgentAfterToolCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAgentAfterToolCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentAfterToolCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentAfterToolCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentBeforeAgentCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAgentBeforeAgentCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAgentBeforeAgentCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAgentBeforeAgentCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAgentBeforeAgentCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentBeforeAgentCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentBeforeAgentCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentBeforeModelCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAgentBeforeModelCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAgentBeforeModelCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAgentBeforeModelCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAgentBeforeModelCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentBeforeModelCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentBeforeModelCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentBeforeToolCallbacks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"description": flattenCESAgentBeforeToolCallbacksDescription(original["description"], d, config),
			"disabled":    flattenCESAgentBeforeToolCallbacksDisabled(original["disabled"], d, config),
			"python_code": flattenCESAgentBeforeToolCallbacksPythonCode(original["pythonCode"], d, config),
		})
	}
	return transformed
}
func flattenCESAgentBeforeToolCallbacksDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentBeforeToolCallbacksDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentBeforeToolCallbacksPythonCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentChildAgents(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentGeneratedSummary(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentGuardrails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentInstruction(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentModelSettings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["model"] =
		flattenCESAgentModelSettingsModel(original["model"], d, config)
	transformed["temperature"] =
		flattenCESAgentModelSettingsTemperature(original["temperature"], d, config)
	return []interface{}{transformed}
}
func flattenCESAgentModelSettingsModel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentModelSettingsTemperature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.GetResourceNameFromSelfLink(v.(string))
}

func flattenCESAgentLlmAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenCESAgentRemoteDialogflowAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["agent"] =
		flattenCESAgentRemoteDialogflowAgentAgent(original["agent"], d, config)
	transformed["environment_id"] =
		flattenCESAgentRemoteDialogflowAgentEnvironmentId(original["environmentId"], d, config)
	transformed["flow_id"] =
		flattenCESAgentRemoteDialogflowAgentFlowId(original["flowId"], d, config)
	transformed["input_variable_mapping"] =
		flattenCESAgentRemoteDialogflowAgentInputVariableMapping(original["inputVariableMapping"], d, config)
	transformed["output_variable_mapping"] =
		flattenCESAgentRemoteDialogflowAgentOutputVariableMapping(original["outputVariableMapping"], d, config)
	return []interface{}{transformed}
}
func flattenCESAgentRemoteDialogflowAgentAgent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentRemoteDialogflowAgentEnvironmentId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentRemoteDialogflowAgentFlowId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentRemoteDialogflowAgentInputVariableMapping(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentRemoteDialogflowAgentOutputVariableMapping(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentTools(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentToolsets(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"toolset":  flattenCESAgentToolsetsToolset(original["toolset"], d, config),
			"tool_ids": flattenCESAgentToolsetsToolIds(original["toolIds"], d, config),
		})
	}
	return transformed
}
func flattenCESAgentToolsetsToolset(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentToolsetsToolIds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCESAgentUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandCESAgentAfterAgentCallbacks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDescription, err := expandCESAgentAfterAgentCallbacksDescription(original["description"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["description"] = transformedDescription
		}

		transformedDisabled, err := expandCESAgentAfterAgentCallbacksDisabled(original["disabled"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["disabled"] = transformedDisabled
		}

		transformedPythonCode, err := expandCESAgentAfterAgentCallbacksPythonCode(original["python_code"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPythonCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["pythonCode"] = transformedPythonCode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESAgentAfterAgentCallbacksDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentAfterAgentCallbacksDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentAfterAgentCallbacksPythonCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentAfterModelCallbacks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDescription, err := expandCESAgentAfterModelCallbacksDescription(original["description"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["description"] = transformedDescription
		}

		transformedDisabled, err := expandCESAgentAfterModelCallbacksDisabled(original["disabled"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["disabled"] = transformedDisabled
		}

		transformedPythonCode, err := expandCESAgentAfterModelCallbacksPythonCode(original["python_code"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPythonCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["pythonCode"] = transformedPythonCode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESAgentAfterModelCallbacksDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentAfterModelCallbacksDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentAfterModelCallbacksPythonCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentAfterToolCallbacks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDescription, err := expandCESAgentAfterToolCallbacksDescription(original["description"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["description"] = transformedDescription
		}

		transformedDisabled, err := expandCESAgentAfterToolCallbacksDisabled(original["disabled"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["disabled"] = transformedDisabled
		}

		transformedPythonCode, err := expandCESAgentAfterToolCallbacksPythonCode(original["python_code"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPythonCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["pythonCode"] = transformedPythonCode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESAgentAfterToolCallbacksDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentAfterToolCallbacksDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentAfterToolCallbacksPythonCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentBeforeAgentCallbacks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDescription, err := expandCESAgentBeforeAgentCallbacksDescription(original["description"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["description"] = transformedDescription
		}

		transformedDisabled, err := expandCESAgentBeforeAgentCallbacksDisabled(original["disabled"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["disabled"] = transformedDisabled
		}

		transformedPythonCode, err := expandCESAgentBeforeAgentCallbacksPythonCode(original["python_code"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPythonCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["pythonCode"] = transformedPythonCode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESAgentBeforeAgentCallbacksDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentBeforeAgentCallbacksDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentBeforeAgentCallbacksPythonCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentBeforeModelCallbacks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDescription, err := expandCESAgentBeforeModelCallbacksDescription(original["description"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["description"] = transformedDescription
		}

		transformedDisabled, err := expandCESAgentBeforeModelCallbacksDisabled(original["disabled"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["disabled"] = transformedDisabled
		}

		transformedPythonCode, err := expandCESAgentBeforeModelCallbacksPythonCode(original["python_code"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPythonCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["pythonCode"] = transformedPythonCode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESAgentBeforeModelCallbacksDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentBeforeModelCallbacksDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentBeforeModelCallbacksPythonCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentBeforeToolCallbacks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDescription, err := expandCESAgentBeforeToolCallbacksDescription(original["description"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["description"] = transformedDescription
		}

		transformedDisabled, err := expandCESAgentBeforeToolCallbacksDisabled(original["disabled"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["disabled"] = transformedDisabled
		}

		transformedPythonCode, err := expandCESAgentBeforeToolCallbacksPythonCode(original["python_code"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPythonCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["pythonCode"] = transformedPythonCode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESAgentBeforeToolCallbacksDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentBeforeToolCallbacksDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentBeforeToolCallbacksPythonCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentChildAgents(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentGuardrails(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentInstruction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentModelSettings(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedModel, err := expandCESAgentModelSettingsModel(original["model"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["model"] = transformedModel
	}

	transformedTemperature, err := expandCESAgentModelSettingsTemperature(original["temperature"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTemperature); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["temperature"] = transformedTemperature
	}

	return transformed, nil
}

func expandCESAgentModelSettingsModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentModelSettingsTemperature(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentLlmAgent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandCESAgentRemoteDialogflowAgent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAgent, err := expandCESAgentRemoteDialogflowAgentAgent(original["agent"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAgent); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["agent"] = transformedAgent
	}

	transformedEnvironmentId, err := expandCESAgentRemoteDialogflowAgentEnvironmentId(original["environment_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnvironmentId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["environmentId"] = transformedEnvironmentId
	}

	transformedFlowId, err := expandCESAgentRemoteDialogflowAgentFlowId(original["flow_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFlowId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["flowId"] = transformedFlowId
	}

	transformedInputVariableMapping, err := expandCESAgentRemoteDialogflowAgentInputVariableMapping(original["input_variable_mapping"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInputVariableMapping); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inputVariableMapping"] = transformedInputVariableMapping
	}

	transformedOutputVariableMapping, err := expandCESAgentRemoteDialogflowAgentOutputVariableMapping(original["output_variable_mapping"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputVariableMapping); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputVariableMapping"] = transformedOutputVariableMapping
	}

	return transformed, nil
}

func expandCESAgentRemoteDialogflowAgentAgent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentRemoteDialogflowAgentEnvironmentId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentRemoteDialogflowAgentFlowId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentRemoteDialogflowAgentInputVariableMapping(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCESAgentRemoteDialogflowAgentOutputVariableMapping(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCESAgentTools(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentToolsets(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedToolset, err := expandCESAgentToolsetsToolset(original["toolset"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedToolset); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["toolset"] = transformedToolset
		}

		transformedToolIds, err := expandCESAgentToolsetsToolIds(original["tool_ids"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedToolIds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["toolIds"] = transformedToolIds
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCESAgentToolsetsToolset(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCESAgentToolsetsToolIds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func resourceCESAgentPostCreateSetComputedFields(d *schema.ResourceData, meta interface{}, res map[string]interface{}) error {
	config := meta.(*transport_tpg.Config)
	if err := d.Set("name", flattenCESAgentName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}
	return nil
}
