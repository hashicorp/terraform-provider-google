// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/dataproc/SessionTemplate.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package dataproc

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceDataprocSessionTemplate() *schema.Resource {
	return &schema.Resource{
		Create: resourceDataprocSessionTemplateCreate,
		Read:   resourceDataprocSessionTemplateRead,
		Update: resourceDataprocSessionTemplateUpdate,
		Delete: resourceDataprocSessionTemplateDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDataprocSessionTemplateImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The resource name of the session template in the following format:
projects/{project}/locations/{location}/sessionTemplates/{template_id}`,
			},
			"environment_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Environment configuration for the session execution.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"execution_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Execution configuration for a workload.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"kms_key": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The Cloud KMS key to use for encryption.`,
									},
									"network_tags": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Tags used for network traffic control.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"service_account": {
										Type:        schema.TypeString,
										Computed:    true,
										Optional:    true,
										Description: `Service account that used to execute workload.`,
									},
									"staging_bucket": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `A Cloud Storage bucket used to stage workload dependencies, config files, and store
workload output and other ephemeral data, such as Spark history files. If you do not specify a staging bucket,
Cloud Dataproc will determine a Cloud Storage location according to the region where your workload is running,
and then create and manage project-level, per-location staging and temporary buckets.
This field requires a Cloud Storage bucket name, not a gs://... URI to a Cloud Storage bucket.`,
									},
									"subnetwork_uri": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Subnetwork configuration for workload execution.`,
									},
									"ttl": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										Description: `The duration after which the workload will be terminated.
When the workload exceeds this duration, it will be unconditionally terminated without waiting for ongoing
work to finish. If ttl is not specified for a session workload, the workload will be allowed to run until it
exits naturally (or run forever without exiting). If ttl is not specified for an interactive session,
it defaults to 24 hours. If ttl is not specified for a batch that uses 2.1+ runtime version, it defaults to 4 hours.
Minimum value is 10 minutes; maximum value is 14 days. If both ttl and idleTtl are specified (for an interactive session),
the conditions are treated as OR conditions: the workload will be terminated when it has been idle for idleTtl or
when ttl has been exceeded, whichever occurs first.`,
									},
								},
							},
						},
						"peripherals_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Peripherals configuration that workload has access to.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"metastore_service": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Resource name of an existing Dataproc Metastore service.`,
									},
									"spark_history_server_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `The Spark History Server configuration for the workload.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"dataproc_cluster": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Resource name of an existing Dataproc Cluster to act as a Spark History Server for the workload.`,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"jupyter_session": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Jupyter configuration for an interactive session.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"display_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Display name, shown in the Jupyter kernelspec card.`,
						},
						"kernel": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"PYTHON", "SCALA", ""}),
							Description:  `Kernel to be used with Jupyter interactive session. Possible values: ["PYTHON", "SCALA"]`,
						},
					},
				},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `The labels to associate with this session template.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"location": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The location in which the session template will be created in.`,
			},
			"runtime_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Runtime configuration for the session template.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"container_image": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Optional custom container image for the job runtime environment. If not specified, a default container image will be used.`,
						},
						"properties": {
							Type:        schema.TypeMap,
							Optional:    true,
							Description: `A mapping of property names to values, which are used to configure workload execution.`,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
						"version": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Version of the session runtime.`,
						},
						"effective_properties": {
							Type:        schema.TypeMap,
							Computed:    true,
							Description: `A mapping of property names to values, which are used to configure workload execution.`,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			"spark_connect_session": {
				Type:             schema.TypeList,
				Optional:         true,
				DiffSuppressFunc: tpgresource.EmptyOrUnsetBlockDiffSuppress,
				Description:      `Spark connect configuration for an interactive session.`,
				MaxItems:         1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time when the session template was created.`,
			},
			"creator": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The email address of the user who created the session template.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time when the session template was updated.`,
			},
			"uuid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `A session template UUID (Unique Universal Identifier). The service generates this value when it creates the session template.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDataprocSessionTemplateCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandDataprocSessionTemplateName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	runtimeConfigProp, err := expandDataprocSessionTemplateRuntimeConfig(d.Get("runtime_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("runtime_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(runtimeConfigProp)) && (ok || !reflect.DeepEqual(v, runtimeConfigProp)) {
		obj["runtimeConfig"] = runtimeConfigProp
	}
	environmentConfigProp, err := expandDataprocSessionTemplateEnvironmentConfig(d.Get("environment_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("environment_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(environmentConfigProp)) && (ok || !reflect.DeepEqual(v, environmentConfigProp)) {
		obj["environmentConfig"] = environmentConfigProp
	}
	jupyterSessionProp, err := expandDataprocSessionTemplateJupyterSession(d.Get("jupyter_session"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("jupyter_session"); !tpgresource.IsEmptyValue(reflect.ValueOf(jupyterSessionProp)) && (ok || !reflect.DeepEqual(v, jupyterSessionProp)) {
		obj["jupyterSession"] = jupyterSessionProp
	}
	sparkConnectSessionProp, err := expandDataprocSessionTemplateSparkConnectSession(d.Get("spark_connect_session"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("spark_connect_session"); ok || !reflect.DeepEqual(v, sparkConnectSessionProp) {
		obj["sparkConnectSession"] = sparkConnectSessionProp
	}
	labelsProp, err := expandDataprocSessionTemplateEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DataprocBasePath}}projects/{{project}}/locations/{{location}}/sessionTemplates")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new SessionTemplate: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SessionTemplate: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating SessionTemplate: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating SessionTemplate %q: %#v", d.Id(), res)

	return resourceDataprocSessionTemplateRead(d, meta)
}

func resourceDataprocSessionTemplateRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DataprocBasePath}}{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SessionTemplate: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DataprocSessionTemplate %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}

	if err := d.Set("name", flattenDataprocSessionTemplateName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}
	if err := d.Set("uuid", flattenDataprocSessionTemplateUuid(res["uuid"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}
	if err := d.Set("create_time", flattenDataprocSessionTemplateCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}
	if err := d.Set("update_time", flattenDataprocSessionTemplateUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}
	if err := d.Set("creator", flattenDataprocSessionTemplateCreator(res["creator"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}
	if err := d.Set("labels", flattenDataprocSessionTemplateLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}
	if err := d.Set("runtime_config", flattenDataprocSessionTemplateRuntimeConfig(res["runtimeConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}
	if err := d.Set("environment_config", flattenDataprocSessionTemplateEnvironmentConfig(res["environmentConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}
	if err := d.Set("jupyter_session", flattenDataprocSessionTemplateJupyterSession(res["jupyterSession"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}
	if err := d.Set("spark_connect_session", flattenDataprocSessionTemplateSparkConnectSession(res["sparkConnectSession"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}
	if err := d.Set("terraform_labels", flattenDataprocSessionTemplateTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}
	if err := d.Set("effective_labels", flattenDataprocSessionTemplateEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading SessionTemplate: %s", err)
	}

	return nil
}

func resourceDataprocSessionTemplateUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SessionTemplate: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	runtimeConfigProp, err := expandDataprocSessionTemplateRuntimeConfig(d.Get("runtime_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("runtime_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, runtimeConfigProp)) {
		obj["runtimeConfig"] = runtimeConfigProp
	}
	environmentConfigProp, err := expandDataprocSessionTemplateEnvironmentConfig(d.Get("environment_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("environment_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, environmentConfigProp)) {
		obj["environmentConfig"] = environmentConfigProp
	}
	jupyterSessionProp, err := expandDataprocSessionTemplateJupyterSession(d.Get("jupyter_session"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("jupyter_session"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, jupyterSessionProp)) {
		obj["jupyterSession"] = jupyterSessionProp
	}
	sparkConnectSessionProp, err := expandDataprocSessionTemplateSparkConnectSession(d.Get("spark_connect_session"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("spark_connect_session"); ok || !reflect.DeepEqual(v, sparkConnectSessionProp) {
		obj["sparkConnectSession"] = sparkConnectSessionProp
	}
	labelsProp, err := expandDataprocSessionTemplateEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DataprocBasePath}}{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating SessionTemplate %q: %#v", d.Id(), obj)
	headers := make(http.Header)

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "PATCH",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutUpdate),
		Headers:   headers,
	})

	if err != nil {
		return fmt.Errorf("Error updating SessionTemplate %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating SessionTemplate %q: %#v", d.Id(), res)
	}

	return resourceDataprocSessionTemplateRead(d, meta)
}

func resourceDataprocSessionTemplateDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for SessionTemplate: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{DataprocBasePath}}{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting SessionTemplate %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "SessionTemplate")
	}

	log.Printf("[DEBUG] Finished deleting SessionTemplate %q: %#v", d.Id(), res)
	return nil
}

func resourceDataprocSessionTemplateImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)

	// current import_formats can't import fields with forward slashes in their value
	if err := tpgresource.ParseImportId([]string{"(?P<name>.+)"}, d, config); err != nil {
		return nil, err
	}

	name := d.Get("name").(string)

	if err := d.Set("name", name); err != nil {
		return nil, fmt.Errorf("Error setting name: %s", err)
	}
	d.SetId(name)
	return []*schema.ResourceData{d}, nil
}

func flattenDataprocSessionTemplateName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateUuid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateCreator(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDataprocSessionTemplateRuntimeConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["version"] =
		flattenDataprocSessionTemplateRuntimeConfigVersion(original["version"], d, config)
	transformed["container_image"] =
		flattenDataprocSessionTemplateRuntimeConfigContainerImage(original["containerImage"], d, config)
	transformed["properties"] =
		flattenDataprocSessionTemplateRuntimeConfigProperties(original["properties"], d, config)
	transformed["effective_properties"] =
		flattenDataprocSessionTemplateRuntimeConfigEffectiveProperties(original["effective_properties"], d, config)
	return []interface{}{transformed}
}
func flattenDataprocSessionTemplateRuntimeConfigVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateRuntimeConfigContainerImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateRuntimeConfigProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateRuntimeConfigEffectiveProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateEnvironmentConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["execution_config"] =
		flattenDataprocSessionTemplateEnvironmentConfigExecutionConfig(original["executionConfig"], d, config)
	transformed["peripherals_config"] =
		flattenDataprocSessionTemplateEnvironmentConfigPeripheralsConfig(original["peripheralsConfig"], d, config)
	return []interface{}{transformed}
}
func flattenDataprocSessionTemplateEnvironmentConfigExecutionConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_account"] =
		flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigServiceAccount(original["serviceAccount"], d, config)
	transformed["network_tags"] =
		flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigNetworkTags(original["networkTags"], d, config)
	transformed["kms_key"] =
		flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigKmsKey(original["kmsKey"], d, config)
	transformed["ttl"] =
		flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigTtl(original["ttl"], d, config)
	transformed["staging_bucket"] =
		flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigStagingBucket(original["stagingBucket"], d, config)
	transformed["subnetwork_uri"] =
		flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigSubnetworkUri(original["subnetworkUri"], d, config)
	return []interface{}{transformed}
}
func flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigNetworkTags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigKmsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigTtl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigStagingBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateEnvironmentConfigExecutionConfigSubnetworkUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateEnvironmentConfigPeripheralsConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["metastore_service"] =
		flattenDataprocSessionTemplateEnvironmentConfigPeripheralsConfigMetastoreService(original["metastoreService"], d, config)
	transformed["spark_history_server_config"] =
		flattenDataprocSessionTemplateEnvironmentConfigPeripheralsConfigSparkHistoryServerConfig(original["sparkHistoryServerConfig"], d, config)
	return []interface{}{transformed}
}
func flattenDataprocSessionTemplateEnvironmentConfigPeripheralsConfigMetastoreService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateEnvironmentConfigPeripheralsConfigSparkHistoryServerConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dataproc_cluster"] =
		flattenDataprocSessionTemplateEnvironmentConfigPeripheralsConfigSparkHistoryServerConfigDataprocCluster(original["dataprocCluster"], d, config)
	return []interface{}{transformed}
}
func flattenDataprocSessionTemplateEnvironmentConfigPeripheralsConfigSparkHistoryServerConfigDataprocCluster(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateJupyterSession(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["kernel"] =
		flattenDataprocSessionTemplateJupyterSessionKernel(original["kernel"], d, config)
	transformed["display_name"] =
		flattenDataprocSessionTemplateJupyterSessionDisplayName(original["displayName"], d, config)
	return []interface{}{transformed}
}
func flattenDataprocSessionTemplateJupyterSessionKernel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateJupyterSessionDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataprocSessionTemplateSparkConnectSession(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDataprocSessionTemplateTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDataprocSessionTemplateEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandDataprocSessionTemplateName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateRuntimeConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedVersion, err := expandDataprocSessionTemplateRuntimeConfigVersion(original["version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["version"] = transformedVersion
	}

	transformedContainerImage, err := expandDataprocSessionTemplateRuntimeConfigContainerImage(original["container_image"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContainerImage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["containerImage"] = transformedContainerImage
	}

	transformedProperties, err := expandDataprocSessionTemplateRuntimeConfigProperties(original["properties"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProperties); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["properties"] = transformedProperties
	}

	transformedEffectiveProperties, err := expandDataprocSessionTemplateRuntimeConfigEffectiveProperties(original["effective_properties"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEffectiveProperties); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["effective_properties"] = transformedEffectiveProperties
	}

	return transformed, nil
}

func expandDataprocSessionTemplateRuntimeConfigVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateRuntimeConfigContainerImage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateRuntimeConfigProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandDataprocSessionTemplateRuntimeConfigEffectiveProperties(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandDataprocSessionTemplateEnvironmentConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedExecutionConfig, err := expandDataprocSessionTemplateEnvironmentConfigExecutionConfig(original["execution_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExecutionConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["executionConfig"] = transformedExecutionConfig
	}

	transformedPeripheralsConfig, err := expandDataprocSessionTemplateEnvironmentConfigPeripheralsConfig(original["peripherals_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeripheralsConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["peripheralsConfig"] = transformedPeripheralsConfig
	}

	return transformed, nil
}

func expandDataprocSessionTemplateEnvironmentConfigExecutionConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServiceAccount, err := expandDataprocSessionTemplateEnvironmentConfigExecutionConfigServiceAccount(original["service_account"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccount"] = transformedServiceAccount
	}

	transformedNetworkTags, err := expandDataprocSessionTemplateEnvironmentConfigExecutionConfigNetworkTags(original["network_tags"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetworkTags); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["networkTags"] = transformedNetworkTags
	}

	transformedKmsKey, err := expandDataprocSessionTemplateEnvironmentConfigExecutionConfigKmsKey(original["kms_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKey"] = transformedKmsKey
	}

	transformedTtl, err := expandDataprocSessionTemplateEnvironmentConfigExecutionConfigTtl(original["ttl"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTtl); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ttl"] = transformedTtl
	}

	transformedStagingBucket, err := expandDataprocSessionTemplateEnvironmentConfigExecutionConfigStagingBucket(original["staging_bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStagingBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["stagingBucket"] = transformedStagingBucket
	}

	transformedSubnetworkUri, err := expandDataprocSessionTemplateEnvironmentConfigExecutionConfigSubnetworkUri(original["subnetwork_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSubnetworkUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["subnetworkUri"] = transformedSubnetworkUri
	}

	return transformed, nil
}

func expandDataprocSessionTemplateEnvironmentConfigExecutionConfigServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateEnvironmentConfigExecutionConfigNetworkTags(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateEnvironmentConfigExecutionConfigKmsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateEnvironmentConfigExecutionConfigTtl(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateEnvironmentConfigExecutionConfigStagingBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateEnvironmentConfigExecutionConfigSubnetworkUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateEnvironmentConfigPeripheralsConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMetastoreService, err := expandDataprocSessionTemplateEnvironmentConfigPeripheralsConfigMetastoreService(original["metastore_service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMetastoreService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["metastoreService"] = transformedMetastoreService
	}

	transformedSparkHistoryServerConfig, err := expandDataprocSessionTemplateEnvironmentConfigPeripheralsConfigSparkHistoryServerConfig(original["spark_history_server_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSparkHistoryServerConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sparkHistoryServerConfig"] = transformedSparkHistoryServerConfig
	}

	return transformed, nil
}

func expandDataprocSessionTemplateEnvironmentConfigPeripheralsConfigMetastoreService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateEnvironmentConfigPeripheralsConfigSparkHistoryServerConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDataprocCluster, err := expandDataprocSessionTemplateEnvironmentConfigPeripheralsConfigSparkHistoryServerConfigDataprocCluster(original["dataproc_cluster"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataprocCluster); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataprocCluster"] = transformedDataprocCluster
	}

	return transformed, nil
}

func expandDataprocSessionTemplateEnvironmentConfigPeripheralsConfigSparkHistoryServerConfigDataprocCluster(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateJupyterSession(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKernel, err := expandDataprocSessionTemplateJupyterSessionKernel(original["kernel"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKernel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kernel"] = transformedKernel
	}

	transformedDisplayName, err := expandDataprocSessionTemplateJupyterSessionDisplayName(original["display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayName"] = transformedDisplayName
	}

	return transformed, nil
}

func expandDataprocSessionTemplateJupyterSessionKernel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateJupyterSessionDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataprocSessionTemplateSparkConnectSession(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDataprocSessionTemplateEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
