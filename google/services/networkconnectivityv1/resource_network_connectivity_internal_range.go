// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/networkconnectivityv1/InternalRange.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package networkconnectivityv1

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceNetworkConnectivityv1InternalRange() *schema.Resource {
	return &schema.Resource{
		Create: resourceNetworkConnectivityv1InternalRangeCreate,
		Read:   resourceNetworkConnectivityv1InternalRangeRead,
		Update: resourceNetworkConnectivityv1InternalRangeUpdate,
		Delete: resourceNetworkConnectivityv1InternalRangeDelete,

		Importer: &schema.ResourceImporter{
			State: resourceNetworkConnectivityv1InternalRangeImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(30 * time.Minute),
			Update: schema.DefaultTimeout(30 * time.Minute),
			Delete: schema.DefaultTimeout(30 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of the policy based route.`,
			},
			"network": {
				Type:             schema.TypeString,
				Required:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description:      `Fully-qualified URL of the network that this route applies to, for example: projects/my-project/global/networks/my-network.`,
			},
			"peering": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: verify.ValidateEnum([]string{"FOR_SELF", "FOR_PEER", "NOT_SHARED"}),
				Description:  `The type of peering set for this internal range. Possible values: ["FOR_SELF", "FOR_PEER", "NOT_SHARED"]`,
			},
			"usage": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: verify.ValidateEnum([]string{"FOR_VPC", "EXTERNAL_TO_VPC", "FOR_MIGRATION"}),
				Description:  `The type of usage set for this InternalRange. Possible values: ["FOR_VPC", "EXTERNAL_TO_VPC", "FOR_MIGRATION"]`,
			},
			"allocation_options": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Options for automatically allocating a free range with a size given by prefixLength.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allocation_strategy": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"RANDOM", "FIRST_AVAILABLE", "RANDOM_FIRST_N_AVAILABLE", "FIRST_SMALLEST_FITTING", ""}),
							Description:  `Optional. Sets the strategy used to automatically find a free range of a size given by prefixLength. Can be set only when trying to create a reservation that automatically finds the free range to reserve. Possible values: ["RANDOM", "FIRST_AVAILABLE", "RANDOM_FIRST_N_AVAILABLE", "FIRST_SMALLEST_FITTING"]`,
						},
						"first_available_ranges_lookup_size": {
							Type:         schema.TypeInt,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: validation.IntAtLeast(1),
							Description: `Must be set when allocation_strategy is RANDOM_FIRST_N_AVAILABLE, otherwise must remain unset. Defines the size of the set of free ranges from which RANDOM_FIRST_N_AVAILABLE strategy randomy selects one,
in other words it sets the N in the RANDOM_FIRST_N_AVAILABLE.`,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An optional description of this resource.`,
			},
			"exclude_cidr_ranges": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Optional. List of IP CIDR ranges to be excluded. Resulting reserved Internal Range will not overlap with any CIDR blocks mentioned in this list.
Only IPv4 CIDR ranges are supported.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"immutable": {
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Description: `Immutable ranges cannot have their fields modified, except for labels and description.`,
			},
			"ip_cidr_range": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				Description: `The IP range that this internal range defines.
NOTE: IPv6 ranges are limited to usage=EXTERNAL_TO_VPC and peering=FOR_SELF
NOTE: For IPv6 Ranges this field is compulsory, i.e. the address range must be specified explicitly.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `User-defined labels.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"migration": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Specification for migration with source and target resource names.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"source": {
							Type:     schema.TypeString,
							Required: true,
							Description: `Resource path as an URI of the source resource, for example a subnet.
The project for the source resource should match the project for the
InternalRange.
An example /projects/{project}/regions/{region}/subnetworks/{subnet}`,
						},
						"target": {
							Type:     schema.TypeString,
							Required: true,
							Description: `Resource path of the target resource. The target project can be
different, as in the cases when migrating to peer networks. The resource
may not exist yet.
For example /projects/{project}/regions/{region}/subnetworks/{subnet}`,
						},
					},
				},
			},
			"overlaps": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Optional. Types of resources that are allowed to overlap with the current internal range. Possible values: ["OVERLAP_ROUTE_RANGE", "OVERLAP_EXISTING_SUBNET_RANGE"]`,
				Elem: &schema.Schema{
					Type:         schema.TypeString,
					ValidateFunc: verify.ValidateEnum([]string{"OVERLAP_ROUTE_RANGE", "OVERLAP_EXISTING_SUBNET_RANGE"}),
				},
			},
			"prefix_length": {
				Type:     schema.TypeInt,
				Optional: true,
				Description: `An alternate to ipCidrRange. Can be set when trying to create a reservation that automatically finds a free range of the given size.
If both ipCidrRange and prefixLength are set, there is an error if the range sizes do not match. Can also be used during updates to change the range size.
NOTE: For IPv6 this field only works if ip_cidr_range is set as well, and both fields must match. In other words, with IPv6 this field only works as
a redundant parameter.`,
			},
			"target_cidr_range": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Optional. Can be set to narrow down or pick a different address space while searching for a free range.
If not set, defaults to the "10.0.0.0/8" address space. This can be used to search in other rfc-1918 address spaces like "172.16.0.0/12" and "192.168.0.0/16" or non-rfc-1918 address spaces used in the VPC.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"users": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `Output only. The list of resources that refer to this internal range.
Resources that use the internal range for their range allocation are referred to as users of the range.
Other resources mark themselves as users while doing so by creating a reference to this internal range. Having a user, based on this reference, prevents deletion of the internal range referred to. Can be empty.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceNetworkConnectivityv1InternalRangeCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandNetworkConnectivityv1InternalRangeDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	ipCidrRangeProp, err := expandNetworkConnectivityv1InternalRangeIpCidrRange(d.Get("ip_cidr_range"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ip_cidr_range"); !tpgresource.IsEmptyValue(reflect.ValueOf(ipCidrRangeProp)) && (ok || !reflect.DeepEqual(v, ipCidrRangeProp)) {
		obj["ipCidrRange"] = ipCidrRangeProp
	}
	networkProp, err := expandNetworkConnectivityv1InternalRangeNetwork(d.Get("network"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network"); !tpgresource.IsEmptyValue(reflect.ValueOf(networkProp)) && (ok || !reflect.DeepEqual(v, networkProp)) {
		obj["network"] = networkProp
	}
	usageProp, err := expandNetworkConnectivityv1InternalRangeUsage(d.Get("usage"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("usage"); !tpgresource.IsEmptyValue(reflect.ValueOf(usageProp)) && (ok || !reflect.DeepEqual(v, usageProp)) {
		obj["usage"] = usageProp
	}
	peeringProp, err := expandNetworkConnectivityv1InternalRangePeering(d.Get("peering"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("peering"); !tpgresource.IsEmptyValue(reflect.ValueOf(peeringProp)) && (ok || !reflect.DeepEqual(v, peeringProp)) {
		obj["peering"] = peeringProp
	}
	prefixLengthProp, err := expandNetworkConnectivityv1InternalRangePrefixLength(d.Get("prefix_length"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("prefix_length"); !tpgresource.IsEmptyValue(reflect.ValueOf(prefixLengthProp)) && (ok || !reflect.DeepEqual(v, prefixLengthProp)) {
		obj["prefixLength"] = prefixLengthProp
	}
	targetCidrRangeProp, err := expandNetworkConnectivityv1InternalRangeTargetCidrRange(d.Get("target_cidr_range"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("target_cidr_range"); !tpgresource.IsEmptyValue(reflect.ValueOf(targetCidrRangeProp)) && (ok || !reflect.DeepEqual(v, targetCidrRangeProp)) {
		obj["targetCidrRange"] = targetCidrRangeProp
	}
	excludeCidrRangesProp, err := expandNetworkConnectivityv1InternalRangeExcludeCidrRanges(d.Get("exclude_cidr_ranges"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("exclude_cidr_ranges"); !tpgresource.IsEmptyValue(reflect.ValueOf(excludeCidrRangesProp)) && (ok || !reflect.DeepEqual(v, excludeCidrRangesProp)) {
		obj["excludeCidrRanges"] = excludeCidrRangesProp
	}
	allocationOptionsProp, err := expandNetworkConnectivityv1InternalRangeAllocationOptions(d.Get("allocation_options"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("allocation_options"); !tpgresource.IsEmptyValue(reflect.ValueOf(allocationOptionsProp)) && (ok || !reflect.DeepEqual(v, allocationOptionsProp)) {
		obj["allocationOptions"] = allocationOptionsProp
	}
	overlapsProp, err := expandNetworkConnectivityv1InternalRangeOverlaps(d.Get("overlaps"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("overlaps"); !tpgresource.IsEmptyValue(reflect.ValueOf(overlapsProp)) && (ok || !reflect.DeepEqual(v, overlapsProp)) {
		obj["overlaps"] = overlapsProp
	}
	migrationProp, err := expandNetworkConnectivityv1InternalRangeMigration(d.Get("migration"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("migration"); !tpgresource.IsEmptyValue(reflect.ValueOf(migrationProp)) && (ok || !reflect.DeepEqual(v, migrationProp)) {
		obj["migration"] = migrationProp
	}
	immutableProp, err := expandNetworkConnectivityv1InternalRangeImmutable(d.Get("immutable"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("immutable"); !tpgresource.IsEmptyValue(reflect.ValueOf(immutableProp)) && (ok || !reflect.DeepEqual(v, immutableProp)) {
		obj["immutable"] = immutableProp
	}
	effectiveLabelsProp, err := expandNetworkConnectivityv1InternalRangeEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkConnectivityv1BasePath}}projects/{{project}}/locations/global/internalRanges?internalRangeId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new InternalRange: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InternalRange: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating InternalRange: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/global/internalRanges/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = NetworkConnectivityv1OperationWaitTime(
		config, res, project, "Creating InternalRange", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create InternalRange: %s", err)
	}

	log.Printf("[DEBUG] Finished creating InternalRange %q: %#v", d.Id(), res)

	return resourceNetworkConnectivityv1InternalRangeRead(d, meta)
}

func resourceNetworkConnectivityv1InternalRangeRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkConnectivityv1BasePath}}projects/{{project}}/locations/global/internalRanges/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InternalRange: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("NetworkConnectivityv1InternalRange %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}

	if err := d.Set("labels", flattenNetworkConnectivityv1InternalRangeLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("description", flattenNetworkConnectivityv1InternalRangeDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("ip_cidr_range", flattenNetworkConnectivityv1InternalRangeIpCidrRange(res["ipCidrRange"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("network", flattenNetworkConnectivityv1InternalRangeNetwork(res["network"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("usage", flattenNetworkConnectivityv1InternalRangeUsage(res["usage"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("peering", flattenNetworkConnectivityv1InternalRangePeering(res["peering"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("prefix_length", flattenNetworkConnectivityv1InternalRangePrefixLength(res["prefixLength"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("target_cidr_range", flattenNetworkConnectivityv1InternalRangeTargetCidrRange(res["targetCidrRange"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("exclude_cidr_ranges", flattenNetworkConnectivityv1InternalRangeExcludeCidrRanges(res["excludeCidrRanges"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("allocation_options", flattenNetworkConnectivityv1InternalRangeAllocationOptions(res["allocationOptions"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("users", flattenNetworkConnectivityv1InternalRangeUsers(res["users"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("overlaps", flattenNetworkConnectivityv1InternalRangeOverlaps(res["overlaps"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("migration", flattenNetworkConnectivityv1InternalRangeMigration(res["migration"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("immutable", flattenNetworkConnectivityv1InternalRangeImmutable(res["immutable"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("terraform_labels", flattenNetworkConnectivityv1InternalRangeTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}
	if err := d.Set("effective_labels", flattenNetworkConnectivityv1InternalRangeEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading InternalRange: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("name"); !ok && v == "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceNetworkConnectivityv1InternalRangeUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InternalRange: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandNetworkConnectivityv1InternalRangeDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	ipCidrRangeProp, err := expandNetworkConnectivityv1InternalRangeIpCidrRange(d.Get("ip_cidr_range"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ip_cidr_range"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, ipCidrRangeProp)) {
		obj["ipCidrRange"] = ipCidrRangeProp
	}
	networkProp, err := expandNetworkConnectivityv1InternalRangeNetwork(d.Get("network"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, networkProp)) {
		obj["network"] = networkProp
	}
	usageProp, err := expandNetworkConnectivityv1InternalRangeUsage(d.Get("usage"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("usage"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, usageProp)) {
		obj["usage"] = usageProp
	}
	peeringProp, err := expandNetworkConnectivityv1InternalRangePeering(d.Get("peering"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("peering"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, peeringProp)) {
		obj["peering"] = peeringProp
	}
	prefixLengthProp, err := expandNetworkConnectivityv1InternalRangePrefixLength(d.Get("prefix_length"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("prefix_length"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, prefixLengthProp)) {
		obj["prefixLength"] = prefixLengthProp
	}
	targetCidrRangeProp, err := expandNetworkConnectivityv1InternalRangeTargetCidrRange(d.Get("target_cidr_range"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("target_cidr_range"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, targetCidrRangeProp)) {
		obj["targetCidrRange"] = targetCidrRangeProp
	}
	excludeCidrRangesProp, err := expandNetworkConnectivityv1InternalRangeExcludeCidrRanges(d.Get("exclude_cidr_ranges"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("exclude_cidr_ranges"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, excludeCidrRangesProp)) {
		obj["excludeCidrRanges"] = excludeCidrRangesProp
	}
	overlapsProp, err := expandNetworkConnectivityv1InternalRangeOverlaps(d.Get("overlaps"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("overlaps"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, overlapsProp)) {
		obj["overlaps"] = overlapsProp
	}
	effectiveLabelsProp, err := expandNetworkConnectivityv1InternalRangeEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkConnectivityv1BasePath}}projects/{{project}}/locations/global/internalRanges/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating InternalRange %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("ip_cidr_range") {
		updateMask = append(updateMask, "ipCidrRange")
	}

	if d.HasChange("network") {
		updateMask = append(updateMask, "network")
	}

	if d.HasChange("usage") {
		updateMask = append(updateMask, "usage")
	}

	if d.HasChange("peering") {
		updateMask = append(updateMask, "peering")
	}

	if d.HasChange("prefix_length") {
		updateMask = append(updateMask, "prefixLength")
	}

	if d.HasChange("target_cidr_range") {
		updateMask = append(updateMask, "targetCidrRange")
	}

	if d.HasChange("exclude_cidr_ranges") {
		updateMask = append(updateMask, "excludeCidrRanges")
	}

	if d.HasChange("overlaps") {
		updateMask = append(updateMask, "overlaps")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating InternalRange %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating InternalRange %q: %#v", d.Id(), res)
		}

		err = NetworkConnectivityv1OperationWaitTime(
			config, res, project, "Updating InternalRange", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceNetworkConnectivityv1InternalRangeRead(d, meta)
}

func resourceNetworkConnectivityv1InternalRangeDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InternalRange: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkConnectivityv1BasePath}}projects/{{project}}/locations/global/internalRanges/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting InternalRange %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "InternalRange")
	}

	err = NetworkConnectivityv1OperationWaitTime(
		config, res, project, "Deleting InternalRange", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting InternalRange %q: %#v", d.Id(), res)
	return nil
}

func resourceNetworkConnectivityv1InternalRangeImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/global/internalRanges/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/global/internalRanges/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenNetworkConnectivityv1InternalRangeLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkConnectivityv1InternalRangeDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangeIpCidrRange(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangeNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.ConvertSelfLinkToV1(v.(string))
}

func flattenNetworkConnectivityv1InternalRangeUsage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangePeering(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangePrefixLength(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetworkConnectivityv1InternalRangeTargetCidrRange(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangeExcludeCidrRanges(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangeAllocationOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["allocation_strategy"] =
		flattenNetworkConnectivityv1InternalRangeAllocationOptionsAllocationStrategy(original["allocationStrategy"], d, config)
	transformed["first_available_ranges_lookup_size"] =
		flattenNetworkConnectivityv1InternalRangeAllocationOptionsFirstAvailableRangesLookupSize(original["firstAvailableRangesLookupSize"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkConnectivityv1InternalRangeAllocationOptionsAllocationStrategy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangeAllocationOptionsFirstAvailableRangesLookupSize(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenNetworkConnectivityv1InternalRangeUsers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangeOverlaps(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangeMigration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["source"] =
		flattenNetworkConnectivityv1InternalRangeMigrationSource(original["source"], d, config)
	transformed["target"] =
		flattenNetworkConnectivityv1InternalRangeMigrationTarget(original["target"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkConnectivityv1InternalRangeMigrationSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangeMigrationTarget(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangeImmutable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkConnectivityv1InternalRangeTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkConnectivityv1InternalRangeEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandNetworkConnectivityv1InternalRangeDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeIpCidrRange(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeUsage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangePeering(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangePrefixLength(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeTargetCidrRange(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeExcludeCidrRanges(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeAllocationOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAllocationStrategy, err := expandNetworkConnectivityv1InternalRangeAllocationOptionsAllocationStrategy(original["allocation_strategy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllocationStrategy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["allocationStrategy"] = transformedAllocationStrategy
	}

	transformedFirstAvailableRangesLookupSize, err := expandNetworkConnectivityv1InternalRangeAllocationOptionsFirstAvailableRangesLookupSize(original["first_available_ranges_lookup_size"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFirstAvailableRangesLookupSize); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["firstAvailableRangesLookupSize"] = transformedFirstAvailableRangesLookupSize
	}

	return transformed, nil
}

func expandNetworkConnectivityv1InternalRangeAllocationOptionsAllocationStrategy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeAllocationOptionsFirstAvailableRangesLookupSize(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeOverlaps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeMigration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSource, err := expandNetworkConnectivityv1InternalRangeMigrationSource(original["source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["source"] = transformedSource
	}

	transformedTarget, err := expandNetworkConnectivityv1InternalRangeMigrationTarget(original["target"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTarget); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["target"] = transformedTarget
	}

	return transformed, nil
}

func expandNetworkConnectivityv1InternalRangeMigrationSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeMigrationTarget(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeImmutable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkConnectivityv1InternalRangeEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
