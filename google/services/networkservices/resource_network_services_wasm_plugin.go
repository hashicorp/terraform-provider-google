// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/networkservices/WasmPlugin.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package networkservices

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceNetworkServicesWasmPlugin() *schema.Resource {
	return &schema.Resource{
		Create: resourceNetworkServicesWasmPluginCreate,
		Read:   resourceNetworkServicesWasmPluginRead,
		Update: resourceNetworkServicesWasmPluginUpdate,
		Delete: resourceNetworkServicesWasmPluginDelete,

		Importer: &schema.ResourceImporter{
			State: resourceNetworkServicesWasmPluginImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"location": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
					"name": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"main_version_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The ID of the WasmPluginVersion resource that is the currently serving one. The version referred to must be a child of this WasmPlugin resource and should be listed in the "versions" field.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Identifier. Name of the WasmPlugin resource.`,
			},
			"versions": {
				Type:        schema.TypeSet,
				Required:    true,
				Description: `All versions of this WasmPlugin resource in the key-value format. The key is the resource ID, and the value is the VersionDetails object.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"version_name": {
							Type:     schema.TypeString,
							Required: true,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Optional. A human-readable description of the resource.`,
						},
						"image_uri": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `Optional. URI of the container image containing the plugin, stored in the Artifact Registry. When a new WasmPluginVersion resource is created, the digest of the container image is saved in the imageDigest field.
When downloading an image, the digest value is used instead of an image tag.`,
						},
						"labels": {
							Type:        schema.TypeMap,
							Optional:    true,
							Description: `Optional. Set of labels associated with the WasmPlugin resource.`,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
						"plugin_config_data": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateBase64String,
							Description: `A base64-encoded string containing the configuration for the plugin. The configuration is provided to the plugin at runtime through the ON_CONFIGURE callback.
When a new WasmPluginVersion resource is created, the digest of the contents is saved in the pluginConfigDigest field.
Conflics with pluginConfigUri.`,
							ConflictsWith: []string{},
						},
						"plugin_config_uri": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `URI of the plugin configuration stored in the Artifact Registry. The configuration is provided to the plugin at runtime through the ON_CONFIGURE callback.
The container image must contain only a single file with the name plugin.config.
When a new WasmPluginVersion resource is created, the digest of the container image is saved in the pluginConfigDigest field.
Conflics with pluginConfigData.`,
							ConflictsWith: []string{},
						},
						"create_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. The timestamp when the resource was created.`,
						},
						"image_digest": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. The resolved digest for the image specified in the image field. The digest is resolved during the creation of WasmPluginVersion resource.
This field holds the digest value, regardless of whether a tag or digest was originally specified in the image field.`,
						},
						"plugin_config_digest": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. This field holds the digest (usually checksum) value for the plugin configuration.
The value is calculated based on the contents of pluginConfigData or the container image defined by the pluginConfigUri field.`,
						},
						"update_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. The timestamp when the resource was updated.`,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Optional. A human-readable description of the resource.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Optional. Set of labels associated with the WasmPlugin resource.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"location": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The location of the traffic extension`,
				Default:     "global",
			},
			"log_config": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Optional. Specifies the logging options for the activity performed by this plugin. If logging is enabled, plugin logs are exported to Cloud Logging.
Note that the settings relate to the logs generated by using logging statements in your Wasm code.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enable": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Optional. Specifies whether to enable logging for activity by this plugin.`,
						},
						"min_log_level": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"LOG_LEVEL_UNSPECIFIED", "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "CRITICAL", ""}),
							Description: `Non-empty default. Specificies the lowest level of the plugin logs that are exported to Cloud Logging. This setting relates to the logs generated by using logging statements in your Wasm code.
This field is can be set only if logging is enabled for the plugin.
If the field is not provided when logging is enabled, it is set to INFO by default. Possible values: ["LOG_LEVEL_UNSPECIFIED", "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "CRITICAL"]`,
						},
						"sample_rate": {
							Type:         schema.TypeFloat,
							Computed:     true,
							Optional:     true,
							ValidateFunc: validation.FloatBetween(0, 1),
							Description: `Non-empty default. Configures the sampling rate of activity logs, where 1.0 means all logged activity is reported and 0.0 means no activity is reported.
A floating point value between 0.0 and 1.0 indicates that a percentage of log messages is stored.
The default value when logging is enabled is 1.0. The value of the field must be between 0 and 1 (inclusive).
This field can be specified only if logging is enabled for this plugin.`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The timestamp when the resource was created.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The timestamp when the resource was updated.`,
			},
			"used_by": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. List of all extensions that use this WasmPlugin resource.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Output only. Full name of the resource`,
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceNetworkServicesWasmPluginCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandNetworkServicesWasmPluginDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	mainVersionIdProp, err := expandNetworkServicesWasmPluginMainVersionId(d.Get("main_version_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("main_version_id"); !tpgresource.IsEmptyValue(reflect.ValueOf(mainVersionIdProp)) && (ok || !reflect.DeepEqual(v, mainVersionIdProp)) {
		obj["mainVersionId"] = mainVersionIdProp
	}
	logConfigProp, err := expandNetworkServicesWasmPluginLogConfig(d.Get("log_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("log_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(logConfigProp)) && (ok || !reflect.DeepEqual(v, logConfigProp)) {
		obj["logConfig"] = logConfigProp
	}
	versionsProp, err := expandNetworkServicesWasmPluginVersions(d.Get("versions"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("versions"); !tpgresource.IsEmptyValue(reflect.ValueOf(versionsProp)) && (ok || !reflect.DeepEqual(v, versionsProp)) {
		obj["versions"] = versionsProp
	}
	effectiveLabelsProp, err := expandNetworkServicesWasmPluginEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkServicesBasePath}}projects/{{project}}/locations/{{location}}/wasmPlugins?wasmPluginId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new WasmPlugin: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for WasmPlugin: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating WasmPlugin: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/wasmPlugins/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = NetworkServicesOperationWaitTime(
		config, res, project, "Creating WasmPlugin", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create WasmPlugin: %s", err)
	}

	log.Printf("[DEBUG] Finished creating WasmPlugin %q: %#v", d.Id(), res)

	return resourceNetworkServicesWasmPluginRead(d, meta)
}

func resourceNetworkServicesWasmPluginRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkServicesBasePath}}projects/{{project}}/locations/{{location}}/wasmPlugins/{{name}}?view=WASM_PLUGIN_VIEW_FULL")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for WasmPlugin: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("NetworkServicesWasmPlugin %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading WasmPlugin: %s", err)
	}

	if err := d.Set("create_time", flattenNetworkServicesWasmPluginCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading WasmPlugin: %s", err)
	}
	if err := d.Set("update_time", flattenNetworkServicesWasmPluginUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading WasmPlugin: %s", err)
	}
	if err := d.Set("description", flattenNetworkServicesWasmPluginDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading WasmPlugin: %s", err)
	}
	if err := d.Set("labels", flattenNetworkServicesWasmPluginLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading WasmPlugin: %s", err)
	}
	if err := d.Set("main_version_id", flattenNetworkServicesWasmPluginMainVersionId(res["mainVersionId"], d, config)); err != nil {
		return fmt.Errorf("Error reading WasmPlugin: %s", err)
	}
	if err := d.Set("log_config", flattenNetworkServicesWasmPluginLogConfig(res["logConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading WasmPlugin: %s", err)
	}
	if err := d.Set("versions", flattenNetworkServicesWasmPluginVersions(res["versions"], d, config)); err != nil {
		return fmt.Errorf("Error reading WasmPlugin: %s", err)
	}
	if err := d.Set("used_by", flattenNetworkServicesWasmPluginUsedBy(res["usedBy"], d, config)); err != nil {
		return fmt.Errorf("Error reading WasmPlugin: %s", err)
	}
	if err := d.Set("terraform_labels", flattenNetworkServicesWasmPluginTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading WasmPlugin: %s", err)
	}
	if err := d.Set("effective_labels", flattenNetworkServicesWasmPluginEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading WasmPlugin: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("name"); !ok && v == "" {
			err = identity.Set("name", d.Get("name").(string))
			if err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceNetworkServicesWasmPluginUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if nameValue, ok := d.GetOk("name"); ok && nameValue.(string) != "" {
			if err = identity.Set("name", nameValue.(string)); err != nil {
				return fmt.Errorf("Error setting name: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for WasmPlugin: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandNetworkServicesWasmPluginDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	mainVersionIdProp, err := expandNetworkServicesWasmPluginMainVersionId(d.Get("main_version_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("main_version_id"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, mainVersionIdProp)) {
		obj["mainVersionId"] = mainVersionIdProp
	}
	logConfigProp, err := expandNetworkServicesWasmPluginLogConfig(d.Get("log_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("log_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, logConfigProp)) {
		obj["logConfig"] = logConfigProp
	}
	versionsProp, err := expandNetworkServicesWasmPluginVersions(d.Get("versions"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("versions"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, versionsProp)) {
		obj["versions"] = versionsProp
	}
	effectiveLabelsProp, err := expandNetworkServicesWasmPluginEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkServicesBasePath}}projects/{{project}}/locations/{{location}}/wasmPlugins/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating WasmPlugin %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("main_version_id") {
		updateMask = append(updateMask, "mainVersionId")
	}

	if d.HasChange("log_config") {
		updateMask = append(updateMask, "logConfig")
	}

	if d.HasChange("versions") {
		updateMask = append(updateMask, "versions")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating WasmPlugin %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating WasmPlugin %q: %#v", d.Id(), res)
		}

		err = NetworkServicesOperationWaitTime(
			config, res, project, "Updating WasmPlugin", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceNetworkServicesWasmPluginRead(d, meta)
}

func resourceNetworkServicesWasmPluginDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for WasmPlugin: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkServicesBasePath}}projects/{{project}}/locations/{{location}}/wasmPlugins/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting WasmPlugin %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "WasmPlugin")
	}

	err = NetworkServicesOperationWaitTime(
		config, res, project, "Deleting WasmPlugin", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting WasmPlugin %q: %#v", d.Id(), res)
	return nil
}

func resourceNetworkServicesWasmPluginImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/wasmPlugins/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/wasmPlugins/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenNetworkServicesWasmPluginCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkServicesWasmPluginMainVersionId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginLogConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enable"] =
		flattenNetworkServicesWasmPluginLogConfigEnable(original["enable"], d, config)
	transformed["sample_rate"] =
		flattenNetworkServicesWasmPluginLogConfigSampleRate(original["sampleRate"], d, config)
	transformed["min_log_level"] =
		flattenNetworkServicesWasmPluginLogConfigMinLogLevel(original["minLogLevel"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkServicesWasmPluginLogConfigEnable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginLogConfigSampleRate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginLogConfigMinLogLevel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginVersions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"version_name":         k,
			"create_time":          flattenNetworkServicesWasmPluginVersionsCreateTime(original["createTime"], d, config),
			"update_time":          flattenNetworkServicesWasmPluginVersionsUpdateTime(original["updateTime"], d, config),
			"description":          flattenNetworkServicesWasmPluginVersionsDescription(original["description"], d, config),
			"labels":               flattenNetworkServicesWasmPluginVersionsLabels(original["labels"], d, config),
			"image_uri":            flattenNetworkServicesWasmPluginVersionsImageUri(original["imageUri"], d, config),
			"image_digest":         flattenNetworkServicesWasmPluginVersionsImageDigest(original["imageDigest"], d, config),
			"plugin_config_digest": flattenNetworkServicesWasmPluginVersionsPluginConfigDigest(original["pluginConfigDigest"], d, config),
			"plugin_config_data":   flattenNetworkServicesWasmPluginVersionsPluginConfigData(original["pluginConfigData"], d, config),
			"plugin_config_uri":    flattenNetworkServicesWasmPluginVersionsPluginConfigUri(original["pluginConfigUri"], d, config),
		})
	}
	return transformed
}
func flattenNetworkServicesWasmPluginVersionsCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginVersionsUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginVersionsDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginVersionsLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginVersionsImageUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginVersionsImageDigest(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginVersionsPluginConfigDigest(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginVersionsPluginConfigData(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginVersionsPluginConfigUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginUsedBy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name": flattenNetworkServicesWasmPluginUsedByName(original["name"], d, config),
		})
	}
	return transformed
}
func flattenNetworkServicesWasmPluginUsedByName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesWasmPluginTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkServicesWasmPluginEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandNetworkServicesWasmPluginDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesWasmPluginMainVersionId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesWasmPluginLogConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnable, err := expandNetworkServicesWasmPluginLogConfigEnable(original["enable"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enable"] = transformedEnable
	}

	transformedSampleRate, err := expandNetworkServicesWasmPluginLogConfigSampleRate(original["sample_rate"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSampleRate); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sampleRate"] = transformedSampleRate
	}

	transformedMinLogLevel, err := expandNetworkServicesWasmPluginLogConfigMinLogLevel(original["min_log_level"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinLogLevel); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minLogLevel"] = transformedMinLogLevel
	}

	return transformed, nil
}

func expandNetworkServicesWasmPluginLogConfigEnable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesWasmPluginLogConfigSampleRate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesWasmPluginLogConfigMinLogLevel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesWasmPluginVersions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		// Ensure we don't send empty versions
		if tpgresource.IsEmptyValue(reflect.ValueOf(original["version_name"])) {
			continue
		}

		transformedDescription, err := expandNetworkServicesWasmPluginVersionsFields(original["description"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["description"] = transformedDescription
		}

		transformedLabels, err := expandNetworkServicesWasmPluginVersionsLabels(original["labels"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["labels"] = transformedLabels
		}

		transformedImageUri, err := expandNetworkServicesWasmPluginVersionsFields(original["image_uri"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedImageUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["imageUri"] = transformedImageUri
		}

		transformedPluginConfigData, err := expandNetworkServicesWasmPluginVersionsFields(original["plugin_config_data"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPluginConfigData); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["pluginConfigData"] = transformedPluginConfigData
		}

		transformedPluginConfigUri, err := expandNetworkServicesWasmPluginVersionsFields(original["plugin_config_uri"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPluginConfigUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["pluginConfigUri"] = transformedPluginConfigUri
		}

		transformedVersionName, err := tpgresource.ExpandString(original["version_name"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedVersionName] = transformed
	}
	return m, nil
}

func expandNetworkServicesWasmPluginVersionsFields(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesWasmPluginVersionsLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandNetworkServicesWasmPluginEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
