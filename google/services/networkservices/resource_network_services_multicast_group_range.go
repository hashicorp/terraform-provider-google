// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/networkservices/MulticastGroupRange.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package networkservices

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceNetworkServicesMulticastGroupRange() *schema.Resource {
	return &schema.Resource{
		Create: resourceNetworkServicesMulticastGroupRangeCreate,
		Read:   resourceNetworkServicesMulticastGroupRangeRead,
		Update: resourceNetworkServicesMulticastGroupRangeUpdate,
		Delete: resourceNetworkServicesMulticastGroupRangeDelete,

		Importer: &schema.ResourceImporter{
			State: resourceNetworkServicesMulticastGroupRangeImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"multicast_group_range_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"multicast_domain": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The resource name of the multicast domain in which to create this
multicast group range.
Use the following format:
'projects/*/locations/global/multicastDomains/*'.`,
			},
			"multicast_group_range_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `A unique name for the multicast group range.
The name is restricted to letters, numbers, and hyphen, with the first
character a letter, and the last a letter or a number. The name must not
exceed 48 characters.`,
			},
			"reserved_internal_range": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The resource name of the internal range reserved for this
multicast group range.

The internal range must be a Class D address (224.0.0.0 to 239.255.255.255)
and have a prefix length >= 23.

Use the following format:
'projects/*/locations/global/internalRanges/*'.`,
			},
			"consumer_accept_list": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `A list of consumer projects that are allowed to subscribe to the multicast
IP addresses within the range defined by this MulticastGroupRange. The
project can be specified using its project ID or project number. If left
empty, then all consumer projects are allowed (unless
require_explicit_accept is set to true) once they have VPC networks
associated to the multicast domain. The current max length of the accept
list is 100.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An optional text description of the multicast group range.`,
			},
			"distribution_scope": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `Multicast group range's distribution scope. Intra-zone or intra-region
cross-zone is supported, with default value being intra-region. Cross
region distribution is not supported.
Possible values:
INTRA_ZONE
INTRA_REGION`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Labels as key-value pairs.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"log_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The logging configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enabled": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Whether to enable logging or not.`,
						},
					},
				},
			},
			"require_explicit_accept": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Whether an empty consumer_accept_list will deny all consumer projects.`,
			},
			"create_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `[Output only] The timestamp when the multicast group range was
created.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"ip_cidr_range": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `[Output only] The multicast group IP address range.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The resource name of the multicast group range.
Use the following format:
'projects/*/locations/global/multicastGroupRanges/*'.`,
			},
			"state": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The multicast resource's state.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"state": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The state of the multicast resource.
Possible values:
CREATING
ACTIVE
DELETING
DELETE_FAILED
UPDATING
UPDATE_FAILED
INACTIVE`,
						},
					},
				},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"unique_id": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `[Output only] The Google-generated UUID for the resource. This value is
unique across all multicast group range resources. If a group
range is deleted and another with the same name is created, the new
group range is assigned a different unique_id.`,
			},
			"update_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `[Output only] The timestamp when the multicast group range was most
recently updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceNetworkServicesMulticastGroupRangeCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	consumerAcceptListProp, err := expandNetworkServicesMulticastGroupRangeConsumerAcceptList(d.Get("consumer_accept_list"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("consumer_accept_list"); !tpgresource.IsEmptyValue(reflect.ValueOf(consumerAcceptListProp)) && (ok || !reflect.DeepEqual(v, consumerAcceptListProp)) {
		obj["consumerAcceptList"] = consumerAcceptListProp
	}
	descriptionProp, err := expandNetworkServicesMulticastGroupRangeDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	distributionScopeProp, err := expandNetworkServicesMulticastGroupRangeDistributionScope(d.Get("distribution_scope"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("distribution_scope"); !tpgresource.IsEmptyValue(reflect.ValueOf(distributionScopeProp)) && (ok || !reflect.DeepEqual(v, distributionScopeProp)) {
		obj["distributionScope"] = distributionScopeProp
	}
	logConfigProp, err := expandNetworkServicesMulticastGroupRangeLogConfig(d.Get("log_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("log_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(logConfigProp)) && (ok || !reflect.DeepEqual(v, logConfigProp)) {
		obj["logConfig"] = logConfigProp
	}
	multicastDomainProp, err := expandNetworkServicesMulticastGroupRangeMulticastDomain(d.Get("multicast_domain"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("multicast_domain"); !tpgresource.IsEmptyValue(reflect.ValueOf(multicastDomainProp)) && (ok || !reflect.DeepEqual(v, multicastDomainProp)) {
		obj["multicastDomain"] = multicastDomainProp
	}
	requireExplicitAcceptProp, err := expandNetworkServicesMulticastGroupRangeRequireExplicitAccept(d.Get("require_explicit_accept"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("require_explicit_accept"); !tpgresource.IsEmptyValue(reflect.ValueOf(requireExplicitAcceptProp)) && (ok || !reflect.DeepEqual(v, requireExplicitAcceptProp)) {
		obj["requireExplicitAccept"] = requireExplicitAcceptProp
	}
	reservedInternalRangeProp, err := expandNetworkServicesMulticastGroupRangeReservedInternalRange(d.Get("reserved_internal_range"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("reserved_internal_range"); !tpgresource.IsEmptyValue(reflect.ValueOf(reservedInternalRangeProp)) && (ok || !reflect.DeepEqual(v, reservedInternalRangeProp)) {
		obj["reservedInternalRange"] = reservedInternalRangeProp
	}
	effectiveLabelsProp, err := expandNetworkServicesMulticastGroupRangeEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkServicesBasePath}}projects/{{project}}/locations/{{location}}/multicastGroupRanges?multicastGroupRangeId={{multicast_group_range_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new MulticastGroupRange: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for MulticastGroupRange: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating MulticastGroupRange: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/multicastGroupRanges/{{multicast_group_range_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if multicastGroupRangeIdValue, ok := d.GetOk("multicast_group_range_id"); ok && multicastGroupRangeIdValue.(string) != "" {
			if err = identity.Set("multicast_group_range_id", multicastGroupRangeIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting multicast_group_range_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = NetworkServicesOperationWaitTime(
		config, res, project, "Creating MulticastGroupRange", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create MulticastGroupRange: %s", err)
	}

	log.Printf("[DEBUG] Finished creating MulticastGroupRange %q: %#v", d.Id(), res)

	return resourceNetworkServicesMulticastGroupRangeRead(d, meta)
}

func resourceNetworkServicesMulticastGroupRangeRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkServicesBasePath}}projects/{{project}}/locations/{{location}}/multicastGroupRanges/{{multicast_group_range_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for MulticastGroupRange: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("NetworkServicesMulticastGroupRange %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}

	if err := d.Set("consumer_accept_list", flattenNetworkServicesMulticastGroupRangeConsumerAcceptList(res["consumerAcceptList"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("create_time", flattenNetworkServicesMulticastGroupRangeCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("description", flattenNetworkServicesMulticastGroupRangeDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("distribution_scope", flattenNetworkServicesMulticastGroupRangeDistributionScope(res["distributionScope"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("ip_cidr_range", flattenNetworkServicesMulticastGroupRangeIpCidrRange(res["ipCidrRange"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("labels", flattenNetworkServicesMulticastGroupRangeLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("log_config", flattenNetworkServicesMulticastGroupRangeLogConfig(res["logConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("multicast_domain", flattenNetworkServicesMulticastGroupRangeMulticastDomain(res["multicastDomain"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("name", flattenNetworkServicesMulticastGroupRangeName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("require_explicit_accept", flattenNetworkServicesMulticastGroupRangeRequireExplicitAccept(res["requireExplicitAccept"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("reserved_internal_range", flattenNetworkServicesMulticastGroupRangeReservedInternalRange(res["reservedInternalRange"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("state", flattenNetworkServicesMulticastGroupRangeState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("unique_id", flattenNetworkServicesMulticastGroupRangeUniqueId(res["uniqueId"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("update_time", flattenNetworkServicesMulticastGroupRangeUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("terraform_labels", flattenNetworkServicesMulticastGroupRangeTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}
	if err := d.Set("effective_labels", flattenNetworkServicesMulticastGroupRangeEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading MulticastGroupRange: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("multicast_group_range_id"); !ok && v == "" {
			err = identity.Set("multicast_group_range_id", d.Get("multicast_group_range_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting multicast_group_range_id: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceNetworkServicesMulticastGroupRangeUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if multicastGroupRangeIdValue, ok := d.GetOk("multicast_group_range_id"); ok && multicastGroupRangeIdValue.(string) != "" {
			if err = identity.Set("multicast_group_range_id", multicastGroupRangeIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting multicast_group_range_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for MulticastGroupRange: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	consumerAcceptListProp, err := expandNetworkServicesMulticastGroupRangeConsumerAcceptList(d.Get("consumer_accept_list"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("consumer_accept_list"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, consumerAcceptListProp)) {
		obj["consumerAcceptList"] = consumerAcceptListProp
	}
	descriptionProp, err := expandNetworkServicesMulticastGroupRangeDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	logConfigProp, err := expandNetworkServicesMulticastGroupRangeLogConfig(d.Get("log_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("log_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, logConfigProp)) {
		obj["logConfig"] = logConfigProp
	}
	requireExplicitAcceptProp, err := expandNetworkServicesMulticastGroupRangeRequireExplicitAccept(d.Get("require_explicit_accept"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("require_explicit_accept"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, requireExplicitAcceptProp)) {
		obj["requireExplicitAccept"] = requireExplicitAcceptProp
	}
	effectiveLabelsProp, err := expandNetworkServicesMulticastGroupRangeEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkServicesBasePath}}projects/{{project}}/locations/{{location}}/multicastGroupRanges/{{multicast_group_range_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating MulticastGroupRange %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("consumer_accept_list") {
		updateMask = append(updateMask, "consumerAcceptList")
	}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("log_config") {
		updateMask = append(updateMask, "logConfig")
	}

	if d.HasChange("require_explicit_accept") {
		updateMask = append(updateMask, "requireExplicitAccept")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating MulticastGroupRange %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating MulticastGroupRange %q: %#v", d.Id(), res)
		}

		err = NetworkServicesOperationWaitTime(
			config, res, project, "Updating MulticastGroupRange", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceNetworkServicesMulticastGroupRangeRead(d, meta)
}

func resourceNetworkServicesMulticastGroupRangeDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for MulticastGroupRange: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{NetworkServicesBasePath}}projects/{{project}}/locations/{{location}}/multicastGroupRanges/{{multicast_group_range_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting MulticastGroupRange %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "MulticastGroupRange")
	}

	err = NetworkServicesOperationWaitTime(
		config, res, project, "Deleting MulticastGroupRange", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting MulticastGroupRange %q: %#v", d.Id(), res)
	return nil
}

func resourceNetworkServicesMulticastGroupRangeImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/multicastGroupRanges/(?P<multicast_group_range_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<multicast_group_range_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<multicast_group_range_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/multicastGroupRanges/{{multicast_group_range_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenNetworkServicesMulticastGroupRangeConsumerAcceptList(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeDistributionScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeIpCidrRange(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkServicesMulticastGroupRangeLogConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenNetworkServicesMulticastGroupRangeLogConfigEnabled(original["enabled"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkServicesMulticastGroupRangeLogConfigEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeMulticastDomain(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeRequireExplicitAccept(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeReservedInternalRange(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["state"] =
		flattenNetworkServicesMulticastGroupRangeStateState(original["state"], d, config)
	return []interface{}{transformed}
}
func flattenNetworkServicesMulticastGroupRangeStateState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeUniqueId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenNetworkServicesMulticastGroupRangeTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenNetworkServicesMulticastGroupRangeEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandNetworkServicesMulticastGroupRangeConsumerAcceptList(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesMulticastGroupRangeDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesMulticastGroupRangeDistributionScope(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesMulticastGroupRangeLogConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandNetworkServicesMulticastGroupRangeLogConfigEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	return transformed, nil
}

func expandNetworkServicesMulticastGroupRangeLogConfigEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesMulticastGroupRangeMulticastDomain(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesMulticastGroupRangeRequireExplicitAccept(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesMulticastGroupRangeReservedInternalRange(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandNetworkServicesMulticastGroupRangeEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
