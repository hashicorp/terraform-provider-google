// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/memorystore/Instance.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package memorystore

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceMemorystoreInstance() *schema.Resource {
	return &schema.Resource{
		Create: resourceMemorystoreInstanceCreate,
		Read:   resourceMemorystoreInstanceRead,
		Update: resourceMemorystoreInstanceUpdate,
		Delete: resourceMemorystoreInstanceDelete,

		Importer: &schema.ResourceImporter{
			State: resourceMemorystoreInstanceImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(60 * time.Minute),
			Update: schema.DefaultTimeout(120 * time.Minute),
			Delete: schema.DefaultTimeout(30 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"instance_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Required. The ID to use for the instance, which will become the final component of
the instance's resource name.

This value is subject to the following restrictions:

* Must be 4-63 characters in length
* Must begin with a letter or digit
* Must contain only lowercase letters, digits, and hyphens
* Must not end with a hyphen
* Must be unique within a location`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type 'memorystore.googleapis.com/CertificateAuthority'.`,
			},
			"shard_count": {
				Type:        schema.TypeInt,
				Required:    true,
				Description: `Required. Number of shards for the instance.`,
			},
			"authorization_mode": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				ForceNew: true,
				Description: `Optional. Immutable. Authorization mode of the instance. Possible values:
 AUTH_DISABLED
IAM_AUTH`,
			},
			"automated_backup_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The automated backup config for a instance.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"fixed_frequency_schedule": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Trigger automated backups at a fixed frequency.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"start_time": {
										Type:     schema.TypeList,
										Required: true,
										Description: `The start time of every automated backup in UTC.
It must be set to the start of an hour. This field is required.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"hours": {
													Type:     schema.TypeInt,
													Required: true,
													Description: `Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23.
An API may choose to allow the value "24:00:00" for scenarios like business closing time.`,
												},
											},
										},
									},
								},
							},
						},
						"retention": {
							Type:     schema.TypeString,
							Required: true,
							Description: `How long to keep automated backups before the backups are deleted.
The value should be between 1 day and 365 days. If not specified, the default value is 35 days.
A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s". The default_value is "3024000s"`,
						},
					},
				},
			},
			"cross_instance_replication_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Cross instance replication config`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"instance_role": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"INSTANCE_ROLE_UNSPECIFIED", "NONE", "PRIMARY", "SECONDARY", ""}),
							Description: `The instance role supports the following values:
1. 'INSTANCE_ROLE_UNSPECIFIED': This is an independent instance that has never participated in cross instance replication. It allows both reads and writes.
2. 'NONE': This is an independent instance that previously participated in cross instance replication(either as a 'PRIMARY' or 'SECONDARY' cluster). It allows both reads and writes.
3. 'PRIMARY': This instance serves as the replication source for secondary instance that are replicating from it. Any data written to it is automatically replicated to its secondary clusters. It allows both reads and writes.
4. 'SECONDARY': This instance replicates data from the primary instance. It allows only reads. Possible values: ["INSTANCE_ROLE_UNSPECIFIED", "NONE", "PRIMARY", "SECONDARY"]`,
						},
						"primary_instance": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `This field is only set for a secondary instance. Details of the primary instance that is used as the replication source for this secondary instance. This is allowed to be set only for clusters whose cluster role is of type 'SECONDARY'.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"instance": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The full resource path of the primary instance in the format: projects/{project}/locations/{region}/instances/{instance-id}`,
									},
									"uid": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The unique id of the primary instance.`,
									},
								},
							},
						},
						"secondary_instances": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `List of secondary instances that are replicating from this primary cluster. This is allowed to be set only for instances whose cluster role is of type 'PRIMARY'.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"instance": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The full resource path of the Nth instance in the format: projects/{project}/locations/{region}/instance/{instance-id}`,
									},
									"uid": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The unique id of the Nth instance.`,
									},
								},
							},
						},
						"membership": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `An output only view of all the member instance participating in cross instance replication. This field is populated for all the member clusters irrespective of their cluster role.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"primary_instance": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Details of the primary instance that is used as the replication source for all the secondary instances.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"instance": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The full resource path of the primary instance in the format: projects/{project}/locations/{region}/instance/{instance-id}`,
												},
												"uid": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The unique id of the primary instance.`,
												},
											},
										},
									},
									"secondary_instance": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `List of secondary instances that are replicating from the primary instance.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"instance": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The full resource path of the secondary instance in the format: projects/{project}/locations/{region}/instance/{instance-id}`,
												},
												"uid": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The unique id of the secondary instance.`,
												},
											},
										},
									},
								},
							},
						},
						"update_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The last time cross instance replication config was updated.`,
						},
					},
				},
			},
			"deletion_protection_enabled": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Optional. If set to true deletion of the instance will fail.`,
				Default:     true,
			},
			"engine_configs": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: `Optional. User-provided engine configurations for the instance.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"engine_version": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				Description: `Optional. Engine version of the instance.`,
			},
			"gcs_source": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `GCS source for the instance.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"uris": {
							Type:     schema.TypeSet,
							Required: true,
							ForceNew: true,
							Description: `URIs of the GCS objects to import.
Example: gs://bucket1/object1, gs//bucket2/folder2/object2`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Set: schema.HashString,
						},
					},
				},
				ConflictsWith: []string{"managed_backup_source"},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Optional. Labels to represent user-provided metadata. 

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"maintenance_policy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Maintenance policy for a cluster`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"weekly_maintenance_window": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Optional. Maintenance window that is applied to resources covered by this policy.
Minimum 1. For the current version, the maximum number
of weekly_window is expected to be one.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"day": {
										Type:         schema.TypeString,
										Required:     true,
										ValidateFunc: verify.ValidateEnum([]string{"DAY_OF_WEEK_UNSPECIFIED", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"}),
										Description: `The day of week that maintenance updates occur.

- DAY_OF_WEEK_UNSPECIFIED: The day of the week is unspecified.
- MONDAY: Monday
- TUESDAY: Tuesday
- WEDNESDAY: Wednesday
- THURSDAY: Thursday
- FRIDAY: Friday
- SATURDAY: Saturday
- SUNDAY: Sunday Possible values: ["DAY_OF_WEEK_UNSPECIFIED", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]`,
									},
									"start_time": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `Start time of the window in UTC time.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"hours": {
													Type:         schema.TypeInt,
													Optional:     true,
													ValidateFunc: validation.IntBetween(0, 23),
													Description: `Hours of day in 24 hour format. Should be from 0 to 23.
An API may choose to allow the value "24:00:00" for scenarios like business closing time.`,
												},
												"minutes": {
													Type:         schema.TypeInt,
													Optional:     true,
													ValidateFunc: validation.IntBetween(0, 59),
													Description:  `Minutes of hour of day. Must be from 0 to 59.`,
												},
												"nanos": {
													Type:         schema.TypeInt,
													Optional:     true,
													ValidateFunc: validation.IntBetween(0, 999999999),
													Description:  `Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.`,
												},
												"seconds": {
													Type:         schema.TypeInt,
													Optional:     true,
													ValidateFunc: validation.IntBetween(0, 60),
													Description: `Seconds of minutes of the time. Must normally be from 0 to 59.
An API may allow the value 60 if it allows leap-seconds.`,
												},
											},
										},
									},
									"duration": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Duration of the maintenance window.
The current window is fixed at 1 hour.
A duration in seconds with up to nine fractional digits,
terminated by 's'. Example: "3.5s".`,
									},
								},
							},
						},
						"create_time": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The time when the policy was created.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
resolution and up to nine fractional digits.`,
						},
						"update_time": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The time when the policy was last updated.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
resolution and up to nine fractional digits.`,
						},
					},
				},
			},
			"managed_backup_source": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Managed backup source for the instance.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"backup": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Example: //memorystore.googleapis.com/projects/{project}/locations/{location}/backups/{backupId}. In this case, it assumes the backup is under memorystore.googleapis.com.`,
						},
					},
				},
				ConflictsWith: []string{"gcs_source"},
			},
			"mode": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"CLUSTER", "CLUSTER_DISABLED", ""}),
				Description: `Optional. cluster or cluster-disabled. 
 Possible values:
 CLUSTER
 CLUSTER_DISABLED Possible values: ["CLUSTER", "CLUSTER_DISABLED"]`,
			},
			"node_type": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				Description: `Optional. Machine type for individual nodes of the instance. 
 Possible values:
 SHARED_CORE_NANO
HIGHMEM_MEDIUM
HIGHMEM_XLARGE
STANDARD_SMALL`,
			},
			"persistence_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Represents persistence configuration for a instance.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"aof_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Configuration for AOF based persistence.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"append_fsync": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										Description: `Optional. The fsync mode. 
 Possible values:
 NEVER
EVERY_SEC
ALWAYS`,
									},
								},
							},
						},
						"mode": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"DISABLED", "RDB", "AOF", ""}),
							Description: `Optional. Current persistence mode. 
 Possible values:
DISABLED
RDB
AOF Possible values: ["DISABLED", "RDB", "AOF"]`,
						},
						"rdb_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Configuration for RDB based persistence.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"rdb_snapshot_period": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										Description: `Optional. Period between RDB snapshots. 
 Possible values:
 ONE_HOUR
SIX_HOURS
TWELVE_HOURS
TWENTY_FOUR_HOURS`,
									},
									"rdb_snapshot_start_time": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										Description: `Optional. Time that the first snapshot was/will be attempted, and to which future
snapshots will be aligned. If not provided, the current time will be
used.`,
									},
								},
							},
						},
					},
				},
			},
			"replica_count": {
				Type:        schema.TypeInt,
				Computed:    true,
				Optional:    true,
				Description: `Optional. Number of replica nodes per shard. If omitted the default is 0 replicas.`,
			},
			"transit_encryption_mode": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				ForceNew: true,
				Description: `Optional. Immutable. In-transit encryption mode of the instance. 
 Possible values:
 TRANSIT_ENCRYPTION_DISABLED
SERVER_AUTHENTICATION`,
			},
			"zone_distribution_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `Zone distribution configuration for allocation of instance resources.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"mode": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"MULTI_ZONE", "SINGLE_ZONE", ""}),
							Description: `Optional. Current zone distribution mode. Defaults to MULTI_ZONE. 
 Possible values:
 MULTI_ZONE
SINGLE_ZONE Possible values: ["MULTI_ZONE", "SINGLE_ZONE"]`,
						},
						"zone": {
							Type:     schema.TypeString,
							Optional: true,
							ForceNew: true,
							Description: `Optional. Defines zone where all resources will be allocated with SINGLE_ZONE mode.
Ignored for MULTI_ZONE mode.`,
						},
					},
				},
			},
			"backup_collection": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The backup collection full resource name.
Example: projects/{project}/locations/{location}/backupCollections/{collection}`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Creation timestamp of the instance.`,
			},
			"discovery_endpoints": {
				Type:       schema.TypeList,
				Computed:   true,
				Deprecated: "`discovery_endpoints` is deprecated  Use `endpoints` instead.",
				Description: `Output only. Endpoints clients can connect to the instance through. Currently only one
discovery endpoint is supported.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"address": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. IP address of the exposed endpoint clients connect to.`,
						},
						"network": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. The network where the IP address of the discovery endpoint will be
reserved, in the form of
projects/{network_project}/global/networks/{network_id}.`,
						},
						"port": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `Output only. The port number of the exposed endpoint.`,
						},
					},
				},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"endpoints": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Endpoints for the instance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"connections": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `A group of PSC connections. They are created in the same VPC network, one for each service attachment in the cluster.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"psc_auto_connection": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Detailed information of a PSC connection that is created through service connectivity automation.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"connection_type": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `Output Only. Type of a PSC Connection. 
 Possible values:
 CONNECTION_TYPE_DISCOVERY 
 CONNECTION_TYPE_PRIMARY 
 CONNECTION_TYPE_READER`,
												},
												"forwarding_rule": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `Output only. The URI of the consumer side forwarding rule.
Format:
projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}`,
												},
												"ip_address": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Output only. The IP allocated on the consumer network for the PSC forwarding rule.`,
												},
												"network": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `Output only. The consumer network where the IP address resides, in the form of
projects/{project_id}/global/networks/{network_id}.`,
												},
												"port": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: `Output only. Ports of the exposed endpoint.`,
												},
												"project_id": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Output only. The consumer project_id where the forwarding rule is created from.`,
												},
												"psc_connection_id": {
													Type:     schema.TypeString,
													Computed: true,
													Description: `Output only. The PSC connection id of the forwarding rule connected to the
service attachment.`,
												},
												"service_attachment": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.`,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"maintenance_schedule": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Upcoming maintenance schedule.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"end_time": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The end time of any upcoming scheduled maintenance for this cluster.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
resolution and up to nine fractional digits.`,
						},
						"schedule_deadline_time": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The deadline that the maintenance schedule start time
can not go beyond, including reschedule.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
resolution and up to nine fractional digits.`,
						},
						"start_time": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The start time of any upcoming scheduled maintenance for this cluster.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
resolution and up to nine fractional digits.`,
						},
					},
				},
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. Unique name of the instance.
Format: projects/{project}/locations/{location}/instances/{instance}`,
			},
			"node_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Represents configuration for nodes of the instance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"size_gb": {
							Type:        schema.TypeFloat,
							Computed:    true,
							Description: `Output only. Memory size in GB of the node.`,
						},
					},
				},
			},
			"psc_attachment_details": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Configuration of a service attachment of the cluster, for creating PSC connections.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"connection_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Service attachment URI which your self-created PscConnection should use as target.`,
						},
						"service_attachment": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Service attachment URI which your self-created PscConnection should use as target.`,
						},
					},
				},
			},
			"psc_auto_connections": {
				Type:        schema.TypeList,
				Computed:    true,
				Deprecated:  "`psc_auto_connections` is deprecated  Use `endpoints.connections.pscAutoConnections` instead.",
				Description: `Output only. User inputs and resource details of the auto-created PSC connections.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"connection_type": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output Only. Type of a PSC Connection. 
 Possible values:
 CONNECTION_TYPE_DISCOVERY 
 CONNECTION_TYPE_PRIMARY 
 CONNECTION_TYPE_READER`,
						},
						"forwarding_rule": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. The URI of the consumer side forwarding rule.
Format:
projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}`,
						},
						"ip_address": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. The IP allocated on the consumer network for the PSC forwarding rule.`,
						},
						"network": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. The consumer network where the IP address resides, in the form of
projects/{project_id}/global/networks/{network_id}.`,
						},
						"port": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `Output only. Ports of the exposed endpoint.`,
						},
						"project_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. The consumer project_id where the forwarding rule is created from.`,
						},
						"psc_connection_id": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. The PSC connection id of the forwarding rule connected to the
service attachment.`,
						},
						"psc_connection_status": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists. 
 Possible values:
 ACTIVE 
 NOT_FOUND`,
						},
						"service_attachment": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.`,
						},
					},
				},
			},
			"state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Output only. Current state of the instance. 
 Possible values:
 CREATING
ACTIVE
UPDATING
DELETING`,
			},
			"state_info": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Additional information about the state of the instance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"update_info": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Represents information about instance with state UPDATING.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"target_engine_version": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. Target engine version for the instance.`,
									},
									"target_node_type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Output only. Target node type for the instance.`,
									},
									"target_replica_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Output only. Target number of replica nodes per shard for the instance.`,
									},
									"target_shard_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Output only. Target number of shards for the instance.`,
									},
								},
							},
						},
					},
				},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. System assigned, unique identifier for the instance.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Latest update timestamp of the instance.`,
			},
			"desired_psc_auto_connections": {
				Type:        schema.TypeList,
				Optional:    true,
				Deprecated:  "`desired_psc_auto_connections` is deprecated  Use `desired_auto_created_endpoints` instead.",
				ForceNew:    true,
				Description: `'desired_psc_auto_connections' is deprecated  Use 'desired_auto_created_endpoints' instead.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"network": {
							Type:     schema.TypeString,
							Required: true,
							Description: `Required. The consumer network where the IP address resides, in the form of
projects/{project_id}/global/networks/{network_id}.`,
						},
						"project_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Required. The consumer project_id where the forwarding rule is created from.`,
						},
					},
				},
				ConflictsWith: []string{},
			},
			"desired_auto_created_endpoints": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Immutable. User inputs for the auto-created endpoints connections.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"network": {
							Type:     schema.TypeString,
							Required: true,
							Description: `Required. The consumer network where the IP address resides, in the form of
projects/{project_id}/global/networks/{network_id}.`,
						},
						"project_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Required. The consumer project_id where the forwarding rule is created from.`,
						},
					},
				},
				ConflictsWith: []string{},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceMemorystoreInstanceCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	automatedBackupConfigProp, err := expandMemorystoreInstanceAutomatedBackupConfig(d.Get("automated_backup_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("automated_backup_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(automatedBackupConfigProp)) && (ok || !reflect.DeepEqual(v, automatedBackupConfigProp)) {
		obj["automatedBackupConfig"] = automatedBackupConfigProp
	}
	replicaCountProp, err := expandMemorystoreInstanceReplicaCount(d.Get("replica_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("replica_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(replicaCountProp)) && (ok || !reflect.DeepEqual(v, replicaCountProp)) {
		obj["replicaCount"] = replicaCountProp
	}
	authorizationModeProp, err := expandMemorystoreInstanceAuthorizationMode(d.Get("authorization_mode"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("authorization_mode"); !tpgresource.IsEmptyValue(reflect.ValueOf(authorizationModeProp)) && (ok || !reflect.DeepEqual(v, authorizationModeProp)) {
		obj["authorizationMode"] = authorizationModeProp
	}
	transitEncryptionModeProp, err := expandMemorystoreInstanceTransitEncryptionMode(d.Get("transit_encryption_mode"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("transit_encryption_mode"); !tpgresource.IsEmptyValue(reflect.ValueOf(transitEncryptionModeProp)) && (ok || !reflect.DeepEqual(v, transitEncryptionModeProp)) {
		obj["transitEncryptionMode"] = transitEncryptionModeProp
	}
	shardCountProp, err := expandMemorystoreInstanceShardCount(d.Get("shard_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("shard_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(shardCountProp)) && (ok || !reflect.DeepEqual(v, shardCountProp)) {
		obj["shardCount"] = shardCountProp
	}
	nodeTypeProp, err := expandMemorystoreInstanceNodeType(d.Get("node_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("node_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(nodeTypeProp)) && (ok || !reflect.DeepEqual(v, nodeTypeProp)) {
		obj["nodeType"] = nodeTypeProp
	}
	persistenceConfigProp, err := expandMemorystoreInstancePersistenceConfig(d.Get("persistence_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("persistence_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(persistenceConfigProp)) && (ok || !reflect.DeepEqual(v, persistenceConfigProp)) {
		obj["persistenceConfig"] = persistenceConfigProp
	}
	maintenancePolicyProp, err := expandMemorystoreInstanceMaintenancePolicy(d.Get("maintenance_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("maintenance_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(maintenancePolicyProp)) && (ok || !reflect.DeepEqual(v, maintenancePolicyProp)) {
		obj["maintenancePolicy"] = maintenancePolicyProp
	}
	engineVersionProp, err := expandMemorystoreInstanceEngineVersion(d.Get("engine_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("engine_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(engineVersionProp)) && (ok || !reflect.DeepEqual(v, engineVersionProp)) {
		obj["engineVersion"] = engineVersionProp
	}
	engineConfigsProp, err := expandMemorystoreInstanceEngineConfigs(d.Get("engine_configs"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("engine_configs"); !tpgresource.IsEmptyValue(reflect.ValueOf(engineConfigsProp)) && (ok || !reflect.DeepEqual(v, engineConfigsProp)) {
		obj["engineConfigs"] = engineConfigsProp
	}
	zoneDistributionConfigProp, err := expandMemorystoreInstanceZoneDistributionConfig(d.Get("zone_distribution_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("zone_distribution_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(zoneDistributionConfigProp)) && (ok || !reflect.DeepEqual(v, zoneDistributionConfigProp)) {
		obj["zoneDistributionConfig"] = zoneDistributionConfigProp
	}
	deletionProtectionEnabledProp, err := expandMemorystoreInstanceDeletionProtectionEnabled(d.Get("deletion_protection_enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("deletion_protection_enabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(deletionProtectionEnabledProp)) && (ok || !reflect.DeepEqual(v, deletionProtectionEnabledProp)) {
		obj["deletionProtectionEnabled"] = deletionProtectionEnabledProp
	}
	crossInstanceReplicationConfigProp, err := expandMemorystoreInstanceCrossInstanceReplicationConfig(d.Get("cross_instance_replication_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cross_instance_replication_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(crossInstanceReplicationConfigProp)) && (ok || !reflect.DeepEqual(v, crossInstanceReplicationConfigProp)) {
		obj["crossInstanceReplicationConfig"] = crossInstanceReplicationConfigProp
	}
	modeProp, err := expandMemorystoreInstanceMode(d.Get("mode"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("mode"); !tpgresource.IsEmptyValue(reflect.ValueOf(modeProp)) && (ok || !reflect.DeepEqual(v, modeProp)) {
		obj["mode"] = modeProp
	}
	gcsSourceProp, err := expandMemorystoreInstanceGcsSource(d.Get("gcs_source"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("gcs_source"); !tpgresource.IsEmptyValue(reflect.ValueOf(gcsSourceProp)) && (ok || !reflect.DeepEqual(v, gcsSourceProp)) {
		obj["gcsSource"] = gcsSourceProp
	}
	managedBackupSourceProp, err := expandMemorystoreInstanceManagedBackupSource(d.Get("managed_backup_source"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("managed_backup_source"); !tpgresource.IsEmptyValue(reflect.ValueOf(managedBackupSourceProp)) && (ok || !reflect.DeepEqual(v, managedBackupSourceProp)) {
		obj["managedBackupSource"] = managedBackupSourceProp
	}
	labelsProp, err := expandMemorystoreInstanceEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	obj, err = resourceMemorystoreInstanceEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{MemorystoreBasePath}}projects/{{project}}/locations/{{location}}/instances?instanceId={{instance_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Instance: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Instance: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{instance_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = MemorystoreOperationWaitTime(
		config, res, project, "Creating Instance", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Instance: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Instance %q: %#v", d.Id(), res)

	return resourceMemorystoreInstanceRead(d, meta)
}

func resourceMemorystoreInstanceRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{MemorystoreBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("MemorystoreInstance %q", d.Id()))
	}

	res, err = resourceMemorystoreInstanceDecoder(d, meta, res)
	if err != nil {
		return err
	}

	if res == nil {
		// Decoding the object has resulted in it being gone. It may be marked deleted
		log.Printf("[DEBUG] Removing MemorystoreInstance because it no longer exists.")
		d.SetId("")
		return nil
	}

	// Explicitly set virtual fields to default values if unset
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}

	if err := d.Set("name", flattenMemorystoreInstanceName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("create_time", flattenMemorystoreInstanceCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("update_time", flattenMemorystoreInstanceUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("labels", flattenMemorystoreInstanceLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("state", flattenMemorystoreInstanceState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("state_info", flattenMemorystoreInstanceStateInfo(res["stateInfo"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("automated_backup_config", flattenMemorystoreInstanceAutomatedBackupConfig(res["automatedBackupConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("uid", flattenMemorystoreInstanceUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("replica_count", flattenMemorystoreInstanceReplicaCount(res["replicaCount"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("authorization_mode", flattenMemorystoreInstanceAuthorizationMode(res["authorizationMode"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("transit_encryption_mode", flattenMemorystoreInstanceTransitEncryptionMode(res["transitEncryptionMode"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("shard_count", flattenMemorystoreInstanceShardCount(res["shardCount"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("discovery_endpoints", flattenMemorystoreInstanceDiscoveryEndpoints(res["discoveryEndpoints"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("node_type", flattenMemorystoreInstanceNodeType(res["nodeType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("persistence_config", flattenMemorystoreInstancePersistenceConfig(res["persistenceConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("maintenance_policy", flattenMemorystoreInstanceMaintenancePolicy(res["maintenancePolicy"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("maintenance_schedule", flattenMemorystoreInstanceMaintenanceSchedule(res["maintenanceSchedule"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("engine_version", flattenMemorystoreInstanceEngineVersion(res["engineVersion"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("engine_configs", flattenMemorystoreInstanceEngineConfigs(res["engineConfigs"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("node_config", flattenMemorystoreInstanceNodeConfig(res["nodeConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("zone_distribution_config", flattenMemorystoreInstanceZoneDistributionConfig(res["zoneDistributionConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("deletion_protection_enabled", flattenMemorystoreInstanceDeletionProtectionEnabled(res["deletionProtectionEnabled"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("endpoints", flattenMemorystoreInstanceEndpoints(res["endpoints"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("cross_instance_replication_config", flattenMemorystoreInstanceCrossInstanceReplicationConfig(res["crossInstanceReplicationConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("mode", flattenMemorystoreInstanceMode(res["mode"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("psc_attachment_details", flattenMemorystoreInstancePscAttachmentDetails(res["pscAttachmentDetails"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("psc_auto_connections", flattenMemorystoreInstancePscAutoConnections(res["pscAutoConnections"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("backup_collection", flattenMemorystoreInstanceBackupCollection(res["backupCollection"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("terraform_labels", flattenMemorystoreInstanceTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("effective_labels", flattenMemorystoreInstanceEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}

	return nil
}

func resourceMemorystoreInstanceUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	automatedBackupConfigProp, err := expandMemorystoreInstanceAutomatedBackupConfig(d.Get("automated_backup_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("automated_backup_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, automatedBackupConfigProp)) {
		obj["automatedBackupConfig"] = automatedBackupConfigProp
	}
	replicaCountProp, err := expandMemorystoreInstanceReplicaCount(d.Get("replica_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("replica_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, replicaCountProp)) {
		obj["replicaCount"] = replicaCountProp
	}
	shardCountProp, err := expandMemorystoreInstanceShardCount(d.Get("shard_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("shard_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, shardCountProp)) {
		obj["shardCount"] = shardCountProp
	}
	nodeTypeProp, err := expandMemorystoreInstanceNodeType(d.Get("node_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("node_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nodeTypeProp)) {
		obj["nodeType"] = nodeTypeProp
	}
	persistenceConfigProp, err := expandMemorystoreInstancePersistenceConfig(d.Get("persistence_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("persistence_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, persistenceConfigProp)) {
		obj["persistenceConfig"] = persistenceConfigProp
	}
	maintenancePolicyProp, err := expandMemorystoreInstanceMaintenancePolicy(d.Get("maintenance_policy"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("maintenance_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, maintenancePolicyProp)) {
		obj["maintenancePolicy"] = maintenancePolicyProp
	}
	engineVersionProp, err := expandMemorystoreInstanceEngineVersion(d.Get("engine_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("engine_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, engineVersionProp)) {
		obj["engineVersion"] = engineVersionProp
	}
	engineConfigsProp, err := expandMemorystoreInstanceEngineConfigs(d.Get("engine_configs"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("engine_configs"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, engineConfigsProp)) {
		obj["engineConfigs"] = engineConfigsProp
	}
	deletionProtectionEnabledProp, err := expandMemorystoreInstanceDeletionProtectionEnabled(d.Get("deletion_protection_enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("deletion_protection_enabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, deletionProtectionEnabledProp)) {
		obj["deletionProtectionEnabled"] = deletionProtectionEnabledProp
	}
	crossInstanceReplicationConfigProp, err := expandMemorystoreInstanceCrossInstanceReplicationConfig(d.Get("cross_instance_replication_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cross_instance_replication_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, crossInstanceReplicationConfigProp)) {
		obj["crossInstanceReplicationConfig"] = crossInstanceReplicationConfigProp
	}
	labelsProp, err := expandMemorystoreInstanceEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	obj, err = resourceMemorystoreInstanceEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{MemorystoreBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Instance %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("automated_backup_config") {
		updateMask = append(updateMask, "automatedBackupConfig")
	}

	if d.HasChange("replica_count") {
		updateMask = append(updateMask, "replicaCount")
	}

	if d.HasChange("shard_count") {
		updateMask = append(updateMask, "shardCount")
	}

	if d.HasChange("node_type") {
		updateMask = append(updateMask, "nodeType")
	}

	if d.HasChange("persistence_config") {
		updateMask = append(updateMask, "persistenceConfig")
	}

	if d.HasChange("maintenance_policy") {
		updateMask = append(updateMask, "maintenancePolicy")
	}

	if d.HasChange("engine_version") {
		updateMask = append(updateMask, "engineVersion")
	}

	if d.HasChange("engine_configs") {
		updateMask = append(updateMask, "engineConfigs")
	}

	if d.HasChange("deletion_protection_enabled") {
		updateMask = append(updateMask, "deletionProtectionEnabled")
	}

	if d.HasChange("cross_instance_replication_config") {
		updateMask = append(updateMask, "crossInstanceReplicationConfig")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Instance %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Instance %q: %#v", d.Id(), res)
		}

		err = MemorystoreOperationWaitTime(
			config, res, project, "Updating Instance", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceMemorystoreInstanceRead(d, meta)
}

func resourceMemorystoreInstanceDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{MemorystoreBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Instance %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Instance")
	}

	err = MemorystoreOperationWaitTime(
		config, res, project, "Deleting Instance", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Instance %q: %#v", d.Id(), res)
	return nil
}

func resourceMemorystoreInstanceImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/instances/(?P<instance_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<instance_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<instance_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{instance_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Explicitly set virtual fields to default values on import

	return []*schema.ResourceData{d}, nil
}

func flattenMemorystoreInstanceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenMemorystoreInstanceState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceStateInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["update_info"] =
		flattenMemorystoreInstanceStateInfoUpdateInfo(original["updateInfo"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceStateInfoUpdateInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["target_shard_count"] =
		flattenMemorystoreInstanceStateInfoUpdateInfoTargetShardCount(original["targetShardCount"], d, config)
	transformed["target_replica_count"] =
		flattenMemorystoreInstanceStateInfoUpdateInfoTargetReplicaCount(original["targetReplicaCount"], d, config)
	transformed["target_engine_version"] =
		flattenMemorystoreInstanceStateInfoUpdateInfoTargetEngineVersion(original["targetEngineVersion"], d, config)
	transformed["target_node_type"] =
		flattenMemorystoreInstanceStateInfoUpdateInfoTargetNodeType(original["targetNodeType"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceStateInfoUpdateInfoTargetShardCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceStateInfoUpdateInfoTargetReplicaCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceStateInfoUpdateInfoTargetEngineVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceStateInfoUpdateInfoTargetNodeType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceAutomatedBackupConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	// if automated_backup_config is not defined

	if original["automatedBackupMode"] == "DISABLED" {
		return nil
	}

	transformed["fixed_frequency_schedule"] =
		flattenMemorystoreInstanceAutomatedBackupConfigFixedFrequencySchedule(original["fixedFrequencySchedule"], d, config)
	transformed["retention"] =
		flattenMemorystoreInstanceAutomatedBackupConfigRetention(original["retention"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceAutomatedBackupConfigFixedFrequencySchedule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}

	transformed := make(map[string]interface{})
	transformed["start_time"] =
		flattenMemorystoreInstanceAutomatedBackupConfigFixedFrequencyScheduleStartTime(original["startTime"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceAutomatedBackupConfigFixedFrequencyScheduleStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}

	transformed := make(map[string]interface{})
	transformed["hours"] =
		flattenMemorystoreInstanceAutomatedBackupConfigFixedFrequencyScheduleStartTimeHours(original["hours"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceAutomatedBackupConfigFixedFrequencyScheduleStartTimeHours(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceAutomatedBackupConfigRetention(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {

	return v
}

func flattenMemorystoreInstanceUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceReplicaCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceAuthorizationMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceTransitEncryptionMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceShardCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceDiscoveryEndpoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"address": flattenMemorystoreInstanceDiscoveryEndpointsAddress(original["address"], d, config),
			"port":    flattenMemorystoreInstanceDiscoveryEndpointsPort(original["port"], d, config),
			"network": flattenMemorystoreInstanceDiscoveryEndpointsNetwork(original["network"], d, config),
		})
	}
	return transformed
}
func flattenMemorystoreInstanceDiscoveryEndpointsAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceDiscoveryEndpointsPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceDiscoveryEndpointsNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceNodeType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePersistenceConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["mode"] =
		flattenMemorystoreInstancePersistenceConfigMode(original["mode"], d, config)
	transformed["rdb_config"] =
		flattenMemorystoreInstancePersistenceConfigRdbConfig(original["rdbConfig"], d, config)
	transformed["aof_config"] =
		flattenMemorystoreInstancePersistenceConfigAofConfig(original["aofConfig"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstancePersistenceConfigMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePersistenceConfigRdbConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["rdb_snapshot_period"] =
		flattenMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotPeriod(original["rdbSnapshotPeriod"], d, config)
	transformed["rdb_snapshot_start_time"] =
		flattenMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotStartTime(original["rdbSnapshotStartTime"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotPeriod(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePersistenceConfigAofConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["append_fsync"] =
		flattenMemorystoreInstancePersistenceConfigAofConfigAppendFsync(original["appendFsync"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstancePersistenceConfigAofConfigAppendFsync(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceMaintenancePolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["create_time"] =
		flattenMemorystoreInstanceMaintenancePolicyCreateTime(original["createTime"], d, config)
	transformed["update_time"] =
		flattenMemorystoreInstanceMaintenancePolicyUpdateTime(original["updateTime"], d, config)
	transformed["weekly_maintenance_window"] =
		flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindow(original["weeklyMaintenanceWindow"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceMaintenancePolicyCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceMaintenancePolicyUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindow(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"day":        flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowDay(original["day"], d, config),
			"duration":   flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowDuration(original["duration"], d, config),
			"start_time": flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTime(original["startTime"], d, config),
		})
	}
	return transformed
}
func flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowDay(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["hours"] =
		flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeHours(original["hours"], d, config)
	transformed["minutes"] =
		flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeMinutes(original["minutes"], d, config)
	transformed["seconds"] =
		flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeSeconds(original["seconds"], d, config)
	transformed["nanos"] =
		flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeNanos(original["nanos"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeHours(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeMinutes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeNanos(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceMaintenanceSchedule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["start_time"] =
		flattenMemorystoreInstanceMaintenanceScheduleStartTime(original["startTime"], d, config)
	transformed["end_time"] =
		flattenMemorystoreInstanceMaintenanceScheduleEndTime(original["endTime"], d, config)
	transformed["schedule_deadline_time"] =
		flattenMemorystoreInstanceMaintenanceScheduleScheduleDeadlineTime(original["scheduleDeadlineTime"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceMaintenanceScheduleStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceMaintenanceScheduleEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceMaintenanceScheduleScheduleDeadlineTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEngineVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEngineConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceNodeConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["size_gb"] =
		flattenMemorystoreInstanceNodeConfigSizeGb(original["sizeGb"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceNodeConfigSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceZoneDistributionConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["zone"] =
		flattenMemorystoreInstanceZoneDistributionConfigZone(original["zone"], d, config)
	transformed["mode"] =
		flattenMemorystoreInstanceZoneDistributionConfigMode(original["mode"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceZoneDistributionConfigZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceZoneDistributionConfigMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceDeletionProtectionEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEndpoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"connections": flattenMemorystoreInstanceEndpointsConnections(original["connections"], d, config),
		})
	}
	return transformed
}
func flattenMemorystoreInstanceEndpointsConnections(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"psc_auto_connection": flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnection(original["pscAutoConnection"], d, config),
		})
	}
	return transformed
}
func flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnection(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["psc_connection_id"] =
		flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionPscConnectionId(original["pscConnectionId"], d, config)
	transformed["ip_address"] =
		flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionIpAddress(original["ipAddress"], d, config)
	transformed["forwarding_rule"] =
		flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionForwardingRule(original["forwardingRule"], d, config)
	transformed["project_id"] =
		flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionProjectId(original["projectId"], d, config)
	transformed["network"] =
		flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionNetwork(original["network"], d, config)
	transformed["service_attachment"] =
		flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionServiceAttachment(original["serviceAttachment"], d, config)
	transformed["connection_type"] =
		flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionConnectionType(original["connectionType"], d, config)
	transformed["port"] =
		flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionPort(original["port"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionPscConnectionId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionIpAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionForwardingRule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionProjectId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionServiceAttachment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionConnectionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEndpointsConnectionsPscAutoConnectionPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceCrossInstanceReplicationConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["instance_role"] =
		flattenMemorystoreInstanceCrossInstanceReplicationConfigInstanceRole(original["instanceRole"], d, config)
	transformed["primary_instance"] =
		flattenMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstance(original["primaryInstance"], d, config)
	transformed["secondary_instances"] =
		flattenMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstances(original["secondaryInstances"], d, config)
	transformed["membership"] =
		flattenMemorystoreInstanceCrossInstanceReplicationConfigMembership(original["membership"], d, config)
	transformed["update_time"] =
		flattenMemorystoreInstanceCrossInstanceReplicationConfigUpdateTime(original["updateTime"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceCrossInstanceReplicationConfigInstanceRole(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["instance"] =
		flattenMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstanceInstance(original["instance"], d, config)
	transformed["uid"] =
		flattenMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstanceUid(original["uid"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstanceInstance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstanceUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstances(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"instance": flattenMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstancesInstance(original["instance"], d, config),
			"uid":      flattenMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstancesUid(original["uid"], d, config),
		})
	}
	return transformed
}
func flattenMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstancesInstance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstancesUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceCrossInstanceReplicationConfigMembership(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["primary_instance"] =
		flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstance(original["primaryInstance"], d, config)
	transformed["secondary_instance"] =
		flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstance(original["secondaryInstance"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["instance"] =
		flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceInstance(original["instance"], d, config)
	transformed["uid"] =
		flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceUid(original["uid"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceInstance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"instance": flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceInstance(original["instance"], d, config),
			"uid":      flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceUid(original["uid"], d, config),
		})
	}
	return transformed
}
func flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceInstance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceCrossInstanceReplicationConfigUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAttachmentDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"service_attachment": flattenMemorystoreInstancePscAttachmentDetailsServiceAttachment(original["serviceAttachment"], d, config),
			"connection_type":    flattenMemorystoreInstancePscAttachmentDetailsConnectionType(original["connectionType"], d, config),
		})
	}
	return transformed
}
func flattenMemorystoreInstancePscAttachmentDetailsServiceAttachment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAttachmentDetailsConnectionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnections(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"psc_connection_id":     flattenMemorystoreInstancePscAutoConnectionsPscConnectionId(original["pscConnectionId"], d, config),
			"ip_address":            flattenMemorystoreInstancePscAutoConnectionsIpAddress(original["ipAddress"], d, config),
			"forwarding_rule":       flattenMemorystoreInstancePscAutoConnectionsForwardingRule(original["forwardingRule"], d, config),
			"project_id":            flattenMemorystoreInstancePscAutoConnectionsProjectId(original["projectId"], d, config),
			"network":               flattenMemorystoreInstancePscAutoConnectionsNetwork(original["network"], d, config),
			"service_attachment":    flattenMemorystoreInstancePscAutoConnectionsServiceAttachment(original["serviceAttachment"], d, config),
			"psc_connection_status": flattenMemorystoreInstancePscAutoConnectionsPscConnectionStatus(original["pscConnectionStatus"], d, config),
			"connection_type":       flattenMemorystoreInstancePscAutoConnectionsConnectionType(original["connectionType"], d, config),
			"port":                  flattenMemorystoreInstancePscAutoConnectionsPort(original["port"], d, config),
		})
	}
	return transformed
}
func flattenMemorystoreInstancePscAutoConnectionsPscConnectionId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsIpAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsForwardingRule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsProjectId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsServiceAttachment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsPscConnectionStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsConnectionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceBackupCollection(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenMemorystoreInstanceEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandMemorystoreInstanceAutomatedBackupConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})

	// The automated_backup_config block is not specified, so automatedBackupMode should be DISABLED
	transformed := make(map[string]interface{})
	if len(d.Get("automated_backup_config").([]interface{})) < 1 {
		transformed["automatedBackupMode"] = "DISABLED"
		return transformed, nil
	}
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})

	// The automated_backup_config block is specified, so automatedBackupMode should be ENABLED
	transformed["automatedBackupMode"] = "ENABLED"
	transformedFixedFrequencySchedule, err := expandMemorystoreInstanceAutomatedBackupConfigFixedFrequencySchedule(original["fixed_frequency_schedule"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFixedFrequencySchedule); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fixedFrequencySchedule"] = transformedFixedFrequencySchedule
	}

	transformedRetention, err := expandMemorystoreInstanceAutomatedBackupConfigRetention(original["retention"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRetention); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["retention"] = transformedRetention
	}

	return transformed, nil
}

func expandMemorystoreInstanceAutomatedBackupConfigFixedFrequencySchedule(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedStartTime, err := expandMemorystoreInstanceAutomatedBackupConfigFixedFrequencyScheduleStartTime(original["start_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStartTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["startTime"] = transformedStartTime
	}

	return transformed, nil
}

func expandMemorystoreInstanceAutomatedBackupConfigFixedFrequencyScheduleStartTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHours, err := expandMemorystoreInstanceAutomatedBackupConfigFixedFrequencyScheduleStartTimeHours(original["hours"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHours); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hours"] = transformedHours
	}

	return transformed, nil
}

func expandMemorystoreInstanceAutomatedBackupConfigFixedFrequencyScheduleStartTimeHours(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceAutomatedBackupConfigRetention(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceReplicaCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceAuthorizationMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceTransitEncryptionMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceShardCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceNodeType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstancePersistenceConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMode, err := expandMemorystoreInstancePersistenceConfigMode(original["mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["mode"] = transformedMode
	}

	transformedRdbConfig, err := expandMemorystoreInstancePersistenceConfigRdbConfig(original["rdb_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRdbConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rdbConfig"] = transformedRdbConfig
	}

	transformedAofConfig, err := expandMemorystoreInstancePersistenceConfigAofConfig(original["aof_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAofConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["aofConfig"] = transformedAofConfig
	}

	return transformed, nil
}

func expandMemorystoreInstancePersistenceConfigMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstancePersistenceConfigRdbConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRdbSnapshotPeriod, err := expandMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotPeriod(original["rdb_snapshot_period"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRdbSnapshotPeriod); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rdbSnapshotPeriod"] = transformedRdbSnapshotPeriod
	}

	transformedRdbSnapshotStartTime, err := expandMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotStartTime(original["rdb_snapshot_start_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRdbSnapshotStartTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rdbSnapshotStartTime"] = transformedRdbSnapshotStartTime
	}

	return transformed, nil
}

func expandMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotPeriod(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotStartTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstancePersistenceConfigAofConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAppendFsync, err := expandMemorystoreInstancePersistenceConfigAofConfigAppendFsync(original["append_fsync"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAppendFsync); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["appendFsync"] = transformedAppendFsync
	}

	return transformed, nil
}

func expandMemorystoreInstancePersistenceConfigAofConfigAppendFsync(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceMaintenancePolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCreateTime, err := expandMemorystoreInstanceMaintenancePolicyCreateTime(original["create_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCreateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["createTime"] = transformedCreateTime
	}

	transformedUpdateTime, err := expandMemorystoreInstanceMaintenancePolicyUpdateTime(original["update_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUpdateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["updateTime"] = transformedUpdateTime
	}

	transformedWeeklyMaintenanceWindow, err := expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindow(original["weekly_maintenance_window"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWeeklyMaintenanceWindow); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["weeklyMaintenanceWindow"] = transformedWeeklyMaintenanceWindow
	}

	return transformed, nil
}

func expandMemorystoreInstanceMaintenancePolicyCreateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceMaintenancePolicyUpdateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindow(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDay, err := expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowDay(original["day"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDay); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["day"] = transformedDay
		}

		transformedDuration, err := expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowDuration(original["duration"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDuration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["duration"] = transformedDuration
		}

		transformedStartTime, err := expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTime(original["start_time"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["startTime"] = transformedStartTime
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowDay(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHours, err := expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeHours(original["hours"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHours); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hours"] = transformedHours
	}

	transformedMinutes, err := expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeMinutes(original["minutes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinutes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minutes"] = transformedMinutes
	}

	transformedSeconds, err := expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeSeconds(original["seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["seconds"] = transformedSeconds
	}

	transformedNanos, err := expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeNanos(original["nanos"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNanos); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nanos"] = transformedNanos
	}

	return transformed, nil
}

func expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeHours(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeMinutes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeNanos(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceEngineVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceEngineConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandMemorystoreInstanceZoneDistributionConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedZone, err := expandMemorystoreInstanceZoneDistributionConfigZone(original["zone"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedZone); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["zone"] = transformedZone
	}

	transformedMode, err := expandMemorystoreInstanceZoneDistributionConfigMode(original["mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["mode"] = transformedMode
	}

	return transformed, nil
}

func expandMemorystoreInstanceZoneDistributionConfigZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceZoneDistributionConfigMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceDeletionProtectionEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInstanceRole, err := expandMemorystoreInstanceCrossInstanceReplicationConfigInstanceRole(original["instance_role"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstanceRole); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instanceRole"] = transformedInstanceRole
	}

	transformedPrimaryInstance, err := expandMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstance(original["primary_instance"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrimaryInstance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["primaryInstance"] = transformedPrimaryInstance
	}

	transformedSecondaryInstances, err := expandMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstances(original["secondary_instances"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecondaryInstances); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secondaryInstances"] = transformedSecondaryInstances
	}

	transformedMembership, err := expandMemorystoreInstanceCrossInstanceReplicationConfigMembership(original["membership"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMembership); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["membership"] = transformedMembership
	}

	transformedUpdateTime, err := expandMemorystoreInstanceCrossInstanceReplicationConfigUpdateTime(original["update_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUpdateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["updateTime"] = transformedUpdateTime
	}

	return transformed, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigInstanceRole(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInstance, err := expandMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstanceInstance(original["instance"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instance"] = transformedInstance
	}

	transformedUid, err := expandMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstanceUid(original["uid"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUid); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uid"] = transformedUid
	}

	return transformed, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstanceInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigPrimaryInstanceUid(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstances(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedInstance, err := expandMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstancesInstance(original["instance"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInstance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["instance"] = transformedInstance
		}

		transformedUid, err := expandMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstancesUid(original["uid"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedUid); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["uid"] = transformedUid
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstancesInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigSecondaryInstancesUid(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigMembership(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPrimaryInstance, err := expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstance(original["primary_instance"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrimaryInstance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["primaryInstance"] = transformedPrimaryInstance
	}

	transformedSecondaryInstance, err := expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstance(original["secondary_instance"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecondaryInstance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secondaryInstance"] = transformedSecondaryInstance
	}

	return transformed, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInstance, err := expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceInstance(original["instance"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instance"] = transformedInstance
	}

	transformedUid, err := expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceUid(original["uid"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUid); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uid"] = transformedUid
	}

	return transformed, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceUid(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedInstance, err := expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceInstance(original["instance"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInstance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["instance"] = transformedInstance
		}

		transformedUid, err := expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceUid(original["uid"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedUid); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["uid"] = transformedUid
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceUid(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceCrossInstanceReplicationConfigUpdateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceGcsSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUris, err := expandMemorystoreInstanceGcsSourceUris(original["uris"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUris); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uris"] = transformedUris
	}

	return transformed, nil
}

func expandMemorystoreInstanceGcsSourceUris(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	v = v.(*schema.Set).List()
	return v, nil
}

func expandMemorystoreInstanceManagedBackupSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBackup, err := expandMemorystoreInstanceManagedBackupSourceBackup(original["backup"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBackup); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["backup"] = transformedBackup
	}

	return transformed, nil
}

func expandMemorystoreInstanceManagedBackupSourceBackup(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func resourceMemorystoreInstanceEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	// Handles desired_auto_created_endpoints virtual field
	v, ok := d.GetOk("desired_auto_created_endpoints")
	if ok {
		l := v.([]interface{})
		if len(l) > 0 {
			endpoints := make([]interface{}, 1)
			endpointObj := make(map[string]interface{})
			connections := make([]interface{}, 0, len(l))

			for _, raw := range l {
				if raw == nil {
					continue
				}
				desiredEndpoint := raw.(map[string]interface{})
				connectionObj := make(map[string]interface{})
				pscAutoConnection := make(map[string]interface{})

				projectId := desiredEndpoint["project_id"]
				if val := reflect.ValueOf(projectId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
					pscAutoConnection["projectId"] = projectId
				}

				network := desiredEndpoint["network"]
				if val := reflect.ValueOf(network); val.IsValid() && !tpgresource.IsEmptyValue(val) {
					pscAutoConnection["network"] = network
				}

				connectionObj["pscAutoConnection"] = pscAutoConnection
				connections = append(connections, connectionObj)
			}

			endpointObj["connections"] = connections
			endpoints[0] = endpointObj
			obj["endpoints"] = endpoints
			log.Printf("[DEBUG] You are setting desired_auto_created_endpoints in encoder %#v", endpoints)

		}
		// Handles desired_auto_created_endpoints virtual field
	} else if v, ok := d.GetOk("desired_psc_auto_connections"); ok {
		l := v.([]interface{})
		req := make([]interface{}, 0, len(l))
		for _, raw := range l {
			if raw == nil {
				continue
			}
			desiredConnection := raw.(map[string]interface{})
			connectionReq := make(map[string]interface{})

			projectId := desiredConnection["project_id"]
			if val := reflect.ValueOf(projectId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
				connectionReq["projectId"] = projectId
			}

			network := desiredConnection["network"]
			if val := reflect.ValueOf(network); val.IsValid() && !tpgresource.IsEmptyValue(val) {
				connectionReq["network"] = network
			}

			req = append(req, connectionReq)
		}

		obj["pscAutoConnections"] = req
		log.Printf("[DEBUG] You are setting desired_psc_auto_connections in encoder  %#v", req)

	}

	// If the automated_backup_config is not defined, automatedBackupMode needs to be passed and set to DISABLED in the expand
	if obj["automatedBackupConfig"] == nil {
		config := meta.(*transport_tpg.Config)
		automatedBackupConfigProp, _ := expandMemorystoreInstanceAutomatedBackupConfig(d.Get("automated_backup_config"), d, config)
		obj["automatedBackupConfig"] = automatedBackupConfigProp
	}
	return obj, nil
}

func resourceMemorystoreInstanceDecoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
	// Retrieve endpoints.connections.pscAutoConnection from API response
	v, ok := res["pscAutoConnections"]
	if ok {

		connections, ok := v.([]interface{})
		if !ok {
			return nil, fmt.Errorf("pscAutoConnections is not an array")
		}

		transformed := make([]interface{}, 0, len(connections))
		uniqueConnections := make(map[string]bool) // Track unique project+network combos

		for _, raw := range connections {
			connectionData, ok := raw.(map[string]interface{})
			if !ok || len(connectionData) < 1 {
				return nil, fmt.Errorf("Invalid or empty psc connection data: %v", raw)
			}

			projectID, ok := connectionData["projectId"].(string)
			if !ok {
				return nil, fmt.Errorf("invalid project ID in psc connection: %v", connectionData)
			}

			networkID, ok := connectionData["network"].(string)
			if !ok {
				return nil, fmt.Errorf("invalid network ID in psc connection: %v", connectionData)
			}

			uniqueKey := projectID + networkID
			if !uniqueConnections[uniqueKey] { // Check for uniqueness
				uniqueConnections[uniqueKey] = true
				transformed = append(transformed, map[string]interface{}{
					"project_id": projectID,
					"network":    networkID,
				})
			}
		}
		d.Set("desired_psc_auto_connections", transformed)
		log.Printf("[DEBUG] You are setting desired_psc_auto_connections in decoder %#v", transformed)

		// Retrieve pscAutoConnections from API response
	} else if v, ok := res["endpoints"]; ok {

		endpointsArray, ok := v.([]interface{})
		if !ok || len(endpointsArray) == 0 {
			// No endpoints or empty array, nothing to process
		} else {
			transformed := make([]interface{}, 0)
			uniqueEndpoints := make(map[string]bool) // Track unique project+network combos

			for _, endpoint := range endpointsArray {
				endpointData, ok := endpoint.(map[string]interface{})
				if !ok {
					continue
				}

				connections, ok := endpointData["connections"].([]interface{})
				if !ok {
					continue
				}

				for _, connection := range connections {
					connectionData, ok := connection.(map[string]interface{})
					if !ok {
						continue
					}

					pscAutoConnection, ok := connectionData["pscAutoConnection"].(map[string]interface{})
					if !ok {
						continue
					}

					projectID, projectOk := pscAutoConnection["projectId"].(string)
					networkID, networkOk := pscAutoConnection["network"].(string)

					if projectOk && networkOk {
						uniqueKey := projectID + networkID
						if !uniqueEndpoints[uniqueKey] { // Check for uniqueness
							uniqueEndpoints[uniqueKey] = true
							transformed = append(transformed, map[string]interface{}{
								"project_id": projectID,
								"network":    networkID,
							})
						}
					}
				}
			}
			if len(transformed) > 0 {
				d.Set("desired_auto_created_endpoints", transformed)
				log.Printf("[DEBUG] Setting desired_auto_created_endpoints in decoder for %#v", transformed)

			}
		}

	}

	return res, nil
}
