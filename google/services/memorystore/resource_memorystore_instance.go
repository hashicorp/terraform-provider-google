// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package memorystore

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceMemorystoreInstance() *schema.Resource {
	return &schema.Resource{
		Create: resourceMemorystoreInstanceCreate,
		Read:   resourceMemorystoreInstanceRead,
		Update: resourceMemorystoreInstanceUpdate,
		Delete: resourceMemorystoreInstanceDelete,

		Importer: &schema.ResourceImporter{
			State: resourceMemorystoreInstanceImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(60 * time.Minute),
			Update: schema.DefaultTimeout(120 * time.Minute),
			Delete: schema.DefaultTimeout(30 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"instance_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Required. The ID to use for the instance, which will become the final component of
the instance's resource name.

This value is subject to the following restrictions:

* Must be 4-63 characters in length
* Must begin with a letter or digit
* Must contain only lowercase letters, digits, and hyphens
* Must not end with a hyphen
* Must be unique within a location`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type 'memorystore.googleapis.com/CertificateAuthority'.`,
			},
			"shard_count": {
				Type:        schema.TypeInt,
				Required:    true,
				Description: `Required. Number of shards for the instance.`,
			},
			"authorization_mode": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				ForceNew: true,
				Description: `Optional. Immutable. Authorization mode of the instance. Possible values:
 AUTH_DISABLED
IAM_AUTH`,
			},
			"deletion_protection_enabled": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Optional. If set to true deletion of the instance will fail.`,
				Default:     true,
			},
			"engine_configs": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: `Optional. User-provided engine configurations for the instance.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"engine_version": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `Optional. Immutable. Engine version of the instance.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Optional. Labels to represent user-provided metadata. 

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"mode": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"CLUSTER", "STANDALONE", ""}),
				Description: `Optional. Standalone or cluster. 
 Possible values:
 CLUSTER
STANDALONE Possible values: ["CLUSTER", "STANDALONE"]`,
			},
			"node_type": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				ForceNew: true,
				Description: `Optional. Immutable. Machine type for individual nodes of the instance. 
 Possible values:
 SHARED_CORE_NANO
HIGHMEM_MEDIUM
HIGHMEM_XLARGE
STANDARD_SMALL`,
			},
			"persistence_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Represents persistence configuration for a instance.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"aof_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Configuration for AOF based persistence.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"append_fsync": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										Description: `Optional. The fsync mode. 
 Possible values:
 NEVER
EVERY_SEC
ALWAYS`,
									},
								},
							},
						},
						"mode": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"DISABLED", "RDB", "AOF", ""}),
							Description: `Optional. Current persistence mode. 
 Possible values:
DISABLED
RDB
AOF Possible values: ["DISABLED", "RDB", "AOF"]`,
						},
						"rdb_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Configuration for RDB based persistence.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"rdb_snapshot_period": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										Description: `Optional. Period between RDB snapshots. 
 Possible values:
 ONE_HOUR
SIX_HOURS
TWELVE_HOURS
TWENTY_FOUR_HOURS`,
									},
									"rdb_snapshot_start_time": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										Description: `Optional. Time that the first snapshot was/will be attempted, and to which future
snapshots will be aligned. If not provided, the current time will be
used.`,
									},
								},
							},
						},
					},
				},
			},
			"replica_count": {
				Type:        schema.TypeInt,
				Computed:    true,
				Optional:    true,
				Description: `Optional. Number of replica nodes per shard. If omitted the default is 0 replicas.`,
			},
			"transit_encryption_mode": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				ForceNew: true,
				Description: `Optional. Immutable. In-transit encryption mode of the instance. 
 Possible values:
 TRANSIT_ENCRYPTION_DISABLED
SERVER_AUTHENTICATION`,
			},
			"zone_distribution_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `Zone distribution configuration for allocation of instance resources.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"mode": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"MULTI_ZONE", "SINGLE_ZONE", ""}),
							Description: `Optional. Current zone distribution mode. Defaults to MULTI_ZONE. 
 Possible values:
 MULTI_ZONE
SINGLE_ZONE Possible values: ["MULTI_ZONE", "SINGLE_ZONE"]`,
						},
						"zone": {
							Type:     schema.TypeString,
							Optional: true,
							ForceNew: true,
							Description: `Optional. Defines zone where all resources will be allocated with SINGLE_ZONE mode.
Ignored for MULTI_ZONE mode.`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Creation timestamp of the instance.`,
			},
			"discovery_endpoints": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `Output only. Endpoints clients can connect to the instance through. Currently only one
discovery endpoint is supported.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"address": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. IP address of the exposed endpoint clients connect to.`,
						},
						"network": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. The network where the IP address of the discovery endpoint will be
reserved, in the form of
projects/{network_project}/global/networks/{network_id}.`,
						},
						"port": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `Output only. The port number of the exposed endpoint.`,
						},
					},
				},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"endpoints": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Endpoints for the instance.`,
				Elem: &schema.Schema{
					Type: schema.TypeList,
				},
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. Unique name of the instance.
Format: projects/{project}/locations/{location}/instances/{instance}`,
			},
			"node_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Represents configuration for nodes of the instance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"size_gb": {
							Type:        schema.TypeFloat,
							Computed:    true,
							Description: `Output only. Memory size in GB of the node.`,
						},
					},
				},
			},
			"psc_auto_connections": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. User inputs and resource details of the auto-created PSC connections.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"connection_type": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output Only. Type of a PSC Connection. 
 Possible values:
 CONNECTION_TYPE_DISCOVERY 
 CONNECTION_TYPE_PRIMARY 
 CONNECTION_TYPE_READER`,
						},
						"forwarding_rule": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. The URI of the consumer side forwarding rule.
Format:
projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}`,
						},
						"ip_address": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. The IP allocated on the consumer network for the PSC forwarding rule.`,
						},
						"network": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. The consumer network where the IP address resides, in the form of
projects/{project_id}/global/networks/{network_id}.`,
						},
						"port": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `Output only. Ports of the exposed endpoint.`,
						},
						"project_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. The consumer project_id where the forwarding rule is created from.`,
						},
						"psc_connection_id": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. The PSC connection id of the forwarding rule connected to the
service attachment.`,
						},
						"psc_connection_status": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists. 
 Possible values:
 ACTIVE 
 NOT_FOUND`,
						},
						"service_attachment": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.`,
						},
					},
				},
			},
			"state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Output only. Current state of the instance. 
 Possible values:
 CREATING
ACTIVE
UPDATING
DELETING`,
			},
			"state_info": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Additional information about the state of the instance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"update_info": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Represents information about instance with state UPDATING.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"target_replica_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Output only. Target number of replica nodes per shard for the instance.`,
									},
									"target_shard_count": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Output only. Target number of shards for the instance.`,
									},
								},
							},
						},
					},
				},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. System assigned, unique identifier for the instance.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Latest update timestamp of the instance.`,
			},
			"desired_psc_auto_connections": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `Required. Immutable. User inputs for the auto-created PSC connections.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"network": {
							Type:     schema.TypeString,
							Required: true,
							Description: `Required. The consumer network where the IP address resides, in the form of
projects/{project_id}/global/networks/{network_id}.`,
						},
						"project_id": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `Required. The consumer project_id where the forwarding rule is created from.`,
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceMemorystoreInstanceCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	replicaCountProp, err := expandMemorystoreInstanceReplicaCount(d.Get("replica_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("replica_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(replicaCountProp)) && (ok || !reflect.DeepEqual(v, replicaCountProp)) {
		obj["replicaCount"] = replicaCountProp
	}
	authorizationModeProp, err := expandMemorystoreInstanceAuthorizationMode(d.Get("authorization_mode"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("authorization_mode"); !tpgresource.IsEmptyValue(reflect.ValueOf(authorizationModeProp)) && (ok || !reflect.DeepEqual(v, authorizationModeProp)) {
		obj["authorizationMode"] = authorizationModeProp
	}
	transitEncryptionModeProp, err := expandMemorystoreInstanceTransitEncryptionMode(d.Get("transit_encryption_mode"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("transit_encryption_mode"); !tpgresource.IsEmptyValue(reflect.ValueOf(transitEncryptionModeProp)) && (ok || !reflect.DeepEqual(v, transitEncryptionModeProp)) {
		obj["transitEncryptionMode"] = transitEncryptionModeProp
	}
	shardCountProp, err := expandMemorystoreInstanceShardCount(d.Get("shard_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("shard_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(shardCountProp)) && (ok || !reflect.DeepEqual(v, shardCountProp)) {
		obj["shardCount"] = shardCountProp
	}
	nodeTypeProp, err := expandMemorystoreInstanceNodeType(d.Get("node_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("node_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(nodeTypeProp)) && (ok || !reflect.DeepEqual(v, nodeTypeProp)) {
		obj["nodeType"] = nodeTypeProp
	}
	persistenceConfigProp, err := expandMemorystoreInstancePersistenceConfig(d.Get("persistence_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("persistence_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(persistenceConfigProp)) && (ok || !reflect.DeepEqual(v, persistenceConfigProp)) {
		obj["persistenceConfig"] = persistenceConfigProp
	}
	engineVersionProp, err := expandMemorystoreInstanceEngineVersion(d.Get("engine_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("engine_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(engineVersionProp)) && (ok || !reflect.DeepEqual(v, engineVersionProp)) {
		obj["engineVersion"] = engineVersionProp
	}
	engineConfigsProp, err := expandMemorystoreInstanceEngineConfigs(d.Get("engine_configs"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("engine_configs"); !tpgresource.IsEmptyValue(reflect.ValueOf(engineConfigsProp)) && (ok || !reflect.DeepEqual(v, engineConfigsProp)) {
		obj["engineConfigs"] = engineConfigsProp
	}
	zoneDistributionConfigProp, err := expandMemorystoreInstanceZoneDistributionConfig(d.Get("zone_distribution_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("zone_distribution_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(zoneDistributionConfigProp)) && (ok || !reflect.DeepEqual(v, zoneDistributionConfigProp)) {
		obj["zoneDistributionConfig"] = zoneDistributionConfigProp
	}
	deletionProtectionEnabledProp, err := expandMemorystoreInstanceDeletionProtectionEnabled(d.Get("deletion_protection_enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("deletion_protection_enabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(deletionProtectionEnabledProp)) && (ok || !reflect.DeepEqual(v, deletionProtectionEnabledProp)) {
		obj["deletionProtectionEnabled"] = deletionProtectionEnabledProp
	}
	modeProp, err := expandMemorystoreInstanceMode(d.Get("mode"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("mode"); !tpgresource.IsEmptyValue(reflect.ValueOf(modeProp)) && (ok || !reflect.DeepEqual(v, modeProp)) {
		obj["mode"] = modeProp
	}
	labelsProp, err := expandMemorystoreInstanceEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	obj, err = resourceMemorystoreInstanceEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{MemorystoreBasePath}}projects/{{project}}/locations/{{location}}/instances?instanceId={{instance_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Instance: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Instance: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{instance_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = MemorystoreOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating Instance", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create Instance: %s", err)
	}

	opRes, err = resourceMemorystoreInstanceDecoder(d, meta, opRes)
	if err != nil {
		return fmt.Errorf("Error decoding response from operation: %s", err)
	}
	if opRes == nil {
		return fmt.Errorf("Error decoding response from operation, could not find object")
	}

	if err := d.Set("name", flattenMemorystoreInstanceName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{instance_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Instance %q: %#v", d.Id(), res)

	return resourceMemorystoreInstanceRead(d, meta)
}

func resourceMemorystoreInstanceRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{MemorystoreBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("MemorystoreInstance %q", d.Id()))
	}

	res, err = resourceMemorystoreInstanceDecoder(d, meta, res)
	if err != nil {
		return err
	}

	if res == nil {
		// Decoding the object has resulted in it being gone. It may be marked deleted
		log.Printf("[DEBUG] Removing MemorystoreInstance because it no longer exists.")
		d.SetId("")
		return nil
	}

	// Explicitly set virtual fields to default values if unset
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}

	if err := d.Set("name", flattenMemorystoreInstanceName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("create_time", flattenMemorystoreInstanceCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("update_time", flattenMemorystoreInstanceUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("labels", flattenMemorystoreInstanceLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("state", flattenMemorystoreInstanceState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("state_info", flattenMemorystoreInstanceStateInfo(res["stateInfo"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("uid", flattenMemorystoreInstanceUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("replica_count", flattenMemorystoreInstanceReplicaCount(res["replicaCount"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("authorization_mode", flattenMemorystoreInstanceAuthorizationMode(res["authorizationMode"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("transit_encryption_mode", flattenMemorystoreInstanceTransitEncryptionMode(res["transitEncryptionMode"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("shard_count", flattenMemorystoreInstanceShardCount(res["shardCount"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("discovery_endpoints", flattenMemorystoreInstanceDiscoveryEndpoints(res["discoveryEndpoints"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("node_type", flattenMemorystoreInstanceNodeType(res["nodeType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("persistence_config", flattenMemorystoreInstancePersistenceConfig(res["persistenceConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("engine_version", flattenMemorystoreInstanceEngineVersion(res["engineVersion"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("engine_configs", flattenMemorystoreInstanceEngineConfigs(res["engineConfigs"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("node_config", flattenMemorystoreInstanceNodeConfig(res["nodeConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("zone_distribution_config", flattenMemorystoreInstanceZoneDistributionConfig(res["zoneDistributionConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("deletion_protection_enabled", flattenMemorystoreInstanceDeletionProtectionEnabled(res["deletionProtectionEnabled"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("endpoints", flattenMemorystoreInstanceEndpoints(res["endpoints"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("mode", flattenMemorystoreInstanceMode(res["mode"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("psc_auto_connections", flattenMemorystoreInstancePscAutoConnections(res["pscAutoConnections"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("terraform_labels", flattenMemorystoreInstanceTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}
	if err := d.Set("effective_labels", flattenMemorystoreInstanceEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Instance: %s", err)
	}

	return nil
}

func resourceMemorystoreInstanceUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	replicaCountProp, err := expandMemorystoreInstanceReplicaCount(d.Get("replica_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("replica_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, replicaCountProp)) {
		obj["replicaCount"] = replicaCountProp
	}
	shardCountProp, err := expandMemorystoreInstanceShardCount(d.Get("shard_count"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("shard_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, shardCountProp)) {
		obj["shardCount"] = shardCountProp
	}
	persistenceConfigProp, err := expandMemorystoreInstancePersistenceConfig(d.Get("persistence_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("persistence_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, persistenceConfigProp)) {
		obj["persistenceConfig"] = persistenceConfigProp
	}
	engineConfigsProp, err := expandMemorystoreInstanceEngineConfigs(d.Get("engine_configs"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("engine_configs"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, engineConfigsProp)) {
		obj["engineConfigs"] = engineConfigsProp
	}
	deletionProtectionEnabledProp, err := expandMemorystoreInstanceDeletionProtectionEnabled(d.Get("deletion_protection_enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("deletion_protection_enabled"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, deletionProtectionEnabledProp)) {
		obj["deletionProtectionEnabled"] = deletionProtectionEnabledProp
	}
	labelsProp, err := expandMemorystoreInstanceEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	obj, err = resourceMemorystoreInstanceEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{MemorystoreBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Instance %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("replica_count") {
		updateMask = append(updateMask, "replicaCount")
	}

	if d.HasChange("shard_count") {
		updateMask = append(updateMask, "shardCount")
	}

	if d.HasChange("persistence_config") {
		updateMask = append(updateMask, "persistenceConfig")
	}

	if d.HasChange("engine_configs") {
		updateMask = append(updateMask, "engineConfigs")
	}

	if d.HasChange("deletion_protection_enabled") {
		updateMask = append(updateMask, "deletionProtectionEnabled")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating Instance %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Instance %q: %#v", d.Id(), res)
		}

		err = MemorystoreOperationWaitTime(
			config, res, project, "Updating Instance", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceMemorystoreInstanceRead(d, meta)
}

func resourceMemorystoreInstanceDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Instance: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{MemorystoreBasePath}}projects/{{project}}/locations/{{location}}/instances/{{instance_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Instance %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Instance")
	}

	err = MemorystoreOperationWaitTime(
		config, res, project, "Deleting Instance", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Instance %q: %#v", d.Id(), res)
	return nil
}

func resourceMemorystoreInstanceImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/instances/(?P<instance_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<instance_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<instance_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/instances/{{instance_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Explicitly set virtual fields to default values on import

	return []*schema.ResourceData{d}, nil
}

func flattenMemorystoreInstanceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenMemorystoreInstanceState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceStateInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["update_info"] =
		flattenMemorystoreInstanceStateInfoUpdateInfo(original["updateInfo"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceStateInfoUpdateInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["target_shard_count"] =
		flattenMemorystoreInstanceStateInfoUpdateInfoTargetShardCount(original["targetShardCount"], d, config)
	transformed["target_replica_count"] =
		flattenMemorystoreInstanceStateInfoUpdateInfoTargetReplicaCount(original["targetReplicaCount"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceStateInfoUpdateInfoTargetShardCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceStateInfoUpdateInfoTargetReplicaCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceReplicaCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceAuthorizationMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceTransitEncryptionMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceShardCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceDiscoveryEndpoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"address": flattenMemorystoreInstanceDiscoveryEndpointsAddress(original["address"], d, config),
			"port":    flattenMemorystoreInstanceDiscoveryEndpointsPort(original["port"], d, config),
			"network": flattenMemorystoreInstanceDiscoveryEndpointsNetwork(original["network"], d, config),
		})
	}
	return transformed
}
func flattenMemorystoreInstanceDiscoveryEndpointsAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceDiscoveryEndpointsPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceDiscoveryEndpointsNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceNodeType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePersistenceConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["mode"] =
		flattenMemorystoreInstancePersistenceConfigMode(original["mode"], d, config)
	transformed["rdb_config"] =
		flattenMemorystoreInstancePersistenceConfigRdbConfig(original["rdbConfig"], d, config)
	transformed["aof_config"] =
		flattenMemorystoreInstancePersistenceConfigAofConfig(original["aofConfig"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstancePersistenceConfigMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePersistenceConfigRdbConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["rdb_snapshot_period"] =
		flattenMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotPeriod(original["rdbSnapshotPeriod"], d, config)
	transformed["rdb_snapshot_start_time"] =
		flattenMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotStartTime(original["rdbSnapshotStartTime"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotPeriod(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePersistenceConfigAofConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["append_fsync"] =
		flattenMemorystoreInstancePersistenceConfigAofConfigAppendFsync(original["appendFsync"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstancePersistenceConfigAofConfigAppendFsync(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEngineVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEngineConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceNodeConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["size_gb"] =
		flattenMemorystoreInstanceNodeConfigSizeGb(original["sizeGb"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceNodeConfigSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceZoneDistributionConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["zone"] =
		flattenMemorystoreInstanceZoneDistributionConfigZone(original["zone"], d, config)
	transformed["mode"] =
		flattenMemorystoreInstanceZoneDistributionConfigMode(original["mode"], d, config)
	return []interface{}{transformed}
}
func flattenMemorystoreInstanceZoneDistributionConfigZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceZoneDistributionConfigMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceDeletionProtectionEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceEndpoints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstanceMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnections(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"psc_connection_id":     flattenMemorystoreInstancePscAutoConnectionsPscConnectionId(original["pscConnectionId"], d, config),
			"ip_address":            flattenMemorystoreInstancePscAutoConnectionsIpAddress(original["ipAddress"], d, config),
			"forwarding_rule":       flattenMemorystoreInstancePscAutoConnectionsForwardingRule(original["forwardingRule"], d, config),
			"project_id":            flattenMemorystoreInstancePscAutoConnectionsProjectId(original["projectId"], d, config),
			"network":               flattenMemorystoreInstancePscAutoConnectionsNetwork(original["network"], d, config),
			"service_attachment":    flattenMemorystoreInstancePscAutoConnectionsServiceAttachment(original["serviceAttachment"], d, config),
			"psc_connection_status": flattenMemorystoreInstancePscAutoConnectionsPscConnectionStatus(original["pscConnectionStatus"], d, config),
			"connection_type":       flattenMemorystoreInstancePscAutoConnectionsConnectionType(original["connectionType"], d, config),
			"port":                  flattenMemorystoreInstancePscAutoConnectionsPort(original["port"], d, config),
		})
	}
	return transformed
}
func flattenMemorystoreInstancePscAutoConnectionsPscConnectionId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsIpAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsForwardingRule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsProjectId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsServiceAttachment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsPscConnectionStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsConnectionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenMemorystoreInstancePscAutoConnectionsPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenMemorystoreInstanceTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenMemorystoreInstanceEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandMemorystoreInstanceReplicaCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceAuthorizationMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceTransitEncryptionMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceShardCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceNodeType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstancePersistenceConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMode, err := expandMemorystoreInstancePersistenceConfigMode(original["mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["mode"] = transformedMode
	}

	transformedRdbConfig, err := expandMemorystoreInstancePersistenceConfigRdbConfig(original["rdb_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRdbConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rdbConfig"] = transformedRdbConfig
	}

	transformedAofConfig, err := expandMemorystoreInstancePersistenceConfigAofConfig(original["aof_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAofConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["aofConfig"] = transformedAofConfig
	}

	return transformed, nil
}

func expandMemorystoreInstancePersistenceConfigMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstancePersistenceConfigRdbConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRdbSnapshotPeriod, err := expandMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotPeriod(original["rdb_snapshot_period"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRdbSnapshotPeriod); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rdbSnapshotPeriod"] = transformedRdbSnapshotPeriod
	}

	transformedRdbSnapshotStartTime, err := expandMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotStartTime(original["rdb_snapshot_start_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRdbSnapshotStartTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rdbSnapshotStartTime"] = transformedRdbSnapshotStartTime
	}

	return transformed, nil
}

func expandMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotPeriod(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstancePersistenceConfigRdbConfigRdbSnapshotStartTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstancePersistenceConfigAofConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAppendFsync, err := expandMemorystoreInstancePersistenceConfigAofConfigAppendFsync(original["append_fsync"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAppendFsync); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["appendFsync"] = transformedAppendFsync
	}

	return transformed, nil
}

func expandMemorystoreInstancePersistenceConfigAofConfigAppendFsync(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceEngineVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceEngineConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandMemorystoreInstanceZoneDistributionConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedZone, err := expandMemorystoreInstanceZoneDistributionConfigZone(original["zone"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedZone); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["zone"] = transformedZone
	}

	transformedMode, err := expandMemorystoreInstanceZoneDistributionConfigMode(original["mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["mode"] = transformedMode
	}

	return transformed, nil
}

func expandMemorystoreInstanceZoneDistributionConfigZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceZoneDistributionConfigMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceDeletionProtectionEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandMemorystoreInstanceEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func resourceMemorystoreInstanceEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	v, ok := d.GetOk("desired_psc_auto_connections")
	if !ok {
		return obj, nil // No desired connections, nothing to update
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		desiredConnection := raw.(map[string]interface{})
		connectionReq := make(map[string]interface{})

		projectId := desiredConnection["project_id"]
		if val := reflect.ValueOf(projectId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			connectionReq["projectId"] = projectId
		}

		network := desiredConnection["network"]
		if val := reflect.ValueOf(network); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			connectionReq["network"] = network
		}

		req = append(req, connectionReq)
	}
	obj["pscAutoConnections"] = req
	return obj, nil
}

func resourceMemorystoreInstanceDecoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
	// Retrieve pscAutoConnections from API response
	v, ok := res["pscAutoConnections"]
	if !ok {
		return nil, fmt.Errorf("pscAutoConnections field not found in API response")
	}

	connections, ok := v.([]interface{})
	if !ok {
		return nil, fmt.Errorf("pscAutoConnections is not an array")
	}

	transformed := make([]interface{}, 0, len(connections))
	uniqueConnections := make(map[string]bool) // Track unique project+network combos

	for _, raw := range connections {
		connectionData, ok := raw.(map[string]interface{})
		if !ok || len(connectionData) < 1 {
			return nil, fmt.Errorf("Invalid or empty psc connection data: %v", raw)
		}

		projectID, ok := connectionData["projectId"].(string)
		if !ok {
			return nil, fmt.Errorf("invalid project ID in psc connection: %v", connectionData)
		}

		networkID, ok := connectionData["network"].(string)
		if !ok {
			return nil, fmt.Errorf("invalid network ID in psc connection: %v", connectionData)
		}

		uniqueKey := projectID + networkID
		if !uniqueConnections[uniqueKey] { // Check for uniqueness
			uniqueConnections[uniqueKey] = true
			transformed = append(transformed, map[string]interface{}{
				"project_id": projectID,
				"network":    networkID,
			})
		}
	}

	d.Set("desired_psc_auto_connections", transformed)
	return res, nil
}
