// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/cloudidentity/data_source_cloud_identity_policies.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package cloudidentity

import (
	"encoding/json"
	"fmt"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func DataSourceGoogleCloudIdentityPolicies() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceGoogleCloudIdentityPoliciesRead,
		Schema: map[string]*schema.Schema{
			"filter": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Filter expression for listing policies, as documented in the Cloud Identity Policy API policies.list method`,
			},
			"policies": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `List of Cloud Identity policies that match the filter (or all policies if no filter is provided).`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The resource name of the policy.`,
						},
						"customer": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The customer that the policy belongs to.`,
						},
						"policy_query": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The CEL query that defines which entities the policy applies to.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"query": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "The query that defines which entities the policy applies to.",
									},
									"group": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "The group that the policy applies to.",
									},
									"org_unit": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "The org unit that the policy applies to.",
									},
									"sort_order": {
										Type:        schema.TypeFloat,
										Computed:    true,
										Description: "The sort order of the policy.",
									},
								},
							},
						},
						"setting": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The setting configured by this policy.`,
						},
						"type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The type of the policy.`,
						},
					},
				},
			},
		},
	}
}

func dataSourceGoogleCloudIdentityPoliciesRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	policiesListCall := config.NewCloudIdentityClient(userAgent).Policies.List()

	if filter, ok := d.GetOk("filter"); ok {
		policiesListCall = policiesListCall.Filter(filter.(string))
	}

	if config.UserProjectOverride {
		billingProject := ""
		// err may be nil - project isn't required for this resource
		if project, err := tpgresource.GetProject(d, config); err == nil {
			billingProject = project
		}

		// err == nil indicates that the billing_project value was found
		if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
			billingProject = bp
		}

		if billingProject != "" {
			policiesListCall.Header().Set("X-Goog-User-Project", billingProject)
		}
	}

	var allPolicies []map[string]interface{}

	for {
		resp, err := policiesListCall.Do()
		if err != nil {
			return transport_tpg.HandleDataSourceNotFoundError(err, d, "CloudIdentityListPolicies", "Policies")
		}

		if resp.Policies != nil {
			for _, p := range resp.Policies {
				policyMap := map[string]interface{}{
					"name":     p.Name,
					"customer": p.Customer,
				}

				if p.PolicyQuery != nil {
					pq := map[string]interface{}{
						"query":      p.PolicyQuery.Query,
						"group":      p.PolicyQuery.Group,
						"org_unit":   p.PolicyQuery.OrgUnit,
						"sort_order": p.PolicyQuery.SortOrder,
					}
					policyMap["policy_query"] = []interface{}{pq}
				}

				if p.Setting != nil {
					settingBytes, err := json.Marshal(p.Setting)
					if err != nil {
						return fmt.Errorf("error marshalling policy setting: %s", err)
					}
					policyMap["setting"] = string(settingBytes)
				}

				policyMap["type"] = p.Type

				allPolicies = append(allPolicies, policyMap)
			}
		}

		if resp.NextPageToken == "" {
			break
		}

		policiesListCall = policiesListCall.PageToken(resp.NextPageToken)
	}

	if err := d.Set("policies", allPolicies); err != nil {
		return fmt.Errorf("error setting policies: %s", err)
	}

	if filter, ok := d.GetOk("filter"); ok {
		d.SetId(fmt.Sprintf("cloud-identity-policies-%s", filter.(string)))
	} else {
		d.SetId(fmt.Sprintf("cloud-identity-policies-%d", len(allPolicies)))
	}

	return nil
}
