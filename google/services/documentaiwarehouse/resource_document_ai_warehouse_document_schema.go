// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package documentaiwarehouse

import (
	"fmt"
	"log"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
)

func ResourceDocumentAIWarehouseDocumentSchema() *schema.Resource {
	return &schema.Resource{
		Create: resourceDocumentAIWarehouseDocumentSchemaCreate,
		Read:   resourceDocumentAIWarehouseDocumentSchemaRead,
		Delete: resourceDocumentAIWarehouseDocumentSchemaDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDocumentAIWarehouseDocumentSchemaImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Name of the schema given by the user.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the resource.`,
			},
			"project_number": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The unique identifier of the project.`,
			},
			"property_definitions": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `Defines the metadata for a schema property.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `The name of the metadata property.`,
						},
						"date_time_type_options": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Date time property. Not supported by CMEK compliant deployment.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},
						"display_name": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `The display-name for the property, used for front-end.`,
						},
						"enum_type_options": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Enum/categorical property.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"possible_values": {
										Type:        schema.TypeList,
										Required:    true,
										ForceNew:    true,
										Description: `List of possible enum values.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"validation_check_disabled": {
										Type:        schema.TypeBool,
										Optional:    true,
										ForceNew:    true,
										Description: `Make sure the enum property value provided in the document is in the possile value list during document creation. The validation check runs by default.`,
									},
								},
							},
						},
						"float_type_options": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Float property.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},
						"integer_type_options": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Integer property.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},
						"is_filterable": {
							Type:        schema.TypeBool,
							Optional:    true,
							ForceNew:    true,
							Description: `Whether the property can be filtered. If this is a sub-property, all the parent properties must be marked filterable.`,
						},
						"is_metadata": {
							Type:        schema.TypeBool,
							Optional:    true,
							ForceNew:    true,
							Description: `Whether the property is user supplied metadata.`,
						},
						"is_repeatable": {
							Type:        schema.TypeBool,
							Optional:    true,
							ForceNew:    true,
							Description: `Whether the property can have multiple values.`,
						},
						"is_required": {
							Type:        schema.TypeBool,
							Optional:    true,
							ForceNew:    true,
							Description: `Whether the property is mandatory.`,
						},
						"is_searchable": {
							Type:        schema.TypeBool,
							Optional:    true,
							ForceNew:    true,
							Description: `Indicates that the property should be included in a global search.`,
						},
						"map_type_options": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Map property.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},
						"property_type_options": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Nested structured data property.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"property_definitions": {
										Type:        schema.TypeList,
										Required:    true,
										ForceNew:    true,
										Description: `Defines the metadata for a schema property.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"name": {
													Type:        schema.TypeString,
													Required:    true,
													ForceNew:    true,
													Description: `The name of the metadata property.`,
												},
												"date_time_type_options": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Date time property. Not supported by CMEK compliant deployment.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
												"display_name": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `The display-name for the property, used for front-end.`,
												},
												"enum_type_options": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Enum/categorical property.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"possible_values": {
																Type:        schema.TypeList,
																Required:    true,
																ForceNew:    true,
																Description: `List of possible enum values.`,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
															"validation_check_disabled": {
																Type:        schema.TypeBool,
																Optional:    true,
																ForceNew:    true,
																Description: `Make sure the enum property value provided in the document is in the possile value list during document creation. The validation check runs by default.`,
															},
														},
													},
												},
												"float_type_options": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Float property.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
												"integer_type_options": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Integer property.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
												"is_filterable": {
													Type:        schema.TypeBool,
													Optional:    true,
													ForceNew:    true,
													Description: `Whether the property can be filtered. If this is a sub-property, all the parent properties must be marked filterable.`,
												},
												"is_metadata": {
													Type:        schema.TypeBool,
													Optional:    true,
													ForceNew:    true,
													Description: `Whether the property is user supplied metadata.`,
												},
												"is_repeatable": {
													Type:        schema.TypeBool,
													Optional:    true,
													ForceNew:    true,
													Description: `Whether the property can have multiple values.`,
												},
												"is_required": {
													Type:        schema.TypeBool,
													Optional:    true,
													ForceNew:    true,
													Description: `Whether the property is mandatory.`,
												},
												"is_searchable": {
													Type:        schema.TypeBool,
													Optional:    true,
													ForceNew:    true,
													Description: `Indicates that the property should be included in a global search.`,
												},
												"map_type_options": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Map property.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
												"retrieval_importance": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"HIGHEST", "HIGHER", "HIGH", "MEDIUM", "LOW", "LOWEST", ""}),
													Description:  `Stores the retrieval importance. Possible values: ["HIGHEST", "HIGHER", "HIGH", "MEDIUM", "LOW", "LOWEST"]`,
												},
												"schema_sources": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `The schema source information.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"name": {
																Type:        schema.TypeString,
																Optional:    true,
																ForceNew:    true,
																Description: `The schema name in the source.`,
															},
															"processor_type": {
																Type:        schema.TypeString,
																Optional:    true,
																ForceNew:    true,
																Description: `The Doc AI processor type name.`,
															},
														},
													},
												},
												"text_type_options": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Text property.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
												"timestamp_type_options": {
													Type:        schema.TypeList,
													Optional:    true,
													ForceNew:    true,
													Description: `Timestamp property. Not supported by CMEK compliant deployment.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},
											},
										},
									},
								},
							},
						},
						"retrieval_importance": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"HIGHEST", "HIGHER", "HIGH", "MEDIUM", "LOW", "LOWEST", ""}),
							Description:  `Stores the retrieval importance. Possible values: ["HIGHEST", "HIGHER", "HIGH", "MEDIUM", "LOW", "LOWEST"]`,
						},
						"schema_sources": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `The schema source information.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `The schema name in the source.`,
									},
									"processor_type": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `The Doc AI processor type name.`,
									},
								},
							},
						},
						"text_type_options": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Text/string property.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},
						"timestamp_type_options": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Timestamp property. Not supported by CMEK compliant deployment.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},
					},
				},
			},
			"document_is_folder": {
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Description: `Tells whether the document is a folder or a typical document.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The resource name of the document schema.`,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDocumentAIWarehouseDocumentSchemaCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandDocumentAIWarehouseDocumentSchemaDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	documentIsFolderProp, err := expandDocumentAIWarehouseDocumentSchemaDocumentIsFolder(d.Get("document_is_folder"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("document_is_folder"); !tpgresource.IsEmptyValue(reflect.ValueOf(documentIsFolderProp)) && (ok || !reflect.DeepEqual(v, documentIsFolderProp)) {
		obj["documentIsFolder"] = documentIsFolderProp
	}
	propertyDefinitionsProp, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitions(d.Get("property_definitions"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("property_definitions"); !tpgresource.IsEmptyValue(reflect.ValueOf(propertyDefinitionsProp)) && (ok || !reflect.DeepEqual(v, propertyDefinitionsProp)) {
		obj["propertyDefinitions"] = propertyDefinitionsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DocumentAIWarehouseBasePath}}projects/{{project_number}}/locations/{{location}}/documentSchemas")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new DocumentSchema: %#v", obj)
	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating DocumentSchema: %s", err)
	}
	if err := d.Set("name", flattenDocumentAIWarehouseDocumentSchemaName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating DocumentSchema %q: %#v", d.Id(), res)

	return resourceDocumentAIWarehouseDocumentSchemaRead(d, meta)
}

func resourceDocumentAIWarehouseDocumentSchemaRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DocumentAIWarehouseBasePath}}{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DocumentAIWarehouseDocumentSchema %q", d.Id()))
	}

	if err := d.Set("name", flattenDocumentAIWarehouseDocumentSchemaName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading DocumentSchema: %s", err)
	}
	if err := d.Set("display_name", flattenDocumentAIWarehouseDocumentSchemaDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading DocumentSchema: %s", err)
	}
	if err := d.Set("document_is_folder", flattenDocumentAIWarehouseDocumentSchemaDocumentIsFolder(res["documentIsFolder"], d, config)); err != nil {
		return fmt.Errorf("Error reading DocumentSchema: %s", err)
	}
	if err := d.Set("property_definitions", flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitions(res["propertyDefinitions"], d, config)); err != nil {
		return fmt.Errorf("Error reading DocumentSchema: %s", err)
	}

	return nil
}

func resourceDocumentAIWarehouseDocumentSchemaDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	url, err := tpgresource.ReplaceVars(d, config, "{{DocumentAIWarehouseBasePath}}{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting DocumentSchema %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "DocumentSchema")
	}

	log.Printf("[DEBUG] Finished deleting DocumentSchema %q: %#v", d.Id(), res)
	return nil
}

func resourceDocumentAIWarehouseDocumentSchemaImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)

	if err := tpgresource.ParseImportId([]string{
		"projects/(?P<project_number>[^/]+)/locations/(?P<location>[^/]+)/documentSchemas/(?P<name>[^/]+)"}, d, config); err != nil {
		return nil, err
	}

	originalName := d.Get("name").(string)
	originalLocation := d.Get("location").(string)
	originalProject := d.Get("project_number").(string)
	name := fmt.Sprintf("projects/%s/locations/%s/documentSchemas/%s", originalProject, originalLocation, originalName)

	if err := d.Set("name", name); err != nil {
		return nil, fmt.Errorf("Error setting name: %s", err)
	}
	d.SetId(name)
	return []*schema.ResourceData{d}, nil
}

func flattenDocumentAIWarehouseDocumentSchemaName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaDocumentIsFolder(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":                   flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsName(original["name"], d, config),
			"display_name":           flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsDisplayName(original["displayName"], d, config),
			"is_repeatable":          flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsRepeatable(original["isRepeatable"], d, config),
			"is_filterable":          flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsFilterable(original["isFilterable"], d, config),
			"is_searchable":          flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsSearchable(original["isSearchable"], d, config),
			"is_metadata":            flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsMetadata(original["isMetadata"], d, config),
			"is_required":            flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsRequired(original["isRequired"], d, config),
			"retrieval_importance":   flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsRetrievalImportance(original["retrievalImportance"], d, config),
			"schema_sources":         flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSources(original["schemaSources"], d, config),
			"integer_type_options":   flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIntegerTypeOptions(original["integerTypeOptions"], d, config),
			"float_type_options":     flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsFloatTypeOptions(original["floatTypeOptions"], d, config),
			"text_type_options":      flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsTextTypeOptions(original["textTypeOptions"], d, config),
			"property_type_options":  flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptions(original["propertyTypeOptions"], d, config),
			"enum_type_options":      flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptions(original["enumTypeOptions"], d, config),
			"date_time_type_options": flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsDateTimeTypeOptions(original["dateTimeTypeOptions"], d, config),
			"map_type_options":       flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsMapTypeOptions(original["mapTypeOptions"], d, config),
			"timestamp_type_options": flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsTimestampTypeOptions(original["timestampTypeOptions"], d, config),
		})
	}
	return transformed
}
func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsRepeatable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsFilterable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsSearchable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsMetadata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsRequired(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsRetrievalImportance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":           flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSourcesName(original["name"], d, config),
			"processor_type": flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSourcesProcessorType(original["processorType"], d, config),
		})
	}
	return transformed
}
func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSourcesName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSourcesProcessorType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIntegerTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsFloatTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsTextTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["property_definitions"] =
		flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitions(original["propertyDefinitions"], d, config)
	return []interface{}{transformed}
}
func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":                   flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsName(original["name"], d, config),
			"display_name":           flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsDisplayName(original["displayName"], d, config),
			"is_repeatable":          flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsRepeatable(original["isRepeatable"], d, config),
			"is_filterable":          flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsFilterable(original["isFilterable"], d, config),
			"is_searchable":          flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsSearchable(original["isSearchable"], d, config),
			"is_metadata":            flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsMetadata(original["isMetadata"], d, config),
			"is_required":            flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsRequired(original["isRequired"], d, config),
			"retrieval_importance":   flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsRetrievalImportance(original["retrievalImportance"], d, config),
			"schema_sources":         flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSources(original["schemaSources"], d, config),
			"integer_type_options":   flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIntegerTypeOptions(original["integerTypeOptions"], d, config),
			"float_type_options":     flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsFloatTypeOptions(original["floatTypeOptions"], d, config),
			"text_type_options":      flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsTextTypeOptions(original["textTypeOptions"], d, config),
			"enum_type_options":      flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptions(original["enumTypeOptions"], d, config),
			"date_time_type_options": flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsDateTimeTypeOptions(original["dateTimeTypeOptions"], d, config),
			"map_type_options":       flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsMapTypeOptions(original["mapTypeOptions"], d, config),
			"timestamp_type_options": flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsTimestampTypeOptions(original["timestampTypeOptions"], d, config),
		})
	}
	return transformed
}
func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsRepeatable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsFilterable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsSearchable(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsMetadata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsRequired(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsRetrievalImportance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":           flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSourcesName(original["name"], d, config),
			"processor_type": flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSourcesProcessorType(original["processorType"], d, config),
		})
	}
	return transformed
}
func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSourcesName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSourcesProcessorType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIntegerTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsFloatTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsTextTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["possible_values"] =
		flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptionsPossibleValues(original["possibleValues"], d, config)
	transformed["validation_check_disabled"] =
		flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptionsValidationCheckDisabled(original["validationCheckDisabled"], d, config)
	return []interface{}{transformed}
}
func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptionsPossibleValues(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptionsValidationCheckDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsDateTimeTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsMapTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsTimestampTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["possible_values"] =
		flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptionsPossibleValues(original["possibleValues"], d, config)
	transformed["validation_check_disabled"] =
		flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptionsValidationCheckDisabled(original["validationCheckDisabled"], d, config)
	return []interface{}{transformed}
}
func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptionsPossibleValues(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptionsValidationCheckDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsDateTimeTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsMapTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func flattenDocumentAIWarehouseDocumentSchemaPropertyDefinitionsTimestampTypeOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	transformed := make(map[string]interface{})
	return []interface{}{transformed}
}

func expandDocumentAIWarehouseDocumentSchemaDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaDocumentIsFolder(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedDisplayName, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsDisplayName(original["display_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["displayName"] = transformedDisplayName
		}

		transformedIsRepeatable, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsRepeatable(original["is_repeatable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIsRepeatable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["isRepeatable"] = transformedIsRepeatable
		}

		transformedIsFilterable, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsFilterable(original["is_filterable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIsFilterable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["isFilterable"] = transformedIsFilterable
		}

		transformedIsSearchable, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsSearchable(original["is_searchable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIsSearchable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["isSearchable"] = transformedIsSearchable
		}

		transformedIsMetadata, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsMetadata(original["is_metadata"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIsMetadata); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["isMetadata"] = transformedIsMetadata
		}

		transformedIsRequired, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsRequired(original["is_required"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIsRequired); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["isRequired"] = transformedIsRequired
		}

		transformedRetrievalImportance, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsRetrievalImportance(original["retrieval_importance"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedRetrievalImportance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["retrievalImportance"] = transformedRetrievalImportance
		}

		transformedSchemaSources, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSources(original["schema_sources"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSchemaSources); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["schemaSources"] = transformedSchemaSources
		}

		transformedIntegerTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIntegerTypeOptions(original["integer_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["integerTypeOptions"] = transformedIntegerTypeOptions
		}

		transformedFloatTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsFloatTypeOptions(original["float_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["floatTypeOptions"] = transformedFloatTypeOptions
		}

		transformedTextTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsTextTypeOptions(original["text_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["textTypeOptions"] = transformedTextTypeOptions
		}

		transformedPropertyTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptions(original["property_type_options"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPropertyTypeOptions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["propertyTypeOptions"] = transformedPropertyTypeOptions
		}

		transformedEnumTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptions(original["enum_type_options"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEnumTypeOptions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["enumTypeOptions"] = transformedEnumTypeOptions
		}

		transformedDateTimeTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsDateTimeTypeOptions(original["date_time_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["dateTimeTypeOptions"] = transformedDateTimeTypeOptions
		}

		transformedMapTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsMapTypeOptions(original["map_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["mapTypeOptions"] = transformedMapTypeOptions
		}

		transformedTimestampTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsTimestampTypeOptions(original["timestamp_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["timestampTypeOptions"] = transformedTimestampTypeOptions
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsRepeatable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsFilterable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsSearchable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsMetadata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIsRequired(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsRetrievalImportance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSourcesName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedProcessorType, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSourcesProcessorType(original["processor_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedProcessorType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["processorType"] = transformedProcessorType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSourcesName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsSchemaSourcesProcessorType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsIntegerTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsFloatTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsTextTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPropertyDefinitions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitions(original["property_definitions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPropertyDefinitions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["propertyDefinitions"] = transformedPropertyDefinitions
	}

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedDisplayName, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsDisplayName(original["display_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["displayName"] = transformedDisplayName
		}

		transformedIsRepeatable, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsRepeatable(original["is_repeatable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIsRepeatable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["isRepeatable"] = transformedIsRepeatable
		}

		transformedIsFilterable, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsFilterable(original["is_filterable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIsFilterable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["isFilterable"] = transformedIsFilterable
		}

		transformedIsSearchable, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsSearchable(original["is_searchable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIsSearchable); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["isSearchable"] = transformedIsSearchable
		}

		transformedIsMetadata, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsMetadata(original["is_metadata"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIsMetadata); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["isMetadata"] = transformedIsMetadata
		}

		transformedIsRequired, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsRequired(original["is_required"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIsRequired); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["isRequired"] = transformedIsRequired
		}

		transformedRetrievalImportance, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsRetrievalImportance(original["retrieval_importance"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedRetrievalImportance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["retrievalImportance"] = transformedRetrievalImportance
		}

		transformedSchemaSources, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSources(original["schema_sources"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSchemaSources); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["schemaSources"] = transformedSchemaSources
		}

		transformedIntegerTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIntegerTypeOptions(original["integer_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["integerTypeOptions"] = transformedIntegerTypeOptions
		}

		transformedFloatTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsFloatTypeOptions(original["float_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["floatTypeOptions"] = transformedFloatTypeOptions
		}

		transformedTextTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsTextTypeOptions(original["text_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["textTypeOptions"] = transformedTextTypeOptions
		}

		transformedEnumTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptions(original["enum_type_options"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEnumTypeOptions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["enumTypeOptions"] = transformedEnumTypeOptions
		}

		transformedDateTimeTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsDateTimeTypeOptions(original["date_time_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["dateTimeTypeOptions"] = transformedDateTimeTypeOptions
		}

		transformedMapTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsMapTypeOptions(original["map_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["mapTypeOptions"] = transformedMapTypeOptions
		}

		transformedTimestampTypeOptions, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsTimestampTypeOptions(original["timestamp_type_options"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["timestampTypeOptions"] = transformedTimestampTypeOptions
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsRepeatable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsFilterable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsSearchable(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsMetadata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIsRequired(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsRetrievalImportance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSourcesName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedProcessorType, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSourcesProcessorType(original["processor_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedProcessorType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["processorType"] = transformedProcessorType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSourcesName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsSchemaSourcesProcessorType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsIntegerTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsFloatTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsTextTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPossibleValues, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptionsPossibleValues(original["possible_values"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPossibleValues); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["possibleValues"] = transformedPossibleValues
	}

	transformedValidationCheckDisabled, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptionsValidationCheckDisabled(original["validation_check_disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedValidationCheckDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["validationCheckDisabled"] = transformedValidationCheckDisabled
	}

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptionsPossibleValues(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsEnumTypeOptionsValidationCheckDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsDateTimeTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsMapTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsPropertyTypeOptionsPropertyDefinitionsTimestampTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPossibleValues, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptionsPossibleValues(original["possible_values"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPossibleValues); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["possibleValues"] = transformedPossibleValues
	}

	transformedValidationCheckDisabled, err := expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptionsValidationCheckDisabled(original["validation_check_disabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedValidationCheckDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["validationCheckDisabled"] = transformedValidationCheckDisabled
	}

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptionsPossibleValues(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsEnumTypeOptionsValidationCheckDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsDateTimeTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsMapTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDocumentAIWarehouseDocumentSchemaPropertyDefinitionsTimestampTypeOptions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}
