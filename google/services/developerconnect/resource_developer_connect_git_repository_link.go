// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/developerconnect/GitRepositoryLink.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package developerconnect

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func ResourceDeveloperConnectGitRepositoryLink() *schema.Resource {
	return &schema.Resource{
		Create: resourceDeveloperConnectGitRepositoryLinkCreate,
		Read:   resourceDeveloperConnectGitRepositoryLinkRead,
		Update: resourceDeveloperConnectGitRepositoryLinkUpdate,
		Delete: resourceDeveloperConnectGitRepositoryLinkDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDeveloperConnectGitRepositoryLinkImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.SetAnnotationsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"clone_uri": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Required. Git Clone URI.`,
			},
			"git_repository_link_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Required. The ID to use for the repository, which will become the final component of
the repository's resource name. This ID should be unique in the connection.
Allows alphanumeric characters and any of -._~%!$&'()*+,;=@.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type 'developerconnect.googleapis.com/GitRepositoryLink'.`,
			},
			"parent_connection": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type 'developerconnect.googleapis.com/GitRepositoryLink'.`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				ForceNew: true,
				Description: `Optional. Allows clients to store small amounts of arbitrary data. 

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"etag": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `Optional. This checksum is computed by the server based on the value of other
fields, and may be sent on update and delete requests to ensure the
client has an up-to-date value before proceeding.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Optional. Labels as key value pairs 

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. [Output only] Create timestamp`,
			},
			"delete_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. [Output only] Delete timestamp`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				ForceNew:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				ForceNew:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. Resource name of the repository, in the format
'projects/*/locations/*/connections/*/gitRepositoryLinks/*'.`,
			},
			"reconciling": {
				Type:     schema.TypeBool,
				Computed: true,
				Description: `Output only. Set to true when the connection is being set up or updated in the
background.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. A system-assigned unique identifier for a the GitRepositoryLink.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. [Output only] Update timestamp`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDeveloperConnectGitRepositoryLinkCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	cloneUriProp, err := expandDeveloperConnectGitRepositoryLinkCloneUri(d.Get("clone_uri"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("clone_uri"); !tpgresource.IsEmptyValue(reflect.ValueOf(cloneUriProp)) && (ok || !reflect.DeepEqual(v, cloneUriProp)) {
		obj["cloneUri"] = cloneUriProp
	}
	etagProp, err := expandDeveloperConnectGitRepositoryLinkEtag(d.Get("etag"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("etag"); !tpgresource.IsEmptyValue(reflect.ValueOf(etagProp)) && (ok || !reflect.DeepEqual(v, etagProp)) {
		obj["etag"] = etagProp
	}
	labelsProp, err := expandDeveloperConnectGitRepositoryLinkEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	annotationsProp, err := expandDeveloperConnectGitRepositoryLinkEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(annotationsProp)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DeveloperConnectBasePath}}projects/{{project}}/locations/{{location}}/connections/{{parent_connection}}/gitRepositoryLinks?gitRepositoryLinkId={{git_repository_link_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new GitRepositoryLink: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for GitRepositoryLink: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating GitRepositoryLink: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/connections/{{parent_connection}}/gitRepositoryLinks/{{git_repository_link_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = DeveloperConnectOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating GitRepositoryLink", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create GitRepositoryLink: %s", err)
	}

	if err := d.Set("name", flattenDeveloperConnectGitRepositoryLinkName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/connections/{{parent_connection}}/gitRepositoryLinks/{{git_repository_link_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating GitRepositoryLink %q: %#v", d.Id(), res)

	return resourceDeveloperConnectGitRepositoryLinkRead(d, meta)
}

func resourceDeveloperConnectGitRepositoryLinkRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DeveloperConnectBasePath}}projects/{{project}}/locations/{{location}}/connections/{{parent_connection}}/gitRepositoryLinks/{{git_repository_link_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for GitRepositoryLink: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DeveloperConnectGitRepositoryLink %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}

	if err := d.Set("name", flattenDeveloperConnectGitRepositoryLinkName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("clone_uri", flattenDeveloperConnectGitRepositoryLinkCloneUri(res["cloneUri"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("create_time", flattenDeveloperConnectGitRepositoryLinkCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("update_time", flattenDeveloperConnectGitRepositoryLinkUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("delete_time", flattenDeveloperConnectGitRepositoryLinkDeleteTime(res["deleteTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("labels", flattenDeveloperConnectGitRepositoryLinkLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("etag", flattenDeveloperConnectGitRepositoryLinkEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("reconciling", flattenDeveloperConnectGitRepositoryLinkReconciling(res["reconciling"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("annotations", flattenDeveloperConnectGitRepositoryLinkAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("uid", flattenDeveloperConnectGitRepositoryLinkUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("terraform_labels", flattenDeveloperConnectGitRepositoryLinkTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("effective_labels", flattenDeveloperConnectGitRepositoryLinkEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}
	if err := d.Set("effective_annotations", flattenDeveloperConnectGitRepositoryLinkEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitRepositoryLink: %s", err)
	}

	return nil
}

func resourceDeveloperConnectGitRepositoryLinkUpdate(d *schema.ResourceData, meta interface{}) error {
	// Only the root field "labels" and "terraform_labels" are mutable
	return resourceDeveloperConnectGitRepositoryLinkRead(d, meta)
}

func resourceDeveloperConnectGitRepositoryLinkDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for GitRepositoryLink: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{DeveloperConnectBasePath}}projects/{{project}}/locations/{{location}}/connections/{{parent_connection}}/gitRepositoryLinks/{{git_repository_link_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting GitRepositoryLink %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "GitRepositoryLink")
	}

	err = DeveloperConnectOperationWaitTime(
		config, res, project, "Deleting GitRepositoryLink", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting GitRepositoryLink %q: %#v", d.Id(), res)
	return nil
}

func resourceDeveloperConnectGitRepositoryLinkImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/connections/(?P<parent_connection>[^/]+)/gitRepositoryLinks/(?P<git_repository_link_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<parent_connection>[^/]+)/(?P<git_repository_link_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<parent_connection>[^/]+)/(?P<git_repository_link_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/connections/{{parent_connection}}/gitRepositoryLinks/{{git_repository_link_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenDeveloperConnectGitRepositoryLinkName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectGitRepositoryLinkCloneUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectGitRepositoryLinkCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectGitRepositoryLinkUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectGitRepositoryLinkDeleteTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectGitRepositoryLinkLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDeveloperConnectGitRepositoryLinkEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectGitRepositoryLinkReconciling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectGitRepositoryLinkAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDeveloperConnectGitRepositoryLinkUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectGitRepositoryLinkTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDeveloperConnectGitRepositoryLinkEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectGitRepositoryLinkEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandDeveloperConnectGitRepositoryLinkCloneUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDeveloperConnectGitRepositoryLinkEtag(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDeveloperConnectGitRepositoryLinkEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandDeveloperConnectGitRepositoryLinkEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
