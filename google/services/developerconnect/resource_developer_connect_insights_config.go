// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/developerconnect/InsightsConfig.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package developerconnect

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"

	"google.golang.org/api/googleapi"
)

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.NewDecoder
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = log.Print
	_ = http.Get
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = errwrap.Wrap
	_ = cty.BoolVal
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = validation.All
	_ = structure.ExpandJsonFromString
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ValidateEnum
	_ = googleapi.Error{}
)

func ResourceDeveloperConnectInsightsConfig() *schema.Resource {
	return &schema.Resource{
		Create: resourceDeveloperConnectInsightsConfigCreate,
		Read:   resourceDeveloperConnectInsightsConfigRead,
		Update: resourceDeveloperConnectInsightsConfigUpdate,
		Delete: resourceDeveloperConnectInsightsConfigDelete,

		Importer: &schema.ResourceImporter{
			State: resourceDeveloperConnectInsightsConfigImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetAnnotationsDiff,
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Identity: &schema.ResourceIdentity{
			Version: 1,
			SchemaFunc: func() map[string]*schema.Schema {
				return map[string]*schema.Schema{
					"location": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"insights_config_id": {
						Type:              schema.TypeString,
						RequiredForImport: true,
					},
					"project": {
						Type:              schema.TypeString,
						OptionalForImport: true,
					},
				}
			},
		},
		Schema: map[string]*schema.Schema{
			"app_hub_application": {
				Type:     schema.TypeString,
				Required: true,
				Description: `The name of the App Hub Application.
Format:
projects/{project}/locations/{location}/applications/{application}`,
			},
			"insights_config_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `ID of the requesting InsightsConfig.`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Resource ID segment making up resource 'name'. It identifies the resource within its parent collection as described in https://google.aip.dev/122.`,
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `User specified annotations. See https://google.aip.dev/148#annotations
for more details such as format and size limitations.

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"artifact_configs": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The artifact configurations of the artifacts that are deployed.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"google_artifact_analysis": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Google Artifact Analysis configurations.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"project_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The project id of the project where the provenance is stored.`,
									},
								},
							},
						},
						"google_artifact_registry": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Google Artifact Registry configurations.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"artifact_registry_package": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `The name of the artifact registry package.`,
									},
									"project_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The host project of Artifact Registry.`,
									},
								},
							},
						},
						"uri": {
							Type:     schema.TypeString,
							Optional: true,
							ForceNew: true,
							Description: `The URI of the artifact that is deployed.
e.g. 'us-docker.pkg.dev/my-project/my-repo/image'.
The URI does not include the tag / digest because it captures a lineage of
artifacts.`,
						},
					},
				},
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Set of labels associated with an InsightsConfig.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `[Output only] Create timestamp`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"errors": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `Any errors that occurred while setting up the InsightsConfig.
Each error will be in the format: 'field_name: error_message', e.g.
GetAppHubApplication: Permission denied while getting App Hub
application. Please grant permissions to the P4SA.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"code": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The status code, which should be an enum value of google.rpc.Code.`,
						},
						"details": {
							Type:     schema.TypeList,
							Computed: true,
							Description: `A list of messages that carry the error details.  There is a common set of
message types for APIs to use.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"detail_message": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `A message with details about the error.`,
									},
								},
							},
						},
						"message": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `A developer-facing error message, which should be in English. Any
user-facing error message should be localized and sent in the
google.rpc.Status.details field, or localized by the client.`,
						},
					},
				},
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Identifier. The name of the InsightsConfig.
Format:
projects/{project}/locations/{location}/insightsConfigs/{insightsConfig}`,
			},
			"reconciling": {
				Type:     schema.TypeBool,
				Computed: true,
				Description: `Reconciling (https://google.aip.dev/128#reconciliation).
Set to true if the current state of InsightsConfig does not match the
user's intended state, and the service is actively updating the resource to
reconcile them. This can happen due to user-triggered updates or
system actions like failover or maintenance.`,
			},
			"runtime_configs": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The runtime configurations where the application is deployed.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"uri": {
							Type:     schema.TypeString,
							Required: true,
							ForceNew: true,
							Description: `The URI of the runtime configuration.
For GKE, this is the cluster name.
For Cloud Run, this is the service name.`,
						},
						"app_hub_workload": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `AppHubWorkload represents the App Hub Workload.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"criticality": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The criticality of the App Hub Workload.`,
									},
									"environment": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The environment of the App Hub Workload.`,
									},
									"workload": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Output only. The name of the App Hub Workload.
Format:
'projects/{project}/locations/{location}/applications/{application}/workloads/{workload}'.`,
									},
								},
							},
						},
						"gke_workload": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `GKEWorkload represents the Google Kubernetes Engine runtime.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"cluster": {
										Type:     schema.TypeString,
										Required: true,
										ForceNew: true,
										Description: `The name of the GKE cluster.
Format:
'projects/{project}/locations/{location}/clusters/{cluster}'.`,
									},
									"deployment": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `The name of the GKE deployment.
Format:
'projects/{project}/locations/{location}/clusters/{cluster}/namespaces/{namespace}/deployments/{deployment}'.`,
									},
								},
							},
						},
						"state": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `The state of the Runtime.
Possible values:
STATE_UNSPECIFIED
LINKED
UNLINKED`,
						},
					},
				},
			},
			"state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The state of the InsightsConfig.
Possible values:
STATE_UNSPECIFIED
PENDING
COMPLETE
ERROR`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `[Output only] Update timestamp`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceDeveloperConnectInsightsConfigCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	appHubApplicationProp, err := expandDeveloperConnectInsightsConfigAppHubApplication(d.Get("app_hub_application"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("app_hub_application"); !tpgresource.IsEmptyValue(reflect.ValueOf(appHubApplicationProp)) && (ok || !reflect.DeepEqual(v, appHubApplicationProp)) {
		obj["appHubApplication"] = appHubApplicationProp
	}
	artifactConfigsProp, err := expandDeveloperConnectInsightsConfigArtifactConfigs(d.Get("artifact_configs"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("artifact_configs"); !tpgresource.IsEmptyValue(reflect.ValueOf(artifactConfigsProp)) && (ok || !reflect.DeepEqual(v, artifactConfigsProp)) {
		obj["artifactConfigs"] = artifactConfigsProp
	}
	effectiveAnnotationsProp, err := expandDeveloperConnectInsightsConfigEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveAnnotationsProp)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}
	effectiveLabelsProp, err := expandDeveloperConnectInsightsConfigEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DeveloperConnectBasePath}}projects/{{project}}/locations/{{location}}/insightsConfigs?insightsConfigId={{insights_config_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new InsightsConfig: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InsightsConfig: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating InsightsConfig: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/insightsConfigs/{{insights_config_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if insightsConfigIdValue, ok := d.GetOk("insights_config_id"); ok && insightsConfigIdValue.(string) != "" {
			if err = identity.Set("insights_config_id", insightsConfigIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting insights_config_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Create) identity not set: %s", err)
	}

	err = DeveloperConnectOperationWaitTime(
		config, res, project, "Creating InsightsConfig", userAgent,
		d.Timeout(schema.TimeoutCreate))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create InsightsConfig: %s", err)
	}

	log.Printf("[DEBUG] Finished creating InsightsConfig %q: %#v", d.Id(), res)

	return resourceDeveloperConnectInsightsConfigRead(d, meta)
}

func resourceDeveloperConnectInsightsConfigRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DeveloperConnectBasePath}}projects/{{project}}/locations/{{location}}/insightsConfigs/{{insights_config_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InsightsConfig: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("DeveloperConnectInsightsConfig %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}

	if err := d.Set("app_hub_application", flattenDeveloperConnectInsightsConfigAppHubApplication(res["appHubApplication"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("name", flattenDeveloperConnectInsightsConfigName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("update_time", flattenDeveloperConnectInsightsConfigUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("artifact_configs", flattenDeveloperConnectInsightsConfigArtifactConfigs(res["artifactConfigs"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("annotations", flattenDeveloperConnectInsightsConfigAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("reconciling", flattenDeveloperConnectInsightsConfigReconciling(res["reconciling"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("errors", flattenDeveloperConnectInsightsConfigErrors(res["errors"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("create_time", flattenDeveloperConnectInsightsConfigCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("runtime_configs", flattenDeveloperConnectInsightsConfigRuntimeConfigs(res["runtimeConfigs"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("state", flattenDeveloperConnectInsightsConfigState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("effective_annotations", flattenDeveloperConnectInsightsConfigEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("terraform_labels", flattenDeveloperConnectInsightsConfigTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}
	if err := d.Set("effective_labels", flattenDeveloperConnectInsightsConfigEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading InsightsConfig: %s", err)
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if v, ok := identity.GetOk("location"); !ok && v == "" {
			err = identity.Set("location", d.Get("location").(string))
			if err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if v, ok := identity.GetOk("insights_config_id"); !ok && v == "" {
			err = identity.Set("insights_config_id", d.Get("insights_config_id").(string))
			if err != nil {
				return fmt.Errorf("Error setting insights_config_id: %s", err)
			}
		}
		if v, ok := identity.GetOk("project"); !ok && v == "" {
			err = identity.Set("project", d.Get("project").(string))
			if err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Read) identity not set: %s", err)
	}

	return nil
}

func resourceDeveloperConnectInsightsConfigUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	identity, err := d.Identity()
	if err == nil && identity != nil {
		if locationValue, ok := d.GetOk("location"); ok && locationValue.(string) != "" {
			if err = identity.Set("location", locationValue.(string)); err != nil {
				return fmt.Errorf("Error setting location: %s", err)
			}
		}
		if insightsConfigIdValue, ok := d.GetOk("insights_config_id"); ok && insightsConfigIdValue.(string) != "" {
			if err = identity.Set("insights_config_id", insightsConfigIdValue.(string)); err != nil {
				return fmt.Errorf("Error setting insights_config_id: %s", err)
			}
		}
		if projectValue, ok := d.GetOk("project"); ok && projectValue.(string) != "" {
			if err = identity.Set("project", projectValue.(string)); err != nil {
				return fmt.Errorf("Error setting project: %s", err)
			}
		}
	} else {
		log.Printf("[DEBUG] (Update) identity not set: %s", err)
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InsightsConfig: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	appHubApplicationProp, err := expandDeveloperConnectInsightsConfigAppHubApplication(d.Get("app_hub_application"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("app_hub_application"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, appHubApplicationProp)) {
		obj["appHubApplication"] = appHubApplicationProp
	}
	artifactConfigsProp, err := expandDeveloperConnectInsightsConfigArtifactConfigs(d.Get("artifact_configs"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("artifact_configs"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, artifactConfigsProp)) {
		obj["artifactConfigs"] = artifactConfigsProp
	}
	effectiveAnnotationsProp, err := expandDeveloperConnectInsightsConfigEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveAnnotationsProp)) {
		obj["annotations"] = effectiveAnnotationsProp
	}
	effectiveLabelsProp, err := expandDeveloperConnectInsightsConfigEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{DeveloperConnectBasePath}}projects/{{project}}/locations/{{location}}/insightsConfigs/{{insights_config_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating InsightsConfig %q: %#v", d.Id(), obj)
	headers := make(http.Header)
	updateMask := []string{}

	if d.HasChange("app_hub_application") {
		updateMask = append(updateMask, "appHubApplication")
	}

	if d.HasChange("artifact_configs") {
		updateMask = append(updateMask, "artifactConfigs")
	}

	if d.HasChange("effective_annotations") {
		updateMask = append(updateMask, "annotations")
	}

	if d.HasChange("effective_labels") {
		updateMask = append(updateMask, "labels")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})

		if err != nil {
			return fmt.Errorf("Error updating InsightsConfig %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating InsightsConfig %q: %#v", d.Id(), res)
		}

		err = DeveloperConnectOperationWaitTime(
			config, res, project, "Updating InsightsConfig", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceDeveloperConnectInsightsConfigRead(d, meta)
}

func resourceDeveloperConnectInsightsConfigDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for InsightsConfig: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{DeveloperConnectBasePath}}projects/{{project}}/locations/{{location}}/insightsConfigs/{{insights_config_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting InsightsConfig %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "InsightsConfig")
	}

	err = DeveloperConnectOperationWaitTime(
		config, res, project, "Deleting InsightsConfig", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting InsightsConfig %q: %#v", d.Id(), res)
	return nil
}

func resourceDeveloperConnectInsightsConfigImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/insightsConfigs/(?P<insights_config_id>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<insights_config_id>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<insights_config_id>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/insightsConfigs/{{insights_config_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenDeveloperConnectInsightsConfigAppHubApplication(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigArtifactConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"google_artifact_registry": flattenDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistry(original["googleArtifactRegistry"], d, config),
			"google_artifact_analysis": flattenDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactAnalysis(original["googleArtifactAnalysis"], d, config),
			"uri":                      flattenDeveloperConnectInsightsConfigArtifactConfigsUri(original["uri"], d, config),
		})
	}
	return transformed
}
func flattenDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistry(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["project_id"] =
		flattenDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistryProjectId(original["projectId"], d, config)
	transformed["artifact_registry_package"] =
		flattenDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistryArtifactRegistryPackage(original["artifactRegistryPackage"], d, config)
	return []interface{}{transformed}
}
func flattenDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistryProjectId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistryArtifactRegistryPackage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactAnalysis(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["project_id"] =
		flattenDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactAnalysisProjectId(original["projectId"], d, config)
	return []interface{}{transformed}
}
func flattenDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactAnalysisProjectId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigArtifactConfigsUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDeveloperConnectInsightsConfigReconciling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigErrors(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"code":    flattenDeveloperConnectInsightsConfigErrorsCode(original["code"], d, config),
			"message": flattenDeveloperConnectInsightsConfigErrorsMessage(original["message"], d, config),
			"details": flattenDeveloperConnectInsightsConfigErrorsDetails(original["details"], d, config),
		})
	}
	return transformed
}
func flattenDeveloperConnectInsightsConfigErrorsCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenDeveloperConnectInsightsConfigErrorsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigErrorsDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"detail_message": flattenDeveloperConnectInsightsConfigErrorsDetailsDetailMessage(original["detail_message"], d, config),
		})
	}
	return transformed
}
func flattenDeveloperConnectInsightsConfigErrorsDetailsDetailMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigRuntimeConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"uri":              flattenDeveloperConnectInsightsConfigRuntimeConfigsUri(original["uri"], d, config),
			"state":            flattenDeveloperConnectInsightsConfigRuntimeConfigsState(original["state"], d, config),
			"gke_workload":     flattenDeveloperConnectInsightsConfigRuntimeConfigsGkeWorkload(original["gkeWorkload"], d, config),
			"app_hub_workload": flattenDeveloperConnectInsightsConfigRuntimeConfigsAppHubWorkload(original["appHubWorkload"], d, config),
		})
	}
	return transformed
}
func flattenDeveloperConnectInsightsConfigRuntimeConfigsUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigRuntimeConfigsState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigRuntimeConfigsGkeWorkload(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["cluster"] =
		flattenDeveloperConnectInsightsConfigRuntimeConfigsGkeWorkloadCluster(original["cluster"], d, config)
	transformed["deployment"] =
		flattenDeveloperConnectInsightsConfigRuntimeConfigsGkeWorkloadDeployment(original["deployment"], d, config)
	return []interface{}{transformed}
}
func flattenDeveloperConnectInsightsConfigRuntimeConfigsGkeWorkloadCluster(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigRuntimeConfigsGkeWorkloadDeployment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigRuntimeConfigsAppHubWorkload(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["criticality"] =
		flattenDeveloperConnectInsightsConfigRuntimeConfigsAppHubWorkloadCriticality(original["criticality"], d, config)
	transformed["environment"] =
		flattenDeveloperConnectInsightsConfigRuntimeConfigsAppHubWorkloadEnvironment(original["environment"], d, config)
	transformed["workload"] =
		flattenDeveloperConnectInsightsConfigRuntimeConfigsAppHubWorkloadWorkload(original["workload"], d, config)
	return []interface{}{transformed}
}
func flattenDeveloperConnectInsightsConfigRuntimeConfigsAppHubWorkloadCriticality(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigRuntimeConfigsAppHubWorkloadEnvironment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigRuntimeConfigsAppHubWorkloadWorkload(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDeveloperConnectInsightsConfigTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDeveloperConnectInsightsConfigEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandDeveloperConnectInsightsConfigAppHubApplication(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDeveloperConnectInsightsConfigArtifactConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedGoogleArtifactRegistry, err := expandDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistry(original["google_artifact_registry"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedGoogleArtifactRegistry); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["googleArtifactRegistry"] = transformedGoogleArtifactRegistry
		}

		transformedGoogleArtifactAnalysis, err := expandDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactAnalysis(original["google_artifact_analysis"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedGoogleArtifactAnalysis); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["googleArtifactAnalysis"] = transformedGoogleArtifactAnalysis
		}

		transformedUri, err := expandDeveloperConnectInsightsConfigArtifactConfigsUri(original["uri"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["uri"] = transformedUri
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistry(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProjectId, err := expandDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistryProjectId(original["project_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["projectId"] = transformedProjectId
	}

	transformedArtifactRegistryPackage, err := expandDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistryArtifactRegistryPackage(original["artifact_registry_package"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedArtifactRegistryPackage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["artifactRegistryPackage"] = transformedArtifactRegistryPackage
	}

	return transformed, nil
}

func expandDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistryProjectId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactRegistryArtifactRegistryPackage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactAnalysis(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProjectId, err := expandDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactAnalysisProjectId(original["project_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["projectId"] = transformedProjectId
	}

	return transformed, nil
}

func expandDeveloperConnectInsightsConfigArtifactConfigsGoogleArtifactAnalysisProjectId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDeveloperConnectInsightsConfigArtifactConfigsUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDeveloperConnectInsightsConfigEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandDeveloperConnectInsightsConfigEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
