// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/fwvalidators/framework_validators_test.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package fwvalidators_test

import (
	"context"
	"testing"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/hashicorp/terraform-provider-google/google/acctest"
	"github.com/hashicorp/terraform-provider-google/google/fwvalidators"

	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
)

func TestFrameworkProvider_CredentialsValidator(t *testing.T) {
	cases := map[string]struct {
		ConfigValue          types.String
		ExpectedWarningCount int
		ExpectedErrorCount   int
	}{
		"configuring credentials as a path to a credentials JSON file is valid": {
			ConfigValue: types.StringValue(transport_tpg.TestFakeCredentialsPath), // Path to a test fixture
		},
		"configuring credentials as a path to a non-existent file is NOT valid": {
			ConfigValue:        types.StringValue("./this/path/doesnt/exist.json"), // Doesn't exist
			ExpectedErrorCount: 1,
		},
		"configuring credentials as a credentials JSON string is valid": {
			ConfigValue: types.StringValue(acctest.GenerateFakeCredentialsJson("CredentialsValidator")),
		},
		"configuring credentials as an empty string is not valid": {
			ConfigValue:        types.StringValue(""),
			ExpectedErrorCount: 1,
		},
		"leaving credentials unconfigured is valid": {
			ConfigValue: types.StringNull(),
		},
	}

	for tn, tc := range cases {
		t.Run(tn, func(t *testing.T) {
			// Arrange
			req := validator.StringRequest{
				ConfigValue: tc.ConfigValue,
			}

			resp := validator.StringResponse{
				Diagnostics: diag.Diagnostics{},
			}

			cv := fwvalidators.CredentialsValidator()

			// Act
			cv.ValidateString(context.Background(), req, &resp)

			// Assert
			if resp.Diagnostics.WarningsCount() > tc.ExpectedWarningCount {
				t.Errorf("Expected %d warnings, got %d", tc.ExpectedWarningCount, resp.Diagnostics.WarningsCount())
			}
			if resp.Diagnostics.ErrorsCount() > tc.ExpectedErrorCount {
				t.Errorf("Expected %d errors, got %d", tc.ExpectedErrorCount, resp.Diagnostics.ErrorsCount())
			}
		})
	}
}

func TestServiceAccountEmailValidator(t *testing.T) {
	t.Parallel()

	type testCase struct {
		value         types.String
		expectError   bool
		errorContains string
	}

	tests := map[string]testCase{
		"correct service account name": {
			value:       types.StringValue("test@test.iam.gserviceaccount.com"),
			expectError: false,
		},
		"developer service account": {
			value:       types.StringValue("test@developer.gserviceaccount.com"),
			expectError: false,
		},
		"app engine service account": {
			value:       types.StringValue("test@appspot.gserviceaccount.com"),
			expectError: false,
		},
		"cloud services service account": {
			value:       types.StringValue("test@cloudservices.gserviceaccount.com"),
			expectError: false,
		},
		"cloud build service account": {
			value:       types.StringValue("test@cloudbuild.gserviceaccount.com"),
			expectError: false,
		},
		"compute engine service account": {
			value:       types.StringValue("service-123456@compute-system.iam.gserviceaccount.com"),
			expectError: false,
		},
		"incorrect service account name": {
			value:         types.StringValue("test"),
			expectError:   true,
			errorContains: "Service account name must match one of the expected patterns for Google service accounts",
		},
		"empty string": {
			value:         types.StringValue(""),
			expectError:   true,
			errorContains: "Service account name must not be empty",
		},
		"null value": {
			value:       types.StringNull(),
			expectError: false,
		},
		"unknown value": {
			value:       types.StringUnknown(),
			expectError: false,
		},
	}

	for name, test := range tests {
		name, test := name, test
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			request := validator.StringRequest{
				Path:           path.Root("test"),
				PathExpression: path.MatchRoot("test"),
				ConfigValue:    test.value,
			}
			response := validator.StringResponse{}
			validator := fwvalidators.ServiceAccountEmailValidator{}

			validator.ValidateString(context.Background(), request, &response)

			if test.expectError && !response.Diagnostics.HasError() {
				t.Errorf("expected error, got none")
			}

			if !test.expectError && response.Diagnostics.HasError() {
				t.Errorf("got unexpected error: %s", response.Diagnostics.Errors())
			}

			if test.errorContains != "" {
				foundError := false
				for _, err := range response.Diagnostics.Errors() {
					if err.Detail() == test.errorContains {
						foundError = true
						break
					}
				}
				if !foundError {
					t.Errorf("expected error with summary %q, got none", test.errorContains)
				}
			}
		})
	}
}

func TestBoundedDuration(t *testing.T) {
	t.Parallel()

	type testCase struct {
		value         types.String
		minDuration   time.Duration
		maxDuration   time.Duration
		expectError   bool
		errorContains string
	}

	tests := map[string]testCase{
		"valid duration between min and max": {
			value:       types.StringValue("1800s"),
			minDuration: time.Hour / 2,
			maxDuration: time.Hour,
			expectError: false,
		},
		"valid duration at min": {
			value:       types.StringValue("1800s"),
			minDuration: 30 * time.Minute,
			maxDuration: time.Hour,
			expectError: false,
		},
		"valid duration at max": {
			value:       types.StringValue("3600s"),
			minDuration: time.Hour / 2,
			maxDuration: time.Hour,
			expectError: false,
		},
		"valid duration with different unit": {
			value:       types.StringValue("1h"),
			minDuration: 30 * time.Minute,
			maxDuration: 2 * time.Hour,
			expectError: false,
		},
		"duration below min": {
			value:         types.StringValue("900s"),
			minDuration:   30 * time.Minute,
			maxDuration:   time.Hour,
			expectError:   true,
			errorContains: "Invalid Duration",
		},
		"duration exceeds max - seconds": {
			value:         types.StringValue("7200s"),
			minDuration:   30 * time.Minute,
			maxDuration:   time.Hour,
			expectError:   true,
			errorContains: "Invalid Duration",
		},
		"duration exceeds max - minutes": {
			value:         types.StringValue("120m"),
			minDuration:   30 * time.Minute,
			maxDuration:   time.Hour,
			expectError:   true,
			errorContains: "Invalid Duration",
		},
		"duration exceeds max - hours": {
			value:         types.StringValue("2h"),
			minDuration:   30 * time.Minute,
			maxDuration:   time.Hour,
			expectError:   true,
			errorContains: "Invalid Duration",
		},
		"invalid duration format": {
			value:         types.StringValue("invalid"),
			minDuration:   30 * time.Minute,
			maxDuration:   time.Hour,
			expectError:   true,
			errorContains: "Invalid Duration Format",
		},
		"setting min to 0": {
			value:       types.StringValue("10s"),
			minDuration: 0,
			maxDuration: time.Hour,
			expectError: false,
		},
		"setting max to be less than min": {
			value:         types.StringValue("10s"),
			minDuration:   30 * time.Minute,
			maxDuration:   10 * time.Second,
			expectError:   true,
			errorContains: "Invalid Duration",
		},
		"empty string": {
			value:         types.StringValue(""),
			minDuration:   30 * time.Minute,
			maxDuration:   time.Hour,
			expectError:   true,
			errorContains: "Invalid Duration Format",
		},
		"null value": {
			value:       types.StringNull(),
			minDuration: 30 * time.Minute,
			maxDuration: time.Hour,
			expectError: false,
		},
		"unknown value": {
			value:       types.StringUnknown(),
			minDuration: 30 * time.Minute,
			maxDuration: time.Hour,
			expectError: false,
		},
	}

	for name, test := range tests {
		name, test := name, test
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			request := validator.StringRequest{
				Path:           path.Root("test"),
				PathExpression: path.MatchRoot("test"),
				ConfigValue:    test.value,
			}
			response := validator.StringResponse{}
			validator := fwvalidators.BoundedDuration{
				MinDuration: test.minDuration,
				MaxDuration: test.maxDuration,
			}

			validator.ValidateString(context.Background(), request, &response)

			if test.expectError && !response.Diagnostics.HasError() {
				t.Errorf("expected error, got none")
			}

			if !test.expectError && response.Diagnostics.HasError() {
				t.Errorf("got unexpected error: %s", response.Diagnostics.Errors())
			}

			if test.errorContains != "" {
				foundError := false
				for _, err := range response.Diagnostics.Errors() {
					if err.Summary() == test.errorContains {
						foundError = true
						break
					}
				}
				if !foundError {
					t.Errorf("expected error with summary %q, got none", test.errorContains)
				}
			}
		})
	}
}

func TestStringValuesInSetValidator(t *testing.T) {
	t.Parallel()

	// Define the set of valid strings for the validator
	validStrings := []string{"APPLE", "BANANA", "CHERRY"}

	stringSet := func(elems []string) types.Set {
		if elems == nil {
			return types.SetNull(types.StringType)
		}
		val, diags := types.SetValueFrom(context.Background(), types.StringType, elems)
		if diags.HasError() {
			t.Fatalf("Failed to create test set: %v", diags)
		}
		return val
	}

	cases := map[string]struct {
		ConfigValue        types.Set
		ExpectedErrorCount int
	}{
		"valid set with one element": {
			ConfigValue:        stringSet([]string{"APPLE"}),
			ExpectedErrorCount: 0,
		},
		"valid set with multiple elements": {
			ConfigValue:        stringSet([]string{"BANANA", "CHERRY"}),
			ExpectedErrorCount: 0,
		},
		"valid empty set": {
			ConfigValue:        stringSet([]string{}),
			ExpectedErrorCount: 0,
		},
		"null set is valid": {
			ConfigValue:        stringSet(nil),
			ExpectedErrorCount: 0,
		},
		"unknown set is valid": {
			ConfigValue:        types.SetUnknown(types.StringType),
			ExpectedErrorCount: 0,
		},
		"invalid set with one element": {
			ConfigValue:        stringSet([]string{"DURIAN"}),
			ExpectedErrorCount: 1,
		},
		"invalid set with multiple elements": {
			ConfigValue:        stringSet([]string{"DURIAN", "ELDERBERRY"}),
			ExpectedErrorCount: 2,
		},
		"set with mixed valid and invalid elements": {
			ConfigValue:        stringSet([]string{"APPLE", "DURIAN", "CHERRY"}),
			ExpectedErrorCount: 1,
		},
	}

	for tn, tc := range cases {
		tn, tc := tn, tc
		t.Run(tn, func(t *testing.T) {
			t.Parallel()

			req := validator.SetRequest{
				Path:        path.Root("test_attribute"),
				ConfigValue: tc.ConfigValue,
			}
			resp := &validator.SetResponse{
				Diagnostics: diag.Diagnostics{},
			}
			v := fwvalidators.StringValuesInSet(validStrings...)

			v.ValidateSet(context.Background(), req, resp)

			if resp.Diagnostics.ErrorsCount() != tc.ExpectedErrorCount {
				t.Errorf("Expected %d errors, but got %d. Errors: %v", tc.ExpectedErrorCount, resp.Diagnostics.ErrorsCount(), resp.Diagnostics.Errors())
			}
		})
	}
}

func TestTopicPrefixValidator(t *testing.T) {
	t.Parallel()

	type testCase struct {
		value         types.String
		expectError   bool
		errorContains string
	}

	tests := map[string]testCase{
		"valid topic format": {
			value:       types.StringValue("projects/my-project/topics/my-topic"),
			expectError: false,
		},
		"invalid topic format - starts with pubsub prefix": {
			value:         types.StringValue("//pubsub.googleapis.com/projects/my-project/topics/my-topic"),
			expectError:   true,
			errorContains: "The topic must not start with '//pubsub.googleapis.com/', please use the format projects/{project}/topics/{topic} instead.",
		},
	}

	for name, test := range tests {
		name, test := name, test
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			request := validator.StringRequest{
				Path:           path.Root("test_topic"),
				PathExpression: path.MatchRoot("test_topic"),
				ConfigValue:    test.value,
			}
			response := validator.StringResponse{}
			v := fwvalidators.NewTopicPrefixValidator()

			v.ValidateString(context.Background(), request, &response)

			if test.expectError && !response.Diagnostics.HasError() {
				t.Errorf("expected error, got none for value: %q", test.value.ValueString())
			}

			if !test.expectError && response.Diagnostics.HasError() {
				t.Errorf("got unexpected error for value: %q: %s", test.value.ValueString(), response.Diagnostics.Errors())
			}

			if test.errorContains != "" {
				foundError := false
				for _, err := range response.Diagnostics.Errors() {
					if err.Detail() == test.errorContains {
						foundError = true
						break
					}
				}
				if !foundError {
					t.Errorf("expected error with detail %q, got none", test.errorContains)
				}
			}
		})
	}
}
