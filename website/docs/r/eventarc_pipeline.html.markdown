---
# ----------------------------------------------------------------------------
#
#     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
#
# ----------------------------------------------------------------------------
#
#     This code is generated by Magic Modules using the following:
#
#     Configuration: https:#github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/eventarc/Pipeline.yaml
#     Template:      https:#github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.html.markdown.tmpl
#
#     DO NOT EDIT this file directly. Any changes made to this file will be
#     overwritten during the next generation cycle.
#
# ----------------------------------------------------------------------------
subcategory: "Eventarc"
description: |-
  The Eventarc Pipeline resource
---

# google_eventarc_pipeline

The Eventarc Pipeline resource


To get more information about Pipeline, see:

* [API documentation](https://cloud.google.com/eventarc/docs/reference/rest/v1/projects.locations.pipelines)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/eventarc/advanced/docs/receive-events/create-enrollment)

## Example Usage - Eventarc Pipeline With Topic Destination


```hcl
resource "google_pubsub_topic" "topic" {
  name = "some-topic"
}

resource "google_eventarc_pipeline" "primary" {
  location    = "us-central1"
  pipeline_id = "some-pipeline"
  destinations {
    topic = google_pubsub_topic.topic.id
  }
  labels = {
    test_label = "test-eventarc-label"
  }
  annotations = {
    test_annotation = "test-eventarc-annotation"
  }
  display_name = "Testing Pipeline"
}
```
## Example Usage - Eventarc Pipeline With Http Destination


```hcl
resource "google_eventarc_pipeline" "primary" {
  location    = "us-central1"
  pipeline_id = "some-pipeline"
  destinations {
    http_endpoint {
      uri = "https://10.77.0.0:80/route"
    }
    network_config {
      network_attachment = "projects/my-project-name/regions/us-central1/networkAttachments/some-network-attachment"
    }
  }
}
```
## Example Usage - Eventarc Pipeline With Workflow Destination


```hcl
resource "google_workflows_workflow" "workflow" {
  name                = "some-workflow"
  deletion_protection = false
  region              = "us-central1"
  source_contents     = <<-EOF
  # This is a sample workflow, feel free to replace it with your source code
  #
  # This workflow does the following:
  # - reads current time and date information from an external API and stores
  #   the response in CurrentDateTime variable
  # - retrieves a list of Wikipedia articles related to the day of the week
  #   from CurrentDateTime
  # - returns the list of articles as an output of the workflow
  # FYI, In terraform you need to escape the $$ or it will cause errors.

  - getCurrentTime:
      call: http.get
      args:
          url: $${sys.get_env("url")}
      result: CurrentDateTime
  - readWikipedia:
      call: http.get
      args:
          url: https://en.wikipedia.org/w/api.php
          query:
              action: opensearch
              search: $${CurrentDateTime.body.dayOfTheWeek}
      result: WikiResult
  - returnOutput:
      return: $${WikiResult.body[1]}
EOF
}

resource "google_eventarc_pipeline" "primary" {
  location    = "us-central1"
  pipeline_id = "some-pipeline"
  destinations {
    workflow = google_workflows_workflow.workflow.id
  }
}
```
## Example Usage - Eventarc Pipeline With Oidc And Json Format


```hcl
resource "google_eventarc_pipeline" "primary" {
  location    = "us-central1"
  pipeline_id = "some-pipeline"
  destinations {
    http_endpoint {
      uri                      = "https://10.77.0.0:80/route"
      message_binding_template = "{\"headers\":{\"new-header-key\": \"new-header-value\"}}"
    }
    network_config {
      network_attachment = "projects/my-project-name/regions/us-central1/networkAttachments/some-network-attachment"
    }
    authentication_config {
      google_oidc {
        service_account = "my@service-account.com"
        audience        = "http://www.example.com"
      }
    }
    output_payload_format {
      json {}
    }
  }
  input_payload_format {
    json {}
  }
  retry_policy {
    max_retry_delay = "50s"
    max_attempts    = 2
    min_retry_delay = "40s"
  }
  mediations {
    transformation {
      transformation_template = <<-EOF
{
"id": message.id,
"datacontenttype": "application/json",
"data": "{ \"scrubbed\": \"true\" }"
}
EOF
    }
  }
  logging_config {
    log_severity = "DEBUG"
  }
}
```
## Example Usage - Eventarc Pipeline With Oauth And Protobuf Format


```hcl
resource "google_eventarc_pipeline" "primary" {
  location    = "us-central1"
  pipeline_id = "some-pipeline"
  destinations {
    http_endpoint {
      uri                      = "https://10.77.0.0:80/route"
      message_binding_template = "{\"headers\":{\"new-header-key\": \"new-header-value\"}}"
    }
    network_config {
      network_attachment = "projects/my-project-name/regions/us-central1/networkAttachments/some-network-attachment"
    }
    authentication_config {
      oauth_token {
        service_account = "my@service-account.com"
        scope           = "https://www.googleapis.com/auth/cloud-platform"
      }
    }
    output_payload_format {
      protobuf {
        schema_definition = <<-EOF
syntax = "proto3";
message schema {
string name = 1;
string severity = 2;
}
EOF
      }
    }
  }
  input_payload_format {
    protobuf {
      schema_definition = <<-EOF
syntax = "proto3";
message schema {
string name = 1;
string severity = 2;
}
EOF
    }
  }
  retry_policy {
    max_retry_delay = "50s"
    max_attempts    = 2
    min_retry_delay = "40s"
  }
  mediations {
    transformation {
      transformation_template = <<-EOF
{
"id": message.id,
"datacontenttype": "application/json",
"data": "{ \"scrubbed\": \"true\" }"
}
EOF
    }
  }
  logging_config {
    log_severity = "DEBUG"
  }
}
```
## Example Usage - Eventarc Pipeline With Cmek And Avro Format


```hcl
resource "google_eventarc_pipeline" "primary" {
  location        = "us-central1"
  pipeline_id     = "some-pipeline"
  crypto_key_name = "some-key"
  destinations {
    http_endpoint {
      uri                      = "https://10.77.0.0:80/route"
      message_binding_template = "{\"headers\":{\"new-header-key\": \"new-header-value\"}}"
    }
    network_config {
      network_attachment = "projects/my-project-name/regions/us-central1/networkAttachments/some-network-attachment"
    }
    output_payload_format {
      avro {
        schema_definition = "{\"type\": \"record\", \"name\": \"my_record\", \"fields\": [{\"name\": \"my_field\", \"type\": \"string\"}]}"
      }
    }
  }
  input_payload_format {
    avro {
      schema_definition = "{\"type\": \"record\", \"name\": \"my_record\", \"fields\": [{\"name\": \"my_field\", \"type\": \"string\"}]}"
    }
  }
  retry_policy {
    max_retry_delay = "50s"
    max_attempts    = 2
    min_retry_delay = "40s"
  }
  mediations {
    transformation {
      transformation_template = <<-EOF
{
"id": message.id,
"datacontenttype": "application/json",
"data": "{ \"scrubbed\": \"true\" }"
}
EOF
    }
  }
  logging_config {
    log_severity = "DEBUG"
  }
}
```

## Argument Reference

The following arguments are supported:


* `destinations` -
  (Required)
  List of destinations to which messages will be forwarded. Currently,
  exactly one destination is supported per Pipeline.
  Structure is [documented below](#nested_destinations).

* `location` -
  (Required)
  Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122.

* `pipeline_id` -
  (Required)
  The user-provided ID to be assigned to the Pipeline. It should match the
  format `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.


* `annotations` -
  (Optional)
  User-defined annotations. See https://google.aip.dev/128#annotations.
  **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
  Please refer to the field `effective_annotations` for all of the annotations present on the resource.

* `display_name` -
  (Optional)
  Display name of resource.

* `crypto_key_name` -
  (Optional)
  Resource name of a KMS crypto key (managed by the user) used to
  encrypt/decrypt the event data. If not set, an internal Google-owned key
  will be used to encrypt messages. It must match the pattern
  "projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}".

* `input_payload_format` -
  (Optional)
  Represents the format of message data.
  Structure is [documented below](#nested_input_payload_format).

* `retry_policy` -
  (Optional)
  The retry policy configuration for the Pipeline. The pipeline
  exponentially backs off in case the destination is non responsive or
  returns a retryable error code. The default semantics are as follows:
  The backoff starts with a 5 second delay and doubles the
  delay after each failed attempt (10 seconds, 20 seconds, 40 seconds, etc.).
  The delay is capped at 60 seconds by default.
  Please note that if you set the min_retry_delay and max_retry_delay fields
  to the same value this will make the duration between retries constant.
  Structure is [documented below](#nested_retry_policy).

* `labels` -
  (Optional)
  User labels attached to the Pipeline that can be used to group
  resources. An object containing a list of "key": value pairs. Example: {
  "name": "wrench", "mass": "1.3kg", "count": "3" }.
  **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
  Please refer to the field `effective_labels` for all of the labels present on the resource.

* `mediations` -
  (Optional)
  List of mediation operations to be performed on the message. Currently,
  only one Transformation operation is allowed in each Pipeline.
  Structure is [documented below](#nested_mediations).

* `logging_config` -
  (Optional)
  The configuration for Platform Telemetry logging for Eventarc Advanced
  resources.
  Structure is [documented below](#nested_logging_config).

* `project` - (Optional) The ID of the project in which the resource belongs.
    If it is not provided, the provider project is used.



<a name="nested_destinations"></a>The `destinations` block supports:

* `authentication_config` -
  (Optional)
  Represents a config used to authenticate message requests.
  Structure is [documented below](#nested_destinations_destinations_authentication_config).

* `output_payload_format` -
  (Optional)
  Represents the format of message data.
  Structure is [documented below](#nested_destinations_destinations_output_payload_format).

* `network_config` -
  (Optional)
  Represents a network config to be used for destination resolution and
  connectivity.
  Structure is [documented below](#nested_destinations_destinations_network_config).

* `http_endpoint` -
  (Optional)
  Represents a HTTP endpoint destination.
  Structure is [documented below](#nested_destinations_destinations_http_endpoint).

* `workflow` -
  (Optional)
  The resource name of the Workflow whose Executions are triggered by
  the events. The Workflow resource should be deployed in the same
  project as the Pipeline. Format:
  `projects/{project}/locations/{location}/workflows/{workflow}`

* `message_bus` -
  (Optional)
  The resource name of the Message Bus to which events should be
  published. The Message Bus resource should exist in the same project as
  the Pipeline. Format:
  `projects/{project}/locations/{location}/messageBuses/{message_bus}`

* `topic` -
  (Optional)
  The resource name of the Pub/Sub topic to which events should be
  published. Format:
  `projects/{project}/locations/{location}/topics/{topic}`


<a name="nested_destinations_destinations_authentication_config"></a>The `authentication_config` block supports:

* `google_oidc` -
  (Optional)
  Represents a config used to authenticate with a Google OIDC token using
  a GCP service account. Use this authentication method to invoke your
  Cloud Run and Cloud Functions destinations or HTTP endpoints that
  support Google OIDC.
  Structure is [documented below](#nested_destinations_destinations_authentication_config_google_oidc).

* `oauth_token` -
  (Optional)
  Contains information needed for generating an
  [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
  This type of authorization should generally only be used when calling
  Google APIs hosted on *.googleapis.com.
  Structure is [documented below](#nested_destinations_destinations_authentication_config_oauth_token).


<a name="nested_destinations_destinations_authentication_config_google_oidc"></a>The `google_oidc` block supports:

* `service_account` -
  (Required)
  Service account email used to generate the OIDC Token.
  The principal who calls this API must have
  iam.serviceAccounts.actAs permission in the service account. See
  https://cloud.google.com/iam/docs/understanding-service-accounts
  for more information. Eventarc service agents must have
  roles/roles/iam.serviceAccountTokenCreator role to allow the
  Pipeline to create OpenID tokens for authenticated requests.

* `audience` -
  (Optional)
  Audience to be used to generate the OIDC Token. The audience claim
  identifies the recipient that the JWT is intended for. If
  unspecified, the destination URI will be used.

<a name="nested_destinations_destinations_authentication_config_oauth_token"></a>The `oauth_token` block supports:

* `service_account` -
  (Required)
  Service account email used to generate the [OAuth
  token](https://developers.google.com/identity/protocols/OAuth2).
  The principal who calls this API must have
  iam.serviceAccounts.actAs permission in the service account. See
  https://cloud.google.com/iam/docs/understanding-service-accounts
  for more information. Eventarc service agents must have
  roles/roles/iam.serviceAccountTokenCreator role to allow Pipeline
  to create OAuth2 tokens for authenticated requests.

* `scope` -
  (Optional)
  OAuth scope to be used for generating OAuth access token. If not
  specified, "https://www.googleapis.com/auth/cloud-platform" will be
  used.

<a name="nested_destinations_destinations_output_payload_format"></a>The `output_payload_format` block supports:

* `protobuf` -
  (Optional)
  The format of a Protobuf message payload.
  Structure is [documented below](#nested_destinations_destinations_output_payload_format_protobuf).

* `avro` -
  (Optional)
  The format of an AVRO message payload.
  Structure is [documented below](#nested_destinations_destinations_output_payload_format_avro).

* `json` -
  (Optional)
  The format of a JSON message payload.


<a name="nested_destinations_destinations_output_payload_format_protobuf"></a>The `protobuf` block supports:

* `schema_definition` -
  (Optional)
  The entire schema definition is stored in this field.

<a name="nested_destinations_destinations_output_payload_format_avro"></a>The `avro` block supports:

* `schema_definition` -
  (Optional)
  The entire schema definition is stored in this field.

<a name="nested_destinations_destinations_network_config"></a>The `network_config` block supports:

* `network_attachment` -
  (Optional)
  Name of the NetworkAttachment that allows access to the consumer VPC.
  Format:
  `projects/{PROJECT_ID}/regions/{REGION}/networkAttachments/{NETWORK_ATTACHMENT_NAME}`
  Required for HTTP endpoint destinations. Must not be specified for
  Workflows, MessageBus, or Topic destinations.

<a name="nested_destinations_destinations_http_endpoint"></a>The `http_endpoint` block supports:

* `uri` -
  (Required)
  The URI of the HTTP enpdoint.
  The value must be a RFC2396 URI string.
  Examples: `https://svc.us-central1.p.local:8080/route`.
  Only the HTTPS protocol is supported.

* `message_binding_template` -
  (Optional)
  The CEL expression used to modify how the destination-bound HTTP
  request is constructed.
  If a binding expression is not specified here, the message
  is treated as a CloudEvent and is mapped to the HTTP request according
  to the CloudEvent HTTP Protocol Binding Binary Content Mode
  (https://github.com/cloudevents/spec/blob/main/cloudevents/bindings/http-protocol-binding.md#31-binary-content-mode).
  In this representation, all fields except the `data` and
  `datacontenttype` field on the message are mapped to HTTP request
  headers with a prefix of `ce-`.
  To construct the HTTP request payload and the value of the content-type
  HTTP header, the payload format is defined as follows:
  1) Use the output_payload_format_type on the Pipeline.Destination if it
  is set, else:
  2) Use the input_payload_format_type on the Pipeline if it is set,
  else:
  3) Treat the payload as opaque binary data.
  The `data` field of the message is converted to the payload format or
  left as-is for case 3) and then attached as the payload of the HTTP
  request. The `content-type` header on the HTTP request is set to the
  payload format type or left empty for case 3). However, if a mediation
  has updated the `datacontenttype` field on the message so that it is
  not the same as the payload format type but it is still a prefix of the
  payload format type, then the `content-type` header on the HTTP request
  is set to this `datacontenttype` value. For example, if the
  `datacontenttype` is "application/json" and the payload format type is
  "application/json; charset=utf-8", then the `content-type` header on
  the HTTP request is set to "application/json; charset=utf-8".
  If a non-empty binding expression is specified then this expression is
  used to modify the default CloudEvent HTTP Protocol Binding Binary
  Content representation.
  The result of the CEL expression must be a map of key/value pairs
  which is used as follows:
  - If a map named `headers` exists on the result of the expression,
  then its key/value pairs are directly mapped to the HTTP request
  headers. The headers values are constructed from the corresponding
  value type's canonical representation. If the `headers` field doesn't
  exist then the resulting HTTP request will be the headers of the
  CloudEvent HTTP Binding Binary Content Mode representation of the final
  message. Note: If the specified binding expression, has updated the
  `datacontenttype` field on the message so that it is not the same as
  the payload format type but it is still a prefix of the payload format
  type, then the `content-type` header in the `headers` map is set to
  this `datacontenttype` value.
  - If a field named `body` exists on the result of the expression then
  its value is directly mapped to the body of the request. If the value
  of the `body` field is of type bytes or string then it is used for
  the HTTP request body as-is, with no conversion. If the body field is
  of any other type then it is converted to a JSON string. If the body
  field does not exist then the resulting payload of the HTTP request
  will be data value of the CloudEvent HTTP Binding Binary Content Mode
  representation of the final message as described earlier.
  - Any other fields in the resulting expression will be ignored.
  The CEL expression may access the incoming CloudEvent message in its
  definition, as follows:
  - The `data` field of the incoming CloudEvent message can be accessed
  using the `message.data` value. Subfields of `message.data` may also be
  accessed if an input_payload_format has been specified on the Pipeline.
  - Each attribute of the incoming CloudEvent message can be accessed
  using the `message.` value, where  is replaced with the
  name of the attribute.
  - Existing headers can be accessed in the CEL expression using the
  `headers` variable. The `headers` variable defines a map of key/value
  pairs corresponding to the HTTP headers of the CloudEvent HTTP Binding
  Binary Content Mode representation of the final message as described
  earlier. For example, the following CEL expression can be used to
  construct an HTTP request by adding an additional header to the HTTP
  headers of the CloudEvent HTTP Binding Binary Content Mode
  representation of the final message and by overwriting the body of the
  request:
  ```
  {
  "headers": headers.merge({"new-header-key": "new-header-value"}),
  "body": "new-body"
  }
  ```
  - The default binding for the message payload can be accessed using the
  `body` variable. It conatins a string representation of the message
  payload in the format specified by the `output_payload_format` field.
  If the `input_payload_format` field is not set, the `body`
  variable contains the same message payload bytes that were published.
  Additionally, the following CEL extension functions are provided for
  use in this CEL expression:
  - toBase64Url:
  map.toBase64Url() -> string
  - Converts a CelValue to a base64url encoded string
  - toJsonString: map.toJsonString() -> string
  - Converts a CelValue to a JSON string
  - merge:
  map1.merge(map2) -> map3
  - Merges the passed CEL map with the existing CEL map the
  function is applied to.
  - If the same key exists in both maps, if the key's value is type
  map both maps are merged else the value from the passed map is
  used.
  - denormalize:
  map.denormalize() -> map
  - Denormalizes a CEL map such that every value of type map or key
  in the map is expanded to return a single level map.
  - The resulting keys are "." separated indices of the map keys.
  - For example:
  {
  "a": 1,
  "b": {
  "c": 2,
  "d": 3
  }
  "e": [4, 5]
  }
  .denormalize()
  -> {
  "a": 1,
  "b.c": 2,
  "b.d": 3,
  "e.0": 4,
  "e.1": 5
  }
  - setField:
  map.setField(key, value) -> message
  - Sets the field of the message with the given key to the
  given value.
  - If the field is not present it will be added.
  - If the field is present it will be overwritten.
  - The key can be a dot separated path to set a field in a nested
  message.
  - Key must be of type string.
  - Value may be any valid type.
  - removeFields:
  map.removeFields([key1, key2, ...]) -> message
  - Removes the fields of the map with the given keys.
  - The keys can be a dot separated path to remove a field in a
  nested message.
  - If a key is not found it will be ignored.
  - Keys must be of type string.
  - toMap:
  [map1, map2, ...].toMap() -> map
  - Converts a CEL list of CEL maps to a single CEL map
  - toCloudEventJsonWithPayloadFormat:
  message.toCloudEventJsonWithPayloadFormat() -> map
  - Converts a message to the corresponding structure of JSON
  format for CloudEvents.
  - It converts `data` to destination payload format
  specified in `output_payload_format`. If `output_payload_format` is
  not set, the data will remain unchanged.
  - It also sets the corresponding datacontenttype of
  the CloudEvent, as indicated by
  `output_payload_format`. If no
  `output_payload_format` is set it will use the value of the
  "datacontenttype" attribute on the CloudEvent if present, else
  remove "datacontenttype" attribute.
  - This function expects that the content of the message will
  adhere to the standard CloudEvent format. If it doesn't then this
  function will fail.
  - The result is a CEL map that corresponds to the JSON
  representation of the CloudEvent. To convert that data to a JSON
  string it can be chained with the toJsonString function.
  The Pipeline expects that the message it receives adheres to the
  standard CloudEvent format. If it doesn't then the outgoing message
  request may fail with a persistent error.

<a name="nested_input_payload_format"></a>The `input_payload_format` block supports:

* `protobuf` -
  (Optional)
  The format of a Protobuf message payload.
  Structure is [documented below](#nested_input_payload_format_protobuf).

* `avro` -
  (Optional)
  The format of an AVRO message payload.
  Structure is [documented below](#nested_input_payload_format_avro).

* `json` -
  (Optional)
  The format of a JSON message payload.


<a name="nested_input_payload_format_protobuf"></a>The `protobuf` block supports:

* `schema_definition` -
  (Optional)
  The entire schema definition is stored in this field.

<a name="nested_input_payload_format_avro"></a>The `avro` block supports:

* `schema_definition` -
  (Optional)
  The entire schema definition is stored in this field.

<a name="nested_retry_policy"></a>The `retry_policy` block supports:

* `max_retry_delay` -
  (Optional)
  The maximum amount of seconds to wait between retry attempts. The value
  must be between 1 and 600.
  The default value for this field is 60.

* `max_attempts` -
  (Optional)
  The maximum number of delivery attempts for any message. The value must
  be between 1 and 100.
  The default value for this field is 5.

* `min_retry_delay` -
  (Optional)
  The minimum amount of seconds to wait between retry attempts. The value
  must be between 1 and 600.
  The default value for this field is 5.

<a name="nested_mediations"></a>The `mediations` block supports:

* `transformation` -
  (Optional)
  Transformation defines the way to transform an incoming message.
  Structure is [documented below](#nested_mediations_mediations_transformation).


<a name="nested_mediations_mediations_transformation"></a>The `transformation` block supports:

* `transformation_template` -
  (Optional)
  The CEL expression template to apply to transform messages.
  The following CEL extension functions are provided for
  use in this CEL expression:
  - merge:
  map1.merge(map2) -> map3
  - Merges the passed CEL map with the existing CEL map the
  function is applied to.
  - If the same key exists in both maps, if the key's value is type
  map both maps are merged else the value from the passed map is
  used.
  - denormalize:
  map.denormalize() -> map
  - Denormalizes a CEL map such that every value of type map or key
  in the map is expanded to return a single level map.
  - The resulting keys are "." separated indices of the map keys.
  - For example:
  {
  "a": 1,
  "b": {
  "c": 2,
  "d": 3
  }
  "e": [4, 5]
  }
  .denormalize()
  -> {
  "a": 1,
  "b.c": 2,
  "b.d": 3,
  "e.0": 4,
  "e.1": 5
  }
  - setField:
  map.setField(key, value) -> message
  - Sets the field of the message with the given key to the
  given value.
  - If the field is not present it will be added.
  - If the field is present it will be overwritten.
  - The key can be a dot separated path to set a field in a nested
  message.
  - Key must be of type string.
  - Value may be any valid type.
  - removeFields:
  map.removeFields([key1, key2, ...]) -> message
  - Removes the fields of the map with the given keys.
  - The keys can be a dot separated path to remove a field in a
  nested message.
  - If a key is not found it will be ignored.
  - Keys must be of type string.
  - toMap:
  [map1, map2, ...].toMap() -> map
  - Converts a CEL list of CEL maps to a single CEL map
  - toDestinationPayloadFormat():
  message.data.toDestinationPayloadFormat() -> string or bytes
  - Converts the message data to the destination payload format
  specified in Pipeline.Destination.output_payload_format
  - This function is meant to be applied to the message.data field.
  - If the destination payload format is not set, the function will
  return the message data unchanged.
  - toCloudEventJsonWithPayloadFormat:
  message.toCloudEventJsonWithPayloadFormat() -> map
  - Converts a message to the corresponding structure of JSON
  format for CloudEvents
  - This function applies toDestinationPayloadFormat() to the
  message data. It also sets the corresponding datacontenttype of
  the CloudEvent, as indicated by
  Pipeline.Destination.output_payload_format. If no
  output_payload_format is set it will use the existing
  datacontenttype on the CloudEvent if present, else leave
  datacontenttype absent.
  - This function expects that the content of the message will
  adhere to the standard CloudEvent format. If it doesn't then this
  function will fail.
  - The result is a CEL map that corresponds to the JSON
  representation of the CloudEvent. To convert that data to a JSON
  string it can be chained with the toJsonString function.

<a name="nested_logging_config"></a>The `logging_config` block supports:

* `log_severity` -
  (Optional)
  The minimum severity of logs that will be sent to Stackdriver/Platform
  Telemetry. Logs at severitiy â‰¥ this value will be sent, unless it is NONE.
  Possible values are: `NONE`, `DEBUG`, `INFO`, `NOTICE`, `WARNING`, `ERROR`, `CRITICAL`, `ALERT`, `EMERGENCY`.

## Attributes Reference

In addition to the arguments listed above, the following computed attributes are exported:

* `id` - an identifier for the resource with format `projects/{{project}}/locations/{{location}}/pipelines/{{pipeline_id}}`

* `etag` -
  This checksum is computed by the server based on the value of
  other fields, and might be sent only on create requests to ensure that the
  client has an up-to-date value before proceeding.

* `update_time` -
  The last-modified time.
  A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up
  to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and
  "2014-10-02T15:01:23.045123456Z".

* `uid` -
  Server-assigned unique identifier for the Pipeline. The value
  is a UUID4 string and guaranteed to remain unchanged until the resource is
  deleted.

* `name` -
  The resource name of the Pipeline. Must be unique within the
  location of the project and must be in
  `projects/{project}/locations/{location}/pipelines/{pipeline}` format.

* `create_time` -
  The creation time.
  A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up
  to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and
  "2014-10-02T15:01:23.045123456Z".

* `effective_annotations` -
  All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.

* `terraform_labels` -
  The combination of labels configured directly on the resource
   and default labels configured on the provider.

* `effective_labels` -
  All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.


## Timeouts

This resource provides the following
[Timeouts](https://developer.hashicorp.com/terraform/plugin/sdkv2/resources/retries-and-customizable-timeouts) configuration options:

- `create` - Default is 20 minutes.
- `update` - Default is 20 minutes.
- `delete` - Default is 20 minutes.

## Import


Pipeline can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/pipelines/{{pipeline_id}}`
* `{{project}}/{{location}}/{{pipeline_id}}`
* `{{location}}/{{pipeline_id}}`

In Terraform v1.12.0 and later, use an [`identity` block](https://developer.hashicorp.com/terraform/language/resources/identities) to import Pipeline using identity values. For example:

```tf
import {
  identity = {
    location = "<-required value->"
    pipelineId = "<-required value->"
    project = "<-optional value->"
  }
  to = google_eventarc_pipeline.default
}
```

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import Pipeline using one of the formats above. For example:

```tf
import {
  id = "projects/{{project}}/locations/{{location}}/pipelines/{{pipeline_id}}"
  to = google_eventarc_pipeline.default
}
```

When using the [`terraform import` command](https://developer.hashicorp.com/terraform/cli/commands/import), Pipeline can be imported using one of the formats above. For example:

```
$ terraform import google_eventarc_pipeline.default projects/{{project}}/locations/{{location}}/pipelines/{{pipeline_id}}
$ terraform import google_eventarc_pipeline.default {{project}}/{{location}}/{{pipeline_id}}
$ terraform import google_eventarc_pipeline.default {{location}}/{{pipeline_id}}
```

## User Project Overrides

This resource supports [User Project Overrides](https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/provider_reference#user_project_override).
