---
# ----------------------------------------------------------------------------
#
#     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
#
# ----------------------------------------------------------------------------
#
#     This code is generated by Magic Modules using the following:
#
#     Configuration: https:#github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/redis/Cluster.yaml
#     Template:      https:#github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/terraform/resource.html.markdown.tmpl
#
#     DO NOT EDIT this file directly. Any changes made to this file will be
#     overwritten during the next generation cycle.
#
# ----------------------------------------------------------------------------
subcategory: "Memorystore (Redis)"
description: |-
  A Google Cloud Redis Cluster instance.
---

# google_redis_cluster

A Google Cloud Redis Cluster instance.


To get more information about Cluster, see:

* [API documentation](https://cloud.google.com/memorystore/docs/cluster/reference/rest/v1/projects.locations.clusters)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/memorystore/docs/cluster/)

~> **Note:** For [Multiple VPC Networking](https://cloud.google.com/memorystore/docs/cluster/about-multiple-vpc-networking) if you want to use
[User-registered PSC Connections](https://cloud.google.com/memorystore/docs/cluster/about-multiple-vpc-networking#psc_connection_types),
then please use `google_redis_cluster_user_created_connections` resource.

For [Cross Region Replication](https://cloud.google.com/memorystore/docs/cluster/about-cross-region-replication), please follow the instructions below for performing certain update and failover (switchover and detach) operations

**Cross Region Replication**

**Settings updated on primary and propagated to secondaries**

The settings listed [here](https://cloud.google.com/memorystore/docs/cluster/about-cross-region-replication#set_on_primary)
are only allowed to be updated on the primary cluster and the changes are automatically propagated to the secondary clusters.
To keep the Terraform configuration and state in sync for such settings, please follow the below steps to update them:
  1. Update the setting on the primary cluster:
      * Update the setting to its new desired value in the Terraform configuration file.
      * Execute `terraform apply` to apply the change and wait for it to complete.
  1. Detect configuration drift on the secondary cluster(s):
      * Execute `terraform plan`. This should reveal a diff for the modified setting. The proposed value in the Terraform plan should align with the updated value applied to the primary cluster in the preceding step.
  1. Reconcile secondary cluster(s) configuration:
      * Manually edit the Terraform configuration file(s) for the secondary cluster(s) to update the setting with the latest value from the state.
      * Execute `terraform plan` once again. This should not generate any diff, confirming the configuration is in sync with the infrastructure.


**Switchover**

To perform a [switchover](https://cloud.google.com/memorystore/docs/cluster/working-with-cross-region-replication#perform_a_switchover), please follow the below steps:
  1. Ensure that the Terraform configuration file for the secondary cluster that needs to become the new primary has the `cross_cluster_replication_config` field. If it is not present:
      * Add the `cross_cluster_replication_config` field to the configuration file to match the latest value in the state.
      * Execute `terraform plan`. This should not generate any diff, confirming the configuration is in sync with the infrastructure.
  1. Update the `cross_cluster_replication_config` field of the secondary that needs to become the new primary:
      * Change `cross_cluster_replication_config.cluster_role` from `SECONDARY` to `PRIMARY`.
      * Remove `cross_cluster_replication_config.primary_cluster` field.
      * Set `cross_cluster_replication_config.secondary_clusters` list with the new secondaries. The new secondaries are the current primary and other secondary clusters(if any).

      -> You can refer to the current value of `cross_cluster_replication_config.membership` field to lookup the current primary and secondary clusters.
  1. Execute switchover:
      * Execute`terraform apply` to apply the change and wait for it to complete.
  1. Fix any configuration drifts on the previous primary and other secondary clusters:
      * Execute `terraform plan`. If any diffs are reported for `cross_cluster_replication_config` field:
          * Manually update `cross_cluster_replication_config` field in the configuration file(s) for those clusters with the latest value from the state.
          * Execute `terraform plan` once again. This should not generate any diff, confirming the configuration is in sync with the infrastructure.

**Detach a secondary cluster**

To [detach](https://cloud.google.com/memorystore/docs/cluster/working-with-cross-region-replication#detach_secondary_clusters_option_1) a secondary cluster, please follow the below steps:
  1. Ensure that the Terraform configuration file for the secondary cluster that needs to be detached has the `cross_cluster_replication_config` field. If it is not present:
      * Add the `cross_cluster_replication_config` field to the configuration file to match the latest value in the state.
      * Execute `terraform plan`. This should not generate any diff, confirming the configuration is in sync with the infrastructure.
  1. Update the `cross_cluster_replication_config` field of the secondary that needs to be detached:
      * Change `cross_cluster_replication_config.cluster_role` from `SECONDARY` to `NONE`.
      * Remove `cross_cluster_replication_config.primary_cluster`.
  1. Execute detach:
      * Execute`terraform apply` to apply the change and wait for it to complete.
  1. Fix any configuration drifts on the primary cluster:
      * Execute `terraform plan`. If any diff is reported for `cross_cluster_replication_config` field:
          * Manually update `cross_cluster_replication_config` field in the configuration file with the latest value from the state.
          * Execute `terraform plan` once again. This should not generate any diff, confirming the configuration is in sync with the infrastructure.

**Detach secondary cluster(s) via primary cluster**

To [detach](https://cloud.google.com/memorystore/docs/cluster/working-with-cross-region-replication#detach_secondary_clusters_option_2) secondary clusters via primary, please follow the below steps:
  1. Ensure that the Terraform configuration file for the primary cluster from which the secondary(ies) has(ve) to be detached has the `cross_cluster_replication_config` field. If it is not present:
      * Add the `cross_cluster_replication_config` field to the configuration file to match the latest value in the state.
      * Execute `terraform plan`. This should not generate any diff, confirming the configuration is in sync with the infrastructure.
  1. Update the `cross_cluster_replication_config` field of the primary cluster:
      * If you are detaching all secondaries from the primary:
          * Change `cross_cluster_replication_config.cluster_role` from `PRIMARY` to `NONE`.
          * Remove `cross_cluster_replication_config.secondary_clusters` list field.
      * If you are detaching a subset of secondaries:
          * Update `cross_cluster_replication_config.secondary_clusters` list field to remove the secondary clusters that need to be detached.
  1. Execute detach:
      * Execute `terraform apply` to apply the change and wait for it to complete.
  1. Fix any configuration drifts on the secondary cluster(s) that was detached:
      * Execute `terraform plan`. If any diffs are reported for `cross_cluster_replication_config` field:
          * Manually update `cross_cluster_replication_config` field in the configuration file(s) for those clusters with the latest value from the state.
          * Execute `terraform plan` once again. This should not generate any diff, confirming the configuration is in sync with the infrastructure.

<div class = "oics-button" style="float: right; margin: 0 0 -15px">
  <a href="https://console.cloud.google.com/cloudshell/open?cloudshell_git_repo=https%3A%2F%2Fgithub.com%2Fterraform-google-modules%2Fdocs-examples.git&cloudshell_image=gcr.io%2Fcloudshell-images%2Fcloudshell%3Alatest&cloudshell_print=.%2Fmotd&cloudshell_tutorial=.%2Ftutorial.md&cloudshell_working_dir=redis_cluster_ha_with_labels&open_in_editor=main.tf" target="_blank">
    <img alt="Open in Cloud Shell" src="//gstatic.com/cloudssh/images/open-btn.svg" style="max-height: 44px; margin: 32px auto; max-width: 100%;">
  </a>
</div>
## Example Usage - Redis Cluster Ha With Labels


```hcl
resource "google_redis_cluster" "cluster-ha-with-labels" {
  name           = "ha-cluster"
  shard_count    = 3
  labels = {
    my_key = "my_val"
    other_key = "other_val" 
  }
  psc_configs {
    network = google_compute_network.consumer_net.id
  }
  region = "us-central1"
  replica_count = 1
  node_type = "REDIS_SHARED_CORE_NANO"
  transit_encryption_mode = "TRANSIT_ENCRYPTION_MODE_DISABLED"
  authorization_mode = "AUTH_MODE_DISABLED"
  redis_configs = {
    maxmemory-policy	= "volatile-ttl"
  }
  deletion_protection_enabled = true

  zone_distribution_config {
    mode = "MULTI_ZONE"
  }
  maintenance_policy {
    weekly_maintenance_window {
      day = "MONDAY"
      start_time {
        hours = 1
        minutes = 0
        seconds = 0
        nanos = 0
      }
    }
  }
  depends_on = [
    google_network_connectivity_service_connection_policy.default
  ]
}

resource "google_network_connectivity_service_connection_policy" "default" {
  name = "my-policy"
  location = "us-central1"
  service_class = "gcp-memorystore-redis"
  description   = "my basic service connection policy"
  network = google_compute_network.consumer_net.id
  psc_config {
    subnetworks = [google_compute_subnetwork.consumer_subnet.id]
  }
}

resource "google_compute_subnetwork" "consumer_subnet" {
  name          = "my-subnet"
  ip_cidr_range = "10.0.0.248/29"
  region        = "us-central1"
  network       = google_compute_network.consumer_net.id
}

resource "google_compute_network" "consumer_net" {
  name                    = "my-network"
  auto_create_subnetworks = false
}
```
<div class = "oics-button" style="float: right; margin: 0 0 -15px">
  <a href="https://console.cloud.google.com/cloudshell/open?cloudshell_git_repo=https%3A%2F%2Fgithub.com%2Fterraform-google-modules%2Fdocs-examples.git&cloudshell_image=gcr.io%2Fcloudshell-images%2Fcloudshell%3Alatest&cloudshell_print=.%2Fmotd&cloudshell_tutorial=.%2Ftutorial.md&cloudshell_working_dir=redis_cluster_ha&open_in_editor=main.tf" target="_blank">
    <img alt="Open in Cloud Shell" src="//gstatic.com/cloudssh/images/open-btn.svg" style="max-height: 44px; margin: 32px auto; max-width: 100%;">
  </a>
</div>
## Example Usage - Redis Cluster Ha


```hcl
resource "google_redis_cluster" "cluster-ha" {
  name           = "ha-cluster"
  shard_count    = 3
  psc_configs {
    network = google_compute_network.consumer_net.id
  }
  region = "us-central1"
  replica_count = 1
  node_type = "REDIS_SHARED_CORE_NANO"
  transit_encryption_mode = "TRANSIT_ENCRYPTION_MODE_DISABLED"
  authorization_mode = "AUTH_MODE_DISABLED"
  redis_configs = {
    maxmemory-policy	= "volatile-ttl"
  }
  deletion_protection_enabled = true

  zone_distribution_config {
    mode = "MULTI_ZONE"
  }
  maintenance_policy {
    weekly_maintenance_window {
      day = "MONDAY"
      start_time {
        hours = 1
        minutes = 0
        seconds = 0
        nanos = 0
      }
    }
  }
  depends_on = [
    google_network_connectivity_service_connection_policy.default
  ]
}

resource "google_network_connectivity_service_connection_policy" "default" {
  name = "my-policy"
  location = "us-central1"
  service_class = "gcp-memorystore-redis"
  description   = "my basic service connection policy"
  network = google_compute_network.consumer_net.id
  psc_config {
    subnetworks = [google_compute_subnetwork.consumer_subnet.id]
  }
}

resource "google_compute_subnetwork" "consumer_subnet" {
  name          = "my-subnet"
  ip_cidr_range = "10.0.0.248/29"
  region        = "us-central1"
  network       = google_compute_network.consumer_net.id
}

resource "google_compute_network" "consumer_net" {
  name                    = "my-network"
  auto_create_subnetworks = false
}
```
<div class = "oics-button" style="float: right; margin: 0 0 -15px">
  <a href="https://console.cloud.google.com/cloudshell/open?cloudshell_git_repo=https%3A%2F%2Fgithub.com%2Fterraform-google-modules%2Fdocs-examples.git&cloudshell_image=gcr.io%2Fcloudshell-images%2Fcloudshell%3Alatest&cloudshell_print=.%2Fmotd&cloudshell_tutorial=.%2Ftutorial.md&cloudshell_working_dir=redis_cluster_ha_single_zone&open_in_editor=main.tf" target="_blank">
    <img alt="Open in Cloud Shell" src="//gstatic.com/cloudssh/images/open-btn.svg" style="max-height: 44px; margin: 32px auto; max-width: 100%;">
  </a>
</div>
## Example Usage - Redis Cluster Ha Single Zone


```hcl
resource "google_redis_cluster" "cluster-ha-single-zone" {
  name           = "ha-cluster-single-zone"
  shard_count    = 3
  psc_configs {
    network = google_compute_network.consumer_net.id
  }
  region = "us-central1"
  zone_distribution_config {
    mode = "SINGLE_ZONE"
    zone = "us-central1-f"
  }
  maintenance_policy {
    weekly_maintenance_window {
      day = "MONDAY"
      start_time {
        hours = 1
        minutes = 0
        seconds = 0
        nanos = 0
      }
    }
  }
  deletion_protection_enabled = true
  depends_on = [
    google_network_connectivity_service_connection_policy.default
  ]

}

resource "google_network_connectivity_service_connection_policy" "default" {
  name = "my-policy"
  location = "us-central1"
  service_class = "gcp-memorystore-redis"
  description   = "my basic service connection policy"
  network = google_compute_network.consumer_net.id
  psc_config {
    subnetworks = [google_compute_subnetwork.consumer_subnet.id]
  }
}

resource "google_compute_subnetwork" "consumer_subnet" {
  name          = "my-subnet"
  ip_cidr_range = "10.0.0.248/29"
  region        = "us-central1"
  network       = google_compute_network.consumer_net.id
}

resource "google_compute_network" "consumer_net" {
  name                    = "my-network"
  auto_create_subnetworks = false
}
```
<div class = "oics-button" style="float: right; margin: 0 0 -15px">
  <a href="https://console.cloud.google.com/cloudshell/open?cloudshell_git_repo=https%3A%2F%2Fgithub.com%2Fterraform-google-modules%2Fdocs-examples.git&cloudshell_image=gcr.io%2Fcloudshell-images%2Fcloudshell%3Alatest&cloudshell_print=.%2Fmotd&cloudshell_tutorial=.%2Ftutorial.md&cloudshell_working_dir=redis_cluster_secondary&open_in_editor=main.tf" target="_blank">
    <img alt="Open in Cloud Shell" src="//gstatic.com/cloudssh/images/open-btn.svg" style="max-height: 44px; margin: 32px auto; max-width: 100%;">
  </a>
</div>
## Example Usage - Redis Cluster Secondary


```hcl
// Primary cluster
resource "google_redis_cluster" "primary_cluster" {
  name          = "my-primary-cluster"
  region        = "us-east1"
  psc_configs {
    network = google_compute_network.consumer_net.id
  }

  // Settings that should match on primary and secondary clusters. 
  // If you define a setting here, ensure that the secondary clusters also define it with the same values. 
  // Please see https://cloud.google.com/memorystore/docs/cluster/about-cross-region-replication#settings_copied_from_the_primary_during_instance_creation for the complete list of such settings.
  authorization_mode = "AUTH_MODE_DISABLED"
  transit_encryption_mode = "TRANSIT_ENCRYPTION_MODE_DISABLED"
  shard_count   = 3
  redis_configs = {
    maxmemory-policy = "volatile-ttl"
  }
  node_type = "REDIS_HIGHMEM_MEDIUM"
  persistence_config {
    mode = "RDB"
    rdb_config {
      rdb_snapshot_period = "ONE_HOUR"
      rdb_snapshot_start_time = "2024-10-02T15:01:23Z"
    }
  }

  // Settings that can have different values on primary and secondary clusters.
  // Please see https://cloud.google.com/memorystore/docs/cluster/about-cross-region-replication#override_allowed_during_instance_creation for the complete list of such settings.
  zone_distribution_config {
    mode = "MULTI_ZONE"
  }
  replica_count = 1
  maintenance_policy {
    weekly_maintenance_window {
      day = "MONDAY"
      start_time {
        hours = 1
        minutes = 0
        seconds = 0
        nanos = 0
      }
    }
  }
  deletion_protection_enabled = true

  depends_on = [
    google_network_connectivity_service_connection_policy.primary_cluster_region_scp
  ]
}


// Secondary cluster
resource "google_redis_cluster" "secondary_cluster" {
  name          = "my-secondary-cluster"
  region        = "europe-west1"
  psc_configs {
    network = google_compute_network.consumer_net.id
  }

  // Settings that should match on primary and secondary clusters. 
  // If you defined a setting here for primary, ensure the secondary clusters also define it with the same values. 
  // Please see https://cloud.google.com/memorystore/docs/cluster/about-cross-region-replication#settings_copied_from_the_primary_during_instance_creation for the complete list of such settings.
  authorization_mode = "AUTH_MODE_DISABLED"
  transit_encryption_mode = "TRANSIT_ENCRYPTION_MODE_DISABLED"
  shard_count   = 3
  redis_configs = {
    maxmemory-policy = "volatile-ttl"
  }
  node_type = "REDIS_HIGHMEM_MEDIUM"
  persistence_config {
    mode = "RDB"
    rdb_config {
      rdb_snapshot_period = "ONE_HOUR"
      rdb_snapshot_start_time = "2024-10-02T15:01:23Z"
    }
  }

  // Settings that can be different on primary and secondary clusters.
  // Please see https://cloud.google.com/memorystore/docs/cluster/about-cross-region-replication#override_allowed_during_instance_creation for the complete list of such settings.
  zone_distribution_config {
    mode = "MULTI_ZONE"
  }
  replica_count = 2
  maintenance_policy {
    weekly_maintenance_window {
      day = "WEDNESDAY"
      start_time {
        hours = 1
        minutes = 0
        seconds = 0
        nanos = 0
      }
    }
  }
  deletion_protection_enabled = true

  // Cross cluster replication config
  cross_cluster_replication_config {
    cluster_role = "SECONDARY"
    primary_cluster {
      cluster = google_redis_cluster.primary_cluster.id
    }
  }

  depends_on = [
    google_network_connectivity_service_connection_policy.secondary_cluster_region_scp
  ]
}


resource "google_network_connectivity_service_connection_policy" "primary_cluster_region_scp" {
  name = "mypolicy-primary-cluster"
  location = "us-east1"
  service_class = "gcp-memorystore-redis"
  description   = "Primary cluster service connection policy"
  network = google_compute_network.consumer_net.id
  psc_config {
    subnetworks = [google_compute_subnetwork.primary_cluster_consumer_subnet.id]
  }
}

resource "google_compute_subnetwork" "primary_cluster_consumer_subnet" {
  name          = "mysubnet-primary-cluster"
  ip_cidr_range = "10.0.1.0/29"
  region        = "us-east1"
  network       = google_compute_network.consumer_net.id
}


resource "google_network_connectivity_service_connection_policy" "secondary_cluster_region_scp" {
  name = "mypolicy-secondary-cluster"
  location = "europe-west1"
  service_class = "gcp-memorystore-redis"
  description   = "Secondary cluster service connection policy"
  network = google_compute_network.consumer_net.id
  psc_config {
    subnetworks = [google_compute_subnetwork.secondary_cluster_consumer_subnet.id]
  }
}

resource "google_compute_subnetwork" "secondary_cluster_consumer_subnet" {
  name          = "mysubnet-secondary-cluster"
  ip_cidr_range = "10.0.2.0/29"
  region        = "europe-west1"
  network       = google_compute_network.consumer_net.id
}

resource "google_compute_network" "consumer_net" {
  name                    = "mynetwork"
  auto_create_subnetworks = false
}
```
<div class = "oics-button" style="float: right; margin: 0 0 -15px">
  <a href="https://console.cloud.google.com/cloudshell/open?cloudshell_git_repo=https%3A%2F%2Fgithub.com%2Fterraform-google-modules%2Fdocs-examples.git&cloudshell_image=gcr.io%2Fcloudshell-images%2Fcloudshell%3Alatest&cloudshell_print=.%2Fmotd&cloudshell_tutorial=.%2Ftutorial.md&cloudshell_working_dir=redis_cluster_rdb&open_in_editor=main.tf" target="_blank">
    <img alt="Open in Cloud Shell" src="//gstatic.com/cloudssh/images/open-btn.svg" style="max-height: 44px; margin: 32px auto; max-width: 100%;">
  </a>
</div>
## Example Usage - Redis Cluster Rdb


```hcl
resource "google_redis_cluster" "cluster-rdb" {
  name           = "rdb-cluster"
  shard_count    = 3
  psc_configs {
    network = google_compute_network.consumer_net.id
  }
  region = "us-central1"
  replica_count = 0
  node_type = "REDIS_SHARED_CORE_NANO"
  transit_encryption_mode = "TRANSIT_ENCRYPTION_MODE_DISABLED"
  authorization_mode = "AUTH_MODE_DISABLED"
  redis_configs = {
    maxmemory-policy	= "volatile-ttl"
  }
  deletion_protection_enabled = true

  zone_distribution_config {
    mode = "MULTI_ZONE"
  }
  maintenance_policy {
    weekly_maintenance_window {
      day = "MONDAY"
      start_time {
        hours = 1
        minutes = 0
        seconds = 0
        nanos = 0
      }
    }
  }
  persistence_config { 
    mode = "RDB"
    rdb_config {
      rdb_snapshot_period = "ONE_HOUR"
      rdb_snapshot_start_time = "2024-10-02T15:01:23Z"
    }
  }
  depends_on = [
    google_network_connectivity_service_connection_policy.default
  ]
}

resource "google_network_connectivity_service_connection_policy" "default" {
  name = "my-policy"
  location = "us-central1"
  service_class = "gcp-memorystore-redis"
  description   = "my basic service connection policy"
  network = google_compute_network.consumer_net.id
  psc_config {
    subnetworks = [google_compute_subnetwork.consumer_subnet.id]
  }
}

resource "google_compute_subnetwork" "consumer_subnet" {
  name          = "my-subnet"
  ip_cidr_range = "10.0.0.248/29"
  region        = "us-central1"
  network       = google_compute_network.consumer_net.id
}

resource "google_compute_network" "consumer_net" {
  name                    = "my-network"
  auto_create_subnetworks = false
}
```
<div class = "oics-button" style="float: right; margin: 0 0 -15px">
  <a href="https://console.cloud.google.com/cloudshell/open?cloudshell_git_repo=https%3A%2F%2Fgithub.com%2Fterraform-google-modules%2Fdocs-examples.git&cloudshell_image=gcr.io%2Fcloudshell-images%2Fcloudshell%3Alatest&cloudshell_print=.%2Fmotd&cloudshell_tutorial=.%2Ftutorial.md&cloudshell_working_dir=redis_cluster_aof&open_in_editor=main.tf" target="_blank">
    <img alt="Open in Cloud Shell" src="//gstatic.com/cloudssh/images/open-btn.svg" style="max-height: 44px; margin: 32px auto; max-width: 100%;">
  </a>
</div>
## Example Usage - Redis Cluster Aof


```hcl
resource "google_redis_cluster" "cluster-aof" {
  name           = "aof-cluster"
  shard_count    = 3
  psc_configs {
    network = google_compute_network.consumer_net.id
  }
  region = "us-central1"
  replica_count = 0
  node_type = "REDIS_SHARED_CORE_NANO"
  transit_encryption_mode = "TRANSIT_ENCRYPTION_MODE_DISABLED"
  authorization_mode = "AUTH_MODE_DISABLED"
  redis_configs = {
    maxmemory-policy	= "volatile-ttl"
  }
  deletion_protection_enabled = true
  zone_distribution_config {
    mode = "MULTI_ZONE"
  }
  maintenance_policy {
    weekly_maintenance_window {
      day = "MONDAY"
      start_time {
        hours = 1
        minutes = 0
        seconds = 0
        nanos = 0
      }
    }
  }
  persistence_config { 
    mode = "AOF"
    aof_config {
      append_fsync = "EVERYSEC"
    }
  }
  depends_on = [
    google_network_connectivity_service_connection_policy.default
  ]
}

resource "google_network_connectivity_service_connection_policy" "default" {
  name = "my-policy"
  location = "us-central1"
  service_class = "gcp-memorystore-redis"
  description   = "my basic service connection policy"
  network = google_compute_network.consumer_net.id
  psc_config {
    subnetworks = [google_compute_subnetwork.consumer_subnet.id]
  }
}

resource "google_compute_subnetwork" "consumer_subnet" {
  name          = "my-subnet"
  ip_cidr_range = "10.0.0.248/29"
  region        = "us-central1"
  network       = google_compute_network.consumer_net.id
}

resource "google_compute_network" "consumer_net" {
  name                    = "my-network"
  auto_create_subnetworks = false
}
```
<div class = "oics-button" style="float: right; margin: 0 0 -15px">
  <a href="https://console.cloud.google.com/cloudshell/open?cloudshell_git_repo=https%3A%2F%2Fgithub.com%2Fterraform-google-modules%2Fdocs-examples.git&cloudshell_image=gcr.io%2Fcloudshell-images%2Fcloudshell%3Alatest&cloudshell_print=.%2Fmotd&cloudshell_tutorial=.%2Ftutorial.md&cloudshell_working_dir=redis_cluster_cmek&open_in_editor=main.tf" target="_blank">
    <img alt="Open in Cloud Shell" src="//gstatic.com/cloudssh/images/open-btn.svg" style="max-height: 44px; margin: 32px auto; max-width: 100%;">
  </a>
</div>
## Example Usage - Redis Cluster Cmek


```hcl
resource "google_redis_cluster" "cluster-cmek" {
  name           = "cmek-cluster"
  shard_count    = 3
  psc_configs {
    network = google_compute_network.consumer_net.id
  }
  kms_key = "my-key"
  region = "us-central1"
  deletion_protection_enabled = true
  depends_on = [
    google_network_connectivity_service_connection_policy.default
  ]
}


data "google_project" "project" {
}

resource "google_network_connectivity_service_connection_policy" "default" {
  name = "my-policy"
  location = "us-central1"
  service_class = "gcp-memorystore-redis"
  description   = "my basic service connection policy"
  network = google_compute_network.consumer_net.id
  psc_config {
    subnetworks = [google_compute_subnetwork.consumer_subnet.id]
  }
}

resource "google_compute_subnetwork" "consumer_subnet" {
  name          = "my-subnet"
  ip_cidr_range = "10.0.0.248/29"
  region        = "us-central1"
  network       = google_compute_network.consumer_net.id
}

resource "google_compute_network" "consumer_net" {
  name                    = "my-network"
  auto_create_subnetworks = false
}
```

## Argument Reference

The following arguments are supported:


* `shard_count` -
  (Required)
  Required. Number of shards for the Redis cluster.

* `name` -
  (Required)
  Unique name of the resource in this scope including project and location using the form:
  projects/{projectId}/locations/{locationId}/clusters/{clusterId}


* `labels` -
  (Optional)
  Resource labels to represent user provided metadata.
  **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
  Please refer to the field `effective_labels` for all of the labels present on the resource.

* `gcs_source` -
  (Optional)
  Backups stored in Cloud Storage buckets. The Cloud Storage buckets need to be the same region as the clusters.
  Structure is [documented below](#nested_gcs_source).

* `managed_backup_source` -
  (Optional)
  Backups that generated and managed by memorystore.
  Structure is [documented below](#nested_managed_backup_source).

* `automated_backup_config` -
  (Optional)
  The automated backup config for a instance.
  Structure is [documented below](#nested_automated_backup_config).

* `authorization_mode` -
  (Optional)
  Optional. The authorization mode of the Redis cluster. If not provided, auth feature is disabled for the cluster.
  Default value is `AUTH_MODE_DISABLED`.
  Possible values are: `AUTH_MODE_UNSPECIFIED`, `AUTH_MODE_IAM_AUTH`, `AUTH_MODE_DISABLED`.

* `transit_encryption_mode` -
  (Optional)
  Optional. The in-transit encryption for the Redis cluster.
  If not provided, encryption is disabled for the cluster.
  Default value is `TRANSIT_ENCRYPTION_MODE_DISABLED`.
  Possible values are: `TRANSIT_ENCRYPTION_MODE_UNSPECIFIED`, `TRANSIT_ENCRYPTION_MODE_DISABLED`, `TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION`.

* `node_type` -
  (Optional)
  The nodeType for the Redis cluster.
  If not provided, REDIS_HIGHMEM_MEDIUM will be used as default
  Possible values are: `REDIS_SHARED_CORE_NANO`, `REDIS_HIGHMEM_MEDIUM`, `REDIS_HIGHMEM_XLARGE`, `REDIS_STANDARD_SMALL`.

* `zone_distribution_config` -
  (Optional)
  Immutable. Zone distribution config for Memorystore Redis cluster.
  Structure is [documented below](#nested_zone_distribution_config).

* `psc_configs` -
  (Optional)
  Required. Each PscConfig configures the consumer network where two
  network addresses will be designated to the cluster for client access.
  Currently, only one PscConfig is supported.
  Structure is [documented below](#nested_psc_configs).

* `replica_count` -
  (Optional)
  Optional. The number of replica nodes per shard.

* `deletion_protection_enabled` -
  (Optional)
  Optional. Indicates if the cluster is deletion protected or not.
  If the value if set to true, any delete cluster operation will fail.
  Default value is true.

* `redis_configs` -
  (Optional)
  Configure Redis Cluster behavior using a subset of native Redis configuration parameters.
  Please check Memorystore documentation for the list of supported parameters:
  https://cloud.google.com/memorystore/docs/cluster/supported-instance-configurations

* `persistence_config` -
  (Optional)
  Persistence config (RDB, AOF) for the cluster.
  Structure is [documented below](#nested_persistence_config).

* `maintenance_policy` -
  (Optional)
  Maintenance policy for a cluster
  Structure is [documented below](#nested_maintenance_policy).

* `maintenance_version` -
  (Optional)
  This field can be used to trigger self service update to indicate the desired maintenance version. The input to this field can be determined by the available_maintenance_versions field.
  *Note*: This field can only be specified when updating an existing cluster to a newer version. Downgrades are currently not supported!

* `cross_cluster_replication_config` -
  (Optional)
  Cross cluster replication config
  Structure is [documented below](#nested_cross_cluster_replication_config).

* `kms_key` -
  (Optional)
  The KMS key used to encrypt the at-rest data of the cluster.

* `region` -
  (Optional)
  The name of the region of the Redis cluster.

* `project` - (Optional) The ID of the project in which the resource belongs.
    If it is not provided, the provider project is used.



<a name="nested_gcs_source"></a>The `gcs_source` block supports:

* `uris` -
  (Required)
  URIs of the GCS objects to import. Example: gs://bucket1/object1, gs://bucket2/folder2/object2

<a name="nested_managed_backup_source"></a>The `managed_backup_source` block supports:

* `backup` -
  (Required)
  Example: `projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backup}`.

<a name="nested_automated_backup_config"></a>The `automated_backup_config` block supports:

* `fixed_frequency_schedule` -
  (Required)
  Trigger automated backups at a fixed frequency.
  Structure is [documented below](#nested_automated_backup_config_fixed_frequency_schedule).

* `retention` -
  (Required)
  How long to keep automated backups before the backups are deleted.
  The value should be between 1 day and 365 days. If not specified, the default value is 35 days.
  A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".


<a name="nested_automated_backup_config_fixed_frequency_schedule"></a>The `fixed_frequency_schedule` block supports:

* `start_time` -
  (Required)
  The start time of every automated backup in UTC.
  It must be set to the start of an hour. This field is required.
  Structure is [documented below](#nested_automated_backup_config_fixed_frequency_schedule_start_time).


<a name="nested_automated_backup_config_fixed_frequency_schedule_start_time"></a>The `start_time` block supports:

* `hours` -
  (Required)
  Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23.
  An API may choose to allow the value "24:00:00" for scenarios like business closing time.

<a name="nested_zone_distribution_config"></a>The `zone_distribution_config` block supports:

* `mode` -
  (Optional)
  Immutable. The mode for zone distribution for Memorystore Redis cluster.
  If not provided, MULTI_ZONE will be used as default
  Possible values are: `MULTI_ZONE`, `SINGLE_ZONE`.

* `zone` -
  (Optional)
  Immutable. The zone for single zone Memorystore Redis cluster.

<a name="nested_psc_configs"></a>The `psc_configs` block supports:

* `network` -
  (Required)
  Required. The consumer network where the network address of
  the discovery endpoint will be reserved, in the form of
  projects/{network_project_id_or_number}/global/networks/{network_id}.

<a name="nested_persistence_config"></a>The `persistence_config` block supports:

* `mode` -
  (Optional)
  Optional. Controls whether Persistence features are enabled. If not provided, the existing value will be used.
  - DISABLED: 	Persistence (both backup and restore) is disabled for the cluster.
  - RDB: RDB based Persistence is enabled.
  - AOF: AOF based Persistence is enabled.
  Possible values are: `PERSISTENCE_MODE_UNSPECIFIED`, `DISABLED`, `RDB`, `AOF`.

* `rdb_config` -
  (Optional)
  RDB configuration. This field will be ignored if mode is not RDB.
  Structure is [documented below](#nested_persistence_config_rdb_config).

* `aof_config` -
  (Optional)
  AOF configuration. This field will be ignored if mode is not AOF.
  Structure is [documented below](#nested_persistence_config_aof_config).


<a name="nested_persistence_config_rdb_config"></a>The `rdb_config` block supports:

* `rdb_snapshot_period` -
  (Optional)
  Optional. Available snapshot periods for scheduling.
  - ONE_HOUR:	Snapshot every 1 hour.
  - SIX_HOURS:	Snapshot every 6 hours.
  - TWELVE_HOURS:	Snapshot every 12 hours.
  - TWENTY_FOUR_HOURS:	Snapshot every 24 hours.
  Possible values are: `SNAPSHOT_PERIOD_UNSPECIFIED`, `ONE_HOUR`, `SIX_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`.

* `rdb_snapshot_start_time` -
  (Optional)
  The time that the first snapshot was/will be attempted, and to which
  future snapshots will be aligned.
  If not provided, the current time will be used.

<a name="nested_persistence_config_aof_config"></a>The `aof_config` block supports:

* `append_fsync` -
  (Optional)
  Optional. Available fsync modes.
  - NO - Do not explicitly call fsync(). Rely on OS defaults.
  - EVERYSEC - Call fsync() once per second in a background thread. A balance between performance and durability.
  - ALWAYS - Call fsync() for earch write command.
  Possible values are: `APPEND_FSYNC_UNSPECIFIED`, `NO`, `EVERYSEC`, `ALWAYS`.

<a name="nested_maintenance_policy"></a>The `maintenance_policy` block supports:

* `create_time` -
  (Output)
  Output only. The time when the policy was created.
  A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
  resolution and up to nine fractional digits.

* `update_time` -
  (Output)
  Output only. The time when the policy was last updated.
  A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
  resolution and up to nine fractional digits.

* `weekly_maintenance_window` -
  (Optional)
  Optional. Maintenance window that is applied to resources covered by this policy.
  Minimum 1. For the current version, the maximum number
  of weekly_window is expected to be one.
  Structure is [documented below](#nested_maintenance_policy_weekly_maintenance_window).


<a name="nested_maintenance_policy_weekly_maintenance_window"></a>The `weekly_maintenance_window` block supports:

* `day` -
  (Required)
  Required. The day of week that maintenance updates occur.
  - DAY_OF_WEEK_UNSPECIFIED: The day of the week is unspecified.
  - MONDAY: Monday
  - TUESDAY: Tuesday
  - WEDNESDAY: Wednesday
  - THURSDAY: Thursday
  - FRIDAY: Friday
  - SATURDAY: Saturday
  - SUNDAY: Sunday
  Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.

* `duration` -
  (Output)
  Output only. Duration of the maintenance window.
  The current window is fixed at 1 hour.
  A duration in seconds with up to nine fractional digits,
  terminated by 's'. Example: "3.5s".

* `start_time` -
  (Required)
  Required. Start time of the window in UTC time.
  Structure is [documented below](#nested_maintenance_policy_weekly_maintenance_window_start_time).


<a name="nested_maintenance_policy_weekly_maintenance_window_start_time"></a>The `start_time` block supports:

* `hours` -
  (Optional)
  Hours of day in 24 hour format. Should be from 0 to 23.
  An API may choose to allow the value "24:00:00" for scenarios like business closing time.

* `minutes` -
  (Optional)
  Minutes of hour of day. Must be from 0 to 59.

* `seconds` -
  (Optional)
  Seconds of minutes of the time. Must normally be from 0 to 59.
  An API may allow the value 60 if it allows leap-seconds.

* `nanos` -
  (Optional)
  Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.

<a name="nested_cross_cluster_replication_config"></a>The `cross_cluster_replication_config` block supports:

* `cluster_role` -
  (Optional)
  The role of the cluster in cross cluster replication. Supported values are:
  1. `CLUSTER_ROLE_UNSPECIFIED`: This is an independent cluster that has never participated in cross cluster replication. It allows both reads and writes.
  1. `NONE`: This is an independent cluster that previously participated in cross cluster replication(either as a `PRIMARY` or `SECONDARY` cluster). It allows both reads and writes.
  1. `PRIMARY`: This cluster serves as the replication source for secondary clusters that are replicating from it. Any data written to it is automatically replicated to its secondary clusters. It allows both reads and writes.
  1. `SECONDARY`: This cluster replicates data from the primary cluster. It allows only reads.
  Possible values are: `CLUSTER_ROLE_UNSPECIFIED`, `NONE`, `PRIMARY`, `SECONDARY`.

* `primary_cluster` -
  (Optional)
  Details of the primary cluster that is used as the replication source for this secondary cluster. This is allowed to be set only for clusters whose cluster role is of type `SECONDARY`.
  Structure is [documented below](#nested_cross_cluster_replication_config_primary_cluster).

* `secondary_clusters` -
  (Optional)
  List of secondary clusters that are replicating from this primary cluster. This is allowed to be set only for clusters whose cluster role is of type `PRIMARY`.
  Structure is [documented below](#nested_cross_cluster_replication_config_secondary_clusters).

* `membership` -
  (Output)
  An output only view of all the member clusters participating in cross cluster replication. This field is populated for all the member clusters irrespective of their cluster role.
  Structure is [documented below](#nested_cross_cluster_replication_config_membership).

* `update_time` -
  (Output)
  The last time cross cluster replication config was updated.


<a name="nested_cross_cluster_replication_config_primary_cluster"></a>The `primary_cluster` block supports:

* `cluster` -
  (Optional)
  The full resource path of the primary cluster in the format: projects/{project}/locations/{region}/clusters/{cluster-id}

* `uid` -
  (Output)
  The unique id of the primary cluster.

<a name="nested_cross_cluster_replication_config_secondary_clusters"></a>The `secondary_clusters` block supports:

* `cluster` -
  (Optional)
  The full resource path of the secondary cluster in the format: projects/{project}/locations/{region}/clusters/{cluster-id}

* `uid` -
  (Output)
  The unique id of the secondary cluster.

<a name="nested_cross_cluster_replication_config_membership"></a>The `membership` block contains:

* `primary_cluster` -
  (Output)
  Details of the primary cluster that is used as the replication source for all the secondary clusters.
  Structure is [documented below](#nested_cross_cluster_replication_config_membership_primary_cluster).

* `secondary_clusters` -
  (Output)
  List of secondary clusters that are replicating from the primary cluster.
  Structure is [documented below](#nested_cross_cluster_replication_config_membership_secondary_clusters).


<a name="nested_cross_cluster_replication_config_membership_primary_cluster"></a>The `primary_cluster` block contains:

* `cluster` -
  (Output)
  The full resource path of the primary cluster in the format: projects/{project}/locations/{region}/clusters/{cluster-id}

* `uid` -
  (Output)
  The unique id of the primary cluster.

<a name="nested_cross_cluster_replication_config_membership_secondary_clusters"></a>The `secondary_clusters` block contains:

* `cluster` -
  (Output)
  The full resource path of the secondary cluster in the format: projects/{project}/locations/{region}/clusters/{cluster-id}

* `uid` -
  (Output)
  The unique id of the secondary cluster.

## Attributes Reference

In addition to the arguments listed above, the following computed attributes are exported:

* `id` - an identifier for the resource with format `projects/{{project}}/locations/{{region}}/clusters/{{name}}`

* `create_time` -
  The timestamp associated with the cluster creation request. A timestamp in
  RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional
  digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".

* `state` -
  The current state of this cluster. Can be CREATING, READY, UPDATING, DELETING and SUSPENDED

* `uid` -
  System assigned, unique identifier for the cluster.

* `backup_collection` -
  The backup collection full resource name.
  Example: projects/{project}/locations/{location}/backupCollections/{collection}

* `discovery_endpoints` -
  Output only. Endpoints created on each given network,
  for Redis clients to connect to the cluster.
  Currently only one endpoint is supported.
  Structure is [documented below](#nested_discovery_endpoints).

* `psc_connections` -
  Output only. PSC connections for discovery of the cluster topology and accessing the cluster.
  Structure is [documented below](#nested_psc_connections).

* `state_info` -
  Output only. Additional information about the current state of the cluster.
  Structure is [documented below](#nested_state_info).

* `size_gb` -
  Output only. Redis memory size in GB for the entire cluster.

* `precise_size_gb` -
  Output only. Redis memory precise size in GB for the entire cluster.

* `maintenance_schedule` -
  Upcoming maintenance schedule.
  Structure is [documented below](#nested_maintenance_schedule).

* `effective_maintenance_version` -
  This field represents the actual maintenance version of the cluster.

* `available_maintenance_versions` -
  This field is used to determine the available maintenance versions for the self service update.

* `psc_service_attachments` -
  Service attachment details to configure Psc connections.
  Structure is [documented below](#nested_psc_service_attachments).

* `managed_server_ca` -
  Cluster's Certificate Authority. This field will only be populated if Redis Cluster's transit_encryption_mode is TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION
  Structure is [documented below](#nested_managed_server_ca).

* `terraform_labels` -
  The combination of labels configured directly on the resource
   and default labels configured on the provider.

* `effective_labels` -
  All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.


<a name="nested_discovery_endpoints"></a>The `discovery_endpoints` block contains:

* `address` -
  (Optional)
  Output only. Network address of the exposed Redis endpoint used by clients to connect to the service.

* `port` -
  (Optional)
  Output only. The port number of the exposed Redis endpoint.

* `psc_config` -
  (Optional)
  Output only. Customer configuration for where the endpoint
  is created and accessed from.
  Structure is [documented below](#nested_discovery_endpoints_psc_config).


<a name="nested_discovery_endpoints_psc_config"></a>The `psc_config` block supports:

* `network` -
  (Optional)
  The consumer network where the network address of the discovery
  endpoint will be reserved, in the form of
  projects/{network_project_id}/global/networks/{network_id}.

<a name="nested_psc_connections"></a>The `psc_connections` block contains:

* `psc_connection_id` -
  (Optional)
  Output only. The PSC connection id of the forwarding rule connected to the service attachment.

* `address` -
  (Optional)
  Output only. The IP allocated on the consumer network for the PSC forwarding rule.

* `forwarding_rule` -
  (Optional)
  Output only. The URI of the consumer side forwarding rule. Example: projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}.

* `project_id` -
  (Optional)
  Output only. The consumer projectId where the forwarding rule is created from.

* `network` -
  (Optional)
  The consumer network where the IP address resides, in the form of projects/{projectId}/global/networks/{network_id}.

<a name="nested_state_info"></a>The `state_info` block contains:

* `update_info` -
  (Optional)
  A nested object resource.
  Structure is [documented below](#nested_state_info_update_info).


<a name="nested_state_info_update_info"></a>The `update_info` block supports:

* `target_shard_count` -
  (Optional)
  Target number of shards for redis cluster.

* `target_replica_count` -
  (Optional)
  Target number of replica nodes per shard.

<a name="nested_maintenance_schedule"></a>The `maintenance_schedule` block contains:

* `start_time` -
  (Output)
  Output only. The start time of any upcoming scheduled maintenance for this cluster.
  A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
  resolution and up to nine fractional digits.

* `end_time` -
  (Output)
  Output only. The end time of any upcoming scheduled maintenance for this cluster.
  A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
  resolution and up to nine fractional digits.

* `schedule_deadline_time` -
  (Output)
  Output only. The deadline that the maintenance schedule start time
  can not go beyond, including reschedule.
  A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
  resolution and up to nine fractional digits.

<a name="nested_psc_service_attachments"></a>The `psc_service_attachments` block contains:

* `service_attachment` -
  (Output)
  Service attachment URI which your self-created PscConnection should use as

* `connection_type` -
  (Output)
  Type of a PSC connection targeting this service attachment.

<a name="nested_managed_server_ca"></a>The `managed_server_ca` block contains:

* `ca_certs` -
  (Output)
  The PEM encoded CA certificate chains for redis managed server authentication
  Structure is [documented below](#nested_managed_server_ca_ca_certs).


<a name="nested_managed_server_ca_ca_certs"></a>The `ca_certs` block contains:

* `certificates` -
  (Output)
  The certificates that form the CA chain, from leaf to root order

## Timeouts

This resource provides the following
[Timeouts](https://developer.hashicorp.com/terraform/plugin/sdkv2/resources/retries-and-customizable-timeouts) configuration options:

- `create` - Default is 60 minutes.
- `update` - Default is 120 minutes.
- `delete` - Default is 30 minutes.

## Import


Cluster can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{region}}/clusters/{{name}}`
* `{{project}}/{{region}}/{{name}}`
* `{{region}}/{{name}}`
* `{{name}}`


In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import Cluster using one of the formats above. For example:

```tf
import {
  id = "projects/{{project}}/locations/{{region}}/clusters/{{name}}"
  to = google_redis_cluster.default
}
```

When using the [`terraform import` command](https://developer.hashicorp.com/terraform/cli/commands/import), Cluster can be imported using one of the formats above. For example:

```
$ terraform import google_redis_cluster.default projects/{{project}}/locations/{{region}}/clusters/{{name}}
$ terraform import google_redis_cluster.default {{project}}/{{region}}/{{name}}
$ terraform import google_redis_cluster.default {{region}}/{{name}}
$ terraform import google_redis_cluster.default {{name}}
```

## User Project Overrides

This resource supports [User Project Overrides](https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/provider_reference#user_project_override).
